#!chezscheme
(library (kind) (export suffix? prefix? run-all run_io print-lines run_kind make-string-view string-view? string-view-end string-view-start kstring-length kstring-head kstring-tail string-view-ref kstring? kstring->string kstring-append kstring-getter kstring_join Kind.api.io.term_to_core Kind.api.io.term_to_scheme Kind.api.io.terms_to_scheme_lib Kind.api.io.check_file Kind.api.io.check_files Kind.api.io.check_term Kind.api.io.show_term Kind.api.io.show_term_normal Kind.api.check_code Kind.Term.read)
(import (chezscheme))
; string-view record type (fast way to get a tail)
(define-record string-view
  ((immutable data)  ; underlying string
   (immutable start) ; start position (inclusive)
   (immutable end))) ; end position (exclusive)

(define string-view-ref
  (lambda (x y)
    (string-ref (string-view-data x) (+ (string-view-start x) y))))

(define kstring-tail
  (lambda (x)
    (if (string-view? x)
      (make-string-view
        (string-view-data x)
        (+ (string-view-start x) 1)
        (string-view-end x))
      (make-string-view
        x
        1
        (string-length x)))))

(define kstring-head
  (lambda (x)
    (if (string-view? x)
      (string-ref (string-view-data x) (string-view-start x))
      (string-ref x 0))))

(define kstring-length
  (lambda (x)
    (if (string-view? x)
      (- (string-view-end x) (string-view-start x))
      (string-length x))))

(define kstring?
  (lambda (x)
    (or (string-view? x) (string? x))))

(define kstring->string
  (lambda (x)
    (if (string-view? x)
      (substring (string-view-data x) (string-view-start x) (string-view-end x))
      x)))

; TODO depending on x, we could safely append data at the end
(define kstring-append
  (lambda (x y)
    (string-append (kstring->string x) (kstring->string y))))

(define kstring-getter
  (lambda (x)
    (if (string-view? x)
      string-view-ref
      string-ref)))

; Joins a list of strings with an intercalated separator
(define (kstring_join sep strs fst)
  (if (null? strs) 
    ""
    (kstring-append
      (if fst "" sep)
      (car strs)
      (kstring_join sep (cdr strs) #f))))

; Short alias to vector-ref
(define get vector-ref)

; Converts a Kind word to a native integer
(define (word-to-u16 w)
  (define (word-to-u16-go i w x)
    (cond ((= 16 i) x)
      ((symbol=? 'Word.e (get w 0)) (word-to-u16-go (+ i 1) (vector 'Word.e) x))
      ((symbol=? 'Word.o (get w 0)) (word-to-u16-go (+ i 1) (get w 1) x))
      ((symbol=? 'Word.i (get w 0)) (word-to-u16-go (+ i 1) (get w 1) (fxior x (fxarithmetic-shift-left 1 i))))))
  (word-to-u16-go 0 w 0))

(define (word-to-u n w)
  (define (word-to-u-go n i w x)
    (cond ((= n i) x)
      ((symbol=? 'Word.e (get w 0)) (word-to-u-go n (+ i 1) (vector 'Word.e) x))
      ((symbol=? 'Word.o (get w 0)) (word-to-u-go n (+ i 1) (get w 1) x))
      ((symbol=? 'Word.i (get w 0)) (word-to-u-go n (+ i 1) (get w 1) (fxior x (fxarithmetic-shift-left 1 i))))))
  (word-to-u-go n 0 w 0))

; Converts a native integer to a Kind word
(define (u16-to-word x)
  (define (u16-to-word-go i x w)
    (if (= 16 i) w (u16-to-word-go (+ i 1) x
      (if (= (fxand (fxarithmetic-shift-right x (- 15 i)) 1) 0)
        (vector 'Word.o w)
        (vector 'Word.i w)))))
  (u16-to-word-go 0 x (vector 'Word.e)))

(define (u-to-word n x)
  (define (u-to-word-go n i x w)
    (if (= n i) w (u-to-word-go n (+ i 1) x
      (if (= (fxand (fxarithmetic-shift-right x (- n (+ i 1))) 1) 0)
        (vector 'Word.o w)
        (vector 'Word.i w)))))
  (u-to-word-go n 0 x (vector 'Word.e)))

(define suffix?
  (lambda (str suff)
    (let ((suff_length (string-length suff))
          (str_length (string-length str)))
      (if (<= suff_length str_length)
        (string=?
          (substring str (- str_length suff_length) str_length)
          suff)
        #f))))

(define prefix?
  (lambda (str pref)
    (let ((pref_length (string-length pref))
          (str_length (string-length str)))
      (if (<= pref_length str_length)
        (string=?
          (substring str 0 pref_length)
          pref)
        #f))))

; Returns the last index that chr occurs in str, -1 otherwise
(define (last_index_of chr kstr idx)
  (let ((str (kstring->string kstr)))
    (if (= idx (kstring-length str))
      -1
      (let ((rest (last_index_of chr str (+ idx 1))))
        (if (char=? (string-ref str idx) chr)
          (max idx rest)
          rest)))))

; Returns the first index that chr occurs in str, -1 otherwise
(define (first_index_of chr kstr idx)
  (let ((str (kstring->string kstr)))
    (if (= idx (string-length str))
      -1
      (if (char=? (string-ref str idx) chr)
        idx
        (first_index_of chr str (+ idx 1))))))

; Splits a string using an identifier
(define (split_at_first chr kstr)
  (let ((str (kstring->string kstr)))
    (let ((split_idx (first_index_of chr str 0)))
      (if (= split_idx -1)
        str
        (cons
          (substring str 0 split_idx)
          (substring str (+ split_idx 1) (string-length str)))))))

; Splits a string using an identifier
(define (split_at_last chr kstr)
  (let ((str (kstring->string kstr)))
    (let ((split_idx (last_index_of chr str 0)))
      (if (= split_idx -1)
        str
        (cons
          (substring str 0 split_idx)
          (substring str (+ split_idx 1) (string-length str)))))))

; Converts a date to a string, in milliseconds
(define (time_to_string time)
  (number->string
    (+ (* (time-second time) 1000)
      (div (time-nanosecond time) 1000000))))

; Prints a text with a newline
(define (print txt)
  (display (kstring->string txt))
  (display "
"))

; Gets a line from stdin
(define (get_line)
  (let ((port (current-input-port)))
    (get-line port)))

; Deletes a file
(define (del_file file)
  (delete-file (kstring->string file)))

; Gets the contents of a file as a string
; If it doesn't exist, returns empty
(define (get_file ifile)
  (let ((file (kstring->string ifile)))
    (if (file-exists? file)
      (let ((port (open-input-file file)))
        (let ((text (get-string-all port)))
          (begin
            (close-input-port port)
            text)))
      "")))

; Sets the contents of a file
(define (set_file file text)
  (system (string-append "mkdir -p " (car (split_at_last #\/ file))))
  (if (file-exists? file) (delete-file file))
  (let ((port (open-output-file file)))
    (begin
      (display text port)
      (close-output-port port))))

; Returns a list of files in a directory
(define (get_dir path)
  (directory-list path)) 

; Returns the time a file was modified. TODO: test on Windows/Linux
(define (get_file_mtime file)
  (time_to_string (file-modification-time (kstring->string file))))

; Returns the current time
(define (get_time)
  (time_to_string (current-time)))

; Performs a single Kind IO action
(define (io_action iname)
  (let ((name (kstring->string iname)))
  (case name
    ("print" (lambda (x) (print x)))
    ("put_string" (lambda (x) (display x)))
    ("get_line" (lambda (x) (get_line)))
    ("del_file" (lambda (x) (del_file x)))
    ("get_file" (lambda (x) (get_file x)))
    ("set_file" (lambda (x) (let ((file_text (split_at_first #\= (kstring->string x)))) (set_file (car file_text) (cdr file_text)))))
    ("get_dir" (lambda (x) (get_dir x)))
    ("get_file_mtime" (lambda (x) (get_file_mtime x)))
    ("get_time" (lambda (x) (get_time)))
    ("request" (lambda (x) ""))
    (else (display (string-append "IO action not found: " name))))))

; Runs a Kind IO program
(define (run_io io)
  (case (vector-ref io 0)
    ('IO.end (vector-ref io 1))
    ('IO.ask (let (
      (io_query (vector-ref io 1))
      (io_param (vector-ref io 2))
      (io_then (vector-ref io 3)))
      (run_io (io_then ((io_action io_query) io_param)))))))

(define (run_kind term)
  (if
    (and
      (vector? term)
      (or
        (eq? (vector-ref term 0) 'IO.ask)
        (eq? (vector-ref term 0) 'IO.end)))
    (run_io term)
    (print term)))

(define (print-lines args)
  (unless (null? args)
    (display (car args))
    (newline)
    (print-lines (cdr args))))

(define run-all
    (lambda (p)
      (let ((code (get-datum p)))
        (unless (eq? code #!eof)
          (compile code)
          (run-all p)))))


(define Bool-inst (lambda (x) ((x #t) #f)))
(define Bool-elim (lambda (x) (let ((self0 x)) (case self0 (#t (lambda (c0) (lambda (c1) c0))) (#f (lambda (c0) (lambda (c1) c1)))))))
(define Nat-inst (lambda (x) ((x 0) (lambda (x0) (+ x0 1)))))
(define Nat-elim (lambda (x) (let ((self0 x)) (case (= self0 0) (#t (lambda (c0) (lambda (c1) c0))) (#f (let ((f0 (- self0 1))) (lambda (c0) (lambda (c1) (c1 f0)))))))))
(define Bits-inst (lambda (x) (((x #b1) (lambda (x0) (bitwise-arithmetic-shift-left x0 #b1))) (lambda (x0) (bitwise-ior (bitwise-arithmetic-shift-left x0 #b1) #b1)))))
(define Bits-elim (lambda (x) (let ((self0 x)) (case (if (eq? self0 #b1) 2 (bitwise-and self0 #b1)) (2 (lambda (c0) (lambda (c1) (lambda (c2) c0)))) (0 (let ((f0 (bitwise-arithmetic-shift-right self0 #b1))) (lambda (c0) (lambda (c1) (lambda (c2) (c1 f0)))))) (1 (let ((f0 (bitwise-arithmetic-shift-right self0 #b1))) (lambda (c0) (lambda (c1) (lambda (c2) (c2 f0))))))))))
(define U16-inst (lambda (x) (x (lambda (x0) (word-to-u16 x0)))))
(define U16-elim (lambda (x) (let ((self0 x)) (case #t (#t (let ((f0 (u16-to-word self0))) (lambda (c0) (c0 f0))))))))
(define U32-inst (lambda (x) (x (lambda (x0) (word-to-u 32 x0)))))
(define U32-elim (lambda (x) (let ((self0 x)) (case #t (#t (let ((f0 (u-to-word 32 self0))) (lambda (c0) (c0 f0))))))))
(define String-inst (lambda (x) ((x "") (lambda (x0) (lambda (x1) (kstring-append (make-string 1 (integer->char x0)) x1))))))
(define String-elim (lambda (x) (let ((self0 x)) (case (<= (kstring-length self0) 0) (#t (lambda (c0) (lambda (c1) c0))) (#f (let ((f0 (char->integer (kstring-head self0)))) (let ((f1 (kstring-tail self0))) (lambda (c0) (lambda (c1) ((c1 f0) f1))))))))))
(define ($IO.ask query$1 param$2 then$3) (vector 'IO.ask query$1 param$2 then$3))
(define IO.ask (lambda (query$1) (lambda (param$2) (lambda (then$3) ($IO.ask query$1 param$2 then$3)))))
(define ($IO.bind a$2 f$3) (let ((self0 a$2)) (case (get self0 0) ('IO.end (let ((f0 (get self0 1))) (f$3 f0))) ('IO.ask (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) ($IO.ask f0 f1 (lambda (x$7) ($IO.bind (f2 x$7) f$3))))))))))
(define IO.bind (lambda (a$2) (lambda (f$3) ($IO.bind a$2 f$3))))
(define ($IO.end value$1) (vector 'IO.end value$1))
(define IO.end (lambda (value$1) ($IO.end value$1)))
(define IO.monad (vector 'Monad.new IO.bind IO.end))
(define Maybe.none (vector 'Maybe.none))
(define ($BitsMap.get bits$1 map$2) (let ((self0 bits$1)) (case (if (eq? self0 #b1) 2 (bitwise-and self0 #b1)) (2 (let ((self0 map$2)) (case (get self0 0) ('BitsMap.new Maybe.none) ('BitsMap.tie (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) f0))))))) (0 (let ((f0 (bitwise-arithmetic-shift-right self0 #b1))) (let ((self1 map$2)) (case (get self1 0) ('BitsMap.new Maybe.none) ('BitsMap.tie (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) ($BitsMap.get f0 f2))))))))) (1 (let ((f0 (bitwise-arithmetic-shift-right self0 #b1))) (let ((self1 map$2)) (case (get self1 0) ('BitsMap.new Maybe.none) ('BitsMap.tie (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) ($BitsMap.get f0 f3))))))))))))
(define BitsMap.get (lambda (bits$1) (lambda (map$2) ($BitsMap.get bits$1 map$2))))
(define ($Bits.o pred$0) (bitwise-arithmetic-shift-left pred$0 #b1))
(define Bits.o (lambda (pred$0) ($Bits.o pred$0)))
(define ($Bits.i pred$0) (bitwise-ior (bitwise-arithmetic-shift-left pred$0 #b1) #b1))
(define Bits.i (lambda (pred$0) ($Bits.i pred$0)))
(define Bool.true #t)
(define Bool.false #f)
(define ($Cmp.as_ltn cmp$0) (let ((self0 cmp$0)) (case (get self0 0) ('Cmp.ltn Bool.true) ('Cmp.eql Bool.false) ('Cmp.gtn Bool.false))))
(define Cmp.as_ltn (lambda (cmp$0) ($Cmp.as_ltn cmp$0)))
(define Cmp.ltn (vector 'Cmp.ltn))
(define Cmp.gtn (vector 'Cmp.gtn))
(define ($Word.cmp.go a$1 b$2 c$3) ((let ((self0 a$1)) (case (get self0 0) ('Word.e (lambda (b$4) c$3)) ('Word.o (let ((f0 (get self0 1))) (lambda (b$6) ((let ((self2 b$6)) (case (get self2 0) ('Word.e (lambda (a.pred$7) c$3)) ('Word.o (let ((f2 (get self2 1))) (lambda (a.pred$9) ($Word.cmp.go a.pred$9 f2 c$3)))) ('Word.i (let ((f2 (get self2 1))) (lambda (a.pred$9) ($Word.cmp.go a.pred$9 f2 Cmp.ltn)))))) f0)))) ('Word.i (let ((f0 (get self0 1))) (lambda (b$6) ((let ((self2 b$6)) (case (get self2 0) ('Word.e (lambda (a.pred$7) c$3)) ('Word.o (let ((f2 (get self2 1))) (lambda (a.pred$9) ($Word.cmp.go a.pred$9 f2 Cmp.gtn)))) ('Word.i (let ((f2 (get self2 1))) (lambda (a.pred$9) ($Word.cmp.go a.pred$9 f2 c$3)))))) f0)))))) b$2))
(define Word.cmp.go (lambda (a$1) (lambda (b$2) (lambda (c$3) ($Word.cmp.go a$1 b$2 c$3)))))
(define Cmp.eql (vector 'Cmp.eql))
(define ($Word.cmp a$1 b$2) ($Word.cmp.go a$1 b$2 Cmp.eql))
(define Word.cmp (lambda (a$1) (lambda (b$2) ($Word.cmp a$1 b$2))))
(define ($Word.ltn a$1 b$2) ($Cmp.as_ltn ($Word.cmp a$1 b$2)))
(define Word.ltn (lambda (a$1) (lambda (b$2) ($Word.ltn a$1 b$2))))
(define ($U16.ltn a$0 b$1) (< a$0 b$1))
(define U16.ltn (lambda (a$0) (lambda (b$1) ($U16.ltn a$0 b$1))))
(define ($U16.new value$0) (word-to-u16 value$0))
(define U16.new (lambda (value$0) ($U16.new value$0)))
(define ($Nat.apply n$1 f$2 x$3) (let ((self0 n$1)) (case (= self0 0) (#t x$3) (#f (let ((f0 (- self0 1))) ($Nat.apply f0 f$2 (f$2 x$3)))))))
(define Nat.apply (lambda (n$1) (lambda (f$2) (lambda (x$3) ($Nat.apply n$1 f$2 x$3)))))
(define Word.e (vector 'Word.e))
(define ($Word.i pred$1) (vector 'Word.i pred$1))
(define Word.i (lambda (pred$1) ($Word.i pred$1)))
(define ($Word.o pred$1) (vector 'Word.o pred$1))
(define Word.o (lambda (pred$1) ($Word.o pred$1)))
(define ($Word.inc word$1) (let ((self0 word$1)) (case (get self0 0) ('Word.e Word.e) ('Word.o (let ((f0 (get self0 1))) ($Word.i f0))) ('Word.i (let ((f0 (get self0 1))) ($Word.o ($Word.inc f0)))))))
(define Word.inc (lambda (word$1) ($Word.inc word$1)))
(define ($Word.zero size$0) (let ((self0 size$0)) (case (= self0 0) (#t Word.e) (#f (let ((f0 (- self0 1))) ($Word.o ($Word.zero f0)))))))
(define Word.zero (lambda (size$0) ($Word.zero size$0)))
(define ($Nat.to_word size$0 n$1) ($Nat.apply n$1 Word.inc ($Word.zero size$0)))
(define Nat.to_word (lambda (size$0) (lambda (n$1) ($Nat.to_word size$0 n$1))))
(define ($Nat.succ pred$0) (+ pred$0 1))
(define Nat.succ (lambda (pred$0) ($Nat.succ pred$0)))
(define Nat.zero 0)
(define ($Nat.to_u16 n$0) n$0)
(define Nat.to_u16 (lambda (n$0) ($Nat.to_u16 n$0)))
(define ($Kind.Name.to_bits.go name$0 end$1) (let ((self0 name$0)) (case (<= (kstring-length self0) 0) (#t end$1) (#f (let ((f0 (char->integer (kstring-head self0)))) (let ((f1 (kstring-tail self0))) (let ((x$4 f0)) (let ((O$5 Bits.o)) (let ((I$6 Bits.i)) (let ((self5 ($U16.ltn x$4 ($Nat.to_u16 47)))) (case self5 (#t (I$6 (I$6 (I$6 (I$6 (I$6 (O$5 ($Kind.Name.to_bits f1)))))))) (#f (let ((self5 ($U16.ltn x$4 ($Nat.to_u16 58)))) (case self5 (#t (let ((self5 ($U16.ltn x$4 ($Nat.to_u16 53)))) (case self5 (#t (let ((self5 ($U16.ltn x$4 ($Nat.to_u16 50)))) (case self5 (#t (let ((self5 ($U16.ltn x$4 ($Nat.to_u16 49)))) (case self5 (#t (I$6 (I$6 (O$5 (I$6 (O$5 (O$5 ($Kind.Name.to_bits f1)))))))) (#f (I$6 (I$6 (O$5 (I$6 (O$5 (I$6 ($Kind.Name.to_bits f1))))))))))) (#f (let ((self5 ($U16.ltn x$4 ($Nat.to_u16 51)))) (case self5 (#t (I$6 (I$6 (O$5 (I$6 (I$6 (O$5 ($Kind.Name.to_bits f1)))))))) (#f (let ((self5 ($U16.ltn x$4 ($Nat.to_u16 52)))) (case self5 (#t (I$6 (I$6 (O$5 (I$6 (I$6 (I$6 ($Kind.Name.to_bits f1)))))))) (#f (I$6 (I$6 (I$6 (O$5 (O$5 (O$5 ($Kind.Name.to_bits f1))))))))))))))))) (#f (let ((self5 ($U16.ltn x$4 ($Nat.to_u16 55)))) (case self5 (#t (let ((self5 ($U16.ltn x$4 ($Nat.to_u16 54)))) (case self5 (#t (I$6 (I$6 (I$6 (O$5 (O$5 (I$6 ($Kind.Name.to_bits f1)))))))) (#f (I$6 (I$6 (I$6 (O$5 (I$6 (O$5 ($Kind.Name.to_bits f1))))))))))) (#f (let ((self5 ($U16.ltn x$4 ($Nat.to_u16 56)))) (case self5 (#t (I$6 (I$6 (I$6 (O$5 (I$6 (I$6 ($Kind.Name.to_bits f1)))))))) (#f (let ((self5 ($U16.ltn x$4 ($Nat.to_u16 57)))) (case self5 (#t (I$6 (I$6 (I$6 (I$6 (O$5 (O$5 ($Kind.Name.to_bits f1)))))))) (#f (I$6 (I$6 (I$6 (I$6 (O$5 (I$6 ($Kind.Name.to_bits f1)))))))))))))))))))) (#f (let ((self5 ($U16.ltn x$4 ($Nat.to_u16 91)))) (case self5 (#t (let ((self5 ($U16.ltn x$4 ($Nat.to_u16 78)))) (case self5 (#t (let ((self5 ($U16.ltn x$4 ($Nat.to_u16 71)))) (case self5 (#t (let ((self5 ($U16.ltn x$4 ($Nat.to_u16 68)))) (case self5 (#t (let ((self5 ($U16.ltn x$4 ($Nat.to_u16 66)))) (case self5 (#t (O$5 (O$5 (O$5 (O$5 (O$5 (O$5 ($Kind.Name.to_bits f1)))))))) (#f (let ((self5 ($U16.ltn x$4 ($Nat.to_u16 67)))) (case self5 (#t (O$5 (O$5 (O$5 (O$5 (O$5 (I$6 ($Kind.Name.to_bits f1)))))))) (#f (O$5 (O$5 (O$5 (O$5 (I$6 (O$5 ($Kind.Name.to_bits f1)))))))))))))) (#f (let ((self5 ($U16.ltn x$4 ($Nat.to_u16 69)))) (case self5 (#t (O$5 (O$5 (O$5 (O$5 (I$6 (I$6 ($Kind.Name.to_bits f1)))))))) (#f (let ((self5 ($U16.ltn x$4 ($Nat.to_u16 70)))) (case self5 (#t (O$5 (O$5 (O$5 (I$6 (O$5 (O$5 ($Kind.Name.to_bits f1)))))))) (#f (O$5 (O$5 (O$5 (I$6 (O$5 (I$6 ($Kind.Name.to_bits f1))))))))))))))))) (#f (let ((self5 ($U16.ltn x$4 ($Nat.to_u16 74)))) (case self5 (#t (let ((self5 ($U16.ltn x$4 ($Nat.to_u16 72)))) (case self5 (#t (O$5 (O$5 (O$5 (I$6 (I$6 (O$5 ($Kind.Name.to_bits f1)))))))) (#f (let ((self5 ($U16.ltn x$4 ($Nat.to_u16 73)))) (case self5 (#t (O$5 (O$5 (O$5 (I$6 (I$6 (I$6 ($Kind.Name.to_bits f1)))))))) (#f (O$5 (O$5 (I$6 (O$5 (O$5 (O$5 ($Kind.Name.to_bits f1)))))))))))))) (#f (let ((self5 ($U16.ltn x$4 ($Nat.to_u16 76)))) (case self5 (#t (let ((self5 ($U16.ltn x$4 ($Nat.to_u16 75)))) (case self5 (#t (O$5 (O$5 (I$6 (O$5 (O$5 (I$6 ($Kind.Name.to_bits f1)))))))) (#f (O$5 (O$5 (I$6 (O$5 (I$6 (O$5 ($Kind.Name.to_bits f1))))))))))) (#f (let ((self5 ($U16.ltn x$4 ($Nat.to_u16 77)))) (case self5 (#t (O$5 (O$5 (I$6 (O$5 (I$6 (I$6 ($Kind.Name.to_bits f1)))))))) (#f (O$5 (O$5 (I$6 (I$6 (O$5 (O$5 ($Kind.Name.to_bits f1)))))))))))))))))))) (#f (let ((self5 ($U16.ltn x$4 ($Nat.to_u16 84)))) (case self5 (#t (let ((self5 ($U16.ltn x$4 ($Nat.to_u16 81)))) (case self5 (#t (let ((self5 ($U16.ltn x$4 ($Nat.to_u16 79)))) (case self5 (#t (O$5 (O$5 (I$6 (I$6 (O$5 (I$6 ($Kind.Name.to_bits f1)))))))) (#f (let ((self5 ($U16.ltn x$4 ($Nat.to_u16 80)))) (case self5 (#t (O$5 (O$5 (I$6 (I$6 (I$6 (O$5 ($Kind.Name.to_bits f1)))))))) (#f (O$5 (O$5 (I$6 (I$6 (I$6 (I$6 ($Kind.Name.to_bits f1)))))))))))))) (#f (let ((self5 ($U16.ltn x$4 ($Nat.to_u16 82)))) (case self5 (#t (O$5 (I$6 (O$5 (O$5 (O$5 (O$5 ($Kind.Name.to_bits f1)))))))) (#f (let ((self5 ($U16.ltn x$4 ($Nat.to_u16 83)))) (case self5 (#t (O$5 (I$6 (O$5 (O$5 (O$5 (I$6 ($Kind.Name.to_bits f1)))))))) (#f (O$5 (I$6 (O$5 (O$5 (I$6 (O$5 ($Kind.Name.to_bits f1))))))))))))))))) (#f (let ((self5 ($U16.ltn x$4 ($Nat.to_u16 87)))) (case self5 (#t (let ((self5 ($U16.ltn x$4 ($Nat.to_u16 85)))) (case self5 (#t (O$5 (I$6 (O$5 (O$5 (I$6 (I$6 ($Kind.Name.to_bits f1)))))))) (#f (let ((self5 ($U16.ltn x$4 ($Nat.to_u16 86)))) (case self5 (#t (O$5 (I$6 (O$5 (I$6 (O$5 (O$5 ($Kind.Name.to_bits f1)))))))) (#f (O$5 (I$6 (O$5 (I$6 (O$5 (I$6 ($Kind.Name.to_bits f1)))))))))))))) (#f (let ((self5 ($U16.ltn x$4 ($Nat.to_u16 89)))) (case self5 (#t (let ((self5 ($U16.ltn x$4 ($Nat.to_u16 88)))) (case self5 (#t (O$5 (I$6 (O$5 (I$6 (I$6 (O$5 ($Kind.Name.to_bits f1)))))))) (#f (O$5 (I$6 (O$5 (I$6 (I$6 (I$6 ($Kind.Name.to_bits f1))))))))))) (#f (let ((self5 ($U16.ltn x$4 ($Nat.to_u16 90)))) (case self5 (#t (O$5 (I$6 (I$6 (O$5 (O$5 (O$5 ($Kind.Name.to_bits f1)))))))) (#f (O$5 (I$6 (I$6 (O$5 (O$5 (I$6 ($Kind.Name.to_bits f1))))))))))))))))))))))) (#f (let ((self5 ($U16.ltn x$4 ($Nat.to_u16 96)))) (case self5 (#t (I$6 (I$6 (I$6 (I$6 (I$6 (I$6 ($Kind.Name.to_bits f1)))))))) (#f (let ((self5 ($U16.ltn x$4 ($Nat.to_u16 110)))) (case self5 (#t (let ((self5 ($U16.ltn x$4 ($Nat.to_u16 103)))) (case self5 (#t (let ((self5 ($U16.ltn x$4 ($Nat.to_u16 100)))) (case self5 (#t (let ((self5 ($U16.ltn x$4 ($Nat.to_u16 98)))) (case self5 (#t (O$5 (I$6 (I$6 (O$5 (I$6 (O$5 ($Kind.Name.to_bits f1)))))))) (#f (let ((self5 ($U16.ltn x$4 ($Nat.to_u16 99)))) (case self5 (#t (O$5 (I$6 (I$6 (O$5 (I$6 (I$6 ($Kind.Name.to_bits f1)))))))) (#f (O$5 (I$6 (I$6 (I$6 (O$5 (O$5 ($Kind.Name.to_bits f1)))))))))))))) (#f (let ((self5 ($U16.ltn x$4 ($Nat.to_u16 101)))) (case self5 (#t (O$5 (I$6 (I$6 (I$6 (O$5 (I$6 ($Kind.Name.to_bits f1)))))))) (#f (let ((self5 ($U16.ltn x$4 ($Nat.to_u16 102)))) (case self5 (#t (O$5 (I$6 (I$6 (I$6 (I$6 (O$5 ($Kind.Name.to_bits f1)))))))) (#f (O$5 (I$6 (I$6 (I$6 (I$6 (I$6 ($Kind.Name.to_bits f1))))))))))))))))) (#f (let ((self5 ($U16.ltn x$4 ($Nat.to_u16 106)))) (case self5 (#t (let ((self5 ($U16.ltn x$4 ($Nat.to_u16 104)))) (case self5 (#t (I$6 (O$5 (O$5 (O$5 (O$5 (O$5 ($Kind.Name.to_bits f1)))))))) (#f (let ((self5 ($U16.ltn x$4 ($Nat.to_u16 105)))) (case self5 (#t (I$6 (O$5 (O$5 (O$5 (O$5 (I$6 ($Kind.Name.to_bits f1)))))))) (#f (I$6 (O$5 (O$5 (O$5 (I$6 (O$5 ($Kind.Name.to_bits f1)))))))))))))) (#f (let ((self5 ($U16.ltn x$4 ($Nat.to_u16 108)))) (case self5 (#t (let ((self5 ($U16.ltn x$4 ($Nat.to_u16 107)))) (case self5 (#t (I$6 (O$5 (O$5 (O$5 (I$6 (I$6 ($Kind.Name.to_bits f1)))))))) (#f (I$6 (O$5 (O$5 (I$6 (O$5 (O$5 ($Kind.Name.to_bits f1))))))))))) (#f (let ((self5 ($U16.ltn x$4 ($Nat.to_u16 109)))) (case self5 (#t (I$6 (O$5 (O$5 (I$6 (O$5 (I$6 ($Kind.Name.to_bits f1)))))))) (#f (I$6 (O$5 (O$5 (I$6 (I$6 (O$5 ($Kind.Name.to_bits f1)))))))))))))))))))) (#f (let ((self5 ($U16.ltn x$4 ($Nat.to_u16 116)))) (case self5 (#t (let ((self5 ($U16.ltn x$4 ($Nat.to_u16 113)))) (case self5 (#t (let ((self5 ($U16.ltn x$4 ($Nat.to_u16 111)))) (case self5 (#t (I$6 (O$5 (O$5 (I$6 (I$6 (I$6 ($Kind.Name.to_bits f1)))))))) (#f (let ((self5 ($U16.ltn x$4 ($Nat.to_u16 112)))) (case self5 (#t (I$6 (O$5 (I$6 (O$5 (O$5 (O$5 ($Kind.Name.to_bits f1)))))))) (#f (I$6 (O$5 (I$6 (O$5 (O$5 (I$6 ($Kind.Name.to_bits f1)))))))))))))) (#f (let ((self5 ($U16.ltn x$4 ($Nat.to_u16 114)))) (case self5 (#t (I$6 (O$5 (I$6 (O$5 (I$6 (O$5 ($Kind.Name.to_bits f1)))))))) (#f (let ((self5 ($U16.ltn x$4 ($Nat.to_u16 115)))) (case self5 (#t (I$6 (O$5 (I$6 (O$5 (I$6 (I$6 ($Kind.Name.to_bits f1)))))))) (#f (I$6 (O$5 (I$6 (I$6 (O$5 (O$5 ($Kind.Name.to_bits f1))))))))))))))))) (#f (let ((self5 ($U16.ltn x$4 ($Nat.to_u16 119)))) (case self5 (#t (let ((self5 ($U16.ltn x$4 ($Nat.to_u16 117)))) (case self5 (#t (I$6 (O$5 (I$6 (I$6 (O$5 (I$6 ($Kind.Name.to_bits f1)))))))) (#f (let ((self5 ($U16.ltn x$4 ($Nat.to_u16 118)))) (case self5 (#t (I$6 (O$5 (I$6 (I$6 (I$6 (O$5 ($Kind.Name.to_bits f1)))))))) (#f (I$6 (O$5 (I$6 (I$6 (I$6 (I$6 ($Kind.Name.to_bits f1)))))))))))))) (#f (let ((self5 ($U16.ltn x$4 ($Nat.to_u16 121)))) (case self5 (#t (let ((self5 ($U16.ltn x$4 ($Nat.to_u16 120)))) (case self5 (#t (I$6 (I$6 (O$5 (O$5 (O$5 (O$5 ($Kind.Name.to_bits f1)))))))) (#f (I$6 (I$6 (O$5 (O$5 (O$5 (I$6 ($Kind.Name.to_bits f1))))))))))) (#f (let ((self5 ($U16.ltn x$4 ($Nat.to_u16 122)))) (case self5 (#t (I$6 (I$6 (O$5 (O$5 (I$6 (O$5 ($Kind.Name.to_bits f1)))))))) (#f (I$6 (I$6 (O$5 (O$5 (I$6 (I$6 ($Kind.Name.to_bits f1)))))))))))))))))))))))))))))))))))))))))))
(define Kind.Name.to_bits.go (lambda (name$0) (lambda (end$1) ($Kind.Name.to_bits.go name$0 end$1))))
(define Bits.e #b1)
(define ($Kind.Name.to_bits name$0) ($Kind.Name.to_bits.go name$0 Bits.e))
(define Kind.Name.to_bits (lambda (name$0) ($Kind.Name.to_bits name$0)))
(define ($Kind.Map.get name$1 map$2) ($BitsMap.get ($Kind.Name.to_bits name$1) map$2))
(define Kind.Map.get (lambda (name$1) (lambda (map$2) ($Kind.Map.get name$1 map$2))))
(define ($Maybe.default m$1 a$2) (let ((self0 m$1)) (case (get self0 0) ('Maybe.none a$2) ('Maybe.some (let ((f0 (get self0 1))) f0)))))
(define Maybe.default (lambda (m$1) (lambda (a$2) ($Maybe.default m$1 a$2))))
(define ($Parser.State.new err$0 nam$1 ini$2 idx$3 str$4) (vector 'Parser.State.new err$0 nam$1 ini$2 idx$3 str$4))
(define Parser.State.new (lambda (err$0) (lambda (nam$1) (lambda (ini$2) (lambda (idx$3) (lambda (str$4) ($Parser.State.new err$0 nam$1 ini$2 idx$3 str$4)))))))
(define ($Maybe.some value$1) (vector 'Maybe.some value$1))
(define Maybe.some (lambda (value$1) ($Maybe.some value$1)))
(define ($Parser.run parser$1 code$2) (let ((self0 (parser$1 ($Parser.State.new Maybe.none "" 0 0 code$2)))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))) Maybe.none)) ('Parser.Reply.value (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($Maybe.some f1)))))))
(define Parser.run (lambda (parser$1) (lambda (code$2) ($Parser.run parser$1 code$2))))
(define ($Parser.Reply.error err$1) (vector 'Parser.Reply.error err$1))
(define Parser.Reply.error (lambda (err$1) ($Parser.Reply.error err$1)))
(define ($Nat.gtn n$0 m$1) (> n$0 m$1))
(define Nat.gtn (lambda (n$0) (lambda (m$1) ($Nat.gtn n$0 m$1))))
(define ($Parser.Error.combine a$0 b$1) (let ((self0 a$0)) (case (get self0 0) ('Parser.Error.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((self4 b$1)) (case (get self4 0) ('Parser.Error.new (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((f6 (get self4 3))) (let ((f7 (get self4 4))) (let ((self8 ($Nat.gtn f2 f6))) (case self8 (#t a$0) (#f b$1))))))))))))))))))
(define Parser.Error.combine (lambda (a$0) (lambda (b$1) ($Parser.Error.combine a$0 b$1))))
(define ($Parser.Error.maybe_combine a$0 b$1) (let ((self0 a$0)) (case (get self0 0) ('Maybe.none (let ((self0 b$1)) (case (get self0 0) ('Maybe.none Maybe.none) ('Maybe.some (let ((f0 (get self0 1))) b$1))))) ('Maybe.some (let ((f0 (get self0 1))) (let ((self1 b$1)) (case (get self1 0) ('Maybe.none a$0) ('Maybe.some (let ((f1 (get self1 1))) ($Maybe.some ($Parser.Error.combine f0 f1)))))))))))
(define Parser.Error.maybe_combine (lambda (a$0) (lambda (b$1) ($Parser.Error.maybe_combine a$0 b$1))))
(define ($Parser.Reply.value pst$1 val$2) (vector 'Parser.Reply.value pst$1 val$2))
(define Parser.Reply.value (lambda (pst$1) (lambda (val$2) ($Parser.Reply.value pst$1 val$2))))
(define List.nil (vector 'List.nil))
(define ($List.cons head$1 tail$2) (vector 'List.cons head$1 tail$2))
(define List.cons (lambda (head$1) (lambda (tail$2) ($List.cons head$1 tail$2))))
(define ($Parser.many.go parse$1 values$2 pst$3) (let ((self0 pst$3)) (case (get self0 0) ('Parser.State.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((self5 (parse$1 pst$3))) (case (get self5 0) ('Parser.Reply.error (let ((f5 (get self5 1))) ($Parser.Reply.value pst$3 (values$2 List.nil)))) ('Parser.Reply.value (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) ($Parser.many.go parse$1 (lambda (xs$11) (values$2 ($List.cons f6 xs$11))) f5)))))))))))))))
(define Parser.many.go (lambda (parse$1) (lambda (values$2) (lambda (pst$3) ($Parser.many.go parse$1 values$2 pst$3)))))
(define ($Parser.many parser$1) ((Parser.many.go parser$1) (lambda (x$2) x$2)))
(define Parser.many (lambda (parser$1) ($Parser.many parser$1)))
(define ($Parser.many1 parser$1 pst$2) (let ((self0 pst$2)) (case (get self0 0) ('Parser.State.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((reply$8 (parser$1 pst$2))) (let ((self6 reply$8)) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))) (let ((self7 f0)) (case (get self7 0) ('Maybe.none ($Parser.Reply.error f6)) ('Maybe.some (let ((f7 (get self7 1))) ($Parser.Reply.error ($Parser.Error.combine f7 f6)))))))) ('Parser.Reply.value (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((self8 f6)) (case (get self8 0) ('Parser.State.new (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) (let ((f11 (get self8 4))) (let ((f12 (get self8 5))) (let ((reply.pst$16 ($Parser.State.new ($Parser.Error.maybe_combine f0 f8) f9 f10 f11 f12))) (let ((self14 reply.pst$16)) (case (get self14 0) ('Parser.State.new (let ((f14 (get self14 1))) (let ((f15 (get self14 2))) (let ((f16 (get self14 3))) (let ((f17 (get self14 4))) (let ((f18 (get self14 5))) (let ((reply$22 (($Parser.many parser$1) reply.pst$16))) (let ((self20 reply$22)) (case (get self20 0) ('Parser.Reply.error (let ((f20 (get self20 1))) (let ((self21 f14)) (case (get self21 0) ('Maybe.none ($Parser.Reply.error f20)) ('Maybe.some (let ((f21 (get self21 1))) ($Parser.Reply.error ($Parser.Error.combine f21 f20)))))))) ('Parser.Reply.value (let ((f20 (get self20 1))) (let ((f21 (get self20 2))) (let ((self22 f20)) (case (get self22 0) ('Parser.State.new (let ((f22 (get self22 1))) (let ((f23 (get self22 2))) (let ((f24 (get self22 3))) (let ((f25 (get self22 4))) (let ((f26 (get self22 5))) (let ((reply.pst$30 ($Parser.State.new ($Parser.Error.maybe_combine f14 f22) f23 f24 f25 f26))) ($Parser.Reply.value reply.pst$30 ($List.cons f7 f21)))))))))))))))))))))))))))))))))))))))))))))))))
(define Parser.many1 (lambda (parser$1) (lambda (pst$2) ($Parser.many1 parser$1 pst$2))))
(define ($Parser.Error.new nam$0 ini$1 idx$2 msg$3) (vector 'Parser.Error.new nam$0 ini$1 idx$2 msg$3))
(define Parser.Error.new (lambda (nam$0) (lambda (ini$1) (lambda (idx$2) (lambda (msg$3) ($Parser.Error.new nam$0 ini$1 idx$2 msg$3))))))
(define ($Parser.Reply.fail nam$1 ini$2 idx$3 msg$4) ($Parser.Reply.error ($Parser.Error.new nam$1 ini$2 idx$3 msg$4)))
(define Parser.Reply.fail (lambda (nam$1) (lambda (ini$2) (lambda (idx$3) (lambda (msg$4) ($Parser.Reply.fail nam$1 ini$2 idx$3 msg$4))))))
(define ($Cmp.as_eql cmp$0) (let ((self0 cmp$0)) (case (get self0 0) ('Cmp.ltn Bool.false) ('Cmp.eql Bool.true) ('Cmp.gtn Bool.false))))
(define Cmp.as_eql (lambda (cmp$0) ($Cmp.as_eql cmp$0)))
(define ($Word.eql a$1 b$2) ($Cmp.as_eql ($Word.cmp a$1 b$2)))
(define Word.eql (lambda (a$1) (lambda (b$2) ($Word.eql a$1 b$2))))
(define ($U16.eql a$0 b$1) (= a$0 b$1))
(define U16.eql (lambda (a$0) (lambda (b$1) ($U16.eql a$0 b$1))))
(define ($Parser.digit pst$0) (let ((self0 pst$0)) (case (get self0 0) ('Parser.State.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((self5 f4)) (case (<= (kstring-length self5) 0) (#t ($Parser.Reply.fail f1 f2 f3 "Not a digit.")) (#f (let ((f5 (char->integer (kstring-head self5)))) (let ((f6 (kstring-tail self5))) (let ((pst$8 ($Parser.State.new f0 f1 f2 ($Nat.succ f3) f6))) (let ((self8 ($U16.eql f5 48))) (case self8 (#t ($Parser.Reply.value pst$8 0)) (#f (let ((self8 ($U16.eql f5 49))) (case self8 (#t ($Parser.Reply.value pst$8 1)) (#f (let ((self8 ($U16.eql f5 50))) (case self8 (#t ($Parser.Reply.value pst$8 2)) (#f (let ((self8 ($U16.eql f5 51))) (case self8 (#t ($Parser.Reply.value pst$8 3)) (#f (let ((self8 ($U16.eql f5 52))) (case self8 (#t ($Parser.Reply.value pst$8 4)) (#f (let ((self8 ($U16.eql f5 53))) (case self8 (#t ($Parser.Reply.value pst$8 5)) (#f (let ((self8 ($U16.eql f5 54))) (case self8 (#t ($Parser.Reply.value pst$8 6)) (#f (let ((self8 ($U16.eql f5 55))) (case self8 (#t ($Parser.Reply.value pst$8 7)) (#f (let ((self8 ($U16.eql f5 56))) (case self8 (#t ($Parser.Reply.value pst$8 8)) (#f (let ((self8 ($U16.eql f5 57))) (case self8 (#t ($Parser.Reply.value pst$8 9)) (#f ($Parser.Reply.fail f1 f2 f3 "Not a digit."))))))))))))))))))))))))))))))))))))))))))))))
(define Parser.digit (lambda (pst$0) ($Parser.digit pst$0)))
(define ($Nat.add n$0 m$1) (+ n$0 m$1))
(define Nat.add (lambda (n$0) (lambda (m$1) ($Nat.add n$0 m$1))))
(define ($Nat.mul n$0 m$1) (* n$0 m$1))
(define Nat.mul (lambda (n$0) (lambda (m$1) ($Nat.mul n$0 m$1))))
(define ($Nat.from_base.go b$0 ds$1 p$2 res$3) (let ((self0 ds$1)) (case (get self0 0) ('List.nil res$3) ('List.cons (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($Nat.from_base.go b$0 f1 ($Nat.mul b$0 p$2) ($Nat.add ($Nat.mul f0 p$2) res$3))))))))
(define Nat.from_base.go (lambda (b$0) (lambda (ds$1) (lambda (p$2) (lambda (res$3) ($Nat.from_base.go b$0 ds$1 p$2 res$3))))))
(define ($List.reverse.go xs$1 res$2) (let ((self0 xs$1)) (case (get self0 0) ('List.nil res$2) ('List.cons (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($List.reverse.go f1 ($List.cons f0 res$2))))))))
(define List.reverse.go (lambda (xs$1) (lambda (res$2) ($List.reverse.go xs$1 res$2))))
(define ($List.reverse xs$1) ($List.reverse.go xs$1 List.nil))
(define List.reverse (lambda (xs$1) ($List.reverse xs$1)))
(define ($Nat.from_base base$0 ds$1) ($Nat.from_base.go base$0 ($List.reverse ds$1) 1 0))
(define Nat.from_base (lambda (base$0) (lambda (ds$1) ($Nat.from_base base$0 ds$1))))
(define ($Parser.nat pst$0) (let ((self0 pst$0)) (case (get self0 0) ('Parser.State.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((reply$6 ($Parser.many1 Parser.digit pst$0))) (let ((self6 reply$6)) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))) (let ((self7 f0)) (case (get self7 0) ('Maybe.none ($Parser.Reply.error f6)) ('Maybe.some (let ((f7 (get self7 1))) ($Parser.Reply.error ($Parser.Error.combine f7 f6)))))))) ('Parser.Reply.value (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((self8 f6)) (case (get self8 0) ('Parser.State.new (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) (let ((f11 (get self8 4))) (let ((f12 (get self8 5))) (let ((reply.pst$14 ($Parser.State.new ($Parser.Error.maybe_combine f0 f8) f9 f10 f11 f12))) ($Parser.Reply.value reply.pst$14 ($Nat.from_base 10 f7))))))))))))))))))))))))))
(define Parser.nat (lambda (pst$0) ($Parser.nat pst$0)))
(define ($Nat.read str$0) ($Maybe.default ($Parser.run Parser.nat str$0) 0))
(define Nat.read (lambda (str$0) ($Nat.read str$0)))
(define IO.get_time ($IO.ask "get_time" "" (lambda (time$0) ($IO.end ($Nat.read time$0)))))
(define ($Kind.Synth.load.cached.is_loop name$0 defs$1) (let ((self0 ($Kind.Map.get name$0 defs$1))) (case (get self0 0) ('Maybe.none Bool.false) ('Maybe.some (let ((f0 (get self0 1))) (let ((self1 f0)) (case (get self1 0) ('Kind.Def.new (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((f6 (get self1 6))) (let ((f7 (get self1 7))) (let ((f8 (get self1 8))) (let ((f9 (get self1 9))) (let ((self10 f9)) (case (get self10 0) ('Kind.Status.init Bool.false) ('Kind.Status.wait Bool.false) ('Kind.Status.done (let ((f10 (get self10 1))) f10)) ('Kind.Status.fail (let ((f10 (get self10 1))) Bool.false)))))))))))))))))))))
(define Kind.Synth.load.cached.is_loop (lambda (name$0) (lambda (defs$1) ($Kind.Synth.load.cached.is_loop name$0 defs$1))))
(define ($IO.get_file name$0) ($IO.ask "get_file" name$0 (lambda (file$1) ($IO.end file$1))))
(define IO.get_file (lambda (name$0) ($IO.get_file name$0)))
(define ($String.cons head$0 tail$1) (kstring-append (make-string 1 (integer->char head$0)) tail$1))
(define String.cons (lambda (head$0) (lambda (tail$1) ($String.cons head$0 tail$1))))
(define ($String.concat as$0 bs$1) (kstring-append as$0 bs$1))
(define String.concat (lambda (as$0) (lambda (bs$1) ($String.concat as$0 bs$1))))
(define ($Bits.hex.encode x$0) (let ((self0 x$0)) (case (if (eq? self0 #b1) 2 (bitwise-and self0 #b1)) (2 "") (0 (let ((f0 (bitwise-arithmetic-shift-right self0 #b1))) (let ((self1 f0)) (case (if (eq? self1 #b1) 2 (bitwise-and self1 #b1)) (2 "0") (0 (let ((f1 (bitwise-arithmetic-shift-right self1 #b1))) (let ((self2 f1)) (case (if (eq? self2 #b1) 2 (bitwise-and self2 #b1)) (2 "0") (0 (let ((f2 (bitwise-arithmetic-shift-right self2 #b1))) (let ((self3 f2)) (case (if (eq? self3 #b1) 2 (bitwise-and self3 #b1)) (2 "0") (0 (let ((f3 (bitwise-arithmetic-shift-right self3 #b1))) ($String.concat "0" ($Bits.hex.encode f3)))) (1 (let ((f3 (bitwise-arithmetic-shift-right self3 #b1))) ($String.concat "8" ($Bits.hex.encode f3)))))))) (1 (let ((f2 (bitwise-arithmetic-shift-right self2 #b1))) (let ((self3 f2)) (case (if (eq? self3 #b1) 2 (bitwise-and self3 #b1)) (2 "4") (0 (let ((f3 (bitwise-arithmetic-shift-right self3 #b1))) ($String.concat "4" ($Bits.hex.encode f3)))) (1 (let ((f3 (bitwise-arithmetic-shift-right self3 #b1))) ($String.concat "c" ($Bits.hex.encode f3)))))))))))) (1 (let ((f1 (bitwise-arithmetic-shift-right self1 #b1))) (let ((self2 f1)) (case (if (eq? self2 #b1) 2 (bitwise-and self2 #b1)) (2 "2") (0 (let ((f2 (bitwise-arithmetic-shift-right self2 #b1))) (let ((self3 f2)) (case (if (eq? self3 #b1) 2 (bitwise-and self3 #b1)) (2 "2") (0 (let ((f3 (bitwise-arithmetic-shift-right self3 #b1))) ($String.concat "2" ($Bits.hex.encode f3)))) (1 (let ((f3 (bitwise-arithmetic-shift-right self3 #b1))) ($String.concat "a" ($Bits.hex.encode f3)))))))) (1 (let ((f2 (bitwise-arithmetic-shift-right self2 #b1))) (let ((self3 f2)) (case (if (eq? self3 #b1) 2 (bitwise-and self3 #b1)) (2 "6") (0 (let ((f3 (bitwise-arithmetic-shift-right self3 #b1))) ($String.concat "6" ($Bits.hex.encode f3)))) (1 (let ((f3 (bitwise-arithmetic-shift-right self3 #b1))) ($String.concat "e" ($Bits.hex.encode f3)))))))))))))))) (1 (let ((f0 (bitwise-arithmetic-shift-right self0 #b1))) (let ((self1 f0)) (case (if (eq? self1 #b1) 2 (bitwise-and self1 #b1)) (2 "1") (0 (let ((f1 (bitwise-arithmetic-shift-right self1 #b1))) (let ((self2 f1)) (case (if (eq? self2 #b1) 2 (bitwise-and self2 #b1)) (2 "1") (0 (let ((f2 (bitwise-arithmetic-shift-right self2 #b1))) (let ((self3 f2)) (case (if (eq? self3 #b1) 2 (bitwise-and self3 #b1)) (2 "1") (0 (let ((f3 (bitwise-arithmetic-shift-right self3 #b1))) ($String.concat "1" ($Bits.hex.encode f3)))) (1 (let ((f3 (bitwise-arithmetic-shift-right self3 #b1))) ($String.concat "9" ($Bits.hex.encode f3)))))))) (1 (let ((f2 (bitwise-arithmetic-shift-right self2 #b1))) (let ((self3 f2)) (case (if (eq? self3 #b1) 2 (bitwise-and self3 #b1)) (2 "5") (0 (let ((f3 (bitwise-arithmetic-shift-right self3 #b1))) ($String.concat "5" ($Bits.hex.encode f3)))) (1 (let ((f3 (bitwise-arithmetic-shift-right self3 #b1))) ($String.concat "d" ($Bits.hex.encode f3)))))))))))) (1 (let ((f1 (bitwise-arithmetic-shift-right self1 #b1))) (let ((self2 f1)) (case (if (eq? self2 #b1) 2 (bitwise-and self2 #b1)) (2 "3") (0 (let ((f2 (bitwise-arithmetic-shift-right self2 #b1))) (let ((self3 f2)) (case (if (eq? self3 #b1) 2 (bitwise-and self3 #b1)) (2 "3") (0 (let ((f3 (bitwise-arithmetic-shift-right self3 #b1))) ($String.concat "3" ($Bits.hex.encode f3)))) (1 (let ((f3 (bitwise-arithmetic-shift-right self3 #b1))) ($String.concat "b" ($Bits.hex.encode f3)))))))) (1 (let ((f2 (bitwise-arithmetic-shift-right self2 #b1))) (let ((self3 f2)) (case (if (eq? self3 #b1) 2 (bitwise-and self3 #b1)) (2 "7") (0 (let ((f3 (bitwise-arithmetic-shift-right self3 #b1))) ($String.concat "7" ($Bits.hex.encode f3)))) (1 (let ((f3 (bitwise-arithmetic-shift-right self3 #b1))) ($String.concat "f" ($Bits.hex.encode f3)))))))))))))))))))
(define Bits.hex.encode (lambda (x$0) ($Bits.hex.encode x$0)))
(define ($Kind.Synth.load.cached.name name$0) ($String.concat ".cache/" ($Bits.hex.encode ($Kind.Name.to_bits name$0))))
(define Kind.Synth.load.cached.name (lambda (name$0) ($Kind.Synth.load.cached.name name$0)))
(define ($Kind.Synth.load.cached.get_file name$0) ($IO.get_file ($Kind.Synth.load.cached.name name$0)))
(define Kind.Synth.load.cached.get_file (lambda (name$0) ($Kind.Synth.load.cached.get_file name$0)))
(define ($Bool.not a$0) (not a$0))
(define Bool.not (lambda (a$0) ($Bool.not a$0)))
(define ($String.is_empty str$0) (let ((self0 str$0)) (case (<= (kstring-length self0) 0) (#t Bool.true) (#f (let ((f0 (char->integer (kstring-head self0)))) (let ((f1 (kstring-tail self0))) Bool.false))))))
(define String.is_empty (lambda (str$0) ($String.is_empty str$0)))
(define ($IO.get_file_mtime name$0) ($IO.ask "get_file_mtime" name$0 (lambda (file$1) ($IO.end file$1))))
(define IO.get_file_mtime (lambda (name$0) ($IO.get_file_mtime name$0)))
(define ($Bool.and a$0 b$1) (and a$0 b$1))
(define Bool.and (lambda (a$0) (lambda (b$1) ($Bool.and a$0 b$1))))
(define ($String.eql a$0 b$1) (string=? (kstring->string a$0) (kstring->string b$1)))
(define String.eql (lambda (a$0) (lambda (b$1) ($String.eql a$0 b$1))))
(define ($Pair.new fst$2 snd$3) (vector 'Pair.new fst$2 snd$3))
(define Pair.new (lambda (fst$2) (lambda (snd$3) ($Pair.new fst$2 snd$3))))
(define ($Maybe.bind m$2 f$3) (let ((self0 m$2)) (case (get self0 0) ('Maybe.none Maybe.none) ('Maybe.some (let ((f0 (get self0 1))) (f$3 f0))))))
(define Maybe.bind (lambda (m$2) (lambda (f$3) ($Maybe.bind m$2 f$3))))
(define Maybe.monad (vector 'Monad.new Maybe.bind Maybe.some))
(define Unit.new (vector 'Unit.new))
(define ($Bool.or a$0 b$1) (or a$0 b$1))
(define Bool.or (lambda (a$0) (lambda (b$1) ($Bool.or a$0 b$1))))
(define ($Kind.Core.read.spaces code$0) (let ((self0 code$0)) (case (<= (kstring-length self0) 0) (#t ($Pair.new code$0 Unit.new)) (#f (let ((f0 (char->integer (kstring-head self0)))) (let ((f1 (kstring-tail self0))) (let ((is_space$3 ($Bool.or ($U16.eql f0 32) ($Bool.or ($U16.eql f0 10) ($Bool.or ($U16.eql f0 13) ($Bool.or ($U16.eql f0 9) ($Bool.or ($U16.eql f0 11) ($Bool.or ($U16.eql f0 12) Bool.false)))))))) (let ((self3 is_space$3)) (case self3 (#t ($Kind.Core.read.spaces f1)) (#f ($Pair.new code$0 Unit.new)))))))))))
(define Kind.Core.read.spaces (lambda (code$0) ($Kind.Core.read.spaces code$0)))
(define ($Kind.Term.ref name$0) (vector 'Kind.Term.ref name$0))
(define Kind.Term.ref (lambda (name$0) ($Kind.Term.ref name$0)))
(define ($Char.eql a$0 b$1) ($U16.eql a$0 b$1))
(define Char.eql (lambda (a$0) (lambda (b$1) ($Char.eql a$0 b$1))))
(define Kind.Term.typ (vector 'Kind.Term.typ))
(define ($Cmp.as_gte cmp$0) (let ((self0 cmp$0)) (case (get self0 0) ('Cmp.ltn Bool.false) ('Cmp.eql Bool.true) ('Cmp.gtn Bool.true))))
(define Cmp.as_gte (lambda (cmp$0) ($Cmp.as_gte cmp$0)))
(define ($Word.gte a$1 b$2) ($Cmp.as_gte ($Word.cmp a$1 b$2)))
(define Word.gte (lambda (a$1) (lambda (b$2) ($Word.gte a$1 b$2))))
(define ($U16.gte a$0 b$1) (>= a$0 b$1))
(define U16.gte (lambda (a$0) (lambda (b$1) ($U16.gte a$0 b$1))))
(define ($Cmp.as_lte cmp$0) (let ((self0 cmp$0)) (case (get self0 0) ('Cmp.ltn Bool.true) ('Cmp.eql Bool.true) ('Cmp.gtn Bool.false))))
(define Cmp.as_lte (lambda (cmp$0) ($Cmp.as_lte cmp$0)))
(define ($Word.lte a$1 b$2) ($Cmp.as_lte ($Word.cmp a$1 b$2)))
(define Word.lte (lambda (a$1) (lambda (b$2) ($Word.lte a$1 b$2))))
(define ($U16.lte a$0 b$1) (<= a$0 b$1))
(define U16.lte (lambda (a$0) (lambda (b$1) ($U16.lte a$0 b$1))))
(define ($Kind.Core.read.is_name chr$0) ($Bool.or ($Bool.and ($U16.gte chr$0 ($Nat.to_u16 46)) ($U16.lte chr$0 ($Nat.to_u16 47))) ($Bool.or ($Bool.and ($U16.gte chr$0 ($Nat.to_u16 48)) ($U16.ltn chr$0 ($Nat.to_u16 58))) ($Bool.or ($Bool.and ($U16.gte chr$0 ($Nat.to_u16 65)) ($U16.ltn chr$0 ($Nat.to_u16 91))) ($Bool.or ($Bool.and ($U16.gte chr$0 ($Nat.to_u16 95)) ($U16.ltn chr$0 ($Nat.to_u16 96))) ($Bool.or ($Bool.and ($U16.gte chr$0 ($Nat.to_u16 97)) ($U16.ltn chr$0 ($Nat.to_u16 123))) Bool.false))))))
(define Kind.Core.read.is_name (lambda (chr$0) ($Kind.Core.read.is_name chr$0)))
(define ($Kind.Core.read.name code$0) (let ((self0 code$0)) (case (<= (kstring-length self0) 0) (#t ($Pair.new code$0 "")) (#f (let ((f0 (char->integer (kstring-head self0)))) (let ((f1 (kstring-tail self0))) (let ((self2 ($Kind.Core.read.is_name f0))) (case self2 (#t (let ((self2 ($Kind.Core.read.name f1))) (case (get self2 0) ('Pair.new (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) ($Pair.new f2 ($String.cons f0 f3)))))))) (#f ($Pair.new code$0 ""))))))))))
(define Kind.Core.read.name (lambda (code$0) ($Kind.Core.read.name code$0)))
(define ($Kind.Core.read.char code$0 chr$1) (let ((self0 ($Kind.Core.read.spaces code$0))) (case (get self0 0) ('Pair.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((self2 f0)) (case (<= (kstring-length self2) 0) (#t ($Pair.new "" Unit.new)) (#f (let ((f2 (char->integer (kstring-head self2)))) (let ((f3 (kstring-tail self2))) (let ((self4 ($U16.eql f2 chr$1))) (case self4 (#t ($Pair.new f3 Unit.new)) (#f ($Pair.new "" Unit.new)))))))))))))))
(define Kind.Core.read.char (lambda (code$0) (lambda (chr$1) ($Kind.Core.read.char code$0 chr$1))))
(define ($Kind.Term.all eras$0 self$1 name$2 xtyp$3 body$4) (vector 'Kind.Term.all eras$0 self$1 name$2 xtyp$3 body$4))
(define Kind.Term.all (lambda (eras$0) (lambda (self$1) (lambda (name$2) (lambda (xtyp$3) (lambda (body$4) ($Kind.Term.all eras$0 self$1 name$2 xtyp$3 body$4)))))))
(define ($Kind.Term.lam name$0 body$1) (vector 'Kind.Term.lam name$0 body$1))
(define Kind.Term.lam (lambda (name$0) (lambda (body$1) ($Kind.Term.lam name$0 body$1))))
(define ($Kind.Term.app func$0 argm$1) (vector 'Kind.Term.app func$0 argm$1))
(define Kind.Term.app (lambda (func$0) (lambda (argm$1) ($Kind.Term.app func$0 argm$1))))
(define ($Kind.Term.let name$0 expr$1 body$2) (vector 'Kind.Term.let name$0 expr$1 body$2))
(define Kind.Term.let (lambda (name$0) (lambda (expr$1) (lambda (body$2) ($Kind.Term.let name$0 expr$1 body$2)))))
(define ($Kind.Term.def name$0 expr$1 body$2) (vector 'Kind.Term.def name$0 expr$1 body$2))
(define Kind.Term.def (lambda (name$0) (lambda (expr$1) (lambda (body$2) ($Kind.Term.def name$0 expr$1 body$2)))))
(define ($Kind.Term.ann done$0 term$1 type$2) (vector 'Kind.Term.ann done$0 term$1 type$2))
(define Kind.Term.ann (lambda (done$0) (lambda (term$1) (lambda (type$2) ($Kind.Term.ann done$0 term$1 type$2)))))
(define ($String.starts_with xs$0 match$1) (let ((self0 match$1)) (case (<= (kstring-length self0) 0) (#t Bool.true) (#f (let ((f0 (char->integer (kstring-head self0)))) (let ((f1 (kstring-tail self0))) (let ((self2 xs$0)) (case (<= (kstring-length self2) 0) (#t Bool.false) (#f (let ((f2 (char->integer (kstring-head self2)))) (let ((f3 (kstring-tail self2))) (let ((self4 ($Char.eql f0 f2))) (case self4 (#t ($String.starts_with f3 f1)) (#f Bool.false))))))))))))))
(define String.starts_with (lambda (xs$0) (lambda (match$1) ($String.starts_with xs$0 match$1))))
(define String.nil "")
(define ($String.drop n$0 xs$1) (let ((self0 n$0)) (case (= self0 0) (#t xs$1) (#f (let ((f0 (- self0 1))) (let ((self1 xs$1)) (case (<= (kstring-length self1) 0) (#t String.nil) (#f (let ((f1 (char->integer (kstring-head self1)))) (let ((f2 (kstring-tail self1))) ($String.drop f0 f2)))))))))))
(define String.drop (lambda (n$0) (lambda (xs$1) ($String.drop n$0 xs$1))))
(define ($Char.is_hex chr$0) ($Bool.or ($Bool.and ($U16.gte chr$0 48) ($U16.lte chr$0 57)) ($Bool.or ($Bool.and ($U16.gte chr$0 97) ($U16.lte chr$0 102)) ($Bool.or ($Bool.and ($U16.gte chr$0 65) ($U16.lte chr$0 70)) Bool.false))))
(define Char.is_hex (lambda (chr$0) ($Char.is_hex chr$0)))
(define ($Word.adder a$1 b$2 c$3) ((let ((self0 a$1)) (case (get self0 0) ('Word.e (lambda (b$4) Word.e)) ('Word.o (let ((f0 (get self0 1))) (lambda (b$6) ((let ((self2 b$6)) (case (get self2 0) ('Word.e (lambda (a.pred$7) Word.e)) ('Word.o (let ((f2 (get self2 1))) (lambda (a.pred$9) (let ((self4 c$3)) (case self4 (#t ($Word.i ($Word.adder a.pred$9 f2 Bool.false))) (#f ($Word.o ($Word.adder a.pred$9 f2 Bool.false)))))))) ('Word.i (let ((f2 (get self2 1))) (lambda (a.pred$9) (let ((self4 c$3)) (case self4 (#t ($Word.o ($Word.adder a.pred$9 f2 Bool.true))) (#f ($Word.i ($Word.adder a.pred$9 f2 Bool.false)))))))))) f0)))) ('Word.i (let ((f0 (get self0 1))) (lambda (b$6) ((let ((self2 b$6)) (case (get self2 0) ('Word.e (lambda (a.pred$7) Word.e)) ('Word.o (let ((f2 (get self2 1))) (lambda (a.pred$9) (let ((self4 c$3)) (case self4 (#t ($Word.o ($Word.adder a.pred$9 f2 Bool.true))) (#f ($Word.i ($Word.adder a.pred$9 f2 Bool.false)))))))) ('Word.i (let ((f2 (get self2 1))) (lambda (a.pred$9) (let ((self4 c$3)) (case self4 (#t ($Word.i ($Word.adder a.pred$9 f2 Bool.true))) (#f ($Word.o ($Word.adder a.pred$9 f2 Bool.true)))))))))) f0)))))) b$2))
(define Word.adder (lambda (a$1) (lambda (b$2) (lambda (c$3) ($Word.adder a$1 b$2 c$3)))))
(define ($Word.add a$1 b$2) ($Word.adder a$1 b$2 Bool.false))
(define Word.add (lambda (a$1) (lambda (b$2) ($Word.add a$1 b$2))))
(define ($U16.add a$0 b$1) (mod (+ a$0 b$1) 65536))
(define U16.add (lambda (a$0) (lambda (b$1) ($U16.add a$0 b$1))))
(define ($Word.shift_left.one.go word$1 prev$2) (let ((self0 word$1)) (case (get self0 0) ('Word.e Word.e) ('Word.o (let ((f0 (get self0 1))) (let ((self1 prev$2)) (case self1 (#t ($Word.i ($Word.shift_left.one.go f0 Bool.false))) (#f ($Word.o ($Word.shift_left.one.go f0 Bool.false))))))) ('Word.i (let ((f0 (get self0 1))) (let ((self1 prev$2)) (case self1 (#t ($Word.i ($Word.shift_left.one.go f0 Bool.true))) (#f ($Word.o ($Word.shift_left.one.go f0 Bool.true))))))))))
(define Word.shift_left.one.go (lambda (word$1) (lambda (prev$2) ($Word.shift_left.one.go word$1 prev$2))))
(define ($Word.shift_left.one word$1) (let ((self0 word$1)) (case (get self0 0) ('Word.e Word.e) ('Word.o (let ((f0 (get self0 1))) ($Word.o ($Word.shift_left.one.go f0 Bool.false)))) ('Word.i (let ((f0 (get self0 1))) ($Word.o ($Word.shift_left.one.go f0 Bool.true)))))))
(define Word.shift_left.one (lambda (word$1) ($Word.shift_left.one word$1)))
(define ($Word.shift_left value$1 n$2) (let ((self0 n$2)) (case (= self0 0) (#t value$1) (#f (let ((f0 (- self0 1))) ($Word.shift_left ($Word.shift_left.one value$1) f0))))))
(define Word.shift_left (lambda (value$1) (lambda (n$2) ($Word.shift_left value$1 n$2))))
(define ($Word.mul.go a$2 b$3 acc$4) (let ((self0 a$2)) (case (get self0 0) ('Word.e acc$4) ('Word.o (let ((f0 (get self0 1))) ($Word.mul.go f0 ($Word.shift_left b$3 1) acc$4))) ('Word.i (let ((f0 (get self0 1))) ($Word.mul.go f0 ($Word.shift_left b$3 1) ($Word.add b$3 acc$4)))))))
(define Word.mul.go (lambda (a$2) (lambda (b$3) (lambda (acc$4) ($Word.mul.go a$2 b$3 acc$4)))))
(define ($Word.to_zero word$1) (let ((self0 word$1)) (case (get self0 0) ('Word.e Word.e) ('Word.o (let ((f0 (get self0 1))) ($Word.o ($Word.to_zero f0)))) ('Word.i (let ((f0 (get self0 1))) ($Word.o ($Word.to_zero f0)))))))
(define Word.to_zero (lambda (word$1) ($Word.to_zero word$1)))
(define ($Word.mul a$1 b$2) ($Word.mul.go a$1 b$2 ($Word.to_zero a$1)))
(define Word.mul (lambda (a$1) (lambda (b$2) ($Word.mul a$1 b$2))))
(define ($U16.mul a$0 b$1) (mod (* a$0 b$1) 65536))
(define U16.mul (lambda (a$0) (lambda (b$1) ($U16.mul a$0 b$1))))
(define ($Word.subber a$1 b$2 c$3) ((let ((self0 a$1)) (case (get self0 0) ('Word.e (lambda (b$4) Word.e)) ('Word.o (let ((f0 (get self0 1))) (lambda (b$6) ((let ((self2 b$6)) (case (get self2 0) ('Word.e (lambda (a.pred$7) Word.e)) ('Word.o (let ((f2 (get self2 1))) (lambda (a.pred$9) (let ((self4 c$3)) (case self4 (#t ($Word.i ($Word.subber a.pred$9 f2 Bool.true))) (#f ($Word.o ($Word.subber a.pred$9 f2 Bool.false)))))))) ('Word.i (let ((f2 (get self2 1))) (lambda (a.pred$9) (let ((self4 c$3)) (case self4 (#t ($Word.o ($Word.subber a.pred$9 f2 Bool.true))) (#f ($Word.i ($Word.subber a.pred$9 f2 Bool.true)))))))))) f0)))) ('Word.i (let ((f0 (get self0 1))) (lambda (b$6) ((let ((self2 b$6)) (case (get self2 0) ('Word.e (lambda (a.pred$7) Word.e)) ('Word.o (let ((f2 (get self2 1))) (lambda (a.pred$9) (let ((self4 c$3)) (case self4 (#t ($Word.o ($Word.subber a.pred$9 f2 Bool.false))) (#f ($Word.i ($Word.subber a.pred$9 f2 Bool.false)))))))) ('Word.i (let ((f2 (get self2 1))) (lambda (a.pred$9) (let ((self4 c$3)) (case self4 (#t ($Word.i ($Word.subber a.pred$9 f2 Bool.true))) (#f ($Word.o ($Word.subber a.pred$9 f2 Bool.false)))))))))) f0)))))) b$2))
(define Word.subber (lambda (a$1) (lambda (b$2) (lambda (c$3) ($Word.subber a$1 b$2 c$3)))))
(define ($Word.sub a$1 b$2) ($Word.subber a$1 b$2 Bool.false))
(define Word.sub (lambda (a$1) (lambda (b$2) ($Word.sub a$1 b$2))))
(define ($U16.sub a$0 b$1) (mod (- a$0 b$1) 65536))
(define U16.sub (lambda (a$0) (lambda (b$1) ($U16.sub a$0 b$1))))
(define ($U16.inc a$0) (+ a$0 1))
(define U16.inc (lambda (a$0) ($U16.inc a$0)))
(define U16.zero ($U16.new ($Word.zero ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ Nat.zero)))))))))))))))))))
(define ($Char.hex_value16 chr$0) (let ((self0 ($Bool.and ($U16.gte chr$0 48) ($U16.lte chr$0 57)))) (case self0 (#t ($U16.sub chr$0 48)) (#f (let ((self0 ($Bool.and ($U16.gte chr$0 97) ($U16.lte chr$0 102)))) (case self0 (#t ((lambda (x0$1) ($U16.inc ($U16.inc ($U16.inc ($U16.inc ($U16.inc ($U16.inc ($U16.inc ($U16.inc ($U16.inc ($U16.inc x0$1))))))))))) ($U16.sub chr$0 97))) (#f (let ((self0 ($Bool.and ($U16.gte chr$0 65) ($U16.lte chr$0 70)))) (case self0 (#t ((lambda (x0$1) ($U16.inc ($U16.inc ($U16.inc ($U16.inc ($U16.inc ($U16.inc ($U16.inc ($U16.inc ($U16.inc ($U16.inc x0$1))))))))))) ($U16.sub chr$0 65))) (#f U16.zero))))))))))
(define Char.hex_value16 (lambda (chr$0) ($Char.hex_value16 chr$0)))
(define ($Kind.Core.read.u16 code$0 u16$1) (let ((self0 code$0)) (case (<= (kstring-length self0) 0) (#t ($Pair.new code$0 u16$1)) (#f (let ((f0 (char->integer (kstring-head self0)))) (let ((f1 (kstring-tail self0))) (let ((self2 ($Char.is_hex f0))) (case self2 (#t (let ((u16$4 ($U16.add ($U16.mul u16$1 ($Nat.to_u16 16)) ($Char.hex_value16 f0)))) ($Kind.Core.read.u16 f1 u16$4))) (#f ($Pair.new code$0 u16$1))))))))))
(define Kind.Core.read.u16 (lambda (code$0) (lambda (u16$1) ($Kind.Core.read.u16 code$0 u16$1))))
(define ($Kind.Core.read.chrx code$0) (let ((self0 ($String.starts_with code$0 "\\u{"))) (case self0 (#t (let ((code$1 ($String.drop 3 code$0))) (let ((self1 ($Kind.Core.read.u16 code$1 ($Nat.to_u16 0)))) (case (get self1 0) ('Pair.new (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((self3 ($String.starts_with f1 "}"))) (case self3 (#t ($Pair.new ($String.drop 1 f1) f2)) (#f ($Pair.new "" 63))))))))))) (#f (let ((self0 ($String.starts_with code$0 "\\'"))) (case self0 (#t ($Pair.new ($String.drop 2 code$0) 39)) (#f (let ((self0 ($String.starts_with code$0 "\\\""))) (case self0 (#t ($Pair.new ($String.drop 2 code$0) 34)) (#f (let ((self0 ($String.starts_with code$0 "\\\\"))) (case self0 (#t ($Pair.new ($String.drop 2 code$0) 92)) (#f (let ((self0 code$0)) (case (<= (kstring-length self0) 0) (#t ($Pair.new "" 63)) (#f (let ((f0 (char->integer (kstring-head self0)))) (let ((f1 (kstring-tail self0))) ($Pair.new f1 f0)))))))))))))))))))
(define Kind.Core.read.chrx (lambda (code$0) ($Kind.Core.read.chrx code$0)))
(define ($Kind.Term.chr chrx$0) (vector 'Kind.Term.chr chrx$0))
(define Kind.Term.chr (lambda (chrx$0) ($Kind.Term.chr chrx$0)))
(define ($Kind.Core.read.strx code$0) (let ((self0 ($String.starts_with code$0 "\""))) (case self0 (#t ($Pair.new code$0 "")) (#f (let ((self0 ($Kind.Core.read.chrx code$0))) (case (get self0 0) ('Pair.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((self2 ($Kind.Core.read.strx f0))) (case (get self2 0) ('Pair.new (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) ($Pair.new f2 ($String.cons f1 f3))))))))))))))))
(define Kind.Core.read.strx (lambda (code$0) ($Kind.Core.read.strx code$0)))
(define ($Kind.Term.str strx$0) (vector 'Kind.Term.str strx$0))
(define Kind.Term.str (lambda (strx$0) ($Kind.Term.str strx$0)))
(define ($Char.dec_value chr$0) (let ((self0 ($U16.eql chr$0 48))) (case self0 (#t 0) (#f (let ((self0 ($U16.eql chr$0 49))) (case self0 (#t 1) (#f (let ((self0 ($U16.eql chr$0 50))) (case self0 (#t 2) (#f (let ((self0 ($U16.eql chr$0 51))) (case self0 (#t 3) (#f (let ((self0 ($U16.eql chr$0 52))) (case self0 (#t 4) (#f (let ((self0 ($U16.eql chr$0 53))) (case self0 (#t 5) (#f (let ((self0 ($U16.eql chr$0 54))) (case self0 (#t 6) (#f (let ((self0 ($U16.eql chr$0 55))) (case self0 (#t 7) (#f (let ((self0 ($U16.eql chr$0 56))) (case self0 (#t 8) (#f (let ((self0 ($U16.eql chr$0 57))) (case self0 (#t 9) (#f 0)))))))))))))))))))))))))))))))
(define Char.dec_value (lambda (chr$0) ($Char.dec_value chr$0)))
(define ($Kind.Core.read.natx code$0 nat$1) (let ((self0 code$0)) (case (<= (kstring-length self0) 0) (#t ($Pair.new code$0 nat$1)) (#f (let ((f0 (char->integer (kstring-head self0)))) (let ((f1 (kstring-tail self0))) (let ((self2 ($Char.is_hex f0))) (case self2 (#t (let ((nat$4 ($Nat.add ($Nat.mul nat$1 10) ($Char.dec_value f0)))) ($Kind.Core.read.natx f1 nat$4))) (#f ($Pair.new code$0 nat$1))))))))))
(define Kind.Core.read.natx (lambda (code$0) (lambda (nat$1) ($Kind.Core.read.natx code$0 nat$1))))
(define ($Kind.Term.nat natx$0) (vector 'Kind.Term.nat natx$0))
(define Kind.Term.nat (lambda (natx$0) ($Kind.Term.nat natx$0)))
(define ($Nat.eql n$0 m$1) (= n$0 m$1))
(define Nat.eql (lambda (n$0) (lambda (m$1) ($Nat.eql n$0 m$1))))
(define ($Nat.pred n$0) (let ((self0 n$0)) (case (= self0 0) (#t Nat.zero) (#f (let ((f0 (- self0 1))) f0)))))
(define Nat.pred (lambda (n$0) ($Nat.pred n$0)))
(define ($Kind.Core.read.find list$1 cond$2 indx$3 skip$4) (let ((self0 list$1)) (case (get self0 0) ('List.nil Maybe.none) ('List.cons (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((self2 ((cond$2 f0) indx$3))) (case self2 (#t (let ((self2 ($Nat.eql skip$4 0))) (case self2 (#t ($Maybe.some ($Pair.new f0 indx$3))) (#f ($Kind.Core.read.find f1 cond$2 ($Nat.succ indx$3) ($Nat.pred skip$4)))))) (#f ($Kind.Core.read.find f1 cond$2 ($Nat.succ indx$3) skip$4))))))))))
(define Kind.Core.read.find (lambda (list$1) (lambda (cond$2) (lambda (indx$3) (lambda (skip$4) ($Kind.Core.read.find list$1 cond$2 indx$3 skip$4))))))
(define ($Pair.fst pair$2) (let ((self0 pair$2)) (case (get self0 0) ('Pair.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) f0))))))
(define Pair.fst (lambda (pair$2) ($Pair.fst pair$2)))
(define ($Pair.snd pair$2) (let ((self0 pair$2)) (case (get self0 0) ('Pair.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) f1))))))
(define Pair.snd (lambda (pair$2) ($Pair.snd pair$2)))
(define ($Kind.Core.read.term code$0) (let ((self0 ($Kind.Core.read.spaces code$0))) (case (get self0 0) ('Pair.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((self2 f0)) (case (<= (kstring-length self2) 0) (#t ($Pair.new "" (lambda (ctx$3) ($Kind.Term.ref "error")))) (#f (let ((f2 (char->integer (kstring-head self2)))) (let ((f3 (kstring-tail self2))) (let ((head$5 f2)) (let ((code$6 f3)) (let ((self6 ($Char.eql head$5 42))) (case self6 (#t ($Pair.new code$6 (lambda (ctx$7) Kind.Term.typ))) (#f (let ((self6 ($U16.eql head$5 64))) (case self6 (#t (let ((self6 ($Kind.Core.read.name code$6))) (case (get self6 0) ('Pair.new (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((self8 ($Kind.Core.read.char f6 40))) (case (get self8 0) ('Pair.new (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((self10 ($Kind.Core.read.name f8))) (case (get self10 0) ('Pair.new (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((self12 ($Kind.Core.read.char f10 58))) (case (get self12 0) ('Pair.new (let ((f12 (get self12 1))) (let ((f13 (get self12 2))) (let ((self14 ($Kind.Core.read.term f12))) (case (get self14 0) ('Pair.new (let ((f14 (get self14 1))) (let ((f15 (get self14 2))) (let ((self16 ($Kind.Core.read.char f14 41))) (case (get self16 0) ('Pair.new (let ((f16 (get self16 1))) (let ((f17 (get self16 2))) (let ((self18 ($Kind.Core.read.term f16))) (case (get self18 0) ('Pair.new (let ((f18 (get self18 1))) (let ((f19 (get self18 2))) ($Pair.new f18 (lambda (ctx$21) ($Kind.Term.all Bool.false f7 f11 (f15 ctx$21) (lambda (s$22) (lambda (x$23) (f19 ($List.cons ($Pair.new f11 x$23) ($List.cons ($Pair.new f7 s$22) ctx$21)))))))))))))))))))))))))))))))))))))))))))) (#f (let ((self6 ($U16.eql head$5 37))) (case self6 (#t (let ((self6 ($Kind.Core.read.name code$6))) (case (get self6 0) ('Pair.new (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((self8 ($Kind.Core.read.char f6 40))) (case (get self8 0) ('Pair.new (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((self10 ($Kind.Core.read.name f8))) (case (get self10 0) ('Pair.new (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((self12 ($Kind.Core.read.char f10 58))) (case (get self12 0) ('Pair.new (let ((f12 (get self12 1))) (let ((f13 (get self12 2))) (let ((self14 ($Kind.Core.read.term f12))) (case (get self14 0) ('Pair.new (let ((f14 (get self14 1))) (let ((f15 (get self14 2))) (let ((self16 ($Kind.Core.read.char f14 41))) (case (get self16 0) ('Pair.new (let ((f16 (get self16 1))) (let ((f17 (get self16 2))) (let ((self18 ($Kind.Core.read.term f16))) (case (get self18 0) ('Pair.new (let ((f18 (get self18 1))) (let ((f19 (get self18 2))) ($Pair.new f18 (lambda (ctx$21) ($Kind.Term.all Bool.true f7 f11 (f15 ctx$21) (lambda (s$22) (lambda (x$23) (f19 ($List.cons ($Pair.new f11 x$23) ($List.cons ($Pair.new f7 s$22) ctx$21)))))))))))))))))))))))))))))))))))))))))))) (#f (let ((self6 ($U16.eql head$5 35))) (case self6 (#t (let ((self6 ($Kind.Core.read.name code$6))) (case (get self6 0) ('Pair.new (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((self8 ($Kind.Core.read.term f6))) (case (get self8 0) ('Pair.new (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) ($Pair.new f8 (lambda (ctx$11) ($Kind.Term.lam f7 (lambda (x$12) (f9 ($List.cons ($Pair.new f7 x$12) ctx$11))))))))))))))))) (#f (let ((self6 ($U16.eql head$5 40))) (case self6 (#t (let ((self6 ($Kind.Core.read.term code$6))) (case (get self6 0) ('Pair.new (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((self8 ($Kind.Core.read.term f6))) (case (get self8 0) ('Pair.new (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((self10 ($Kind.Core.read.char f8 41))) (case (get self10 0) ('Pair.new (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) ($Pair.new f10 (lambda (ctx$13) ($Kind.Term.app (f7 ctx$13) (f9 ctx$13)))))))))))))))))))) (#f (let ((self6 ($U16.eql head$5 33))) (case self6 (#t (let ((self6 ($Kind.Core.read.name code$6))) (case (get self6 0) ('Pair.new (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((self8 ($Kind.Core.read.char f6 61))) (case (get self8 0) ('Pair.new (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((self10 ($Kind.Core.read.term f8))) (case (get self10 0) ('Pair.new (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((self12 ($Kind.Core.read.char f10 59))) (case (get self12 0) ('Pair.new (let ((f12 (get self12 1))) (let ((f13 (get self12 2))) (let ((self14 ($Kind.Core.read.term f12))) (case (get self14 0) ('Pair.new (let ((f14 (get self14 1))) (let ((f15 (get self14 2))) ($Pair.new f14 (lambda (ctx$17) ($Kind.Term.let f7 (f11 ctx$17) (lambda (x$18) (f15 ($List.cons ($Pair.new f7 x$18) ctx$17)))))))))))))))))))))))))))))))) (#f (let ((self6 ($U16.eql head$5 36))) (case self6 (#t (let ((self6 ($Kind.Core.read.name code$6))) (case (get self6 0) ('Pair.new (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((self8 ($Kind.Core.read.char f6 61))) (case (get self8 0) ('Pair.new (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((self10 ($Kind.Core.read.term f8))) (case (get self10 0) ('Pair.new (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((self12 ($Kind.Core.read.char f10 59))) (case (get self12 0) ('Pair.new (let ((f12 (get self12 1))) (let ((f13 (get self12 2))) (let ((self14 ($Kind.Core.read.term f12))) (case (get self14 0) ('Pair.new (let ((f14 (get self14 1))) (let ((f15 (get self14 2))) ($Pair.new f14 (lambda (ctx$17) ($Kind.Term.def f7 (f11 ctx$17) (lambda (x$18) (f15 ($List.cons ($Pair.new f7 x$18) ctx$17)))))))))))))))))))))))))))))))) (#f (let ((self6 ($U16.eql head$5 123))) (case self6 (#t (let ((self6 ($Kind.Core.read.term code$6))) (case (get self6 0) ('Pair.new (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((self8 ($Kind.Core.read.char f6 58))) (case (get self8 0) ('Pair.new (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((self10 ($Kind.Core.read.term f8))) (case (get self10 0) ('Pair.new (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((self12 ($Kind.Core.read.char f10 125))) (case (get self12 0) ('Pair.new (let ((f12 (get self12 1))) (let ((f13 (get self12 2))) ($Pair.new f12 (lambda (ctx$15) ($Kind.Term.ann Bool.false (f7 ctx$15) (f11 ctx$15))))))))))))))))))))))))) (#f (let ((self6 ($U16.eql head$5 39))) (case self6 (#t (let ((self6 ($Kind.Core.read.chrx code$6))) (case (get self6 0) ('Pair.new (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((self8 ($Kind.Core.read.char f6 39))) (case (get self8 0) ('Pair.new (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) ($Pair.new f8 (lambda (ctx$11) ($Kind.Term.chr f7)))))))))))))) (#f (let ((self6 ($U16.eql head$5 34))) (case self6 (#t (let ((self6 ($Kind.Core.read.strx code$6))) (case (get self6 0) ('Pair.new (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((self8 ($Kind.Core.read.char f6 34))) (case (get self8 0) ('Pair.new (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) ($Pair.new f8 (lambda (ctx$11) ($Kind.Term.str f7)))))))))))))) (#f (let ((self6 ($U16.eql head$5 43))) (case self6 (#t (let ((self6 ($Kind.Core.read.natx code$6 0))) (case (get self6 0) ('Pair.new (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) ($Pair.new f6 (lambda (ctx$9) ($Kind.Term.nat f7))))))))) (#f (let ((self6 ($Kind.Core.read.is_name head$5))) (case self6 (#t (let ((self6 ($Kind.Core.read.name code$6))) (case (get self6 0) ('Pair.new (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((name$9 ($String.cons head$5 f7))) (let ((self9 (let ((self9 f6)) (case (<= (kstring-length self9) 0) (#t ($Pair.new "" 0)) (#f (let ((f9 (char->integer (kstring-head self9)))) (let ((f10 (kstring-tail self9))) (let ((self11 ($U16.eql f9 94))) (case self11 (#t ($Kind.Core.read.natx f10 0)) (#f ($Pair.new f6 0))))))))))) (case (get self9 0) ('Pair.new (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) ($Pair.new f9 (lambda (ctx$12) (let ((got$13 ($Kind.Core.read.find ctx$12 (lambda (x$13) (lambda (i$14) ($String.eql ($Pair.fst x$13) name$9))) 0 f10))) (let ((self13 got$13)) (case (get self13 0) ('Maybe.none ($Kind.Term.ref name$9)) ('Maybe.some (let ((f13 (get self13 1))) ($Pair.snd ($Pair.fst f13))))))))))))))))))))) (#f ($Pair.new "" (lambda (ctx$7) ($Kind.Term.ref "error"))))))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Core.read.term (lambda (code$0) ($Kind.Core.read.term code$0)))
(define ($Kind.Core.read code$0) (let ((self0 ($Kind.Core.read.term ($String.concat code$0 ";")))) (case (get self0 0) ('Pair.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((self2 f0)) (case (<= (kstring-length self2) 0) (#t Maybe.none) (#f (let ((f2 (char->integer (kstring-head self2)))) (let ((f3 (kstring-tail self2))) ($Maybe.some (f1 List.nil)))))))))))))
(define Kind.Core.read (lambda (code$0) ($Kind.Core.read code$0)))
(define ($Bool.read code$0) (let ((self0 ($String.eql code$0 "Bool.true"))) (case self0 (#t ($Maybe.some Bool.true)) (#f (let ((self0 ($String.eql code$0 "Bool.false"))) (case self0 (#t ($Maybe.some Bool.false)) (#f Maybe.none)))))))
(define Bool.read (lambda (code$0) ($Bool.read code$0)))
(define ($Kind.Status.done cached$0) (vector 'Kind.Status.done cached$0))
(define Kind.Status.done (lambda (cached$0) ($Kind.Status.done cached$0)))
(define ($Kind.Def.new file$0 code$1 orig$2 name$3 term$4 type$5 isct$6 arit$7 stat$8) (vector 'Kind.Def.new file$0 code$1 orig$2 name$3 term$4 type$5 isct$6 arit$7 stat$8))
(define Kind.Def.new (lambda (file$0) (lambda (code$1) (lambda (orig$2) (lambda (name$3) (lambda (term$4) (lambda (type$5) (lambda (isct$6) (lambda (arit$7) (lambda (stat$8) ($Kind.Def.new file$0 code$1 orig$2 name$3 term$4 type$5 isct$6 arit$7 stat$8)))))))))))
(define ($Kind.Synth.load.cached.def name$0) (((let ((self0 IO.monad)) (case (get self0 0) ('Monad.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) f0))))) ($Kind.Synth.load.cached.get_file ($String.concat name$0 ".file"))) (lambda (cache_file$1) (let ((self1 ($Bool.not ($String.is_empty cache_file$1)))) (case self1 (#t (((let ((self1 IO.monad)) (case (get self1 0) ('Monad.new (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) f1))))) ($Kind.Synth.load.cached.get_file ($String.concat name$0 ".time"))) (lambda (cache_time$2) (((let ((self2 IO.monad)) (case (get self2 0) ('Monad.new (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) f2))))) ($IO.get_file_mtime cache_file$1)) (lambda (cache_file_time$3) (let ((self3 ($String.eql cache_time$2 cache_file_time$3))) (case self3 (#t (((let ((self3 IO.monad)) (case (get self3 0) ('Monad.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) f3))))) ($Kind.Synth.load.cached.get_file ($String.concat name$0 ".term"))) (lambda (cache_term$4) (((let ((self4 IO.monad)) (case (get self4 0) ('Monad.new (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) f4))))) ($Kind.Synth.load.cached.get_file ($String.concat name$0 ".type"))) (lambda (cache_type$5) (((let ((self5 IO.monad)) (case (get self5 0) ('Monad.new (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) f5))))) ($Kind.Synth.load.cached.get_file ($String.concat name$0 ".isct"))) (lambda (cache_isct$6) (((let ((self6 IO.monad)) (case (get self6 0) ('Monad.new (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) f6))))) ($Kind.Synth.load.cached.get_file ($String.concat name$0 ".arit"))) (lambda (cache_arit$7) ((let ((self7 IO.monad)) (case (get self7 0) ('Monad.new (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) f8))))) (let ((file$8 cache_file$1)) (let ((code$9 "<cached>")) (let ((orig$10 ($Pair.new 0 0))) (((let ((self10 Maybe.monad)) (case (get self10 0) ('Monad.new (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) f10))))) ($Kind.Core.read cache_term$4)) (lambda (term$11) (((let ((self11 Maybe.monad)) (case (get self11 0) ('Monad.new (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) f11))))) ($Kind.Core.read cache_type$5)) (lambda (type$12) (((let ((self12 Maybe.monad)) (case (get self12 0) ('Monad.new (let ((f12 (get self12 1))) (let ((f13 (get self12 2))) f12))))) ($Bool.read cache_isct$6)) (lambda (isct$13) (((let ((self13 Maybe.monad)) (case (get self13 0) ('Monad.new (let ((f13 (get self13 1))) (let ((f14 (get self13 2))) f13))))) ($Maybe.some ($Nat.read cache_arit$7))) (lambda (arit$14) (let ((stat$15 ($Kind.Status.done Bool.true))) ((let ((self15 Maybe.monad)) (case (get self15 0) ('Monad.new (let ((f15 (get self15 1))) (let ((f16 (get self15 2))) f16))))) ($Kind.Def.new file$8 code$9 orig$10 name$0 term$11 type$12 isct$13 arit$14 stat$15)))))))))))))))))))))))) (#f ((let ((self3 IO.monad)) (case (get self3 0) ('Monad.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) f4))))) Maybe.none))))))))) (#f ((let ((self1 IO.monad)) (case (get self1 0) ('Monad.new (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) f2))))) Maybe.none)))))))
(define Kind.Synth.load.cached.def (lambda (name$0) ($Kind.Synth.load.cached.def name$0)))
(define ($BitsMap.tie val$1 lft$2 rgt$3) (vector 'BitsMap.tie val$1 lft$2 rgt$3))
(define BitsMap.tie (lambda (val$1) (lambda (lft$2) (lambda (rgt$3) ($BitsMap.tie val$1 lft$2 rgt$3)))))
(define BitsMap.new (vector 'BitsMap.new))
(define ($BitsMap.set bits$1 val$2 map$3) (let ((self0 bits$1)) (case (if (eq? self0 #b1) 2 (bitwise-and self0 #b1)) (2 (let ((self0 map$3)) (case (get self0 0) ('BitsMap.new ($BitsMap.tie ($Maybe.some val$2) BitsMap.new BitsMap.new)) ('BitsMap.tie (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) ($BitsMap.tie ($Maybe.some val$2) f1 f2)))))))) (0 (let ((f0 (bitwise-arithmetic-shift-right self0 #b1))) (let ((self1 map$3)) (case (get self1 0) ('BitsMap.new ($BitsMap.tie Maybe.none ($BitsMap.set f0 val$2 BitsMap.new) BitsMap.new)) ('BitsMap.tie (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) ($BitsMap.tie f1 ($BitsMap.set f0 val$2 f2) f3))))))))) (1 (let ((f0 (bitwise-arithmetic-shift-right self0 #b1))) (let ((self1 map$3)) (case (get self1 0) ('BitsMap.new ($BitsMap.tie Maybe.none BitsMap.new ($BitsMap.set f0 val$2 BitsMap.new))) ('BitsMap.tie (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) ($BitsMap.tie f1 f2 ($BitsMap.set f0 val$2 f3)))))))))))))
(define BitsMap.set (lambda (bits$1) (lambda (val$2) (lambda (map$3) ($BitsMap.set bits$1 val$2 map$3)))))
(define ($Kind.Map.set name$1 val$2 map$3) ($BitsMap.set ($Kind.Name.to_bits name$1) val$2 map$3))
(define Kind.Map.set (lambda (name$1) (lambda (val$2) (lambda (map$3) ($Kind.Map.set name$1 val$2 map$3)))))
(define Kind.Map.new BitsMap.new)
(define ($Kind.Core.dependencies.go term$0 deps$1) (let ((nil$2 Kind.Term.typ)) (let ((self1 term$0)) (case (get self1 0) ('Kind.Term.var (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) deps$1))) ('Kind.Term.ref (let ((f1 (get self1 1))) ($Kind.Map.set f1 Unit.new deps$1))) ('Kind.Term.typ deps$1) ('Kind.Term.all (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((deps$8 ($Kind.Core.dependencies.go f4 deps$1))) (let ((deps$9 ($Kind.Core.dependencies.go ((f5 nil$2) nil$2) deps$8))) deps$9)))))))) ('Kind.Term.lam (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((deps$5 ($Kind.Core.dependencies.go (f2 nil$2) deps$1))) deps$5)))) ('Kind.Term.app (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((deps$5 ($Kind.Core.dependencies.go f1 deps$1))) (let ((deps$6 ($Kind.Core.dependencies.go f2 deps$5))) deps$6))))) ('Kind.Term.let (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((deps$6 ($Kind.Core.dependencies.go f2 deps$1))) (let ((deps$7 ($Kind.Core.dependencies.go (f3 nil$2) deps$6))) deps$7)))))) ('Kind.Term.def (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((deps$6 ($Kind.Core.dependencies.go f2 deps$1))) (let ((deps$7 ($Kind.Core.dependencies.go (f3 nil$2) deps$6))) deps$7)))))) ('Kind.Term.ann (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((deps$6 ($Kind.Core.dependencies.go f2 deps$1))) (let ((deps$7 ($Kind.Core.dependencies.go f3 deps$6))) deps$7)))))) ('Kind.Term.gol (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) deps$1)))) ('Kind.Term.hol (let ((f1 (get self1 1))) deps$1)) ('Kind.Term.nat (let ((f1 (get self1 1))) deps$1)) ('Kind.Term.chr (let ((f1 (get self1 1))) deps$1)) ('Kind.Term.str (let ((f1 (get self1 1))) deps$1)) ('Kind.Term.num (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) deps$1)))) ('Kind.Term.cse (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((f6 (get self1 6))) deps$1))))))) ('Kind.Term.new (let ((f1 (get self1 1))) deps$1)) ('Kind.Term.get (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) deps$1))) ('Kind.Term.set (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) deps$1)))) ('Kind.Term.ope (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) deps$1)))) ('Kind.Term.ori (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) deps$1)))))))
(define Kind.Core.dependencies.go (lambda (term$0) (lambda (deps$1) ($Kind.Core.dependencies.go term$0 deps$1))))
(define ($List.mapped as$1 f$3) (let ((self0 as$1)) (case (get self0 0) ('List.nil List.nil) ('List.cons (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($List.cons (f$3 f0) ($List.mapped f1 f$3))))))))
(define List.mapped (lambda (as$1) (lambda (f$3) ($List.mapped as$1 f$3))))
(define ($Bits.reverse.tco a$0 r$1) (let ((self0 a$0)) (case (if (eq? self0 #b1) 2 (bitwise-and self0 #b1)) (2 r$1) (0 (let ((f0 (bitwise-arithmetic-shift-right self0 #b1))) ($Bits.reverse.tco f0 ($Bits.o r$1)))) (1 (let ((f0 (bitwise-arithmetic-shift-right self0 #b1))) ($Bits.reverse.tco f0 ($Bits.i r$1)))))))
(define Bits.reverse.tco (lambda (a$0) (lambda (r$1) ($Bits.reverse.tco a$0 r$1))))
(define ($Bits.reverse a$0) ($Bits.reverse.tco a$0 Bits.e))
(define Bits.reverse (lambda (a$0) ($Bits.reverse a$0)))
(define ($BitsMap.to_list.go xs$1 key$2 list$3) (let ((self0 xs$1)) (case (get self0 0) ('BitsMap.new list$3) ('BitsMap.tie (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((list0$7 (let ((self3 f0)) (case (get self3 0) ('Maybe.none list$3) ('Maybe.some (let ((f3 (get self3 1))) ($List.cons ($Pair.new ($Bits.reverse key$2) f3) list$3))))))) (let ((list1$8 ($BitsMap.to_list.go f1 ($Bits.o key$2) list0$7))) (let ((list2$9 ($BitsMap.to_list.go f2 ($Bits.i key$2) list1$8))) list2$9))))))))))
(define BitsMap.to_list.go (lambda (xs$1) (lambda (key$2) (lambda (list$3) ($BitsMap.to_list.go xs$1 key$2 list$3)))))
(define ($Kind.Name.from_bits bs$0) (let ((self0 bs$0)) (case (if (eq? self0 #b1) 2 (bitwise-and self0 #b1)) (2 String.nil) (0 (let ((f0 (bitwise-arithmetic-shift-right self0 #b1))) (let ((bs$2 f0)) (let ((self2 bs$2)) (case (if (eq? self2 #b1) 2 (bitwise-and self2 #b1)) (2 String.nil) (0 (let ((f2 (bitwise-arithmetic-shift-right self2 #b1))) (let ((bs$4 f2)) (let ((self4 bs$4)) (case (if (eq? self4 #b1) 2 (bitwise-and self4 #b1)) (2 String.nil) (0 (let ((f4 (bitwise-arithmetic-shift-right self4 #b1))) (let ((bs$6 f4)) (let ((self6 bs$6)) (case (if (eq? self6 #b1) 2 (bitwise-and self6 #b1)) (2 String.nil) (0 (let ((f6 (bitwise-arithmetic-shift-right self6 #b1))) (let ((bs$8 f6)) (let ((self8 bs$8)) (case (if (eq? self8 #b1) 2 (bitwise-and self8 #b1)) (2 String.nil) (0 (let ((f8 (bitwise-arithmetic-shift-right self8 #b1))) (let ((bs$10 f8)) (let ((self10 bs$10)) (case (if (eq? self10 #b1) 2 (bitwise-and self10 #b1)) (2 String.nil) (0 (let ((f10 (bitwise-arithmetic-shift-right self10 #b1))) (let ((bs$12 f10)) ($String.cons 65 ($Kind.Name.from_bits bs$12))))) (1 (let ((f10 (bitwise-arithmetic-shift-right self10 #b1))) (let ((bs$12 f10)) ($String.cons 66 ($Kind.Name.from_bits bs$12)))))))))) (1 (let ((f8 (bitwise-arithmetic-shift-right self8 #b1))) (let ((bs$10 f8)) (let ((self10 bs$10)) (case (if (eq? self10 #b1) 2 (bitwise-and self10 #b1)) (2 String.nil) (0 (let ((f10 (bitwise-arithmetic-shift-right self10 #b1))) (let ((bs$12 f10)) ($String.cons 67 ($Kind.Name.from_bits bs$12))))) (1 (let ((f10 (bitwise-arithmetic-shift-right self10 #b1))) (let ((bs$12 f10)) ($String.cons 68 ($Kind.Name.from_bits bs$12))))))))))))))) (1 (let ((f6 (bitwise-arithmetic-shift-right self6 #b1))) (let ((bs$8 f6)) (let ((self8 bs$8)) (case (if (eq? self8 #b1) 2 (bitwise-and self8 #b1)) (2 String.nil) (0 (let ((f8 (bitwise-arithmetic-shift-right self8 #b1))) (let ((bs$10 f8)) (let ((self10 bs$10)) (case (if (eq? self10 #b1) 2 (bitwise-and self10 #b1)) (2 String.nil) (0 (let ((f10 (bitwise-arithmetic-shift-right self10 #b1))) (let ((bs$12 f10)) ($String.cons 69 ($Kind.Name.from_bits bs$12))))) (1 (let ((f10 (bitwise-arithmetic-shift-right self10 #b1))) (let ((bs$12 f10)) ($String.cons 70 ($Kind.Name.from_bits bs$12)))))))))) (1 (let ((f8 (bitwise-arithmetic-shift-right self8 #b1))) (let ((bs$10 f8)) (let ((self10 bs$10)) (case (if (eq? self10 #b1) 2 (bitwise-and self10 #b1)) (2 String.nil) (0 (let ((f10 (bitwise-arithmetic-shift-right self10 #b1))) (let ((bs$12 f10)) ($String.cons 71 ($Kind.Name.from_bits bs$12))))) (1 (let ((f10 (bitwise-arithmetic-shift-right self10 #b1))) (let ((bs$12 f10)) ($String.cons 72 ($Kind.Name.from_bits bs$12)))))))))))))))))))) (1 (let ((f4 (bitwise-arithmetic-shift-right self4 #b1))) (let ((bs$6 f4)) (let ((self6 bs$6)) (case (if (eq? self6 #b1) 2 (bitwise-and self6 #b1)) (2 String.nil) (0 (let ((f6 (bitwise-arithmetic-shift-right self6 #b1))) (let ((bs$8 f6)) (let ((self8 bs$8)) (case (if (eq? self8 #b1) 2 (bitwise-and self8 #b1)) (2 String.nil) (0 (let ((f8 (bitwise-arithmetic-shift-right self8 #b1))) (let ((bs$10 f8)) (let ((self10 bs$10)) (case (if (eq? self10 #b1) 2 (bitwise-and self10 #b1)) (2 String.nil) (0 (let ((f10 (bitwise-arithmetic-shift-right self10 #b1))) (let ((bs$12 f10)) ($String.cons 73 ($Kind.Name.from_bits bs$12))))) (1 (let ((f10 (bitwise-arithmetic-shift-right self10 #b1))) (let ((bs$12 f10)) ($String.cons 74 ($Kind.Name.from_bits bs$12)))))))))) (1 (let ((f8 (bitwise-arithmetic-shift-right self8 #b1))) (let ((bs$10 f8)) (let ((self10 bs$10)) (case (if (eq? self10 #b1) 2 (bitwise-and self10 #b1)) (2 String.nil) (0 (let ((f10 (bitwise-arithmetic-shift-right self10 #b1))) (let ((bs$12 f10)) ($String.cons 75 ($Kind.Name.from_bits bs$12))))) (1 (let ((f10 (bitwise-arithmetic-shift-right self10 #b1))) (let ((bs$12 f10)) ($String.cons 76 ($Kind.Name.from_bits bs$12))))))))))))))) (1 (let ((f6 (bitwise-arithmetic-shift-right self6 #b1))) (let ((bs$8 f6)) (let ((self8 bs$8)) (case (if (eq? self8 #b1) 2 (bitwise-and self8 #b1)) (2 String.nil) (0 (let ((f8 (bitwise-arithmetic-shift-right self8 #b1))) (let ((bs$10 f8)) (let ((self10 bs$10)) (case (if (eq? self10 #b1) 2 (bitwise-and self10 #b1)) (2 String.nil) (0 (let ((f10 (bitwise-arithmetic-shift-right self10 #b1))) (let ((bs$12 f10)) ($String.cons 77 ($Kind.Name.from_bits bs$12))))) (1 (let ((f10 (bitwise-arithmetic-shift-right self10 #b1))) (let ((bs$12 f10)) ($String.cons 78 ($Kind.Name.from_bits bs$12)))))))))) (1 (let ((f8 (bitwise-arithmetic-shift-right self8 #b1))) (let ((bs$10 f8)) (let ((self10 bs$10)) (case (if (eq? self10 #b1) 2 (bitwise-and self10 #b1)) (2 String.nil) (0 (let ((f10 (bitwise-arithmetic-shift-right self10 #b1))) (let ((bs$12 f10)) ($String.cons 79 ($Kind.Name.from_bits bs$12))))) (1 (let ((f10 (bitwise-arithmetic-shift-right self10 #b1))) (let ((bs$12 f10)) ($String.cons 80 ($Kind.Name.from_bits bs$12))))))))))))))))))))))))) (1 (let ((f2 (bitwise-arithmetic-shift-right self2 #b1))) (let ((bs$4 f2)) (let ((self4 bs$4)) (case (if (eq? self4 #b1) 2 (bitwise-and self4 #b1)) (2 String.nil) (0 (let ((f4 (bitwise-arithmetic-shift-right self4 #b1))) (let ((bs$6 f4)) (let ((self6 bs$6)) (case (if (eq? self6 #b1) 2 (bitwise-and self6 #b1)) (2 String.nil) (0 (let ((f6 (bitwise-arithmetic-shift-right self6 #b1))) (let ((bs$8 f6)) (let ((self8 bs$8)) (case (if (eq? self8 #b1) 2 (bitwise-and self8 #b1)) (2 String.nil) (0 (let ((f8 (bitwise-arithmetic-shift-right self8 #b1))) (let ((bs$10 f8)) (let ((self10 bs$10)) (case (if (eq? self10 #b1) 2 (bitwise-and self10 #b1)) (2 String.nil) (0 (let ((f10 (bitwise-arithmetic-shift-right self10 #b1))) (let ((bs$12 f10)) ($String.cons 81 ($Kind.Name.from_bits bs$12))))) (1 (let ((f10 (bitwise-arithmetic-shift-right self10 #b1))) (let ((bs$12 f10)) ($String.cons 82 ($Kind.Name.from_bits bs$12)))))))))) (1 (let ((f8 (bitwise-arithmetic-shift-right self8 #b1))) (let ((bs$10 f8)) (let ((self10 bs$10)) (case (if (eq? self10 #b1) 2 (bitwise-and self10 #b1)) (2 String.nil) (0 (let ((f10 (bitwise-arithmetic-shift-right self10 #b1))) (let ((bs$12 f10)) ($String.cons 83 ($Kind.Name.from_bits bs$12))))) (1 (let ((f10 (bitwise-arithmetic-shift-right self10 #b1))) (let ((bs$12 f10)) ($String.cons 84 ($Kind.Name.from_bits bs$12))))))))))))))) (1 (let ((f6 (bitwise-arithmetic-shift-right self6 #b1))) (let ((bs$8 f6)) (let ((self8 bs$8)) (case (if (eq? self8 #b1) 2 (bitwise-and self8 #b1)) (2 String.nil) (0 (let ((f8 (bitwise-arithmetic-shift-right self8 #b1))) (let ((bs$10 f8)) (let ((self10 bs$10)) (case (if (eq? self10 #b1) 2 (bitwise-and self10 #b1)) (2 String.nil) (0 (let ((f10 (bitwise-arithmetic-shift-right self10 #b1))) (let ((bs$12 f10)) ($String.cons 85 ($Kind.Name.from_bits bs$12))))) (1 (let ((f10 (bitwise-arithmetic-shift-right self10 #b1))) (let ((bs$12 f10)) ($String.cons 86 ($Kind.Name.from_bits bs$12)))))))))) (1 (let ((f8 (bitwise-arithmetic-shift-right self8 #b1))) (let ((bs$10 f8)) (let ((self10 bs$10)) (case (if (eq? self10 #b1) 2 (bitwise-and self10 #b1)) (2 String.nil) (0 (let ((f10 (bitwise-arithmetic-shift-right self10 #b1))) (let ((bs$12 f10)) ($String.cons 87 ($Kind.Name.from_bits bs$12))))) (1 (let ((f10 (bitwise-arithmetic-shift-right self10 #b1))) (let ((bs$12 f10)) ($String.cons 88 ($Kind.Name.from_bits bs$12)))))))))))))))))))) (1 (let ((f4 (bitwise-arithmetic-shift-right self4 #b1))) (let ((bs$6 f4)) (let ((self6 bs$6)) (case (if (eq? self6 #b1) 2 (bitwise-and self6 #b1)) (2 String.nil) (0 (let ((f6 (bitwise-arithmetic-shift-right self6 #b1))) (let ((bs$8 f6)) (let ((self8 bs$8)) (case (if (eq? self8 #b1) 2 (bitwise-and self8 #b1)) (2 String.nil) (0 (let ((f8 (bitwise-arithmetic-shift-right self8 #b1))) (let ((bs$10 f8)) (let ((self10 bs$10)) (case (if (eq? self10 #b1) 2 (bitwise-and self10 #b1)) (2 String.nil) (0 (let ((f10 (bitwise-arithmetic-shift-right self10 #b1))) (let ((bs$12 f10)) ($String.cons 89 ($Kind.Name.from_bits bs$12))))) (1 (let ((f10 (bitwise-arithmetic-shift-right self10 #b1))) (let ((bs$12 f10)) ($String.cons 90 ($Kind.Name.from_bits bs$12)))))))))) (1 (let ((f8 (bitwise-arithmetic-shift-right self8 #b1))) (let ((bs$10 f8)) (let ((self10 bs$10)) (case (if (eq? self10 #b1) 2 (bitwise-and self10 #b1)) (2 String.nil) (0 (let ((f10 (bitwise-arithmetic-shift-right self10 #b1))) (let ((bs$12 f10)) ($String.cons 97 ($Kind.Name.from_bits bs$12))))) (1 (let ((f10 (bitwise-arithmetic-shift-right self10 #b1))) (let ((bs$12 f10)) ($String.cons 98 ($Kind.Name.from_bits bs$12))))))))))))))) (1 (let ((f6 (bitwise-arithmetic-shift-right self6 #b1))) (let ((bs$8 f6)) (let ((self8 bs$8)) (case (if (eq? self8 #b1) 2 (bitwise-and self8 #b1)) (2 String.nil) (0 (let ((f8 (bitwise-arithmetic-shift-right self8 #b1))) (let ((bs$10 f8)) (let ((self10 bs$10)) (case (if (eq? self10 #b1) 2 (bitwise-and self10 #b1)) (2 String.nil) (0 (let ((f10 (bitwise-arithmetic-shift-right self10 #b1))) (let ((bs$12 f10)) ($String.cons 99 ($Kind.Name.from_bits bs$12))))) (1 (let ((f10 (bitwise-arithmetic-shift-right self10 #b1))) (let ((bs$12 f10)) ($String.cons 100 ($Kind.Name.from_bits bs$12)))))))))) (1 (let ((f8 (bitwise-arithmetic-shift-right self8 #b1))) (let ((bs$10 f8)) (let ((self10 bs$10)) (case (if (eq? self10 #b1) 2 (bitwise-and self10 #b1)) (2 String.nil) (0 (let ((f10 (bitwise-arithmetic-shift-right self10 #b1))) (let ((bs$12 f10)) ($String.cons 101 ($Kind.Name.from_bits bs$12))))) (1 (let ((f10 (bitwise-arithmetic-shift-right self10 #b1))) (let ((bs$12 f10)) ($String.cons 102 ($Kind.Name.from_bits bs$12)))))))))))))))))))))))))))))) (1 (let ((f0 (bitwise-arithmetic-shift-right self0 #b1))) (let ((bs$2 f0)) (let ((self2 bs$2)) (case (if (eq? self2 #b1) 2 (bitwise-and self2 #b1)) (2 String.nil) (0 (let ((f2 (bitwise-arithmetic-shift-right self2 #b1))) (let ((bs$4 f2)) (let ((self4 bs$4)) (case (if (eq? self4 #b1) 2 (bitwise-and self4 #b1)) (2 String.nil) (0 (let ((f4 (bitwise-arithmetic-shift-right self4 #b1))) (let ((bs$6 f4)) (let ((self6 bs$6)) (case (if (eq? self6 #b1) 2 (bitwise-and self6 #b1)) (2 String.nil) (0 (let ((f6 (bitwise-arithmetic-shift-right self6 #b1))) (let ((bs$8 f6)) (let ((self8 bs$8)) (case (if (eq? self8 #b1) 2 (bitwise-and self8 #b1)) (2 String.nil) (0 (let ((f8 (bitwise-arithmetic-shift-right self8 #b1))) (let ((bs$10 f8)) (let ((self10 bs$10)) (case (if (eq? self10 #b1) 2 (bitwise-and self10 #b1)) (2 String.nil) (0 (let ((f10 (bitwise-arithmetic-shift-right self10 #b1))) (let ((bs$12 f10)) ($String.cons 103 ($Kind.Name.from_bits bs$12))))) (1 (let ((f10 (bitwise-arithmetic-shift-right self10 #b1))) (let ((bs$12 f10)) ($String.cons 104 ($Kind.Name.from_bits bs$12)))))))))) (1 (let ((f8 (bitwise-arithmetic-shift-right self8 #b1))) (let ((bs$10 f8)) (let ((self10 bs$10)) (case (if (eq? self10 #b1) 2 (bitwise-and self10 #b1)) (2 String.nil) (0 (let ((f10 (bitwise-arithmetic-shift-right self10 #b1))) (let ((bs$12 f10)) ($String.cons 105 ($Kind.Name.from_bits bs$12))))) (1 (let ((f10 (bitwise-arithmetic-shift-right self10 #b1))) (let ((bs$12 f10)) ($String.cons 106 ($Kind.Name.from_bits bs$12))))))))))))))) (1 (let ((f6 (bitwise-arithmetic-shift-right self6 #b1))) (let ((bs$8 f6)) (let ((self8 bs$8)) (case (if (eq? self8 #b1) 2 (bitwise-and self8 #b1)) (2 String.nil) (0 (let ((f8 (bitwise-arithmetic-shift-right self8 #b1))) (let ((bs$10 f8)) (let ((self10 bs$10)) (case (if (eq? self10 #b1) 2 (bitwise-and self10 #b1)) (2 String.nil) (0 (let ((f10 (bitwise-arithmetic-shift-right self10 #b1))) (let ((bs$12 f10)) ($String.cons 107 ($Kind.Name.from_bits bs$12))))) (1 (let ((f10 (bitwise-arithmetic-shift-right self10 #b1))) (let ((bs$12 f10)) ($String.cons 108 ($Kind.Name.from_bits bs$12)))))))))) (1 (let ((f8 (bitwise-arithmetic-shift-right self8 #b1))) (let ((bs$10 f8)) (let ((self10 bs$10)) (case (if (eq? self10 #b1) 2 (bitwise-and self10 #b1)) (2 String.nil) (0 (let ((f10 (bitwise-arithmetic-shift-right self10 #b1))) (let ((bs$12 f10)) ($String.cons 109 ($Kind.Name.from_bits bs$12))))) (1 (let ((f10 (bitwise-arithmetic-shift-right self10 #b1))) (let ((bs$12 f10)) ($String.cons 110 ($Kind.Name.from_bits bs$12)))))))))))))))))))) (1 (let ((f4 (bitwise-arithmetic-shift-right self4 #b1))) (let ((bs$6 f4)) (let ((self6 bs$6)) (case (if (eq? self6 #b1) 2 (bitwise-and self6 #b1)) (2 String.nil) (0 (let ((f6 (bitwise-arithmetic-shift-right self6 #b1))) (let ((bs$8 f6)) (let ((self8 bs$8)) (case (if (eq? self8 #b1) 2 (bitwise-and self8 #b1)) (2 String.nil) (0 (let ((f8 (bitwise-arithmetic-shift-right self8 #b1))) (let ((bs$10 f8)) (let ((self10 bs$10)) (case (if (eq? self10 #b1) 2 (bitwise-and self10 #b1)) (2 String.nil) (0 (let ((f10 (bitwise-arithmetic-shift-right self10 #b1))) (let ((bs$12 f10)) ($String.cons 111 ($Kind.Name.from_bits bs$12))))) (1 (let ((f10 (bitwise-arithmetic-shift-right self10 #b1))) (let ((bs$12 f10)) ($String.cons 112 ($Kind.Name.from_bits bs$12)))))))))) (1 (let ((f8 (bitwise-arithmetic-shift-right self8 #b1))) (let ((bs$10 f8)) (let ((self10 bs$10)) (case (if (eq? self10 #b1) 2 (bitwise-and self10 #b1)) (2 String.nil) (0 (let ((f10 (bitwise-arithmetic-shift-right self10 #b1))) (let ((bs$12 f10)) ($String.cons 113 ($Kind.Name.from_bits bs$12))))) (1 (let ((f10 (bitwise-arithmetic-shift-right self10 #b1))) (let ((bs$12 f10)) ($String.cons 114 ($Kind.Name.from_bits bs$12))))))))))))))) (1 (let ((f6 (bitwise-arithmetic-shift-right self6 #b1))) (let ((bs$8 f6)) (let ((self8 bs$8)) (case (if (eq? self8 #b1) 2 (bitwise-and self8 #b1)) (2 String.nil) (0 (let ((f8 (bitwise-arithmetic-shift-right self8 #b1))) (let ((bs$10 f8)) (let ((self10 bs$10)) (case (if (eq? self10 #b1) 2 (bitwise-and self10 #b1)) (2 String.nil) (0 (let ((f10 (bitwise-arithmetic-shift-right self10 #b1))) (let ((bs$12 f10)) ($String.cons 115 ($Kind.Name.from_bits bs$12))))) (1 (let ((f10 (bitwise-arithmetic-shift-right self10 #b1))) (let ((bs$12 f10)) ($String.cons 116 ($Kind.Name.from_bits bs$12)))))))))) (1 (let ((f8 (bitwise-arithmetic-shift-right self8 #b1))) (let ((bs$10 f8)) (let ((self10 bs$10)) (case (if (eq? self10 #b1) 2 (bitwise-and self10 #b1)) (2 String.nil) (0 (let ((f10 (bitwise-arithmetic-shift-right self10 #b1))) (let ((bs$12 f10)) ($String.cons 117 ($Kind.Name.from_bits bs$12))))) (1 (let ((f10 (bitwise-arithmetic-shift-right self10 #b1))) (let ((bs$12 f10)) ($String.cons 118 ($Kind.Name.from_bits bs$12))))))))))))))))))))))))) (1 (let ((f2 (bitwise-arithmetic-shift-right self2 #b1))) (let ((bs$4 f2)) (let ((self4 bs$4)) (case (if (eq? self4 #b1) 2 (bitwise-and self4 #b1)) (2 String.nil) (0 (let ((f4 (bitwise-arithmetic-shift-right self4 #b1))) (let ((bs$6 f4)) (let ((self6 bs$6)) (case (if (eq? self6 #b1) 2 (bitwise-and self6 #b1)) (2 String.nil) (0 (let ((f6 (bitwise-arithmetic-shift-right self6 #b1))) (let ((bs$8 f6)) (let ((self8 bs$8)) (case (if (eq? self8 #b1) 2 (bitwise-and self8 #b1)) (2 String.nil) (0 (let ((f8 (bitwise-arithmetic-shift-right self8 #b1))) (let ((bs$10 f8)) (let ((self10 bs$10)) (case (if (eq? self10 #b1) 2 (bitwise-and self10 #b1)) (2 String.nil) (0 (let ((f10 (bitwise-arithmetic-shift-right self10 #b1))) (let ((bs$12 f10)) ($String.cons 119 ($Kind.Name.from_bits bs$12))))) (1 (let ((f10 (bitwise-arithmetic-shift-right self10 #b1))) (let ((bs$12 f10)) ($String.cons 120 ($Kind.Name.from_bits bs$12)))))))))) (1 (let ((f8 (bitwise-arithmetic-shift-right self8 #b1))) (let ((bs$10 f8)) (let ((self10 bs$10)) (case (if (eq? self10 #b1) 2 (bitwise-and self10 #b1)) (2 String.nil) (0 (let ((f10 (bitwise-arithmetic-shift-right self10 #b1))) (let ((bs$12 f10)) ($String.cons 121 ($Kind.Name.from_bits bs$12))))) (1 (let ((f10 (bitwise-arithmetic-shift-right self10 #b1))) (let ((bs$12 f10)) ($String.cons 122 ($Kind.Name.from_bits bs$12))))))))))))))) (1 (let ((f6 (bitwise-arithmetic-shift-right self6 #b1))) (let ((bs$8 f6)) (let ((self8 bs$8)) (case (if (eq? self8 #b1) 2 (bitwise-and self8 #b1)) (2 String.nil) (0 (let ((f8 (bitwise-arithmetic-shift-right self8 #b1))) (let ((bs$10 f8)) (let ((self10 bs$10)) (case (if (eq? self10 #b1) 2 (bitwise-and self10 #b1)) (2 String.nil) (0 (let ((f10 (bitwise-arithmetic-shift-right self10 #b1))) (let ((bs$12 f10)) ($String.cons 48 ($Kind.Name.from_bits bs$12))))) (1 (let ((f10 (bitwise-arithmetic-shift-right self10 #b1))) (let ((bs$12 f10)) ($String.cons 49 ($Kind.Name.from_bits bs$12)))))))))) (1 (let ((f8 (bitwise-arithmetic-shift-right self8 #b1))) (let ((bs$10 f8)) (let ((self10 bs$10)) (case (if (eq? self10 #b1) 2 (bitwise-and self10 #b1)) (2 String.nil) (0 (let ((f10 (bitwise-arithmetic-shift-right self10 #b1))) (let ((bs$12 f10)) ($String.cons 50 ($Kind.Name.from_bits bs$12))))) (1 (let ((f10 (bitwise-arithmetic-shift-right self10 #b1))) (let ((bs$12 f10)) ($String.cons 51 ($Kind.Name.from_bits bs$12)))))))))))))))))))) (1 (let ((f4 (bitwise-arithmetic-shift-right self4 #b1))) (let ((bs$6 f4)) (let ((self6 bs$6)) (case (if (eq? self6 #b1) 2 (bitwise-and self6 #b1)) (2 String.nil) (0 (let ((f6 (bitwise-arithmetic-shift-right self6 #b1))) (let ((bs$8 f6)) (let ((self8 bs$8)) (case (if (eq? self8 #b1) 2 (bitwise-and self8 #b1)) (2 String.nil) (0 (let ((f8 (bitwise-arithmetic-shift-right self8 #b1))) (let ((bs$10 f8)) (let ((self10 bs$10)) (case (if (eq? self10 #b1) 2 (bitwise-and self10 #b1)) (2 String.nil) (0 (let ((f10 (bitwise-arithmetic-shift-right self10 #b1))) (let ((bs$12 f10)) ($String.cons 52 ($Kind.Name.from_bits bs$12))))) (1 (let ((f10 (bitwise-arithmetic-shift-right self10 #b1))) (let ((bs$12 f10)) ($String.cons 53 ($Kind.Name.from_bits bs$12)))))))))) (1 (let ((f8 (bitwise-arithmetic-shift-right self8 #b1))) (let ((bs$10 f8)) (let ((self10 bs$10)) (case (if (eq? self10 #b1) 2 (bitwise-and self10 #b1)) (2 String.nil) (0 (let ((f10 (bitwise-arithmetic-shift-right self10 #b1))) (let ((bs$12 f10)) ($String.cons 54 ($Kind.Name.from_bits bs$12))))) (1 (let ((f10 (bitwise-arithmetic-shift-right self10 #b1))) (let ((bs$12 f10)) ($String.cons 55 ($Kind.Name.from_bits bs$12))))))))))))))) (1 (let ((f6 (bitwise-arithmetic-shift-right self6 #b1))) (let ((bs$8 f6)) (let ((self8 bs$8)) (case (if (eq? self8 #b1) 2 (bitwise-and self8 #b1)) (2 String.nil) (0 (let ((f8 (bitwise-arithmetic-shift-right self8 #b1))) (let ((bs$10 f8)) (let ((self10 bs$10)) (case (if (eq? self10 #b1) 2 (bitwise-and self10 #b1)) (2 String.nil) (0 (let ((f10 (bitwise-arithmetic-shift-right self10 #b1))) (let ((bs$12 f10)) ($String.cons 56 ($Kind.Name.from_bits bs$12))))) (1 (let ((f10 (bitwise-arithmetic-shift-right self10 #b1))) (let ((bs$12 f10)) ($String.cons 57 ($Kind.Name.from_bits bs$12)))))))))) (1 (let ((f8 (bitwise-arithmetic-shift-right self8 #b1))) (let ((bs$10 f8)) (let ((self10 bs$10)) (case (if (eq? self10 #b1) 2 (bitwise-and self10 #b1)) (2 String.nil) (0 (let ((f10 (bitwise-arithmetic-shift-right self10 #b1))) (let ((bs$12 f10)) ($String.cons 46 ($Kind.Name.from_bits bs$12))))) (1 (let ((f10 (bitwise-arithmetic-shift-right self10 #b1))) (let ((bs$12 f10)) ($String.cons 95 ($Kind.Name.from_bits bs$12)))))))))))))))))))))))))))))))))
(define Kind.Name.from_bits (lambda (bs$0) ($Kind.Name.from_bits bs$0)))
(define ($Kind.Map.to_list xs$1) (let ((kvs$2 ($List.reverse ($BitsMap.to_list.go xs$1 Bits.e List.nil)))) ($List.mapped kvs$2 (lambda (kv$3) (let ((self2 kv$3)) (case (get self2 0) ('Pair.new (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) ($Pair.new ($Kind.Name.from_bits f2) f3))))))))))
(define Kind.Map.to_list (lambda (xs$1) ($Kind.Map.to_list xs$1)))
(define ($Kind.Map.keys xs$1) ($List.mapped ($Kind.Map.to_list xs$1) Pair.fst))
(define Kind.Map.keys (lambda (xs$1) ($Kind.Map.keys xs$1)))
(define ($Kind.Synth.load.cached names$0 defs$1) (let ((self0 names$0)) (case (get self0 0) ('List.nil ((let ((self0 IO.monad)) (case (get self0 0) ('Monad.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) f1))))) ($Maybe.some defs$1))) ('List.cons (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((self2 ($Kind.Synth.load.cached.is_loop f0 defs$1))) (case self2 (#t ($Kind.Synth.load.cached f1 defs$1)) (#f (let ((name$4 f0)) (((let ((self3 IO.monad)) (case (get self3 0) ('Monad.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) f3))))) ($Kind.Synth.load.cached.def name$4)) (lambda (defn$5) (let ((self4 defn$5)) (case (get self4 0) ('Maybe.none ((let ((self4 IO.monad)) (case (get self4 0) ('Monad.new (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) f5))))) Maybe.none)) ('Maybe.some (let ((f4 (get self4 1))) (let ((self5 f4)) (case (get self5 0) ('Kind.Def.new (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) (let ((f8 (get self5 4))) (let ((f9 (get self5 5))) (let ((f10 (get self5 6))) (let ((f11 (get self5 7))) (let ((f12 (get self5 8))) (let ((f13 (get self5 9))) (let ((defs$16 ($Kind.Map.set name$4 f4 defs$1))) (let ((deps$17 Kind.Map.new)) (let ((deps$18 ($Kind.Core.dependencies.go f9 deps$17))) (let ((deps$19 ($Kind.Core.dependencies.go f10 deps$18))) (let ((deps$20 ($Kind.Map.keys deps$19))) (((let ((self19 IO.monad)) (case (get self19 0) ('Monad.new (let ((f19 (get self19 1))) (let ((f20 (get self19 2))) f19))))) ($Kind.Synth.load.cached deps$20 defs$16)) (lambda (defs$21) (let ((self20 defs$21)) (case (get self20 0) ('Maybe.none ((let ((self20 IO.monad)) (case (get self20 0) ('Monad.new (let ((f20 (get self20 1))) (let ((f21 (get self20 2))) f21))))) Maybe.none)) ('Maybe.some (let ((f20 (get self20 1))) ($Kind.Synth.load.cached f1 f20))))))))))))))))))))))))))))))))))))))))
(define Kind.Synth.load.cached (lambda (names$0) (lambda (defs$1) ($Kind.Synth.load.cached names$0 defs$1))))
(define ($IO.request url$0) ($IO.ask "request" url$0 (lambda (text$1) ($IO.end text$1))))
(define IO.request (lambda (url$0) ($IO.request url$0)))
(define ($Kind.Synth.get_kind_code file$0) (((let ((self0 IO.monad)) (case (get self0 0) ('Monad.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) f0))))) ($IO.get_file file$0)) (lambda (code$1) (let ((self1 ($String.eql code$1 ""))) (case self1 (#t (((let ((self1 IO.monad)) (case (get self1 0) ('Monad.new (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) f1))))) ($IO.request ($String.concat "http://uwu.tech:7172/" file$0))) (lambda (code$2) ((let ((self2 IO.monad)) (case (get self2 0) ('Monad.new (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) f3))))) code$2)))) (#f ((let ((self1 IO.monad)) (case (get self1 0) ('Monad.new (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) f2))))) code$1)))))))
(define Kind.Synth.get_kind_code (lambda (file$0) ($Kind.Synth.get_kind_code file$0)))
(define ($Parser.is_eof pst$0) (let ((self0 pst$0)) (case (get self0 0) ('Parser.State.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((self5 f4)) (case (<= (kstring-length self5) 0) (#t ($Parser.Reply.value pst$0 Bool.true)) (#f (let ((f5 (char->integer (kstring-head self5)))) (let ((f6 (kstring-tail self5))) ($Parser.Reply.value pst$0 Bool.false)))))))))))))))
(define Parser.is_eof (lambda (pst$0) ($Parser.is_eof pst$0)))
(define ($Parser.choice pars$1 pst$2) (let ((self0 pst$2)) (case (get self0 0) ('Parser.State.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((self5 pars$1)) (case (get self5 0) ('List.nil (let ((self5 f0)) (case (get self5 0) ('Maybe.none ($Parser.Reply.fail f1 f2 f3 "No parse.")) ('Maybe.some (let ((f5 (get self5 1))) ($Parser.Reply.error f5)))))) ('List.cons (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((parsed$10 (f5 pst$2))) (let ((self8 parsed$10)) (case (get self8 0) ('Parser.Reply.error (let ((f8 (get self8 1))) (let ((cur_err$12 ($Maybe.some f8))) (let ((far_err$13 ($Parser.Error.maybe_combine f0 cur_err$12))) (let ((new_pst$14 ($Parser.State.new far_err$13 f1 f2 f3 f4))) ($Parser.choice f6 new_pst$14)))))) ('Parser.Reply.value (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) ($Parser.Reply.value f8 f9)))))))))))))))))))))
(define Parser.choice (lambda (pars$1) (lambda (pst$2) ($Parser.choice pars$1 pst$2))))
(define ($Parser.text.go ini_idx$0 ini_txt$1 text$2 pst$3) (let ((self0 pst$3)) (case (get self0 0) ('Parser.State.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((self5 text$2)) (case (<= (kstring-length self5) 0) (#t ($Parser.Reply.value pst$3 Unit.new)) (#f (let ((f5 (char->integer (kstring-head self5)))) (let ((f6 (kstring-tail self5))) (let ((self7 f4)) (case (<= (kstring-length self7) 0) (#t (let ((error_msg$11 ($String.concat "Expected '" ($String.concat ini_txt$1 "', found end of file.")))) ($Parser.Reply.fail f1 f2 ini_idx$0 error_msg$11))) (#f (let ((f7 (char->integer (kstring-head self7)))) (let ((f8 (kstring-tail self7))) (let ((self9 ($U16.eql f5 f7))) (case self9 (#t (let ((pst$13 ($Parser.State.new f0 f1 f2 ($Nat.succ f3) f8))) ($Parser.text.go ini_idx$0 ini_txt$1 f6 pst$13))) (#f (let ((chr$13 ($String.cons f7 String.nil))) (let ((err$14 ($String.concat "Expected '" ($String.concat ini_txt$1 ($String.concat "', found '" ($String.concat chr$13 "'.")))))) ($Parser.Reply.fail f1 f2 ini_idx$0 err$14)))))))))))))))))))))))))
(define Parser.text.go (lambda (ini_idx$0) (lambda (ini_txt$1) (lambda (text$2) (lambda (pst$3) ($Parser.text.go ini_idx$0 ini_txt$1 text$2 pst$3))))))
(define ($Parser.text text$0 pst$1) (let ((self0 pst$1)) (case (get self0 0) ('Parser.State.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((self5 ($Parser.text.go f3 text$0 text$0 pst$1))) (case (get self5 0) ('Parser.Reply.error (let ((f5 (get self5 1))) ($Parser.Reply.error f5))) ('Parser.Reply.value (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) ($Parser.Reply.value f5 f6)))))))))))))))
(define Parser.text (lambda (text$0) (lambda (pst$1) ($Parser.text text$0 pst$1))))
(define ($Parser.eof pst$0) (let ((self0 pst$0)) (case (get self0 0) ('Parser.State.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((self5 f4)) (case (<= (kstring-length self5) 0) (#t ($Parser.Reply.value pst$0 Unit.new)) (#f (let ((f5 (char->integer (kstring-head self5)))) (let ((f6 (kstring-tail self5))) ($Parser.Reply.fail f1 f2 f3 "Expected end-of-file.")))))))))))))))
(define Parser.eof (lambda (pst$0) ($Parser.eof pst$0)))
(define ($Parser.until.go until$1 parse$2 values$3 pst$4) (let ((until_reply$5 (until$1 pst$4))) (let ((self1 until_reply$5)) (case (get self1 0) ('Parser.Reply.error (let ((f1 (get self1 1))) (let ((reply$7 (parse$2 pst$4))) (let ((self3 reply$7)) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))) ($Parser.Reply.error ($Parser.Error.combine f3 f1)))) ('Parser.Reply.value (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) ($Parser.until.go until$1 parse$2 ($List.cons f4 values$3) f3))))))))) ('Parser.Reply.value (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) ($Parser.Reply.value f1 ($List.reverse values$3)))))))))
(define Parser.until.go (lambda (until$1) (lambda (parse$2) (lambda (values$3) (lambda (pst$4) ($Parser.until.go until$1 parse$2 values$3 pst$4))))))
(define ($Parser.until until$1 parse$2) (((Parser.until.go until$1) parse$2) List.nil))
(define Parser.until (lambda (until$1) (lambda (parse$2) ($Parser.until until$1 parse$2))))
(define ($Parser.one pst$0) (let ((self0 pst$0)) (case (get self0 0) ('Parser.State.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((self5 f4)) (case (<= (kstring-length self5) 0) (#t ($Parser.Reply.fail f1 f2 f3 "Unexpected end of file.")) (#f (let ((f5 (char->integer (kstring-head self5)))) (let ((f6 (kstring-tail self5))) (let ((pst$8 ($Parser.State.new f0 f1 f2 ($Nat.succ f3) f6))) ($Parser.Reply.value pst$8 f5))))))))))))))))
(define Parser.one (lambda (pst$0) ($Parser.one pst$0)))
(define ($Kind.Parser.comment pst$0) (let ((self0 pst$0)) (case (get self0 0) ('Parser.State.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((reply$6 ($Parser.text "//" pst$0))) (let ((self6 reply$6)) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))) (let ((self7 f0)) (case (get self7 0) ('Maybe.none ($Parser.Reply.error f6)) ('Maybe.some (let ((f7 (get self7 1))) ($Parser.Reply.error ($Parser.Error.combine f7 f6)))))))) ('Parser.Reply.value (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((self8 f6)) (case (get self8 0) ('Parser.State.new (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) (let ((f11 (get self8 4))) (let ((f12 (get self8 5))) (let ((reply.pst$14 ($Parser.State.new ($Parser.Error.maybe_combine f0 f8) f9 f10 f11 f12))) (let ((end$15 (Parser.choice ($List.cons (Parser.text "\xa;") ($List.cons Parser.eof List.nil))))) (let ((self15 reply.pst$14)) (case (get self15 0) ('Parser.State.new (let ((f15 (get self15 1))) (let ((f16 (get self15 2))) (let ((f17 (get self15 3))) (let ((f18 (get self15 4))) (let ((f19 (get self15 5))) (let ((reply$21 (($Parser.until end$15 Parser.one) reply.pst$14))) (let ((self21 reply$21)) (case (get self21 0) ('Parser.Reply.error (let ((f21 (get self21 1))) (let ((self22 f15)) (case (get self22 0) ('Maybe.none ($Parser.Reply.error f21)) ('Maybe.some (let ((f22 (get self22 1))) ($Parser.Reply.error ($Parser.Error.combine f22 f21)))))))) ('Parser.Reply.value (let ((f21 (get self21 1))) (let ((f22 (get self21 2))) (let ((self23 f21)) (case (get self23 0) ('Parser.State.new (let ((f23 (get self23 1))) (let ((f24 (get self23 2))) (let ((f25 (get self23 3))) (let ((f26 (get self23 4))) (let ((f27 (get self23 5))) (let ((reply.pst$29 ($Parser.State.new ($Parser.Error.maybe_combine f15 f23) f24 f25 f26 f27))) ($Parser.Reply.value reply.pst$29 Unit.new)))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.comment (lambda (pst$0) ($Kind.Parser.comment pst$0)))
(define Kind.Parser.spaces ($Parser.many (Parser.choice ($List.cons (Parser.text " ") ($List.cons (Parser.text "\x9;") ($List.cons (Parser.text "\xd;") ($List.cons (Parser.text "\xa;") ($List.cons Kind.Parser.comment List.nil))))))))
(define ($Parser.get_idx pst$0) (let ((self0 pst$0)) (case (get self0 0) ('Parser.State.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) ($Parser.Reply.value pst$0 f3))))))))))
(define Parser.get_idx (lambda (pst$0) ($Parser.get_idx pst$0)))
(define ($U16.btw a$0 b$1 c$2) ($Bool.and ($U16.lte a$0 b$1) ($U16.lte b$1 c$2)))
(define U16.btw (lambda (a$0) (lambda (b$1) (lambda (c$2) ($U16.btw a$0 b$1 c$2)))))
(define ($Kind.Name.is_letter chr$0) (let ((self0 ($U16.btw 65 chr$0 90))) (case self0 (#t Bool.true) (#f (let ((self0 ($U16.btw 97 chr$0 122))) (case self0 (#t Bool.true) (#f (let ((self0 ($U16.btw 48 chr$0 57))) (case self0 (#t Bool.true) (#f (let ((self0 ($U16.eql 46 chr$0))) (case self0 (#t Bool.true) (#f (let ((self0 ($U16.eql 95 chr$0))) (case self0 (#t Bool.true) (#f (let ((self0 ($U16.eql 94 chr$0))) (case self0 (#t Bool.true) (#f Bool.false)))))))))))))))))))
(define Kind.Name.is_letter (lambda (chr$0) ($Kind.Name.is_letter chr$0)))
(define ($Kind.Parser.letter pst$0) (let ((self0 pst$0)) (case (get self0 0) ('Parser.State.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((self5 f4)) (case (<= (kstring-length self5) 0) (#t ($Parser.Reply.fail f1 f2 f3 "Unexpected eof.")) (#f (let ((f5 (char->integer (kstring-head self5)))) (let ((f6 (kstring-tail self5))) (let ((self7 ($Kind.Name.is_letter f5))) (case self7 (#t (let ((pst$8 ($Parser.State.new f0 f1 f2 ($Nat.succ f3) f6))) ($Parser.Reply.value pst$8 f5))) (#f ($Parser.Reply.fail f1 f2 f3 "Expected name."))))))))))))))))))
(define Kind.Parser.letter (lambda (pst$0) ($Kind.Parser.letter pst$0)))
(define ($List.fold list$1 nil$3 cons$4) (let ((self0 list$1)) (case (get self0 0) ('List.nil nil$3) ('List.cons (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ((cons$4 f0) ($List.fold f1 nil$3 cons$4))))))))
(define List.fold (lambda (list$1) (lambda (nil$3) (lambda (cons$4) ($List.fold list$1 nil$3 cons$4)))))
(define ($Parser.fail error$1 pst$2) (let ((self0 pst$2)) (case (get self0 0) ('Parser.State.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) ($Parser.Reply.fail f1 f2 f3 error$1))))))))))
(define Parser.fail (lambda (error$1) (lambda (pst$2) ($Parser.fail error$1 pst$2))))
(define ($String.head xs$0) (let ((self0 xs$0)) (case (<= (kstring-length self0) 0) (#t Maybe.none) (#f (let ((f0 (char->integer (kstring-head self0)))) (let ((f1 (kstring-tail self0))) ($Maybe.some f0)))))))
(define String.head (lambda (xs$0) ($String.head xs$0)))
(define ($Kind.Parser.name1 pst$0) (let ((self0 pst$0)) (case (get self0 0) ('Parser.State.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((reply$6 (Kind.Parser.spaces pst$0))) (let ((self6 reply$6)) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))) (let ((self7 f0)) (case (get self7 0) ('Maybe.none ($Parser.Reply.error f6)) ('Maybe.some (let ((f7 (get self7 1))) ($Parser.Reply.error ($Parser.Error.combine f7 f6)))))))) ('Parser.Reply.value (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((self8 f6)) (case (get self8 0) ('Parser.State.new (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) (let ((f11 (get self8 4))) (let ((f12 (get self8 5))) (let ((reply.pst$14 ($Parser.State.new ($Parser.Error.maybe_combine f0 f8) f9 f10 f11 f12))) (let ((self14 reply.pst$14)) (case (get self14 0) ('Parser.State.new (let ((f14 (get self14 1))) (let ((f15 (get self14 2))) (let ((f16 (get self14 3))) (let ((f17 (get self14 4))) (let ((f18 (get self14 5))) (let ((reply$20 ($Parser.many1 Kind.Parser.letter reply.pst$14))) (let ((self20 reply$20)) (case (get self20 0) ('Parser.Reply.error (let ((f20 (get self20 1))) (let ((self21 f14)) (case (get self21 0) ('Maybe.none ($Parser.Reply.error f20)) ('Maybe.some (let ((f21 (get self21 1))) ($Parser.Reply.error ($Parser.Error.combine f21 f20)))))))) ('Parser.Reply.value (let ((f20 (get self20 1))) (let ((f21 (get self20 2))) (let ((self22 f20)) (case (get self22 0) ('Parser.State.new (let ((f22 (get self22 1))) (let ((f23 (get self22 2))) (let ((f24 (get self22 3))) (let ((f25 (get self22 4))) (let ((f26 (get self22 5))) (let ((reply.pst$28 ($Parser.State.new ($Parser.Error.maybe_combine f14 f22) f23 f24 f25 f26))) (let ((name$29 ($List.fold f21 String.nil String.cons))) (let ((reserved$30 (Parser.fail "Reserved keyword."))) (let ((numeric$31 (Parser.fail "Name can't start with number or sign."))) ((let ((self31 ($String.eql name$29 "case"))) (case self31 (#t reserved$30) (#f (let ((self31 ($String.eql name$29 "do"))) (case self31 (#t reserved$30) (#f (let ((self31 ($String.eql name$29 "if"))) (case self31 (#t reserved$30) (#f (let ((self31 ($String.eql name$29 "with"))) (case self31 (#t reserved$30) (#f (let ((self31 ($String.eql name$29 "for"))) (case self31 (#t reserved$30) (#f (let ((self31 ($String.eql name$29 "else"))) (case self31 (#t reserved$30) (#f (let ((self31 ($String.eql name$29 "switch"))) (case self31 (#t reserved$30) (#f (let ((self31 ($String.eql name$29 "."))) (case self31 (#t reserved$30) (#f (let ((self31 ($String.eql name$29 ".."))) (case self31 (#t reserved$30) (#f (let ((self31 ($String.eql name$29 "..."))) (case self31 (#t reserved$30) (#f (let ((self31 ($U16.eql ($Maybe.default ($String.head name$29) 120) 43))) (case self31 (#t numeric$31) (#f (let ((self31 ($U16.eql ($Maybe.default ($String.head name$29) 120) 45))) (case self31 (#t numeric$31) (#f (let ((self31 ($U16.eql ($Maybe.default ($String.head name$29) 120) 48))) (case self31 (#t numeric$31) (#f (let ((self31 ($U16.eql ($Maybe.default ($String.head name$29) 120) 49))) (case self31 (#t numeric$31) (#f (let ((self31 ($U16.eql ($Maybe.default ($String.head name$29) 120) 50))) (case self31 (#t numeric$31) (#f (let ((self31 ($U16.eql ($Maybe.default ($String.head name$29) 120) 51))) (case self31 (#t numeric$31) (#f (let ((self31 ($U16.eql ($Maybe.default ($String.head name$29) 120) 52))) (case self31 (#t numeric$31) (#f (let ((self31 ($U16.eql ($Maybe.default ($String.head name$29) 120) 53))) (case self31 (#t numeric$31) (#f (let ((self31 ($U16.eql ($Maybe.default ($String.head name$29) 120) 54))) (case self31 (#t numeric$31) (#f (let ((self31 ($U16.eql ($Maybe.default ($String.head name$29) 120) 55))) (case self31 (#t numeric$31) (#f (let ((self31 ($U16.eql ($Maybe.default ($String.head name$29) 120) 56))) (case self31 (#t numeric$31) (#f (let ((self31 ($U16.eql ($Maybe.default ($String.head name$29) 120) 57))) (case self31 (#t numeric$31) (#f (lambda (pst$32) ($Parser.Reply.value pst$32 name$29)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) reply.pst$28)))))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.name1 (lambda (pst$0) ($Kind.Parser.name1 pst$0)))
(define ($Parser.until1 cond$1 parser$2 pst$3) (let ((self0 pst$3)) (case (get self0 0) ('Parser.State.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((reply$9 (parser$2 pst$3))) (let ((self6 reply$9)) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))) (let ((self7 f0)) (case (get self7 0) ('Maybe.none ($Parser.Reply.error f6)) ('Maybe.some (let ((f7 (get self7 1))) ($Parser.Reply.error ($Parser.Error.combine f7 f6)))))))) ('Parser.Reply.value (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((self8 f6)) (case (get self8 0) ('Parser.State.new (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) (let ((f11 (get self8 4))) (let ((f12 (get self8 5))) (let ((reply.pst$17 ($Parser.State.new ($Parser.Error.maybe_combine f0 f8) f9 f10 f11 f12))) (let ((self14 reply.pst$17)) (case (get self14 0) ('Parser.State.new (let ((f14 (get self14 1))) (let ((f15 (get self14 2))) (let ((f16 (get self14 3))) (let ((f17 (get self14 4))) (let ((f18 (get self14 5))) (let ((reply$23 (($Parser.until cond$1 parser$2) reply.pst$17))) (let ((self20 reply$23)) (case (get self20 0) ('Parser.Reply.error (let ((f20 (get self20 1))) (let ((self21 f14)) (case (get self21 0) ('Maybe.none ($Parser.Reply.error f20)) ('Maybe.some (let ((f21 (get self21 1))) ($Parser.Reply.error ($Parser.Error.combine f21 f20)))))))) ('Parser.Reply.value (let ((f20 (get self20 1))) (let ((f21 (get self20 2))) (let ((self22 f20)) (case (get self22 0) ('Parser.State.new (let ((f22 (get self22 1))) (let ((f23 (get self22 2))) (let ((f24 (get self22 3))) (let ((f25 (get self22 4))) (let ((f26 (get self22 5))) (let ((reply.pst$31 ($Parser.State.new ($Parser.Error.maybe_combine f14 f22) f23 f24 f25 f26))) ($Parser.Reply.value reply.pst$31 ($List.cons f7 f21)))))))))))))))))))))))))))))))))))))))))))))))))
(define Parser.until1 (lambda (cond$1) (lambda (parser$2) (lambda (pst$3) ($Parser.until1 cond$1 parser$2 pst$3)))))
(define ($Parser.wrap1 opens$1 parse$2 close$3 pst$4) (let ((self0 pst$4)) (case (get self0 0) ('Parser.State.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((reply$10 (opens$1 pst$4))) (let ((self6 reply$10)) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))) (let ((self7 f0)) (case (get self7 0) ('Maybe.none ($Parser.Reply.error f6)) ('Maybe.some (let ((f7 (get self7 1))) ($Parser.Reply.error ($Parser.Error.combine f7 f6)))))))) ('Parser.Reply.value (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((self8 f6)) (case (get self8 0) ('Parser.State.new (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) (let ((f11 (get self8 4))) (let ((f12 (get self8 5))) (let ((reply.pst$18 ($Parser.State.new ($Parser.Error.maybe_combine f0 f8) f9 f10 f11 f12))) ($Parser.until1 close$3 parse$2 reply.pst$18)))))))))))))))))))))))))
(define Parser.wrap1 (lambda (opens$1) (lambda (parse$2) (lambda (close$3) (lambda (pst$4) ($Parser.wrap1 opens$1 parse$2 close$3 pst$4))))))
(define ($Kind.Parser.text text$0 pst$1) (let ((self0 pst$1)) (case (get self0 0) ('Parser.State.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((reply$7 (Kind.Parser.spaces pst$1))) (let ((self6 reply$7)) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))) (let ((self7 f0)) (case (get self7 0) ('Maybe.none ($Parser.Reply.error f6)) ('Maybe.some (let ((f7 (get self7 1))) ($Parser.Reply.error ($Parser.Error.combine f7 f6)))))))) ('Parser.Reply.value (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((self8 f6)) (case (get self8 0) ('Parser.State.new (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) (let ((f11 (get self8 4))) (let ((f12 (get self8 5))) (let ((reply.pst$15 ($Parser.State.new ($Parser.Error.maybe_combine f0 f8) f9 f10 f11 f12))) ($Parser.text text$0 reply.pst$15)))))))))))))))))))))))))
(define Kind.Parser.text (lambda (text$0) (lambda (pst$1) ($Kind.Parser.text text$0 pst$1))))
(define ($Parser.maybe parse$1 pst$2) (let ((self0 pst$2)) (case (get self0 0) ('Parser.State.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((self5 (parse$1 pst$2))) (case (get self5 0) ('Parser.Reply.error (let ((f5 (get self5 1))) ($Parser.Reply.value pst$2 Maybe.none))) ('Parser.Reply.value (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) ($Parser.Reply.value f5 ($Maybe.some f6))))))))))))))))
(define Parser.maybe (lambda (parse$1) (lambda (pst$2) ($Parser.maybe parse$1 pst$2))))
(define ($Kind.Parser.items1 ini$1 parser$2 end$3) (((Parser.wrap1 (Kind.Parser.text ini$1)) (lambda (pst$4) (let ((self1 pst$4)) (case (get self1 0) ('Parser.State.new (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((reply$10 (Kind.Parser.spaces pst$4))) (let ((self7 reply$10)) (case (get self7 0) ('Parser.Reply.error (let ((f7 (get self7 1))) (let ((self8 f1)) (case (get self8 0) ('Maybe.none ($Parser.Reply.error f7)) ('Maybe.some (let ((f8 (get self8 1))) ($Parser.Reply.error ($Parser.Error.combine f8 f7)))))))) ('Parser.Reply.value (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((self9 f7)) (case (get self9 0) ('Parser.State.new (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) (let ((reply.pst$18 ($Parser.State.new ($Parser.Error.maybe_combine f1 f9) f10 f11 f12 f13))) (let ((self15 reply.pst$18)) (case (get self15 0) ('Parser.State.new (let ((f15 (get self15 1))) (let ((f16 (get self15 2))) (let ((f17 (get self15 3))) (let ((f18 (get self15 4))) (let ((f19 (get self15 5))) (let ((reply$24 (parser$2 reply.pst$18))) (let ((self21 reply$24)) (case (get self21 0) ('Parser.Reply.error (let ((f21 (get self21 1))) (let ((self22 f15)) (case (get self22 0) ('Maybe.none ($Parser.Reply.error f21)) ('Maybe.some (let ((f22 (get self22 1))) ($Parser.Reply.error ($Parser.Error.combine f22 f21)))))))) ('Parser.Reply.value (let ((f21 (get self21 1))) (let ((f22 (get self21 2))) (let ((self23 f21)) (case (get self23 0) ('Parser.State.new (let ((f23 (get self23 1))) (let ((f24 (get self23 2))) (let ((f25 (get self23 3))) (let ((f26 (get self23 4))) (let ((f27 (get self23 5))) (let ((reply.pst$32 ($Parser.State.new ($Parser.Error.maybe_combine f15 f23) f24 f25 f26 f27))) (let ((self29 reply.pst$32)) (case (get self29 0) ('Parser.State.new (let ((f29 (get self29 1))) (let ((f30 (get self29 2))) (let ((f31 (get self29 3))) (let ((f32 (get self29 4))) (let ((f33 (get self29 5))) (let ((reply$38 ($Parser.maybe (Kind.Parser.text ",") reply.pst$32))) (let ((self35 reply$38)) (case (get self35 0) ('Parser.Reply.error (let ((f35 (get self35 1))) (let ((self36 f29)) (case (get self36 0) ('Maybe.none ($Parser.Reply.error f35)) ('Maybe.some (let ((f36 (get self36 1))) ($Parser.Reply.error ($Parser.Error.combine f36 f35)))))))) ('Parser.Reply.value (let ((f35 (get self35 1))) (let ((f36 (get self35 2))) (let ((self37 f35)) (case (get self37 0) ('Parser.State.new (let ((f37 (get self37 1))) (let ((f38 (get self37 2))) (let ((f39 (get self37 3))) (let ((f40 (get self37 4))) (let ((f41 (get self37 5))) (let ((reply.pst$46 ($Parser.State.new ($Parser.Error.maybe_combine f29 f37) f38 f39 f40 f41))) ($Parser.Reply.value reply.pst$46 f22)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) (Kind.Parser.text end$3)))
(define Kind.Parser.items1 (lambda (ini$1) (lambda (parser$2) (lambda (end$3) ($Kind.Parser.items1 ini$1 parser$2 end$3)))))
(define ($Kind.Parser.name pst$0) (let ((self0 pst$0)) (case (get self0 0) ('Parser.State.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((reply$6 (Kind.Parser.spaces pst$0))) (let ((self6 reply$6)) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))) (let ((self7 f0)) (case (get self7 0) ('Maybe.none ($Parser.Reply.error f6)) ('Maybe.some (let ((f7 (get self7 1))) ($Parser.Reply.error ($Parser.Error.combine f7 f6)))))))) ('Parser.Reply.value (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((self8 f6)) (case (get self8 0) ('Parser.State.new (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) (let ((f11 (get self8 4))) (let ((f12 (get self8 5))) (let ((reply.pst$14 ($Parser.State.new ($Parser.Error.maybe_combine f0 f8) f9 f10 f11 f12))) (let ((self14 reply.pst$14)) (case (get self14 0) ('Parser.State.new (let ((f14 (get self14 1))) (let ((f15 (get self14 2))) (let ((f16 (get self14 3))) (let ((f17 (get self14 4))) (let ((f18 (get self14 5))) (let ((reply$20 (($Parser.many Kind.Parser.letter) reply.pst$14))) (let ((self20 reply$20)) (case (get self20 0) ('Parser.Reply.error (let ((f20 (get self20 1))) (let ((self21 f14)) (case (get self21 0) ('Maybe.none ($Parser.Reply.error f20)) ('Maybe.some (let ((f21 (get self21 1))) ($Parser.Reply.error ($Parser.Error.combine f21 f20)))))))) ('Parser.Reply.value (let ((f20 (get self20 1))) (let ((f21 (get self20 2))) (let ((self22 f20)) (case (get self22 0) ('Parser.State.new (let ((f22 (get self22 1))) (let ((f23 (get self22 2))) (let ((f24 (get self22 3))) (let ((f25 (get self22 4))) (let ((f26 (get self22 5))) (let ((reply.pst$28 ($Parser.State.new ($Parser.Error.maybe_combine f14 f22) f23 f24 f25 f26))) ($Parser.Reply.value reply.pst$28 ($List.fold f21 String.nil String.cons)))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.name (lambda (pst$0) ($Kind.Parser.name pst$0)))
(define ($Kind.Term.ori orig$0 expr$1) (vector 'Kind.Term.ori orig$0 expr$1))
(define Kind.Term.ori (lambda (orig$0) (lambda (expr$1) ($Kind.Term.ori orig$0 expr$1))))
(define ($Kind.Parser.block name$0 parse$1 pst$2) (let ((self0 pst$2)) (case (get self0 0) ('Parser.State.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((reply$8 (Kind.Parser.spaces pst$2))) (let ((self6 reply$8)) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))) ($Parser.Reply.error f6))) ('Parser.Reply.value (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((pst$11 f6)) (let ((self9 pst$11)) (case (get self9 0) ('Parser.State.new (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) (let ((reply$17 (parse$1 ($Parser.State.new f9 name$0 f12 f12 f13)))) (let ((self15 reply$17)) (case (get self15 0) ('Parser.Reply.error (let ((f15 (get self15 1))) ($Parser.Reply.error f15))) ('Parser.Reply.value (let ((f15 (get self15 1))) (let ((f16 (get self15 2))) (let ((self17 f15)) (case (get self17 0) ('Parser.State.new (let ((f17 (get self17 1))) (let ((f18 (get self17 2))) (let ((f19 (get self17 3))) (let ((f20 (get self17 4))) (let ((f21 (get self17 5))) (let ((new_pst$25 ($Parser.State.new f17 f10 f11 f20 f21))) ($Parser.Reply.value new_pst$25 ($Kind.Term.ori ($Pair.new f12 f20) f16)))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.block (lambda (name$0) (lambda (parse$1) (lambda (pst$2) ($Kind.Parser.block name$0 parse$1 pst$2)))))
(define ($Kind.Parser.dom.prop pst$0) (let ((self0 pst$0)) (case (get self0 0) ('Parser.State.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((reply$6 ($Kind.Parser.name1 pst$0))) (let ((self6 reply$6)) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))) (let ((self7 f0)) (case (get self7 0) ('Maybe.none ($Parser.Reply.error f6)) ('Maybe.some (let ((f7 (get self7 1))) ($Parser.Reply.error ($Parser.Error.combine f7 f6)))))))) ('Parser.Reply.value (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((self8 f6)) (case (get self8 0) ('Parser.State.new (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) (let ((f11 (get self8 4))) (let ((f12 (get self8 5))) (let ((reply.pst$14 ($Parser.State.new ($Parser.Error.maybe_combine f0 f8) f9 f10 f11 f12))) (let ((self14 reply.pst$14)) (case (get self14 0) ('Parser.State.new (let ((f14 (get self14 1))) (let ((f15 (get self14 2))) (let ((f16 (get self14 3))) (let ((f17 (get self14 4))) (let ((f18 (get self14 5))) (let ((reply$20 ($Kind.Parser.text "=" reply.pst$14))) (let ((self20 reply$20)) (case (get self20 0) ('Parser.Reply.error (let ((f20 (get self20 1))) (let ((self21 f14)) (case (get self21 0) ('Maybe.none ($Parser.Reply.error f20)) ('Maybe.some (let ((f21 (get self21 1))) ($Parser.Reply.error ($Parser.Error.combine f21 f20)))))))) ('Parser.Reply.value (let ((f20 (get self20 1))) (let ((f21 (get self20 2))) (let ((self22 f20)) (case (get self22 0) ('Parser.State.new (let ((f22 (get self22 1))) (let ((f23 (get self22 2))) (let ((f24 (get self22 3))) (let ((f25 (get self22 4))) (let ((f26 (get self22 5))) (let ((reply.pst$28 ($Parser.State.new ($Parser.Error.maybe_combine f14 f22) f23 f24 f25 f26))) (let ((self28 reply.pst$28)) (case (get self28 0) ('Parser.State.new (let ((f28 (get self28 1))) (let ((f29 (get self28 2))) (let ((f30 (get self28 3))) (let ((f31 (get self28 4))) (let ((f32 (get self28 5))) (let ((reply$34 (Kind.Parser.term reply.pst$28))) (let ((self34 reply$34)) (case (get self34 0) ('Parser.Reply.error (let ((f34 (get self34 1))) (let ((self35 f28)) (case (get self35 0) ('Maybe.none ($Parser.Reply.error f34)) ('Maybe.some (let ((f35 (get self35 1))) ($Parser.Reply.error ($Parser.Error.combine f35 f34)))))))) ('Parser.Reply.value (let ((f34 (get self34 1))) (let ((f35 (get self34 2))) (let ((self36 f34)) (case (get self36 0) ('Parser.State.new (let ((f36 (get self36 1))) (let ((f37 (get self36 2))) (let ((f38 (get self36 3))) (let ((f39 (get self36 4))) (let ((f40 (get self36 5))) (let ((reply.pst$42 ($Parser.State.new ($Parser.Error.maybe_combine f28 f36) f37 f38 f39 f40))) (let ((self42 reply.pst$42)) (case (get self42 0) ('Parser.State.new (let ((f42 (get self42 1))) (let ((f43 (get self42 2))) (let ((f44 (get self42 3))) (let ((f45 (get self42 4))) (let ((f46 (get self42 5))) (let ((reply$48 (Kind.Parser.spaces reply.pst$42))) (let ((self48 reply$48)) (case (get self48 0) ('Parser.Reply.error (let ((f48 (get self48 1))) (let ((self49 f42)) (case (get self49 0) ('Maybe.none ($Parser.Reply.error f48)) ('Maybe.some (let ((f49 (get self49 1))) ($Parser.Reply.error ($Parser.Error.combine f49 f48)))))))) ('Parser.Reply.value (let ((f48 (get self48 1))) (let ((f49 (get self48 2))) (let ((self50 f48)) (case (get self50 0) ('Parser.State.new (let ((f50 (get self50 1))) (let ((f51 (get self50 2))) (let ((f52 (get self50 3))) (let ((f53 (get self50 4))) (let ((f54 (get self50 5))) (let ((reply.pst$56 ($Parser.State.new ($Parser.Error.maybe_combine f42 f50) f51 f52 f53 f54))) ($Parser.Reply.value reply.pst$56 ($Pair.new f7 f35)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.dom.prop (lambda (pst$0) ($Kind.Parser.dom.prop pst$0)))
(define ($Kind.Term.hol path$0) (vector 'Kind.Term.hol path$0))
(define Kind.Term.hol (lambda (path$0) ($Kind.Term.hol path$0)))
(define ($Kind.Parser.dom.gen_prop.go values$0 result$1) (let ((self0 values$0)) (case (get self0 0) ('List.nil result$1) ('List.cons (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((self2 f0)) (case (get self2 0) ('Pair.new (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((self4 ($String.eql f2 "style"))) (case self4 (#t ($Kind.Parser.dom.gen_prop.go f1 ($Pair.new (let ((self4 result$1)) (case (get self4 0) ('Pair.new (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) f4))))) f3))) (#f (let ((pair$6 ($Kind.Term.ref "Pair.new"))) (let ((pair$7 ($Kind.Term.app pair$6 ($Kind.Term.hol Bits.e)))) (let ((pair$8 ($Kind.Term.app pair$7 ($Kind.Term.hol Bits.e)))) (let ((pair$9 ($Kind.Term.app pair$8 ($Kind.Term.str f2)))) (let ((pair$10 ($Kind.Term.app pair$9 f3))) (let ((term$11 ($Kind.Term.ref "List.cons"))) (let ((term$12 ($Kind.Term.app term$11 ($Kind.Term.hol Bits.e)))) (let ((term$13 ($Kind.Term.app term$12 pair$10))) (let ((term$14 ($Kind.Term.app term$13 (let ((self12 result$1)) (case (get self12 0) ('Pair.new (let ((f12 (get self12 1))) (let ((f13 (get self12 2))) f12)))))))) ($Kind.Parser.dom.gen_prop.go f1 ($Pair.new term$14 (let ((self13 result$1)) (case (get self13 0) ('Pair.new (let ((f13 (get self13 1))) (let ((f14 (get self13 2))) f14))))))))))))))))))))))))))))))
(define Kind.Parser.dom.gen_prop.go (lambda (values$0) (lambda (result$1) ($Kind.Parser.dom.gen_prop.go values$0 result$1))))
(define ($Kind.Parser.dom.gen_prop values$0) (let ((empty_list$1 ($Kind.Term.app ($Kind.Term.ref "List.nil") ($Kind.Term.hol Bits.e)))) (let ((empty_map$2 ($Kind.Term.app ($Kind.Term.ref "Map.new") ($Kind.Term.hol Bits.e)))) (let ((self2 ($Kind.Parser.dom.gen_prop.go values$0 ($Pair.new empty_list$1 empty_map$2)))) (case (get self2 0) ('Pair.new (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((term_prop$5 ($Kind.Term.ref "Map.from_list"))) (let ((term_prop$6 ($Kind.Term.app term_prop$5 ($Kind.Term.hol Bits.e)))) (let ((term_prop$7 ($Kind.Term.app term_prop$6 f2))) ($Pair.new term_prop$7 f3))))))))))))
(define Kind.Parser.dom.gen_prop (lambda (values$0) ($Kind.Parser.dom.gen_prop values$0)))
(define Kind.Parser.dom.for ((Kind.Parser.block "for_dom") (lambda (pst$0) (let ((self1 pst$0)) (case (get self1 0) ('Parser.State.new (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((reply$6 ($Kind.Parser.text "for " pst$0))) (let ((self7 reply$6)) (case (get self7 0) ('Parser.Reply.error (let ((f7 (get self7 1))) (let ((self8 f1)) (case (get self8 0) ('Maybe.none ($Parser.Reply.error f7)) ('Maybe.some (let ((f8 (get self8 1))) ($Parser.Reply.error ($Parser.Error.combine f8 f7)))))))) ('Parser.Reply.value (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((self9 f7)) (case (get self9 0) ('Parser.State.new (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) (let ((reply.pst$14 ($Parser.State.new ($Parser.Error.maybe_combine f1 f9) f10 f11 f12 f13))) (let ((self15 reply.pst$14)) (case (get self15 0) ('Parser.State.new (let ((f15 (get self15 1))) (let ((f16 (get self15 2))) (let ((f17 (get self15 3))) (let ((f18 (get self15 4))) (let ((f19 (get self15 5))) (let ((reply$20 ($Kind.Parser.name1 reply.pst$14))) (let ((self21 reply$20)) (case (get self21 0) ('Parser.Reply.error (let ((f21 (get self21 1))) (let ((self22 f15)) (case (get self22 0) ('Maybe.none ($Parser.Reply.error f21)) ('Maybe.some (let ((f22 (get self22 1))) ($Parser.Reply.error ($Parser.Error.combine f22 f21)))))))) ('Parser.Reply.value (let ((f21 (get self21 1))) (let ((f22 (get self21 2))) (let ((self23 f21)) (case (get self23 0) ('Parser.State.new (let ((f23 (get self23 1))) (let ((f24 (get self23 2))) (let ((f25 (get self23 3))) (let ((f26 (get self23 4))) (let ((f27 (get self23 5))) (let ((reply.pst$28 ($Parser.State.new ($Parser.Error.maybe_combine f15 f23) f24 f25 f26 f27))) (let ((self29 reply.pst$28)) (case (get self29 0) ('Parser.State.new (let ((f29 (get self29 1))) (let ((f30 (get self29 2))) (let ((f31 (get self29 3))) (let ((f32 (get self29 4))) (let ((f33 (get self29 5))) (let ((reply$34 ($Kind.Parser.text "in" reply.pst$28))) (let ((self35 reply$34)) (case (get self35 0) ('Parser.Reply.error (let ((f35 (get self35 1))) (let ((self36 f29)) (case (get self36 0) ('Maybe.none ($Parser.Reply.error f35)) ('Maybe.some (let ((f36 (get self36 1))) ($Parser.Reply.error ($Parser.Error.combine f36 f35)))))))) ('Parser.Reply.value (let ((f35 (get self35 1))) (let ((f36 (get self35 2))) (let ((self37 f35)) (case (get self37 0) ('Parser.State.new (let ((f37 (get self37 1))) (let ((f38 (get self37 2))) (let ((f39 (get self37 3))) (let ((f40 (get self37 4))) (let ((f41 (get self37 5))) (let ((reply.pst$42 ($Parser.State.new ($Parser.Error.maybe_combine f29 f37) f38 f39 f40 f41))) (let ((self43 reply.pst$42)) (case (get self43 0) ('Parser.State.new (let ((f43 (get self43 1))) (let ((f44 (get self43 2))) (let ((f45 (get self43 3))) (let ((f46 (get self43 4))) (let ((f47 (get self43 5))) (let ((reply$48 (Kind.Parser.term reply.pst$42))) (let ((self49 reply$48)) (case (get self49 0) ('Parser.Reply.error (let ((f49 (get self49 1))) (let ((self50 f43)) (case (get self50 0) ('Maybe.none ($Parser.Reply.error f49)) ('Maybe.some (let ((f50 (get self50 1))) ($Parser.Reply.error ($Parser.Error.combine f50 f49)))))))) ('Parser.Reply.value (let ((f49 (get self49 1))) (let ((f50 (get self49 2))) (let ((self51 f49)) (case (get self51 0) ('Parser.State.new (let ((f51 (get self51 1))) (let ((f52 (get self51 2))) (let ((f53 (get self51 3))) (let ((f54 (get self51 4))) (let ((f55 (get self51 5))) (let ((reply.pst$56 ($Parser.State.new ($Parser.Error.maybe_combine f43 f51) f52 f53 f54 f55))) (let ((empty_list$57 ($Kind.Term.app ($Kind.Term.ref "List.nil") ($Kind.Term.hol Bits.e)))) (let ((list_cons$58 ($Kind.Term.app ($Kind.Term.ref "List.cons") ($Kind.Term.hol Bits.e)))) (let ((empty_map$59 ($Kind.Term.app ($Kind.Term.ref "Map.new") ($Kind.Term.hol Bits.e)))) (let ((self60 reply.pst$56)) (case (get self60 0) ('Parser.State.new (let ((f60 (get self60 1))) (let ((f61 (get self60 2))) (let ((f62 (get self60 3))) (let ((f63 (get self60 4))) (let ((f64 (get self60 5))) (let ((reply$65 ($Kind.Parser.text ":" reply.pst$56))) (let ((self66 reply$65)) (case (get self66 0) ('Parser.Reply.error (let ((f66 (get self66 1))) (let ((self67 f60)) (case (get self67 0) ('Maybe.none ($Parser.Reply.error f66)) ('Maybe.some (let ((f67 (get self67 1))) ($Parser.Reply.error ($Parser.Error.combine f67 f66)))))))) ('Parser.Reply.value (let ((f66 (get self66 1))) (let ((f67 (get self66 2))) (let ((self68 f66)) (case (get self68 0) ('Parser.State.new (let ((f68 (get self68 1))) (let ((f69 (get self68 2))) (let ((f70 (get self68 3))) (let ((f71 (get self68 4))) (let ((f72 (get self68 5))) (let ((reply.pst$73 ($Parser.State.new ($Parser.Error.maybe_combine f60 f68) f69 f70 f71 f72))) (let ((self74 reply.pst$73)) (case (get self74 0) ('Parser.State.new (let ((f74 (get self74 1))) (let ((f75 (get self74 2))) (let ((f76 (get self74 3))) (let ((f77 (get self74 4))) (let ((f78 (get self74 5))) (let ((reply$79 (Kind.Parser.term reply.pst$73))) (let ((self80 reply$79)) (case (get self80 0) ('Parser.Reply.error (let ((f80 (get self80 1))) (let ((self81 f74)) (case (get self81 0) ('Maybe.none ($Parser.Reply.error f80)) ('Maybe.some (let ((f81 (get self81 1))) ($Parser.Reply.error ($Parser.Error.combine f81 f80)))))))) ('Parser.Reply.value (let ((f80 (get self80 1))) (let ((f81 (get self80 2))) (let ((self82 f80)) (case (get self82 0) ('Parser.State.new (let ((f82 (get self82 1))) (let ((f83 (get self82 2))) (let ((f84 (get self82 3))) (let ((f85 (get self82 4))) (let ((f86 (get self82 5))) (let ((reply.pst$87 ($Parser.State.new ($Parser.Error.maybe_combine f74 f82) f83 f84 f85 f86))) (let ((term$88 ($Kind.Term.ref "List.fold"))) (let ((term$89 ($Kind.Term.app term$88 ($Kind.Term.hol Bits.e)))) (let ((term$90 ($Kind.Term.app term$89 f50))) (let ((term$91 ($Kind.Term.app term$90 ($Kind.Term.hol Bits.e)))) (let ((term$92 ($Kind.Term.app term$91 empty_list$57))) (let ((lamb$93 ($Kind.Term.lam f22 (lambda (i$93) ($Kind.Term.lam "placeholder" (lambda (b$94) ($Kind.Term.app ($Kind.Term.app list_cons$58 f81) b$94))))))) (let ((term$94 ($Kind.Term.app term$92 lamb$93))) (let ((display_content$95 ($Kind.Term.app ($Kind.Term.ref "Map.set") ($Kind.Term.hol Bits.e)))) (let ((display_content$96 ($Kind.Term.app display_content$95 ($Kind.Term.str "display")))) (let ((display_content$97 ($Kind.Term.app display_content$96 ($Kind.Term.str "contents")))) (let ((display_content$98 ($Kind.Term.app display_content$97 empty_map$59))) (let ((root$99 ($Kind.Term.ref "DOM.node"))) (let ((root$100 ($Kind.Term.app root$99 ($Kind.Term.str "div")))) (let ((root$101 ($Kind.Term.app root$100 empty_map$59))) (let ((root$102 ($Kind.Term.app root$101 display_content$98))) (let ((root$103 ($Kind.Term.app root$102 term$94))) ($Parser.Reply.value reply.pst$87 root$103)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.dom.dynamic ((Kind.Parser.block "DOM_dynamic") (lambda (pst$0) (let ((self1 pst$0)) (case (get self1 0) ('Parser.State.new (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((reply$6 ($Kind.Parser.text "{" pst$0))) (let ((self7 reply$6)) (case (get self7 0) ('Parser.Reply.error (let ((f7 (get self7 1))) (let ((self8 f1)) (case (get self8 0) ('Maybe.none ($Parser.Reply.error f7)) ('Maybe.some (let ((f8 (get self8 1))) ($Parser.Reply.error ($Parser.Error.combine f8 f7)))))))) ('Parser.Reply.value (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((self9 f7)) (case (get self9 0) ('Parser.State.new (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) (let ((reply.pst$14 ($Parser.State.new ($Parser.Error.maybe_combine f1 f9) f10 f11 f12 f13))) (let ((self15 reply.pst$14)) (case (get self15 0) ('Parser.State.new (let ((f15 (get self15 1))) (let ((f16 (get self15 2))) (let ((f17 (get self15 3))) (let ((f18 (get self15 4))) (let ((f19 (get self15 5))) (let ((reply$20 ($Parser.choice ($List.cons Kind.Parser.term List.nil) reply.pst$14))) (let ((self21 reply$20)) (case (get self21 0) ('Parser.Reply.error (let ((f21 (get self21 1))) (let ((self22 f15)) (case (get self22 0) ('Maybe.none ($Parser.Reply.error f21)) ('Maybe.some (let ((f22 (get self22 1))) ($Parser.Reply.error ($Parser.Error.combine f22 f21)))))))) ('Parser.Reply.value (let ((f21 (get self21 1))) (let ((f22 (get self21 2))) (let ((self23 f21)) (case (get self23 0) ('Parser.State.new (let ((f23 (get self23 1))) (let ((f24 (get self23 2))) (let ((f25 (get self23 3))) (let ((f26 (get self23 4))) (let ((f27 (get self23 5))) (let ((reply.pst$28 ($Parser.State.new ($Parser.Error.maybe_combine f15 f23) f24 f25 f26 f27))) (let ((self29 reply.pst$28)) (case (get self29 0) ('Parser.State.new (let ((f29 (get self29 1))) (let ((f30 (get self29 2))) (let ((f31 (get self29 3))) (let ((f32 (get self29 4))) (let ((f33 (get self29 5))) (let ((reply$34 ($Kind.Parser.text "}" reply.pst$28))) (let ((self35 reply$34)) (case (get self35 0) ('Parser.Reply.error (let ((f35 (get self35 1))) (let ((self36 f29)) (case (get self36 0) ('Maybe.none ($Parser.Reply.error f35)) ('Maybe.some (let ((f36 (get self36 1))) ($Parser.Reply.error ($Parser.Error.combine f36 f35)))))))) ('Parser.Reply.value (let ((f35 (get self35 1))) (let ((f36 (get self35 2))) (let ((self37 f35)) (case (get self37 0) ('Parser.State.new (let ((f37 (get self37 1))) (let ((f38 (get self37 2))) (let ((f39 (get self37 3))) (let ((f40 (get self37 4))) (let ((f41 (get self37 5))) (let ((reply.pst$42 ($Parser.State.new ($Parser.Error.maybe_combine f29 f37) f38 f39 f40 f41))) ($Parser.Reply.value reply.pst$42 f22)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.dom.text ((Kind.Parser.block "DOM_text") (let ((term$0 ($Kind.Term.ref "DOM.text"))) (lambda (pst$1) (let ((self2 pst$1)) (case (get self2 0) ('Parser.State.new (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) (let ((f5 (get self2 4))) (let ((f6 (get self2 5))) (let ((reply$7 (Kind.Parser.term pst$1))) (let ((self8 reply$7)) (case (get self8 0) ('Parser.Reply.error (let ((f8 (get self8 1))) (let ((self9 f2)) (case (get self9 0) ('Maybe.none ($Parser.Reply.error f8)) ('Maybe.some (let ((f9 (get self9 1))) ($Parser.Reply.error ($Parser.Error.combine f9 f8)))))))) ('Parser.Reply.value (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((self10 f8)) (case (get self10 0) ('Parser.State.new (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) (let ((f13 (get self10 4))) (let ((f14 (get self10 5))) (let ((reply.pst$15 ($Parser.State.new ($Parser.Error.maybe_combine f2 f10) f11 f12 f13 f14))) (let ((term$16 ($Kind.Term.app term$0 f9))) ($Parser.Reply.value reply.pst$15 term$16)))))))))))))))))))))))))))))
(define Kind.Parser.dom.leaf ((Kind.Parser.block "DOM_leaf") (Parser.choice ($List.cons Kind.Parser.dom.for ($List.cons Kind.Parser.dom.dynamic ($List.cons Kind.Parser.dom.text List.nil))))))
(define ($Kind.Parser.dom.transform_children a$0) (let ((self0 a$0)) (case (get self0 0) ('List.nil ($Kind.Term.app ($Kind.Term.ref "List.nil") ($Kind.Term.hol Bits.e))) ('List.cons (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((term$3 ($Kind.Term.app ($Kind.Term.ref "List.cons") ($Kind.Term.hol Bits.e)))) (let ((term$4 ($Kind.Term.app term$3 f0))) (let ((term$5 ($Kind.Term.app term$4 ($Kind.Parser.dom.transform_children f1)))) term$5)))))))))
(define Kind.Parser.dom.transform_children (lambda (a$0) ($Kind.Parser.dom.transform_children a$0)))
(define Kind.Parser.dom.node ((Kind.Parser.block "DOM.node") (lambda (pst$0) (let ((self1 pst$0)) (case (get self1 0) ('Parser.State.new (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((reply$6 ($Kind.Parser.text "<" pst$0))) (let ((self7 reply$6)) (case (get self7 0) ('Parser.Reply.error (let ((f7 (get self7 1))) (let ((self8 f1)) (case (get self8 0) ('Maybe.none ($Parser.Reply.error f7)) ('Maybe.some (let ((f8 (get self8 1))) ($Parser.Reply.error ($Parser.Error.combine f8 f7)))))))) ('Parser.Reply.value (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((self9 f7)) (case (get self9 0) ('Parser.State.new (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) (let ((reply.pst$14 ($Parser.State.new ($Parser.Error.maybe_combine f1 f9) f10 f11 f12 f13))) (let ((self15 reply.pst$14)) (case (get self15 0) ('Parser.State.new (let ((f15 (get self15 1))) (let ((f16 (get self15 2))) (let ((f17 (get self15 3))) (let ((f18 (get self15 4))) (let ((f19 (get self15 5))) (let ((reply$20 ($Kind.Parser.name1 reply.pst$14))) (let ((self21 reply$20)) (case (get self21 0) ('Parser.Reply.error (let ((f21 (get self21 1))) (let ((self22 f15)) (case (get self22 0) ('Maybe.none ($Parser.Reply.error f21)) ('Maybe.some (let ((f22 (get self22 1))) ($Parser.Reply.error ($Parser.Error.combine f22 f21)))))))) ('Parser.Reply.value (let ((f21 (get self21 1))) (let ((f22 (get self21 2))) (let ((self23 f21)) (case (get self23 0) ('Parser.State.new (let ((f23 (get self23 1))) (let ((f24 (get self23 2))) (let ((f25 (get self23 3))) (let ((f26 (get self23 4))) (let ((f27 (get self23 5))) (let ((reply.pst$28 ($Parser.State.new ($Parser.Error.maybe_combine f15 f23) f24 f25 f26 f27))) (let ((self29 reply.pst$28)) (case (get self29 0) ('Parser.State.new (let ((f29 (get self29 1))) (let ((f30 (get self29 2))) (let ((f31 (get self29 3))) (let ((f32 (get self29 4))) (let ((f33 (get self29 5))) (let ((reply$34 (Kind.Parser.spaces reply.pst$28))) (let ((self35 reply$34)) (case (get self35 0) ('Parser.Reply.error (let ((f35 (get self35 1))) (let ((self36 f29)) (case (get self36 0) ('Maybe.none ($Parser.Reply.error f35)) ('Maybe.some (let ((f36 (get self36 1))) ($Parser.Reply.error ($Parser.Error.combine f36 f35)))))))) ('Parser.Reply.value (let ((f35 (get self35 1))) (let ((f36 (get self35 2))) (let ((self37 f35)) (case (get self37 0) ('Parser.State.new (let ((f37 (get self37 1))) (let ((f38 (get self37 2))) (let ((f39 (get self37 3))) (let ((f40 (get self37 4))) (let ((f41 (get self37 5))) (let ((reply.pst$42 ($Parser.State.new ($Parser.Error.maybe_combine f29 f37) f38 f39 f40 f41))) (let ((self43 reply.pst$42)) (case (get self43 0) ('Parser.State.new (let ((f43 (get self43 1))) (let ((f44 (get self43 2))) (let ((f45 (get self43 3))) (let ((f46 (get self43 4))) (let ((f47 (get self43 5))) (let ((reply$48 (($Parser.until (Kind.Parser.text ">") Kind.Parser.dom.prop) reply.pst$42))) (let ((self49 reply$48)) (case (get self49 0) ('Parser.Reply.error (let ((f49 (get self49 1))) (let ((self50 f43)) (case (get self50 0) ('Maybe.none ($Parser.Reply.error f49)) ('Maybe.some (let ((f50 (get self50 1))) ($Parser.Reply.error ($Parser.Error.combine f50 f49)))))))) ('Parser.Reply.value (let ((f49 (get self49 1))) (let ((f50 (get self49 2))) (let ((self51 f49)) (case (get self51 0) ('Parser.State.new (let ((f51 (get self51 1))) (let ((f52 (get self51 2))) (let ((f53 (get self51 3))) (let ((f54 (get self51 4))) (let ((f55 (get self51 5))) (let ((reply.pst$56 ($Parser.State.new ($Parser.Error.maybe_combine f43 f51) f52 f53 f54 f55))) (let ((props$57 ($Kind.Parser.dom.gen_prop f50))) (let ((self58 reply.pst$56)) (case (get self58 0) ('Parser.State.new (let ((f58 (get self58 1))) (let ((f59 (get self58 2))) (let ((f60 (get self58 3))) (let ((f61 (get self58 4))) (let ((f62 (get self58 5))) (let ((reply$63 (($Parser.many (Parser.choice ($List.cons Kind.Parser.dom.node ($List.cons Kind.Parser.dom.leaf List.nil)))) reply.pst$56))) (let ((self64 reply$63)) (case (get self64 0) ('Parser.Reply.error (let ((f64 (get self64 1))) (let ((self65 f58)) (case (get self65 0) ('Maybe.none ($Parser.Reply.error f64)) ('Maybe.some (let ((f65 (get self65 1))) ($Parser.Reply.error ($Parser.Error.combine f65 f64)))))))) ('Parser.Reply.value (let ((f64 (get self64 1))) (let ((f65 (get self64 2))) (let ((self66 f64)) (case (get self66 0) ('Parser.State.new (let ((f66 (get self66 1))) (let ((f67 (get self66 2))) (let ((f68 (get self66 3))) (let ((f69 (get self66 4))) (let ((f70 (get self66 5))) (let ((reply.pst$71 ($Parser.State.new ($Parser.Error.maybe_combine f58 f66) f67 f68 f69 f70))) (let ((children$72 ($Kind.Parser.dom.transform_children f65))) (let ((self73 reply.pst$71)) (case (get self73 0) ('Parser.State.new (let ((f73 (get self73 1))) (let ((f74 (get self73 2))) (let ((f75 (get self73 3))) (let ((f76 (get self73 4))) (let ((f77 (get self73 5))) (let ((reply$78 ($Kind.Parser.text ($String.concat "</" ($String.concat f22 ">")) reply.pst$71))) (let ((self79 reply$78)) (case (get self79 0) ('Parser.Reply.error (let ((f79 (get self79 1))) (let ((self80 f73)) (case (get self80 0) ('Maybe.none ($Parser.Reply.error f79)) ('Maybe.some (let ((f80 (get self80 1))) ($Parser.Reply.error ($Parser.Error.combine f80 f79)))))))) ('Parser.Reply.value (let ((f79 (get self79 1))) (let ((f80 (get self79 2))) (let ((self81 f79)) (case (get self81 0) ('Parser.State.new (let ((f81 (get self81 1))) (let ((f82 (get self81 2))) (let ((f83 (get self81 3))) (let ((f84 (get self81 4))) (let ((f85 (get self81 5))) (let ((reply.pst$86 ($Parser.State.new ($Parser.Error.maybe_combine f73 f81) f82 f83 f84 f85))) (let ((term$87 ($Kind.Term.ref "DOM.node"))) (let ((term$88 ($Kind.Term.app term$87 ($Kind.Term.str f22)))) (let ((term$89 ($Kind.Term.app term$88 (let ((self89 props$57)) (case (get self89 0) ('Pair.new (let ((f89 (get self89 1))) (let ((f90 (get self89 2))) f89)))))))) (let ((term$90 ($Kind.Term.app term$89 (let ((self90 props$57)) (case (get self90 0) ('Pair.new (let ((f90 (get self90 1))) (let ((f91 (get self90 2))) f91)))))))) (let ((term$91 ($Kind.Term.app term$90 children$72))) ($Parser.Reply.value reply.pst$86 term$91)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.dom Kind.Parser.dom.node)
(define Kind.Parser.forall ((Kind.Parser.block "forall") (lambda (pst$0) (let ((self1 pst$0)) (case (get self1 0) ('Parser.State.new (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((reply$6 ($Kind.Parser.name pst$0))) (let ((self7 reply$6)) (case (get self7 0) ('Parser.Reply.error (let ((f7 (get self7 1))) (let ((self8 f1)) (case (get self8 0) ('Maybe.none ($Parser.Reply.error f7)) ('Maybe.some (let ((f8 (get self8 1))) ($Parser.Reply.error ($Parser.Error.combine f8 f7)))))))) ('Parser.Reply.value (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((self9 f7)) (case (get self9 0) ('Parser.State.new (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) (let ((reply.pst$14 ($Parser.State.new ($Parser.Error.maybe_combine f1 f9) f10 f11 f12 f13))) (let ((self15 reply.pst$14)) (case (get self15 0) ('Parser.State.new (let ((f15 (get self15 1))) (let ((f16 (get self15 2))) (let ((f17 (get self15 3))) (let ((f18 (get self15 4))) (let ((f19 (get self15 5))) (let ((reply$20 ($Kind.Parser.binder ":" reply.pst$14))) (let ((self21 reply$20)) (case (get self21 0) ('Parser.Reply.error (let ((f21 (get self21 1))) (let ((self22 f15)) (case (get self22 0) ('Maybe.none ($Parser.Reply.error f21)) ('Maybe.some (let ((f22 (get self22 1))) ($Parser.Reply.error ($Parser.Error.combine f22 f21)))))))) ('Parser.Reply.value (let ((f21 (get self21 1))) (let ((f22 (get self21 2))) (let ((self23 f21)) (case (get self23 0) ('Parser.State.new (let ((f23 (get self23 1))) (let ((f24 (get self23 2))) (let ((f25 (get self23 3))) (let ((f26 (get self23 4))) (let ((f27 (get self23 5))) (let ((reply.pst$28 ($Parser.State.new ($Parser.Error.maybe_combine f15 f23) f24 f25 f26 f27))) (let ((self29 reply.pst$28)) (case (get self29 0) ('Parser.State.new (let ((f29 (get self29 1))) (let ((f30 (get self29 2))) (let ((f31 (get self29 3))) (let ((f32 (get self29 4))) (let ((f33 (get self29 5))) (let ((reply$34 ($Parser.maybe (Kind.Parser.text "->") reply.pst$28))) (let ((self35 reply$34)) (case (get self35 0) ('Parser.Reply.error (let ((f35 (get self35 1))) (let ((self36 f29)) (case (get self36 0) ('Maybe.none ($Parser.Reply.error f35)) ('Maybe.some (let ((f36 (get self36 1))) ($Parser.Reply.error ($Parser.Error.combine f36 f35)))))))) ('Parser.Reply.value (let ((f35 (get self35 1))) (let ((f36 (get self35 2))) (let ((self37 f35)) (case (get self37 0) ('Parser.State.new (let ((f37 (get self37 1))) (let ((f38 (get self37 2))) (let ((f39 (get self37 3))) (let ((f40 (get self37 4))) (let ((f41 (get self37 5))) (let ((reply.pst$42 ($Parser.State.new ($Parser.Error.maybe_combine f29 f37) f38 f39 f40 f41))) (let ((self43 reply.pst$42)) (case (get self43 0) ('Parser.State.new (let ((f43 (get self43 1))) (let ((f44 (get self43 2))) (let ((f45 (get self43 3))) (let ((f46 (get self43 4))) (let ((f47 (get self43 5))) (let ((reply$48 (Kind.Parser.term reply.pst$42))) (let ((self49 reply$48)) (case (get self49 0) ('Parser.Reply.error (let ((f49 (get self49 1))) (let ((self50 f43)) (case (get self50 0) ('Maybe.none ($Parser.Reply.error f49)) ('Maybe.some (let ((f50 (get self50 1))) ($Parser.Reply.error ($Parser.Error.combine f50 f49)))))))) ('Parser.Reply.value (let ((f49 (get self49 1))) (let ((f50 (get self49 2))) (let ((self51 f49)) (case (get self51 0) ('Parser.State.new (let ((f51 (get self51 1))) (let ((f52 (get self51 2))) (let ((f53 (get self51 3))) (let ((f54 (get self51 4))) (let ((f55 (get self51 5))) (let ((reply.pst$56 ($Parser.State.new ($Parser.Error.maybe_combine f43 f51) f52 f53 f54 f55))) (let ((term$57 ($List.fold f22 f50 (lambda (x$57) (lambda (t$58) (let ((self59 x$57)) (case (get self59 0) ('Kind.Binder.new (let ((f59 (get self59 1))) (let ((f60 (get self59 2))) (let ((f61 (get self59 3))) ($Kind.Term.all f59 "" f60 f61 (lambda (s$62) (lambda (x$63) t$58)))))))))))))) ($Parser.Reply.value reply.pst$56 (let ((self58 term$57)) (case (get self58 0) ('Kind.Term.var (let ((f58 (get self58 1))) (let ((f59 (get self58 2))) term$57))) ('Kind.Term.ref (let ((f58 (get self58 1))) term$57)) ('Kind.Term.typ term$57) ('Kind.Term.all (let ((f58 (get self58 1))) (let ((f59 (get self58 2))) (let ((f60 (get self58 3))) (let ((f61 (get self58 4))) (let ((f62 (get self58 5))) ($Kind.Term.all f58 f8 f60 f61 f62))))))) ('Kind.Term.lam (let ((f58 (get self58 1))) (let ((f59 (get self58 2))) term$57))) ('Kind.Term.app (let ((f58 (get self58 1))) (let ((f59 (get self58 2))) term$57))) ('Kind.Term.let (let ((f58 (get self58 1))) (let ((f59 (get self58 2))) (let ((f60 (get self58 3))) term$57)))) ('Kind.Term.def (let ((f58 (get self58 1))) (let ((f59 (get self58 2))) (let ((f60 (get self58 3))) term$57)))) ('Kind.Term.ann (let ((f58 (get self58 1))) (let ((f59 (get self58 2))) (let ((f60 (get self58 3))) term$57)))) ('Kind.Term.gol (let ((f58 (get self58 1))) (let ((f59 (get self58 2))) (let ((f60 (get self58 3))) term$57)))) ('Kind.Term.hol (let ((f58 (get self58 1))) term$57)) ('Kind.Term.nat (let ((f58 (get self58 1))) term$57)) ('Kind.Term.chr (let ((f58 (get self58 1))) term$57)) ('Kind.Term.str (let ((f58 (get self58 1))) term$57)) ('Kind.Term.num (let ((f58 (get self58 1))) (let ((f59 (get self58 2))) (let ((f60 (get self58 3))) term$57)))) ('Kind.Term.cse (let ((f58 (get self58 1))) (let ((f59 (get self58 2))) (let ((f60 (get self58 3))) (let ((f61 (get self58 4))) (let ((f62 (get self58 5))) (let ((f63 (get self58 6))) term$57))))))) ('Kind.Term.new (let ((f58 (get self58 1))) term$57)) ('Kind.Term.get (let ((f58 (get self58 1))) (let ((f59 (get self58 2))) term$57))) ('Kind.Term.set (let ((f58 (get self58 1))) (let ((f59 (get self58 2))) (let ((f60 (get self58 3))) term$57)))) ('Kind.Term.ope (let ((f58 (get self58 1))) (let ((f59 (get self58 2))) (let ((f60 (get self58 3))) term$57)))) ('Kind.Term.ori (let ((f58 (get self58 1))) (let ((f59 (get self58 2))) term$57))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(define ($Parser.wrap opens$1 parse$2 close$3 pst$4) (let ((self0 pst$4)) (case (get self0 0) ('Parser.State.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((reply$10 (opens$1 pst$4))) (let ((self6 reply$10)) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))) (let ((self7 f0)) (case (get self7 0) ('Maybe.none ($Parser.Reply.error f6)) ('Maybe.some (let ((f7 (get self7 1))) ($Parser.Reply.error ($Parser.Error.combine f7 f6)))))))) ('Parser.Reply.value (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((self8 f6)) (case (get self8 0) ('Parser.State.new (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) (let ((f11 (get self8 4))) (let ((f12 (get self8 5))) (let ((reply.pst$18 ($Parser.State.new ($Parser.Error.maybe_combine f0 f8) f9 f10 f11 f12))) (($Parser.until close$3 parse$2) reply.pst$18)))))))))))))))))))))))))
(define Parser.wrap (lambda (opens$1) (lambda (parse$2) (lambda (close$3) (lambda (pst$4) ($Parser.wrap opens$1 parse$2 close$3 pst$4))))))
(define ($Kind.Parser.items ini$1 parser$2 end$3) (((Parser.wrap (Kind.Parser.text ini$1)) (lambda (pst$4) (let ((self1 pst$4)) (case (get self1 0) ('Parser.State.new (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((reply$10 (Kind.Parser.spaces pst$4))) (let ((self7 reply$10)) (case (get self7 0) ('Parser.Reply.error (let ((f7 (get self7 1))) (let ((self8 f1)) (case (get self8 0) ('Maybe.none ($Parser.Reply.error f7)) ('Maybe.some (let ((f8 (get self8 1))) ($Parser.Reply.error ($Parser.Error.combine f8 f7)))))))) ('Parser.Reply.value (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((self9 f7)) (case (get self9 0) ('Parser.State.new (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) (let ((reply.pst$18 ($Parser.State.new ($Parser.Error.maybe_combine f1 f9) f10 f11 f12 f13))) (let ((self15 reply.pst$18)) (case (get self15 0) ('Parser.State.new (let ((f15 (get self15 1))) (let ((f16 (get self15 2))) (let ((f17 (get self15 3))) (let ((f18 (get self15 4))) (let ((f19 (get self15 5))) (let ((reply$24 (parser$2 reply.pst$18))) (let ((self21 reply$24)) (case (get self21 0) ('Parser.Reply.error (let ((f21 (get self21 1))) (let ((self22 f15)) (case (get self22 0) ('Maybe.none ($Parser.Reply.error f21)) ('Maybe.some (let ((f22 (get self22 1))) ($Parser.Reply.error ($Parser.Error.combine f22 f21)))))))) ('Parser.Reply.value (let ((f21 (get self21 1))) (let ((f22 (get self21 2))) (let ((self23 f21)) (case (get self23 0) ('Parser.State.new (let ((f23 (get self23 1))) (let ((f24 (get self23 2))) (let ((f25 (get self23 3))) (let ((f26 (get self23 4))) (let ((f27 (get self23 5))) (let ((reply.pst$32 ($Parser.State.new ($Parser.Error.maybe_combine f15 f23) f24 f25 f26 f27))) (let ((self29 reply.pst$32)) (case (get self29 0) ('Parser.State.new (let ((f29 (get self29 1))) (let ((f30 (get self29 2))) (let ((f31 (get self29 3))) (let ((f32 (get self29 4))) (let ((f33 (get self29 5))) (let ((reply$38 ($Parser.maybe (Kind.Parser.text ",") reply.pst$32))) (let ((self35 reply$38)) (case (get self35 0) ('Parser.Reply.error (let ((f35 (get self35 1))) (let ((self36 f29)) (case (get self36 0) ('Maybe.none ($Parser.Reply.error f35)) ('Maybe.some (let ((f36 (get self36 1))) ($Parser.Reply.error ($Parser.Error.combine f36 f35)))))))) ('Parser.Reply.value (let ((f35 (get self35 1))) (let ((f36 (get self35 2))) (let ((self37 f35)) (case (get self37 0) ('Parser.State.new (let ((f37 (get self37 1))) (let ((f38 (get self37 2))) (let ((f39 (get self37 3))) (let ((f40 (get self37 4))) (let ((f41 (get self37 5))) (let ((reply.pst$46 ($Parser.State.new ($Parser.Error.maybe_combine f29 f37) f38 f39 f40 f41))) ($Parser.Reply.value reply.pst$46 f22)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) (Kind.Parser.text end$3)))
(define Kind.Parser.items (lambda (ini$1) (lambda (parser$2) (lambda (end$3) ($Kind.Parser.items ini$1 parser$2 end$3)))))
(define ($Parser.try parse$1 pst$2) (let ((self0 (parse$1 pst$2))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))) ($Parser.Reply.value pst$2 Bool.false))) ('Parser.Reply.value (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($Parser.Reply.value pst$2 Bool.true)))))))
(define Parser.try (lambda (parse$1) (lambda (pst$2) ($Parser.try parse$1 pst$2))))
(define ($Parser.avoiding test$1 parse$2 pst$3) (let ((self0 pst$3)) (case (get self0 0) ('Parser.State.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((reply$9 ($Parser.try test$1 pst$3))) (let ((self6 reply$9)) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))) (let ((self7 f0)) (case (get self7 0) ('Maybe.none ($Parser.Reply.error f6)) ('Maybe.some (let ((f7 (get self7 1))) ($Parser.Reply.error ($Parser.Error.combine f7 f6)))))))) ('Parser.Reply.value (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((self8 f6)) (case (get self8 0) ('Parser.State.new (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) (let ((f11 (get self8 4))) (let ((f12 (get self8 5))) (let ((reply.pst$17 ($Parser.State.new ($Parser.Error.maybe_combine f0 f8) f9 f10 f11 f12))) ((let ((self14 f7)) (case self14 (#t (Parser.fail "Avoided.")) (#f parse$2))) reply.pst$17)))))))))))))))))))))))))
(define Parser.avoiding (lambda (test$1) (lambda (parse$2) (lambda (pst$3) ($Parser.avoiding test$1 parse$2 pst$3)))))
(define ($Kind.Parser.text_now text$0) (Parser.text text$0))
(define Kind.Parser.text_now (lambda (text$0) ($Kind.Parser.text_now text$0)))
(define ($Kind.Parser.lambda.make names$0 body$1) (let ((self0 names$0)) (case (get self0 0) ('List.nil body$1) ('List.cons (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($Kind.Term.lam f0 (lambda (x$4) ($Kind.Parser.lambda.make f1 body$1)))))))))
(define Kind.Parser.lambda.make (lambda (names$0) (lambda (body$1) ($Kind.Parser.lambda.make names$0 body$1))))
(define ($Kind.Parser.lambda.make.start names$0 body$1) (let ((self0 names$0)) (case (get self0 0) ('List.nil ($Kind.Term.lam "" (lambda (x$2) body$1))) ('List.cons (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($Kind.Parser.lambda.make names$0 body$1)))))))
(define Kind.Parser.lambda.make.start (lambda (names$0) (lambda (body$1) ($Kind.Parser.lambda.make.start names$0 body$1))))
(define Kind.Parser.lambda ((Kind.Parser.block "lambda") (lambda (pst$0) (let ((self1 pst$0)) (case (get self1 0) ('Parser.State.new (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((reply$6 (($Kind.Parser.items "(" Kind.Parser.name1 ")") pst$0))) (let ((self7 reply$6)) (case (get self7 0) ('Parser.Reply.error (let ((f7 (get self7 1))) (let ((self8 f1)) (case (get self8 0) ('Maybe.none ($Parser.Reply.error f7)) ('Maybe.some (let ((f8 (get self8 1))) ($Parser.Reply.error ($Parser.Error.combine f8 f7)))))))) ('Parser.Reply.value (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((self9 f7)) (case (get self9 0) ('Parser.State.new (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) (let ((reply.pst$14 ($Parser.State.new ($Parser.Error.maybe_combine f1 f9) f10 f11 f12 f13))) (let ((self15 reply.pst$14)) (case (get self15 0) ('Parser.State.new (let ((f15 (get self15 1))) (let ((f16 (get self15 2))) (let ((f17 (get self15 3))) (let ((f18 (get self15 4))) (let ((f19 (get self15 5))) (let ((reply$20 ($Parser.avoiding ($Kind.Parser.text_now "(") Kind.Parser.term reply.pst$14))) (let ((self21 reply$20)) (case (get self21 0) ('Parser.Reply.error (let ((f21 (get self21 1))) (let ((self22 f15)) (case (get self22 0) ('Maybe.none ($Parser.Reply.error f21)) ('Maybe.some (let ((f22 (get self22 1))) ($Parser.Reply.error ($Parser.Error.combine f22 f21)))))))) ('Parser.Reply.value (let ((f21 (get self21 1))) (let ((f22 (get self21 2))) (let ((self23 f21)) (case (get self23 0) ('Parser.State.new (let ((f23 (get self23 1))) (let ((f24 (get self23 2))) (let ((f25 (get self23 3))) (let ((f26 (get self23 4))) (let ((f27 (get self23 5))) (let ((reply.pst$28 ($Parser.State.new ($Parser.Error.maybe_combine f15 f23) f24 f25 f26 f27))) ($Parser.Reply.value reply.pst$28 ($Kind.Parser.lambda.make.start f8 f22)))))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.lambda.erased ((Kind.Parser.block "lambda") (lambda (pst$0) (let ((self1 pst$0)) (case (get self1 0) ('Parser.State.new (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((reply$6 (($Kind.Parser.items "<" Kind.Parser.name1 ">") pst$0))) (let ((self7 reply$6)) (case (get self7 0) ('Parser.Reply.error (let ((f7 (get self7 1))) (let ((self8 f1)) (case (get self8 0) ('Maybe.none ($Parser.Reply.error f7)) ('Maybe.some (let ((f8 (get self8 1))) ($Parser.Reply.error ($Parser.Error.combine f8 f7)))))))) ('Parser.Reply.value (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((self9 f7)) (case (get self9 0) ('Parser.State.new (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) (let ((reply.pst$14 ($Parser.State.new ($Parser.Error.maybe_combine f1 f9) f10 f11 f12 f13))) (let ((self15 reply.pst$14)) (case (get self15 0) ('Parser.State.new (let ((f15 (get self15 1))) (let ((f16 (get self15 2))) (let ((f17 (get self15 3))) (let ((f18 (get self15 4))) (let ((f19 (get self15 5))) (let ((reply$20 (Kind.Parser.term reply.pst$14))) (let ((self21 reply$20)) (case (get self21 0) ('Parser.Reply.error (let ((f21 (get self21 1))) (let ((self22 f15)) (case (get self22 0) ('Maybe.none ($Parser.Reply.error f21)) ('Maybe.some (let ((f22 (get self22 1))) ($Parser.Reply.error ($Parser.Error.combine f22 f21)))))))) ('Parser.Reply.value (let ((f21 (get self21 1))) (let ((f22 (get self21 2))) (let ((self23 f21)) (case (get self23 0) ('Parser.State.new (let ((f23 (get self23 1))) (let ((f24 (get self23 2))) (let ((f25 (get self23 3))) (let ((f26 (get self23 4))) (let ((f27 (get self23 5))) (let ((reply.pst$28 ($Parser.State.new ($Parser.Error.maybe_combine f15 f23) f24 f25 f26 f27))) ($Parser.Reply.value reply.pst$28 ($Kind.Parser.lambda.make.start f8 f22)))))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.parenthesis ((Kind.Parser.block "parenthesis") (lambda (pst$0) (let ((self1 pst$0)) (case (get self1 0) ('Parser.State.new (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((reply$6 ($Kind.Parser.text "(" pst$0))) (let ((self7 reply$6)) (case (get self7 0) ('Parser.Reply.error (let ((f7 (get self7 1))) (let ((self8 f1)) (case (get self8 0) ('Maybe.none ($Parser.Reply.error f7)) ('Maybe.some (let ((f8 (get self8 1))) ($Parser.Reply.error ($Parser.Error.combine f8 f7)))))))) ('Parser.Reply.value (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((self9 f7)) (case (get self9 0) ('Parser.State.new (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) (let ((reply.pst$14 ($Parser.State.new ($Parser.Error.maybe_combine f1 f9) f10 f11 f12 f13))) (let ((self15 reply.pst$14)) (case (get self15 0) ('Parser.State.new (let ((f15 (get self15 1))) (let ((f16 (get self15 2))) (let ((f17 (get self15 3))) (let ((f18 (get self15 4))) (let ((f19 (get self15 5))) (let ((reply$20 (Kind.Parser.term reply.pst$14))) (let ((self21 reply$20)) (case (get self21 0) ('Parser.Reply.error (let ((f21 (get self21 1))) (let ((self22 f15)) (case (get self22 0) ('Maybe.none ($Parser.Reply.error f21)) ('Maybe.some (let ((f22 (get self22 1))) ($Parser.Reply.error ($Parser.Error.combine f22 f21)))))))) ('Parser.Reply.value (let ((f21 (get self21 1))) (let ((f22 (get self21 2))) (let ((self23 f21)) (case (get self23 0) ('Parser.State.new (let ((f23 (get self23 1))) (let ((f24 (get self23 2))) (let ((f25 (get self23 3))) (let ((f26 (get self23 4))) (let ((f27 (get self23 5))) (let ((reply.pst$28 ($Parser.State.new ($Parser.Error.maybe_combine f15 f23) f24 f25 f26 f27))) (let ((self29 reply.pst$28)) (case (get self29 0) ('Parser.State.new (let ((f29 (get self29 1))) (let ((f30 (get self29 2))) (let ((f31 (get self29 3))) (let ((f32 (get self29 4))) (let ((f33 (get self29 5))) (let ((reply$34 ($Kind.Parser.text ")" reply.pst$28))) (let ((self35 reply$34)) (case (get self35 0) ('Parser.Reply.error (let ((f35 (get self35 1))) (let ((self36 f29)) (case (get self36 0) ('Maybe.none ($Parser.Reply.error f35)) ('Maybe.some (let ((f36 (get self36 1))) ($Parser.Reply.error ($Parser.Error.combine f36 f35)))))))) ('Parser.Reply.value (let ((f35 (get self35 1))) (let ((f36 (get self35 2))) (let ((self37 f35)) (case (get self37 0) ('Parser.State.new (let ((f37 (get self37 1))) (let ((f38 (get self37 2))) (let ((f39 (get self37 3))) (let ((f40 (get self37 4))) (let ((f41 (get self37 5))) (let ((reply.pst$42 ($Parser.State.new ($Parser.Error.maybe_combine f29 f37) f38 f39 f40 f41))) ($Parser.Reply.value reply.pst$42 f22)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(define ($Kind.Parser.letforrange typename$0 body$1) ((Kind.Parser.block "let-for") (lambda (pst$2) (let ((self1 pst$2)) (case (get self1 0) ('Parser.State.new (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((reply$8 ($Kind.Parser.text "let " pst$2))) (let ((self7 reply$8)) (case (get self7 0) ('Parser.Reply.error (let ((f7 (get self7 1))) (let ((self8 f1)) (case (get self8 0) ('Maybe.none ($Parser.Reply.error f7)) ('Maybe.some (let ((f8 (get self8 1))) ($Parser.Reply.error ($Parser.Error.combine f8 f7)))))))) ('Parser.Reply.value (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((self9 f7)) (case (get self9 0) ('Parser.State.new (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) (let ((reply.pst$16 ($Parser.State.new ($Parser.Error.maybe_combine f1 f9) f10 f11 f12 f13))) (let ((self15 reply.pst$16)) (case (get self15 0) ('Parser.State.new (let ((f15 (get self15 1))) (let ((f16 (get self15 2))) (let ((f17 (get self15 3))) (let ((f18 (get self15 4))) (let ((f19 (get self15 5))) (let ((reply$22 ($Kind.Parser.name1 reply.pst$16))) (let ((self21 reply$22)) (case (get self21 0) ('Parser.Reply.error (let ((f21 (get self21 1))) (let ((self22 f15)) (case (get self22 0) ('Maybe.none ($Parser.Reply.error f21)) ('Maybe.some (let ((f22 (get self22 1))) ($Parser.Reply.error ($Parser.Error.combine f22 f21)))))))) ('Parser.Reply.value (let ((f21 (get self21 1))) (let ((f22 (get self21 2))) (let ((self23 f21)) (case (get self23 0) ('Parser.State.new (let ((f23 (get self23 1))) (let ((f24 (get self23 2))) (let ((f25 (get self23 3))) (let ((f26 (get self23 4))) (let ((f27 (get self23 5))) (let ((reply.pst$30 ($Parser.State.new ($Parser.Error.maybe_combine f15 f23) f24 f25 f26 f27))) (let ((self29 reply.pst$30)) (case (get self29 0) ('Parser.State.new (let ((f29 (get self29 1))) (let ((f30 (get self29 2))) (let ((f31 (get self29 3))) (let ((f32 (get self29 4))) (let ((f33 (get self29 5))) (let ((reply$36 ($Kind.Parser.text "=" reply.pst$30))) (let ((self35 reply$36)) (case (get self35 0) ('Parser.Reply.error (let ((f35 (get self35 1))) (let ((self36 f29)) (case (get self36 0) ('Maybe.none ($Parser.Reply.error f35)) ('Maybe.some (let ((f36 (get self36 1))) ($Parser.Reply.error ($Parser.Error.combine f36 f35)))))))) ('Parser.Reply.value (let ((f35 (get self35 1))) (let ((f36 (get self35 2))) (let ((self37 f35)) (case (get self37 0) ('Parser.State.new (let ((f37 (get self37 1))) (let ((f38 (get self37 2))) (let ((f39 (get self37 3))) (let ((f40 (get self37 4))) (let ((f41 (get self37 5))) (let ((reply.pst$44 ($Parser.State.new ($Parser.Error.maybe_combine f29 f37) f38 f39 f40 f41))) (let ((self43 reply.pst$44)) (case (get self43 0) ('Parser.State.new (let ((f43 (get self43 1))) (let ((f44 (get self43 2))) (let ((f45 (get self43 3))) (let ((f46 (get self43 4))) (let ((f47 (get self43 5))) (let ((reply$50 ($Kind.Parser.text "for " reply.pst$44))) (let ((self49 reply$50)) (case (get self49 0) ('Parser.Reply.error (let ((f49 (get self49 1))) (let ((self50 f43)) (case (get self50 0) ('Maybe.none ($Parser.Reply.error f49)) ('Maybe.some (let ((f50 (get self50 1))) ($Parser.Reply.error ($Parser.Error.combine f50 f49)))))))) ('Parser.Reply.value (let ((f49 (get self49 1))) (let ((f50 (get self49 2))) (let ((self51 f49)) (case (get self51 0) ('Parser.State.new (let ((f51 (get self51 1))) (let ((f52 (get self51 2))) (let ((f53 (get self51 3))) (let ((f54 (get self51 4))) (let ((f55 (get self51 5))) (let ((reply.pst$58 ($Parser.State.new ($Parser.Error.maybe_combine f43 f51) f52 f53 f54 f55))) (let ((self57 reply.pst$58)) (case (get self57 0) ('Parser.State.new (let ((f57 (get self57 1))) (let ((f58 (get self57 2))) (let ((f59 (get self57 3))) (let ((f60 (get self57 4))) (let ((f61 (get self57 5))) (let ((reply$64 ($Kind.Parser.name1 reply.pst$58))) (let ((self63 reply$64)) (case (get self63 0) ('Parser.Reply.error (let ((f63 (get self63 1))) (let ((self64 f57)) (case (get self64 0) ('Maybe.none ($Parser.Reply.error f63)) ('Maybe.some (let ((f64 (get self64 1))) ($Parser.Reply.error ($Parser.Error.combine f64 f63)))))))) ('Parser.Reply.value (let ((f63 (get self63 1))) (let ((f64 (get self63 2))) (let ((self65 f63)) (case (get self65 0) ('Parser.State.new (let ((f65 (get self65 1))) (let ((f66 (get self65 2))) (let ((f67 (get self65 3))) (let ((f68 (get self65 4))) (let ((f69 (get self65 5))) (let ((reply.pst$72 ($Parser.State.new ($Parser.Error.maybe_combine f57 f65) f66 f67 f68 f69))) (let ((self71 reply.pst$72)) (case (get self71 0) ('Parser.State.new (let ((f71 (get self71 1))) (let ((f72 (get self71 2))) (let ((f73 (get self71 3))) (let ((f74 (get self71 4))) (let ((f75 (get self71 5))) (let ((reply$78 ($Kind.Parser.text ":" reply.pst$72))) (let ((self77 reply$78)) (case (get self77 0) ('Parser.Reply.error (let ((f77 (get self77 1))) (let ((self78 f71)) (case (get self78 0) ('Maybe.none ($Parser.Reply.error f77)) ('Maybe.some (let ((f78 (get self78 1))) ($Parser.Reply.error ($Parser.Error.combine f78 f77)))))))) ('Parser.Reply.value (let ((f77 (get self77 1))) (let ((f78 (get self77 2))) (let ((self79 f77)) (case (get self79 0) ('Parser.State.new (let ((f79 (get self79 1))) (let ((f80 (get self79 2))) (let ((f81 (get self79 3))) (let ((f82 (get self79 4))) (let ((f83 (get self79 5))) (let ((reply.pst$86 ($Parser.State.new ($Parser.Error.maybe_combine f71 f79) f80 f81 f82 f83))) (let ((self85 reply.pst$86)) (case (get self85 0) ('Parser.State.new (let ((f85 (get self85 1))) (let ((f86 (get self85 2))) (let ((f87 (get self85 3))) (let ((f88 (get self85 4))) (let ((f89 (get self85 5))) (let ((reply$92 ($Kind.Parser.text typename$0 reply.pst$86))) (let ((self91 reply$92)) (case (get self91 0) ('Parser.Reply.error (let ((f91 (get self91 1))) (let ((self92 f85)) (case (get self92 0) ('Maybe.none ($Parser.Reply.error f91)) ('Maybe.some (let ((f92 (get self92 1))) ($Parser.Reply.error ($Parser.Error.combine f92 f91)))))))) ('Parser.Reply.value (let ((f91 (get self91 1))) (let ((f92 (get self91 2))) (let ((self93 f91)) (case (get self93 0) ('Parser.State.new (let ((f93 (get self93 1))) (let ((f94 (get self93 2))) (let ((f95 (get self93 3))) (let ((f96 (get self93 4))) (let ((f97 (get self93 5))) (let ((reply.pst$100 ($Parser.State.new ($Parser.Error.maybe_combine f85 f93) f94 f95 f96 f97))) (let ((self99 reply.pst$100)) (case (get self99 0) ('Parser.State.new (let ((f99 (get self99 1))) (let ((f100 (get self99 2))) (let ((f101 (get self99 3))) (let ((f102 (get self99 4))) (let ((f103 (get self99 5))) (let ((reply$106 ($Kind.Parser.text "from" reply.pst$100))) (let ((self105 reply$106)) (case (get self105 0) ('Parser.Reply.error (let ((f105 (get self105 1))) (let ((self106 f99)) (case (get self106 0) ('Maybe.none ($Parser.Reply.error f105)) ('Maybe.some (let ((f106 (get self106 1))) ($Parser.Reply.error ($Parser.Error.combine f106 f105)))))))) ('Parser.Reply.value (let ((f105 (get self105 1))) (let ((f106 (get self105 2))) (let ((self107 f105)) (case (get self107 0) ('Parser.State.new (let ((f107 (get self107 1))) (let ((f108 (get self107 2))) (let ((f109 (get self107 3))) (let ((f110 (get self107 4))) (let ((f111 (get self107 5))) (let ((reply.pst$114 ($Parser.State.new ($Parser.Error.maybe_combine f99 f107) f108 f109 f110 f111))) (let ((self113 reply.pst$114)) (case (get self113 0) ('Parser.State.new (let ((f113 (get self113 1))) (let ((f114 (get self113 2))) (let ((f115 (get self113 3))) (let ((f116 (get self113 4))) (let ((f117 (get self113 5))) (let ((reply$120 (Kind.Parser.term reply.pst$114))) (let ((self119 reply$120)) (case (get self119 0) ('Parser.Reply.error (let ((f119 (get self119 1))) (let ((self120 f113)) (case (get self120 0) ('Maybe.none ($Parser.Reply.error f119)) ('Maybe.some (let ((f120 (get self120 1))) ($Parser.Reply.error ($Parser.Error.combine f120 f119)))))))) ('Parser.Reply.value (let ((f119 (get self119 1))) (let ((f120 (get self119 2))) (let ((self121 f119)) (case (get self121 0) ('Parser.State.new (let ((f121 (get self121 1))) (let ((f122 (get self121 2))) (let ((f123 (get self121 3))) (let ((f124 (get self121 4))) (let ((f125 (get self121 5))) (let ((reply.pst$128 ($Parser.State.new ($Parser.Error.maybe_combine f113 f121) f122 f123 f124 f125))) (let ((self127 reply.pst$128)) (case (get self127 0) ('Parser.State.new (let ((f127 (get self127 1))) (let ((f128 (get self127 2))) (let ((f129 (get self127 3))) (let ((f130 (get self127 4))) (let ((f131 (get self127 5))) (let ((reply$134 ($Kind.Parser.text "to" reply.pst$128))) (let ((self133 reply$134)) (case (get self133 0) ('Parser.Reply.error (let ((f133 (get self133 1))) (let ((self134 f127)) (case (get self134 0) ('Maybe.none ($Parser.Reply.error f133)) ('Maybe.some (let ((f134 (get self134 1))) ($Parser.Reply.error ($Parser.Error.combine f134 f133)))))))) ('Parser.Reply.value (let ((f133 (get self133 1))) (let ((f134 (get self133 2))) (let ((self135 f133)) (case (get self135 0) ('Parser.State.new (let ((f135 (get self135 1))) (let ((f136 (get self135 2))) (let ((f137 (get self135 3))) (let ((f138 (get self135 4))) (let ((f139 (get self135 5))) (let ((reply.pst$142 ($Parser.State.new ($Parser.Error.maybe_combine f127 f135) f136 f137 f138 f139))) (let ((self141 reply.pst$142)) (case (get self141 0) ('Parser.State.new (let ((f141 (get self141 1))) (let ((f142 (get self141 2))) (let ((f143 (get self141 3))) (let ((f144 (get self141 4))) (let ((f145 (get self141 5))) (let ((reply$148 (Kind.Parser.term reply.pst$142))) (let ((self147 reply$148)) (case (get self147 0) ('Parser.Reply.error (let ((f147 (get self147 1))) (let ((self148 f141)) (case (get self148 0) ('Maybe.none ($Parser.Reply.error f147)) ('Maybe.some (let ((f148 (get self148 1))) ($Parser.Reply.error ($Parser.Error.combine f148 f147)))))))) ('Parser.Reply.value (let ((f147 (get self147 1))) (let ((f148 (get self147 2))) (let ((self149 f147)) (case (get self149 0) ('Parser.State.new (let ((f149 (get self149 1))) (let ((f150 (get self149 2))) (let ((f151 (get self149 3))) (let ((f152 (get self149 4))) (let ((f153 (get self149 5))) (let ((reply.pst$156 ($Parser.State.new ($Parser.Error.maybe_combine f141 f149) f150 f151 f152 f153))) (let ((self155 reply.pst$156)) (case (get self155 0) ('Parser.State.new (let ((f155 (get self155 1))) (let ((f156 (get self155 2))) (let ((f157 (get self155 3))) (let ((f158 (get self155 4))) (let ((f159 (get self155 5))) (let ((reply$162 ($Kind.Parser.text ":" reply.pst$156))) (let ((self161 reply$162)) (case (get self161 0) ('Parser.Reply.error (let ((f161 (get self161 1))) (let ((self162 f155)) (case (get self162 0) ('Maybe.none ($Parser.Reply.error f161)) ('Maybe.some (let ((f162 (get self162 1))) ($Parser.Reply.error ($Parser.Error.combine f162 f161)))))))) ('Parser.Reply.value (let ((f161 (get self161 1))) (let ((f162 (get self161 2))) (let ((self163 f161)) (case (get self163 0) ('Parser.State.new (let ((f163 (get self163 1))) (let ((f164 (get self163 2))) (let ((f165 (get self163 3))) (let ((f166 (get self163 4))) (let ((f167 (get self163 5))) (let ((reply.pst$170 ($Parser.State.new ($Parser.Error.maybe_combine f155 f163) f164 f165 f166 f167))) (let ((self169 reply.pst$170)) (case (get self169 0) ('Parser.State.new (let ((f169 (get self169 1))) (let ((f170 (get self169 2))) (let ((f171 (get self169 3))) (let ((f172 (get self169 4))) (let ((f173 (get self169 5))) (let ((reply$176 (Kind.Parser.term reply.pst$170))) (let ((self175 reply$176)) (case (get self175 0) ('Parser.Reply.error (let ((f175 (get self175 1))) (let ((self176 f169)) (case (get self176 0) ('Maybe.none ($Parser.Reply.error f175)) ('Maybe.some (let ((f176 (get self176 1))) ($Parser.Reply.error ($Parser.Error.combine f176 f175)))))))) ('Parser.Reply.value (let ((f175 (get self175 1))) (let ((f176 (get self175 2))) (let ((self177 f175)) (case (get self177 0) ('Parser.State.new (let ((f177 (get self177 1))) (let ((f178 (get self177 2))) (let ((f179 (get self177 3))) (let ((f180 (get self177 4))) (let ((f181 (get self177 5))) (let ((reply.pst$184 ($Parser.State.new ($Parser.Error.maybe_combine f169 f177) f178 f179 f180 f181))) (let ((self183 reply.pst$184)) (case (get self183 0) ('Parser.State.new (let ((f183 (get self183 1))) (let ((f184 (get self183 2))) (let ((f185 (get self183 3))) (let ((f186 (get self183 4))) (let ((f187 (get self183 5))) (let ((reply$190 ($Parser.maybe (Kind.Parser.text ";") reply.pst$184))) (let ((self189 reply$190)) (case (get self189 0) ('Parser.Reply.error (let ((f189 (get self189 1))) (let ((self190 f183)) (case (get self190 0) ('Maybe.none ($Parser.Reply.error f189)) ('Maybe.some (let ((f190 (get self190 1))) ($Parser.Reply.error ($Parser.Error.combine f190 f189)))))))) ('Parser.Reply.value (let ((f189 (get self189 1))) (let ((f190 (get self189 2))) (let ((self191 f189)) (case (get self191 0) ('Parser.State.new (let ((f191 (get self191 1))) (let ((f192 (get self191 2))) (let ((f193 (get self191 3))) (let ((f194 (get self191 4))) (let ((f195 (get self191 5))) (let ((reply.pst$198 ($Parser.State.new ($Parser.Error.maybe_combine f183 f191) f192 f193 f194 f195))) (let ((self197 reply.pst$198)) (case (get self197 0) ('Parser.State.new (let ((f197 (get self197 1))) (let ((f198 (get self197 2))) (let ((f199 (get self197 3))) (let ((f200 (get self197 4))) (let ((f201 (get self197 5))) (let ((reply$204 ((body$1 Unit.new) reply.pst$198))) (let ((self203 reply$204)) (case (get self203 0) ('Parser.Reply.error (let ((f203 (get self203 1))) (let ((self204 f197)) (case (get self204 0) ('Maybe.none ($Parser.Reply.error f203)) ('Maybe.some (let ((f204 (get self204 1))) ($Parser.Reply.error ($Parser.Error.combine f204 f203)))))))) ('Parser.Reply.value (let ((f203 (get self203 1))) (let ((f204 (get self203 2))) (let ((self205 f203)) (case (get self205 0) ('Parser.State.new (let ((f205 (get self205 1))) (let ((f206 (get self205 2))) (let ((f207 (get self205 3))) (let ((f208 (get self205 4))) (let ((f209 (get self205 5))) (let ((reply.pst$212 ($Parser.State.new ($Parser.Error.maybe_combine f197 f205) f206 f207 f208 f209))) (let ((term$213 ($Kind.Term.ref ($String.concat typename$0 ".for")))) (let ((term$214 ($Kind.Term.app term$213 ($Kind.Term.hol Bits.e)))) (let ((term$215 ($Kind.Term.app term$214 ($Kind.Term.ref f22)))) (let ((term$216 ($Kind.Term.app term$215 f120))) (let ((term$217 ($Kind.Term.app term$216 f148))) (let ((lamb$218 ($Kind.Term.lam f64 (lambda (e$218) ($Kind.Term.lam f22 (lambda (s$219) f176)))))) (let ((term$219 ($Kind.Term.app term$217 lamb$218))) (let ((term$220 ($Kind.Term.let f22 term$219 (lambda (x$220) f204)))) ($Parser.Reply.value reply.pst$212 term$220)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.letforrange (lambda (typename$0) (lambda (body$1) ($Kind.Parser.letforrange typename$0 body$1))))
(define ($Kind.Parser.letforrange.u32 body$0) ($Kind.Parser.letforrange "U32" body$0))
(define Kind.Parser.letforrange.u32 (lambda (body$0) ($Kind.Parser.letforrange.u32 body$0)))
(define ($Kind.Parser.letforrange.with typename$0 body$1) ((Kind.Parser.block "for") (lambda (pst$2) (let ((self1 pst$2)) (case (get self1 0) ('Parser.State.new (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((reply$8 ($Kind.Parser.text "for " pst$2))) (let ((self7 reply$8)) (case (get self7 0) ('Parser.Reply.error (let ((f7 (get self7 1))) (let ((self8 f1)) (case (get self8 0) ('Maybe.none ($Parser.Reply.error f7)) ('Maybe.some (let ((f8 (get self8 1))) ($Parser.Reply.error ($Parser.Error.combine f8 f7)))))))) ('Parser.Reply.value (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((self9 f7)) (case (get self9 0) ('Parser.State.new (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) (let ((reply.pst$16 ($Parser.State.new ($Parser.Error.maybe_combine f1 f9) f10 f11 f12 f13))) (let ((self15 reply.pst$16)) (case (get self15 0) ('Parser.State.new (let ((f15 (get self15 1))) (let ((f16 (get self15 2))) (let ((f17 (get self15 3))) (let ((f18 (get self15 4))) (let ((f19 (get self15 5))) (let ((reply$22 ($Kind.Parser.name1 reply.pst$16))) (let ((self21 reply$22)) (case (get self21 0) ('Parser.Reply.error (let ((f21 (get self21 1))) (let ((self22 f15)) (case (get self22 0) ('Maybe.none ($Parser.Reply.error f21)) ('Maybe.some (let ((f22 (get self22 1))) ($Parser.Reply.error ($Parser.Error.combine f22 f21)))))))) ('Parser.Reply.value (let ((f21 (get self21 1))) (let ((f22 (get self21 2))) (let ((self23 f21)) (case (get self23 0) ('Parser.State.new (let ((f23 (get self23 1))) (let ((f24 (get self23 2))) (let ((f25 (get self23 3))) (let ((f26 (get self23 4))) (let ((f27 (get self23 5))) (let ((reply.pst$30 ($Parser.State.new ($Parser.Error.maybe_combine f15 f23) f24 f25 f26 f27))) (let ((self29 reply.pst$30)) (case (get self29 0) ('Parser.State.new (let ((f29 (get self29 1))) (let ((f30 (get self29 2))) (let ((f31 (get self29 3))) (let ((f32 (get self29 4))) (let ((f33 (get self29 5))) (let ((reply$36 ($Kind.Parser.text ":" reply.pst$30))) (let ((self35 reply$36)) (case (get self35 0) ('Parser.Reply.error (let ((f35 (get self35 1))) (let ((self36 f29)) (case (get self36 0) ('Maybe.none ($Parser.Reply.error f35)) ('Maybe.some (let ((f36 (get self36 1))) ($Parser.Reply.error ($Parser.Error.combine f36 f35)))))))) ('Parser.Reply.value (let ((f35 (get self35 1))) (let ((f36 (get self35 2))) (let ((self37 f35)) (case (get self37 0) ('Parser.State.new (let ((f37 (get self37 1))) (let ((f38 (get self37 2))) (let ((f39 (get self37 3))) (let ((f40 (get self37 4))) (let ((f41 (get self37 5))) (let ((reply.pst$44 ($Parser.State.new ($Parser.Error.maybe_combine f29 f37) f38 f39 f40 f41))) (let ((self43 reply.pst$44)) (case (get self43 0) ('Parser.State.new (let ((f43 (get self43 1))) (let ((f44 (get self43 2))) (let ((f45 (get self43 3))) (let ((f46 (get self43 4))) (let ((f47 (get self43 5))) (let ((reply$50 ($Kind.Parser.text typename$0 reply.pst$44))) (let ((self49 reply$50)) (case (get self49 0) ('Parser.Reply.error (let ((f49 (get self49 1))) (let ((self50 f43)) (case (get self50 0) ('Maybe.none ($Parser.Reply.error f49)) ('Maybe.some (let ((f50 (get self50 1))) ($Parser.Reply.error ($Parser.Error.combine f50 f49)))))))) ('Parser.Reply.value (let ((f49 (get self49 1))) (let ((f50 (get self49 2))) (let ((self51 f49)) (case (get self51 0) ('Parser.State.new (let ((f51 (get self51 1))) (let ((f52 (get self51 2))) (let ((f53 (get self51 3))) (let ((f54 (get self51 4))) (let ((f55 (get self51 5))) (let ((reply.pst$58 ($Parser.State.new ($Parser.Error.maybe_combine f43 f51) f52 f53 f54 f55))) (let ((self57 reply.pst$58)) (case (get self57 0) ('Parser.State.new (let ((f57 (get self57 1))) (let ((f58 (get self57 2))) (let ((f59 (get self57 3))) (let ((f60 (get self57 4))) (let ((f61 (get self57 5))) (let ((reply$64 ($Kind.Parser.text "from" reply.pst$58))) (let ((self63 reply$64)) (case (get self63 0) ('Parser.Reply.error (let ((f63 (get self63 1))) (let ((self64 f57)) (case (get self64 0) ('Maybe.none ($Parser.Reply.error f63)) ('Maybe.some (let ((f64 (get self64 1))) ($Parser.Reply.error ($Parser.Error.combine f64 f63)))))))) ('Parser.Reply.value (let ((f63 (get self63 1))) (let ((f64 (get self63 2))) (let ((self65 f63)) (case (get self65 0) ('Parser.State.new (let ((f65 (get self65 1))) (let ((f66 (get self65 2))) (let ((f67 (get self65 3))) (let ((f68 (get self65 4))) (let ((f69 (get self65 5))) (let ((reply.pst$72 ($Parser.State.new ($Parser.Error.maybe_combine f57 f65) f66 f67 f68 f69))) (let ((self71 reply.pst$72)) (case (get self71 0) ('Parser.State.new (let ((f71 (get self71 1))) (let ((f72 (get self71 2))) (let ((f73 (get self71 3))) (let ((f74 (get self71 4))) (let ((f75 (get self71 5))) (let ((reply$78 (Kind.Parser.term reply.pst$72))) (let ((self77 reply$78)) (case (get self77 0) ('Parser.Reply.error (let ((f77 (get self77 1))) (let ((self78 f71)) (case (get self78 0) ('Maybe.none ($Parser.Reply.error f77)) ('Maybe.some (let ((f78 (get self78 1))) ($Parser.Reply.error ($Parser.Error.combine f78 f77)))))))) ('Parser.Reply.value (let ((f77 (get self77 1))) (let ((f78 (get self77 2))) (let ((self79 f77)) (case (get self79 0) ('Parser.State.new (let ((f79 (get self79 1))) (let ((f80 (get self79 2))) (let ((f81 (get self79 3))) (let ((f82 (get self79 4))) (let ((f83 (get self79 5))) (let ((reply.pst$86 ($Parser.State.new ($Parser.Error.maybe_combine f71 f79) f80 f81 f82 f83))) (let ((self85 reply.pst$86)) (case (get self85 0) ('Parser.State.new (let ((f85 (get self85 1))) (let ((f86 (get self85 2))) (let ((f87 (get self85 3))) (let ((f88 (get self85 4))) (let ((f89 (get self85 5))) (let ((reply$92 ($Kind.Parser.text "to" reply.pst$86))) (let ((self91 reply$92)) (case (get self91 0) ('Parser.Reply.error (let ((f91 (get self91 1))) (let ((self92 f85)) (case (get self92 0) ('Maybe.none ($Parser.Reply.error f91)) ('Maybe.some (let ((f92 (get self92 1))) ($Parser.Reply.error ($Parser.Error.combine f92 f91)))))))) ('Parser.Reply.value (let ((f91 (get self91 1))) (let ((f92 (get self91 2))) (let ((self93 f91)) (case (get self93 0) ('Parser.State.new (let ((f93 (get self93 1))) (let ((f94 (get self93 2))) (let ((f95 (get self93 3))) (let ((f96 (get self93 4))) (let ((f97 (get self93 5))) (let ((reply.pst$100 ($Parser.State.new ($Parser.Error.maybe_combine f85 f93) f94 f95 f96 f97))) (let ((self99 reply.pst$100)) (case (get self99 0) ('Parser.State.new (let ((f99 (get self99 1))) (let ((f100 (get self99 2))) (let ((f101 (get self99 3))) (let ((f102 (get self99 4))) (let ((f103 (get self99 5))) (let ((reply$106 (Kind.Parser.term reply.pst$100))) (let ((self105 reply$106)) (case (get self105 0) ('Parser.Reply.error (let ((f105 (get self105 1))) (let ((self106 f99)) (case (get self106 0) ('Maybe.none ($Parser.Reply.error f105)) ('Maybe.some (let ((f106 (get self106 1))) ($Parser.Reply.error ($Parser.Error.combine f106 f105)))))))) ('Parser.Reply.value (let ((f105 (get self105 1))) (let ((f106 (get self105 2))) (let ((self107 f105)) (case (get self107 0) ('Parser.State.new (let ((f107 (get self107 1))) (let ((f108 (get self107 2))) (let ((f109 (get self107 3))) (let ((f110 (get self107 4))) (let ((f111 (get self107 5))) (let ((reply.pst$114 ($Parser.State.new ($Parser.Error.maybe_combine f99 f107) f108 f109 f110 f111))) (let ((self113 reply.pst$114)) (case (get self113 0) ('Parser.State.new (let ((f113 (get self113 1))) (let ((f114 (get self113 2))) (let ((f115 (get self113 3))) (let ((f116 (get self113 4))) (let ((f117 (get self113 5))) (let ((reply$120 ($Kind.Parser.text "with " reply.pst$114))) (let ((self119 reply$120)) (case (get self119 0) ('Parser.Reply.error (let ((f119 (get self119 1))) (let ((self120 f113)) (case (get self120 0) ('Maybe.none ($Parser.Reply.error f119)) ('Maybe.some (let ((f120 (get self120 1))) ($Parser.Reply.error ($Parser.Error.combine f120 f119)))))))) ('Parser.Reply.value (let ((f119 (get self119 1))) (let ((f120 (get self119 2))) (let ((self121 f119)) (case (get self121 0) ('Parser.State.new (let ((f121 (get self121 1))) (let ((f122 (get self121 2))) (let ((f123 (get self121 3))) (let ((f124 (get self121 4))) (let ((f125 (get self121 5))) (let ((reply.pst$128 ($Parser.State.new ($Parser.Error.maybe_combine f113 f121) f122 f123 f124 f125))) (let ((self127 reply.pst$128)) (case (get self127 0) ('Parser.State.new (let ((f127 (get self127 1))) (let ((f128 (get self127 2))) (let ((f129 (get self127 3))) (let ((f130 (get self127 4))) (let ((f131 (get self127 5))) (let ((reply$134 ($Kind.Parser.name1 reply.pst$128))) (let ((self133 reply$134)) (case (get self133 0) ('Parser.Reply.error (let ((f133 (get self133 1))) (let ((self134 f127)) (case (get self134 0) ('Maybe.none ($Parser.Reply.error f133)) ('Maybe.some (let ((f134 (get self134 1))) ($Parser.Reply.error ($Parser.Error.combine f134 f133)))))))) ('Parser.Reply.value (let ((f133 (get self133 1))) (let ((f134 (get self133 2))) (let ((self135 f133)) (case (get self135 0) ('Parser.State.new (let ((f135 (get self135 1))) (let ((f136 (get self135 2))) (let ((f137 (get self135 3))) (let ((f138 (get self135 4))) (let ((f139 (get self135 5))) (let ((reply.pst$142 ($Parser.State.new ($Parser.Error.maybe_combine f127 f135) f136 f137 f138 f139))) (let ((self141 reply.pst$142)) (case (get self141 0) ('Parser.State.new (let ((f141 (get self141 1))) (let ((f142 (get self141 2))) (let ((f143 (get self141 3))) (let ((f144 (get self141 4))) (let ((f145 (get self141 5))) (let ((reply$148 ($Kind.Parser.text ":" reply.pst$142))) (let ((self147 reply$148)) (case (get self147 0) ('Parser.Reply.error (let ((f147 (get self147 1))) (let ((self148 f141)) (case (get self148 0) ('Maybe.none ($Parser.Reply.error f147)) ('Maybe.some (let ((f148 (get self148 1))) ($Parser.Reply.error ($Parser.Error.combine f148 f147)))))))) ('Parser.Reply.value (let ((f147 (get self147 1))) (let ((f148 (get self147 2))) (let ((self149 f147)) (case (get self149 0) ('Parser.State.new (let ((f149 (get self149 1))) (let ((f150 (get self149 2))) (let ((f151 (get self149 3))) (let ((f152 (get self149 4))) (let ((f153 (get self149 5))) (let ((reply.pst$156 ($Parser.State.new ($Parser.Error.maybe_combine f141 f149) f150 f151 f152 f153))) (let ((self155 reply.pst$156)) (case (get self155 0) ('Parser.State.new (let ((f155 (get self155 1))) (let ((f156 (get self155 2))) (let ((f157 (get self155 3))) (let ((f158 (get self155 4))) (let ((f159 (get self155 5))) (let ((reply$162 (Kind.Parser.term reply.pst$156))) (let ((self161 reply$162)) (case (get self161 0) ('Parser.Reply.error (let ((f161 (get self161 1))) (let ((self162 f155)) (case (get self162 0) ('Maybe.none ($Parser.Reply.error f161)) ('Maybe.some (let ((f162 (get self162 1))) ($Parser.Reply.error ($Parser.Error.combine f162 f161)))))))) ('Parser.Reply.value (let ((f161 (get self161 1))) (let ((f162 (get self161 2))) (let ((self163 f161)) (case (get self163 0) ('Parser.State.new (let ((f163 (get self163 1))) (let ((f164 (get self163 2))) (let ((f165 (get self163 3))) (let ((f166 (get self163 4))) (let ((f167 (get self163 5))) (let ((reply.pst$170 ($Parser.State.new ($Parser.Error.maybe_combine f155 f163) f164 f165 f166 f167))) (let ((self169 reply.pst$170)) (case (get self169 0) ('Parser.State.new (let ((f169 (get self169 1))) (let ((f170 (get self169 2))) (let ((f171 (get self169 3))) (let ((f172 (get self169 4))) (let ((f173 (get self169 5))) (let ((reply$176 ($Parser.maybe (Kind.Parser.text ";") reply.pst$170))) (let ((self175 reply$176)) (case (get self175 0) ('Parser.Reply.error (let ((f175 (get self175 1))) (let ((self176 f169)) (case (get self176 0) ('Maybe.none ($Parser.Reply.error f175)) ('Maybe.some (let ((f176 (get self176 1))) ($Parser.Reply.error ($Parser.Error.combine f176 f175)))))))) ('Parser.Reply.value (let ((f175 (get self175 1))) (let ((f176 (get self175 2))) (let ((self177 f175)) (case (get self177 0) ('Parser.State.new (let ((f177 (get self177 1))) (let ((f178 (get self177 2))) (let ((f179 (get self177 3))) (let ((f180 (get self177 4))) (let ((f181 (get self177 5))) (let ((reply.pst$184 ($Parser.State.new ($Parser.Error.maybe_combine f169 f177) f178 f179 f180 f181))) (let ((self183 reply.pst$184)) (case (get self183 0) ('Parser.State.new (let ((f183 (get self183 1))) (let ((f184 (get self183 2))) (let ((f185 (get self183 3))) (let ((f186 (get self183 4))) (let ((f187 (get self183 5))) (let ((reply$190 ((body$1 Unit.new) reply.pst$184))) (let ((self189 reply$190)) (case (get self189 0) ('Parser.Reply.error (let ((f189 (get self189 1))) (let ((self190 f183)) (case (get self190 0) ('Maybe.none ($Parser.Reply.error f189)) ('Maybe.some (let ((f190 (get self190 1))) ($Parser.Reply.error ($Parser.Error.combine f190 f189)))))))) ('Parser.Reply.value (let ((f189 (get self189 1))) (let ((f190 (get self189 2))) (let ((self191 f189)) (case (get self191 0) ('Parser.State.new (let ((f191 (get self191 1))) (let ((f192 (get self191 2))) (let ((f193 (get self191 3))) (let ((f194 (get self191 4))) (let ((f195 (get self191 5))) (let ((reply.pst$198 ($Parser.State.new ($Parser.Error.maybe_combine f183 f191) f192 f193 f194 f195))) (let ((term$199 ($Kind.Term.ref ($String.concat typename$0 ".for")))) (let ((term$200 ($Kind.Term.app term$199 ($Kind.Term.hol Bits.e)))) (let ((term$201 ($Kind.Term.app term$200 ($Kind.Term.ref f134)))) (let ((term$202 ($Kind.Term.app term$201 f78))) (let ((term$203 ($Kind.Term.app term$202 f106))) (let ((lamb$204 ($Kind.Term.lam f22 (lambda (e$204) ($Kind.Term.lam f134 (lambda (s$205) f162)))))) (let ((term$205 ($Kind.Term.app term$203 lamb$204))) (let ((term$206 ($Kind.Term.let f134 term$205 (lambda (x$206) f190)))) ($Parser.Reply.value reply.pst$198 term$206))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.letforrange.with (lambda (typename$0) (lambda (body$1) ($Kind.Parser.letforrange.with typename$0 body$1))))
(define ($Kind.Parser.letforrange.u32.with body$0) ($Kind.Parser.letforrange.with "U32" body$0))
(define Kind.Parser.letforrange.u32.with (lambda (body$0) ($Kind.Parser.letforrange.u32.with body$0)))
(define ($Kind.Parser.letforrange.i32 body$0) ($Kind.Parser.letforrange "I32" body$0))
(define Kind.Parser.letforrange.i32 (lambda (body$0) ($Kind.Parser.letforrange.i32 body$0)))
(define ($Kind.Parser.letforrange.i32.with body$0) ($Kind.Parser.letforrange.with "I32" body$0))
(define Kind.Parser.letforrange.i32.with (lambda (body$0) ($Kind.Parser.letforrange.i32.with body$0)))
(define ($Kind.Parser.letforrange.nat body$0) ((Kind.Parser.block "let-for") (lambda (pst$1) (let ((self1 pst$1)) (case (get self1 0) ('Parser.State.new (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((reply$7 ($Kind.Parser.text "let " pst$1))) (let ((self7 reply$7)) (case (get self7 0) ('Parser.Reply.error (let ((f7 (get self7 1))) (let ((self8 f1)) (case (get self8 0) ('Maybe.none ($Parser.Reply.error f7)) ('Maybe.some (let ((f8 (get self8 1))) ($Parser.Reply.error ($Parser.Error.combine f8 f7)))))))) ('Parser.Reply.value (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((self9 f7)) (case (get self9 0) ('Parser.State.new (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) (let ((reply.pst$15 ($Parser.State.new ($Parser.Error.maybe_combine f1 f9) f10 f11 f12 f13))) (let ((self15 reply.pst$15)) (case (get self15 0) ('Parser.State.new (let ((f15 (get self15 1))) (let ((f16 (get self15 2))) (let ((f17 (get self15 3))) (let ((f18 (get self15 4))) (let ((f19 (get self15 5))) (let ((reply$21 ($Kind.Parser.name1 reply.pst$15))) (let ((self21 reply$21)) (case (get self21 0) ('Parser.Reply.error (let ((f21 (get self21 1))) (let ((self22 f15)) (case (get self22 0) ('Maybe.none ($Parser.Reply.error f21)) ('Maybe.some (let ((f22 (get self22 1))) ($Parser.Reply.error ($Parser.Error.combine f22 f21)))))))) ('Parser.Reply.value (let ((f21 (get self21 1))) (let ((f22 (get self21 2))) (let ((self23 f21)) (case (get self23 0) ('Parser.State.new (let ((f23 (get self23 1))) (let ((f24 (get self23 2))) (let ((f25 (get self23 3))) (let ((f26 (get self23 4))) (let ((f27 (get self23 5))) (let ((reply.pst$29 ($Parser.State.new ($Parser.Error.maybe_combine f15 f23) f24 f25 f26 f27))) (let ((self29 reply.pst$29)) (case (get self29 0) ('Parser.State.new (let ((f29 (get self29 1))) (let ((f30 (get self29 2))) (let ((f31 (get self29 3))) (let ((f32 (get self29 4))) (let ((f33 (get self29 5))) (let ((reply$35 ($Kind.Parser.text "=" reply.pst$29))) (let ((self35 reply$35)) (case (get self35 0) ('Parser.Reply.error (let ((f35 (get self35 1))) (let ((self36 f29)) (case (get self36 0) ('Maybe.none ($Parser.Reply.error f35)) ('Maybe.some (let ((f36 (get self36 1))) ($Parser.Reply.error ($Parser.Error.combine f36 f35)))))))) ('Parser.Reply.value (let ((f35 (get self35 1))) (let ((f36 (get self35 2))) (let ((self37 f35)) (case (get self37 0) ('Parser.State.new (let ((f37 (get self37 1))) (let ((f38 (get self37 2))) (let ((f39 (get self37 3))) (let ((f40 (get self37 4))) (let ((f41 (get self37 5))) (let ((reply.pst$43 ($Parser.State.new ($Parser.Error.maybe_combine f29 f37) f38 f39 f40 f41))) (let ((self43 reply.pst$43)) (case (get self43 0) ('Parser.State.new (let ((f43 (get self43 1))) (let ((f44 (get self43 2))) (let ((f45 (get self43 3))) (let ((f46 (get self43 4))) (let ((f47 (get self43 5))) (let ((reply$49 ($Kind.Parser.text "for " reply.pst$43))) (let ((self49 reply$49)) (case (get self49 0) ('Parser.Reply.error (let ((f49 (get self49 1))) (let ((self50 f43)) (case (get self50 0) ('Maybe.none ($Parser.Reply.error f49)) ('Maybe.some (let ((f50 (get self50 1))) ($Parser.Reply.error ($Parser.Error.combine f50 f49)))))))) ('Parser.Reply.value (let ((f49 (get self49 1))) (let ((f50 (get self49 2))) (let ((self51 f49)) (case (get self51 0) ('Parser.State.new (let ((f51 (get self51 1))) (let ((f52 (get self51 2))) (let ((f53 (get self51 3))) (let ((f54 (get self51 4))) (let ((f55 (get self51 5))) (let ((reply.pst$57 ($Parser.State.new ($Parser.Error.maybe_combine f43 f51) f52 f53 f54 f55))) (let ((self57 reply.pst$57)) (case (get self57 0) ('Parser.State.new (let ((f57 (get self57 1))) (let ((f58 (get self57 2))) (let ((f59 (get self57 3))) (let ((f60 (get self57 4))) (let ((f61 (get self57 5))) (let ((reply$63 ($Kind.Parser.name1 reply.pst$57))) (let ((self63 reply$63)) (case (get self63 0) ('Parser.Reply.error (let ((f63 (get self63 1))) (let ((self64 f57)) (case (get self64 0) ('Maybe.none ($Parser.Reply.error f63)) ('Maybe.some (let ((f64 (get self64 1))) ($Parser.Reply.error ($Parser.Error.combine f64 f63)))))))) ('Parser.Reply.value (let ((f63 (get self63 1))) (let ((f64 (get self63 2))) (let ((self65 f63)) (case (get self65 0) ('Parser.State.new (let ((f65 (get self65 1))) (let ((f66 (get self65 2))) (let ((f67 (get self65 3))) (let ((f68 (get self65 4))) (let ((f69 (get self65 5))) (let ((reply.pst$71 ($Parser.State.new ($Parser.Error.maybe_combine f57 f65) f66 f67 f68 f69))) (let ((self71 reply.pst$71)) (case (get self71 0) ('Parser.State.new (let ((f71 (get self71 1))) (let ((f72 (get self71 2))) (let ((f73 (get self71 3))) (let ((f74 (get self71 4))) (let ((f75 (get self71 5))) (let ((reply$77 ($Kind.Parser.text "from" reply.pst$71))) (let ((self77 reply$77)) (case (get self77 0) ('Parser.Reply.error (let ((f77 (get self77 1))) (let ((self78 f71)) (case (get self78 0) ('Maybe.none ($Parser.Reply.error f77)) ('Maybe.some (let ((f78 (get self78 1))) ($Parser.Reply.error ($Parser.Error.combine f78 f77)))))))) ('Parser.Reply.value (let ((f77 (get self77 1))) (let ((f78 (get self77 2))) (let ((self79 f77)) (case (get self79 0) ('Parser.State.new (let ((f79 (get self79 1))) (let ((f80 (get self79 2))) (let ((f81 (get self79 3))) (let ((f82 (get self79 4))) (let ((f83 (get self79 5))) (let ((reply.pst$85 ($Parser.State.new ($Parser.Error.maybe_combine f71 f79) f80 f81 f82 f83))) (let ((self85 reply.pst$85)) (case (get self85 0) ('Parser.State.new (let ((f85 (get self85 1))) (let ((f86 (get self85 2))) (let ((f87 (get self85 3))) (let ((f88 (get self85 4))) (let ((f89 (get self85 5))) (let ((reply$91 (Kind.Parser.term reply.pst$85))) (let ((self91 reply$91)) (case (get self91 0) ('Parser.Reply.error (let ((f91 (get self91 1))) (let ((self92 f85)) (case (get self92 0) ('Maybe.none ($Parser.Reply.error f91)) ('Maybe.some (let ((f92 (get self92 1))) ($Parser.Reply.error ($Parser.Error.combine f92 f91)))))))) ('Parser.Reply.value (let ((f91 (get self91 1))) (let ((f92 (get self91 2))) (let ((self93 f91)) (case (get self93 0) ('Parser.State.new (let ((f93 (get self93 1))) (let ((f94 (get self93 2))) (let ((f95 (get self93 3))) (let ((f96 (get self93 4))) (let ((f97 (get self93 5))) (let ((reply.pst$99 ($Parser.State.new ($Parser.Error.maybe_combine f85 f93) f94 f95 f96 f97))) (let ((self99 reply.pst$99)) (case (get self99 0) ('Parser.State.new (let ((f99 (get self99 1))) (let ((f100 (get self99 2))) (let ((f101 (get self99 3))) (let ((f102 (get self99 4))) (let ((f103 (get self99 5))) (let ((reply$105 ($Kind.Parser.text "to" reply.pst$99))) (let ((self105 reply$105)) (case (get self105 0) ('Parser.Reply.error (let ((f105 (get self105 1))) (let ((self106 f99)) (case (get self106 0) ('Maybe.none ($Parser.Reply.error f105)) ('Maybe.some (let ((f106 (get self106 1))) ($Parser.Reply.error ($Parser.Error.combine f106 f105)))))))) ('Parser.Reply.value (let ((f105 (get self105 1))) (let ((f106 (get self105 2))) (let ((self107 f105)) (case (get self107 0) ('Parser.State.new (let ((f107 (get self107 1))) (let ((f108 (get self107 2))) (let ((f109 (get self107 3))) (let ((f110 (get self107 4))) (let ((f111 (get self107 5))) (let ((reply.pst$113 ($Parser.State.new ($Parser.Error.maybe_combine f99 f107) f108 f109 f110 f111))) (let ((self113 reply.pst$113)) (case (get self113 0) ('Parser.State.new (let ((f113 (get self113 1))) (let ((f114 (get self113 2))) (let ((f115 (get self113 3))) (let ((f116 (get self113 4))) (let ((f117 (get self113 5))) (let ((reply$119 (Kind.Parser.term reply.pst$113))) (let ((self119 reply$119)) (case (get self119 0) ('Parser.Reply.error (let ((f119 (get self119 1))) (let ((self120 f113)) (case (get self120 0) ('Maybe.none ($Parser.Reply.error f119)) ('Maybe.some (let ((f120 (get self120 1))) ($Parser.Reply.error ($Parser.Error.combine f120 f119)))))))) ('Parser.Reply.value (let ((f119 (get self119 1))) (let ((f120 (get self119 2))) (let ((self121 f119)) (case (get self121 0) ('Parser.State.new (let ((f121 (get self121 1))) (let ((f122 (get self121 2))) (let ((f123 (get self121 3))) (let ((f124 (get self121 4))) (let ((f125 (get self121 5))) (let ((reply.pst$127 ($Parser.State.new ($Parser.Error.maybe_combine f113 f121) f122 f123 f124 f125))) (let ((self127 reply.pst$127)) (case (get self127 0) ('Parser.State.new (let ((f127 (get self127 1))) (let ((f128 (get self127 2))) (let ((f129 (get self127 3))) (let ((f130 (get self127 4))) (let ((f131 (get self127 5))) (let ((reply$133 ($Kind.Parser.text ":" reply.pst$127))) (let ((self133 reply$133)) (case (get self133 0) ('Parser.Reply.error (let ((f133 (get self133 1))) (let ((self134 f127)) (case (get self134 0) ('Maybe.none ($Parser.Reply.error f133)) ('Maybe.some (let ((f134 (get self134 1))) ($Parser.Reply.error ($Parser.Error.combine f134 f133)))))))) ('Parser.Reply.value (let ((f133 (get self133 1))) (let ((f134 (get self133 2))) (let ((self135 f133)) (case (get self135 0) ('Parser.State.new (let ((f135 (get self135 1))) (let ((f136 (get self135 2))) (let ((f137 (get self135 3))) (let ((f138 (get self135 4))) (let ((f139 (get self135 5))) (let ((reply.pst$141 ($Parser.State.new ($Parser.Error.maybe_combine f127 f135) f136 f137 f138 f139))) (let ((self141 reply.pst$141)) (case (get self141 0) ('Parser.State.new (let ((f141 (get self141 1))) (let ((f142 (get self141 2))) (let ((f143 (get self141 3))) (let ((f144 (get self141 4))) (let ((f145 (get self141 5))) (let ((reply$147 (Kind.Parser.term reply.pst$141))) (let ((self147 reply$147)) (case (get self147 0) ('Parser.Reply.error (let ((f147 (get self147 1))) (let ((self148 f141)) (case (get self148 0) ('Maybe.none ($Parser.Reply.error f147)) ('Maybe.some (let ((f148 (get self148 1))) ($Parser.Reply.error ($Parser.Error.combine f148 f147)))))))) ('Parser.Reply.value (let ((f147 (get self147 1))) (let ((f148 (get self147 2))) (let ((self149 f147)) (case (get self149 0) ('Parser.State.new (let ((f149 (get self149 1))) (let ((f150 (get self149 2))) (let ((f151 (get self149 3))) (let ((f152 (get self149 4))) (let ((f153 (get self149 5))) (let ((reply.pst$155 ($Parser.State.new ($Parser.Error.maybe_combine f141 f149) f150 f151 f152 f153))) (let ((self155 reply.pst$155)) (case (get self155 0) ('Parser.State.new (let ((f155 (get self155 1))) (let ((f156 (get self155 2))) (let ((f157 (get self155 3))) (let ((f158 (get self155 4))) (let ((f159 (get self155 5))) (let ((reply$161 ($Parser.maybe (Kind.Parser.text ";") reply.pst$155))) (let ((self161 reply$161)) (case (get self161 0) ('Parser.Reply.error (let ((f161 (get self161 1))) (let ((self162 f155)) (case (get self162 0) ('Maybe.none ($Parser.Reply.error f161)) ('Maybe.some (let ((f162 (get self162 1))) ($Parser.Reply.error ($Parser.Error.combine f162 f161)))))))) ('Parser.Reply.value (let ((f161 (get self161 1))) (let ((f162 (get self161 2))) (let ((self163 f161)) (case (get self163 0) ('Parser.State.new (let ((f163 (get self163 1))) (let ((f164 (get self163 2))) (let ((f165 (get self163 3))) (let ((f166 (get self163 4))) (let ((f167 (get self163 5))) (let ((reply.pst$169 ($Parser.State.new ($Parser.Error.maybe_combine f155 f163) f164 f165 f166 f167))) (let ((self169 reply.pst$169)) (case (get self169 0) ('Parser.State.new (let ((f169 (get self169 1))) (let ((f170 (get self169 2))) (let ((f171 (get self169 3))) (let ((f172 (get self169 4))) (let ((f173 (get self169 5))) (let ((reply$175 ((body$0 Unit.new) reply.pst$169))) (let ((self175 reply$175)) (case (get self175 0) ('Parser.Reply.error (let ((f175 (get self175 1))) (let ((self176 f169)) (case (get self176 0) ('Maybe.none ($Parser.Reply.error f175)) ('Maybe.some (let ((f176 (get self176 1))) ($Parser.Reply.error ($Parser.Error.combine f176 f175)))))))) ('Parser.Reply.value (let ((f175 (get self175 1))) (let ((f176 (get self175 2))) (let ((self177 f175)) (case (get self177 0) ('Parser.State.new (let ((f177 (get self177 1))) (let ((f178 (get self177 2))) (let ((f179 (get self177 3))) (let ((f180 (get self177 4))) (let ((f181 (get self177 5))) (let ((reply.pst$183 ($Parser.State.new ($Parser.Error.maybe_combine f169 f177) f178 f179 f180 f181))) (let ((term$184 ($Kind.Term.ref "Nat.for"))) (let ((term$185 ($Kind.Term.app term$184 ($Kind.Term.hol Bits.e)))) (let ((term$186 ($Kind.Term.app term$185 ($Kind.Term.ref f22)))) (let ((term$187 ($Kind.Term.app term$186 f92))) (let ((term$188 ($Kind.Term.app term$187 f120))) (let ((lamb$189 ($Kind.Term.lam f64 (lambda (e$189) ($Kind.Term.lam f22 (lambda (s$190) f148)))))) (let ((term$190 ($Kind.Term.app term$188 lamb$189))) (let ((term$191 ($Kind.Term.let f22 term$190 (lambda (x$191) f176)))) ($Parser.Reply.value reply.pst$183 term$191)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.letforrange.nat (lambda (body$0) ($Kind.Parser.letforrange.nat body$0)))
(define ($Kind.Parser.letforrange.nat.with body$0) ((Kind.Parser.block "for") (lambda (pst$1) (let ((self1 pst$1)) (case (get self1 0) ('Parser.State.new (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((reply$7 ($Kind.Parser.text "for " pst$1))) (let ((self7 reply$7)) (case (get self7 0) ('Parser.Reply.error (let ((f7 (get self7 1))) (let ((self8 f1)) (case (get self8 0) ('Maybe.none ($Parser.Reply.error f7)) ('Maybe.some (let ((f8 (get self8 1))) ($Parser.Reply.error ($Parser.Error.combine f8 f7)))))))) ('Parser.Reply.value (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((self9 f7)) (case (get self9 0) ('Parser.State.new (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) (let ((reply.pst$15 ($Parser.State.new ($Parser.Error.maybe_combine f1 f9) f10 f11 f12 f13))) (let ((self15 reply.pst$15)) (case (get self15 0) ('Parser.State.new (let ((f15 (get self15 1))) (let ((f16 (get self15 2))) (let ((f17 (get self15 3))) (let ((f18 (get self15 4))) (let ((f19 (get self15 5))) (let ((reply$21 ($Kind.Parser.name1 reply.pst$15))) (let ((self21 reply$21)) (case (get self21 0) ('Parser.Reply.error (let ((f21 (get self21 1))) (let ((self22 f15)) (case (get self22 0) ('Maybe.none ($Parser.Reply.error f21)) ('Maybe.some (let ((f22 (get self22 1))) ($Parser.Reply.error ($Parser.Error.combine f22 f21)))))))) ('Parser.Reply.value (let ((f21 (get self21 1))) (let ((f22 (get self21 2))) (let ((self23 f21)) (case (get self23 0) ('Parser.State.new (let ((f23 (get self23 1))) (let ((f24 (get self23 2))) (let ((f25 (get self23 3))) (let ((f26 (get self23 4))) (let ((f27 (get self23 5))) (let ((reply.pst$29 ($Parser.State.new ($Parser.Error.maybe_combine f15 f23) f24 f25 f26 f27))) (let ((self29 reply.pst$29)) (case (get self29 0) ('Parser.State.new (let ((f29 (get self29 1))) (let ((f30 (get self29 2))) (let ((f31 (get self29 3))) (let ((f32 (get self29 4))) (let ((f33 (get self29 5))) (let ((reply$35 ($Kind.Parser.text "from" reply.pst$29))) (let ((self35 reply$35)) (case (get self35 0) ('Parser.Reply.error (let ((f35 (get self35 1))) (let ((self36 f29)) (case (get self36 0) ('Maybe.none ($Parser.Reply.error f35)) ('Maybe.some (let ((f36 (get self36 1))) ($Parser.Reply.error ($Parser.Error.combine f36 f35)))))))) ('Parser.Reply.value (let ((f35 (get self35 1))) (let ((f36 (get self35 2))) (let ((self37 f35)) (case (get self37 0) ('Parser.State.new (let ((f37 (get self37 1))) (let ((f38 (get self37 2))) (let ((f39 (get self37 3))) (let ((f40 (get self37 4))) (let ((f41 (get self37 5))) (let ((reply.pst$43 ($Parser.State.new ($Parser.Error.maybe_combine f29 f37) f38 f39 f40 f41))) (let ((self43 reply.pst$43)) (case (get self43 0) ('Parser.State.new (let ((f43 (get self43 1))) (let ((f44 (get self43 2))) (let ((f45 (get self43 3))) (let ((f46 (get self43 4))) (let ((f47 (get self43 5))) (let ((reply$49 (Kind.Parser.term reply.pst$43))) (let ((self49 reply$49)) (case (get self49 0) ('Parser.Reply.error (let ((f49 (get self49 1))) (let ((self50 f43)) (case (get self50 0) ('Maybe.none ($Parser.Reply.error f49)) ('Maybe.some (let ((f50 (get self50 1))) ($Parser.Reply.error ($Parser.Error.combine f50 f49)))))))) ('Parser.Reply.value (let ((f49 (get self49 1))) (let ((f50 (get self49 2))) (let ((self51 f49)) (case (get self51 0) ('Parser.State.new (let ((f51 (get self51 1))) (let ((f52 (get self51 2))) (let ((f53 (get self51 3))) (let ((f54 (get self51 4))) (let ((f55 (get self51 5))) (let ((reply.pst$57 ($Parser.State.new ($Parser.Error.maybe_combine f43 f51) f52 f53 f54 f55))) (let ((self57 reply.pst$57)) (case (get self57 0) ('Parser.State.new (let ((f57 (get self57 1))) (let ((f58 (get self57 2))) (let ((f59 (get self57 3))) (let ((f60 (get self57 4))) (let ((f61 (get self57 5))) (let ((reply$63 ($Kind.Parser.text "to" reply.pst$57))) (let ((self63 reply$63)) (case (get self63 0) ('Parser.Reply.error (let ((f63 (get self63 1))) (let ((self64 f57)) (case (get self64 0) ('Maybe.none ($Parser.Reply.error f63)) ('Maybe.some (let ((f64 (get self64 1))) ($Parser.Reply.error ($Parser.Error.combine f64 f63)))))))) ('Parser.Reply.value (let ((f63 (get self63 1))) (let ((f64 (get self63 2))) (let ((self65 f63)) (case (get self65 0) ('Parser.State.new (let ((f65 (get self65 1))) (let ((f66 (get self65 2))) (let ((f67 (get self65 3))) (let ((f68 (get self65 4))) (let ((f69 (get self65 5))) (let ((reply.pst$71 ($Parser.State.new ($Parser.Error.maybe_combine f57 f65) f66 f67 f68 f69))) (let ((self71 reply.pst$71)) (case (get self71 0) ('Parser.State.new (let ((f71 (get self71 1))) (let ((f72 (get self71 2))) (let ((f73 (get self71 3))) (let ((f74 (get self71 4))) (let ((f75 (get self71 5))) (let ((reply$77 (Kind.Parser.term reply.pst$71))) (let ((self77 reply$77)) (case (get self77 0) ('Parser.Reply.error (let ((f77 (get self77 1))) (let ((self78 f71)) (case (get self78 0) ('Maybe.none ($Parser.Reply.error f77)) ('Maybe.some (let ((f78 (get self78 1))) ($Parser.Reply.error ($Parser.Error.combine f78 f77)))))))) ('Parser.Reply.value (let ((f77 (get self77 1))) (let ((f78 (get self77 2))) (let ((self79 f77)) (case (get self79 0) ('Parser.State.new (let ((f79 (get self79 1))) (let ((f80 (get self79 2))) (let ((f81 (get self79 3))) (let ((f82 (get self79 4))) (let ((f83 (get self79 5))) (let ((reply.pst$85 ($Parser.State.new ($Parser.Error.maybe_combine f71 f79) f80 f81 f82 f83))) (let ((self85 reply.pst$85)) (case (get self85 0) ('Parser.State.new (let ((f85 (get self85 1))) (let ((f86 (get self85 2))) (let ((f87 (get self85 3))) (let ((f88 (get self85 4))) (let ((f89 (get self85 5))) (let ((reply$91 ($Kind.Parser.text "with " reply.pst$85))) (let ((self91 reply$91)) (case (get self91 0) ('Parser.Reply.error (let ((f91 (get self91 1))) (let ((self92 f85)) (case (get self92 0) ('Maybe.none ($Parser.Reply.error f91)) ('Maybe.some (let ((f92 (get self92 1))) ($Parser.Reply.error ($Parser.Error.combine f92 f91)))))))) ('Parser.Reply.value (let ((f91 (get self91 1))) (let ((f92 (get self91 2))) (let ((self93 f91)) (case (get self93 0) ('Parser.State.new (let ((f93 (get self93 1))) (let ((f94 (get self93 2))) (let ((f95 (get self93 3))) (let ((f96 (get self93 4))) (let ((f97 (get self93 5))) (let ((reply.pst$99 ($Parser.State.new ($Parser.Error.maybe_combine f85 f93) f94 f95 f96 f97))) (let ((self99 reply.pst$99)) (case (get self99 0) ('Parser.State.new (let ((f99 (get self99 1))) (let ((f100 (get self99 2))) (let ((f101 (get self99 3))) (let ((f102 (get self99 4))) (let ((f103 (get self99 5))) (let ((reply$105 ($Kind.Parser.name1 reply.pst$99))) (let ((self105 reply$105)) (case (get self105 0) ('Parser.Reply.error (let ((f105 (get self105 1))) (let ((self106 f99)) (case (get self106 0) ('Maybe.none ($Parser.Reply.error f105)) ('Maybe.some (let ((f106 (get self106 1))) ($Parser.Reply.error ($Parser.Error.combine f106 f105)))))))) ('Parser.Reply.value (let ((f105 (get self105 1))) (let ((f106 (get self105 2))) (let ((self107 f105)) (case (get self107 0) ('Parser.State.new (let ((f107 (get self107 1))) (let ((f108 (get self107 2))) (let ((f109 (get self107 3))) (let ((f110 (get self107 4))) (let ((f111 (get self107 5))) (let ((reply.pst$113 ($Parser.State.new ($Parser.Error.maybe_combine f99 f107) f108 f109 f110 f111))) (let ((self113 reply.pst$113)) (case (get self113 0) ('Parser.State.new (let ((f113 (get self113 1))) (let ((f114 (get self113 2))) (let ((f115 (get self113 3))) (let ((f116 (get self113 4))) (let ((f117 (get self113 5))) (let ((reply$119 ($Kind.Parser.text ":" reply.pst$113))) (let ((self119 reply$119)) (case (get self119 0) ('Parser.Reply.error (let ((f119 (get self119 1))) (let ((self120 f113)) (case (get self120 0) ('Maybe.none ($Parser.Reply.error f119)) ('Maybe.some (let ((f120 (get self120 1))) ($Parser.Reply.error ($Parser.Error.combine f120 f119)))))))) ('Parser.Reply.value (let ((f119 (get self119 1))) (let ((f120 (get self119 2))) (let ((self121 f119)) (case (get self121 0) ('Parser.State.new (let ((f121 (get self121 1))) (let ((f122 (get self121 2))) (let ((f123 (get self121 3))) (let ((f124 (get self121 4))) (let ((f125 (get self121 5))) (let ((reply.pst$127 ($Parser.State.new ($Parser.Error.maybe_combine f113 f121) f122 f123 f124 f125))) (let ((self127 reply.pst$127)) (case (get self127 0) ('Parser.State.new (let ((f127 (get self127 1))) (let ((f128 (get self127 2))) (let ((f129 (get self127 3))) (let ((f130 (get self127 4))) (let ((f131 (get self127 5))) (let ((reply$133 (Kind.Parser.term reply.pst$127))) (let ((self133 reply$133)) (case (get self133 0) ('Parser.Reply.error (let ((f133 (get self133 1))) (let ((self134 f127)) (case (get self134 0) ('Maybe.none ($Parser.Reply.error f133)) ('Maybe.some (let ((f134 (get self134 1))) ($Parser.Reply.error ($Parser.Error.combine f134 f133)))))))) ('Parser.Reply.value (let ((f133 (get self133 1))) (let ((f134 (get self133 2))) (let ((self135 f133)) (case (get self135 0) ('Parser.State.new (let ((f135 (get self135 1))) (let ((f136 (get self135 2))) (let ((f137 (get self135 3))) (let ((f138 (get self135 4))) (let ((f139 (get self135 5))) (let ((reply.pst$141 ($Parser.State.new ($Parser.Error.maybe_combine f127 f135) f136 f137 f138 f139))) (let ((self141 reply.pst$141)) (case (get self141 0) ('Parser.State.new (let ((f141 (get self141 1))) (let ((f142 (get self141 2))) (let ((f143 (get self141 3))) (let ((f144 (get self141 4))) (let ((f145 (get self141 5))) (let ((reply$147 ($Parser.maybe (Kind.Parser.text ";") reply.pst$141))) (let ((self147 reply$147)) (case (get self147 0) ('Parser.Reply.error (let ((f147 (get self147 1))) (let ((self148 f141)) (case (get self148 0) ('Maybe.none ($Parser.Reply.error f147)) ('Maybe.some (let ((f148 (get self148 1))) ($Parser.Reply.error ($Parser.Error.combine f148 f147)))))))) ('Parser.Reply.value (let ((f147 (get self147 1))) (let ((f148 (get self147 2))) (let ((self149 f147)) (case (get self149 0) ('Parser.State.new (let ((f149 (get self149 1))) (let ((f150 (get self149 2))) (let ((f151 (get self149 3))) (let ((f152 (get self149 4))) (let ((f153 (get self149 5))) (let ((reply.pst$155 ($Parser.State.new ($Parser.Error.maybe_combine f141 f149) f150 f151 f152 f153))) (let ((self155 reply.pst$155)) (case (get self155 0) ('Parser.State.new (let ((f155 (get self155 1))) (let ((f156 (get self155 2))) (let ((f157 (get self155 3))) (let ((f158 (get self155 4))) (let ((f159 (get self155 5))) (let ((reply$161 ((body$0 Unit.new) reply.pst$155))) (let ((self161 reply$161)) (case (get self161 0) ('Parser.Reply.error (let ((f161 (get self161 1))) (let ((self162 f155)) (case (get self162 0) ('Maybe.none ($Parser.Reply.error f161)) ('Maybe.some (let ((f162 (get self162 1))) ($Parser.Reply.error ($Parser.Error.combine f162 f161)))))))) ('Parser.Reply.value (let ((f161 (get self161 1))) (let ((f162 (get self161 2))) (let ((self163 f161)) (case (get self163 0) ('Parser.State.new (let ((f163 (get self163 1))) (let ((f164 (get self163 2))) (let ((f165 (get self163 3))) (let ((f166 (get self163 4))) (let ((f167 (get self163 5))) (let ((reply.pst$169 ($Parser.State.new ($Parser.Error.maybe_combine f155 f163) f164 f165 f166 f167))) (let ((term$170 ($Kind.Term.ref "Nat.for"))) (let ((term$171 ($Kind.Term.app term$170 ($Kind.Term.hol Bits.e)))) (let ((term$172 ($Kind.Term.app term$171 ($Kind.Term.ref f106)))) (let ((term$173 ($Kind.Term.app term$172 f50))) (let ((term$174 ($Kind.Term.app term$173 f78))) (let ((lamb$175 ($Kind.Term.lam f22 (lambda (e$175) ($Kind.Term.lam f106 (lambda (s$176) f134)))))) (let ((term$176 ($Kind.Term.app term$174 lamb$175))) (let ((term$177 ($Kind.Term.let f106 term$176 (lambda (x$177) f162)))) ($Parser.Reply.value reply.pst$169 term$177))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.letforrange.nat.with (lambda (body$0) ($Kind.Parser.letforrange.nat.with body$0)))
(define ($Kind.Parser.letforin body$0) ((Kind.Parser.block "let-for") (lambda (pst$1) (let ((self1 pst$1)) (case (get self1 0) ('Parser.State.new (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((reply$7 ($Kind.Parser.text "let " pst$1))) (let ((self7 reply$7)) (case (get self7 0) ('Parser.Reply.error (let ((f7 (get self7 1))) (let ((self8 f1)) (case (get self8 0) ('Maybe.none ($Parser.Reply.error f7)) ('Maybe.some (let ((f8 (get self8 1))) ($Parser.Reply.error ($Parser.Error.combine f8 f7)))))))) ('Parser.Reply.value (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((self9 f7)) (case (get self9 0) ('Parser.State.new (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) (let ((reply.pst$15 ($Parser.State.new ($Parser.Error.maybe_combine f1 f9) f10 f11 f12 f13))) (let ((self15 reply.pst$15)) (case (get self15 0) ('Parser.State.new (let ((f15 (get self15 1))) (let ((f16 (get self15 2))) (let ((f17 (get self15 3))) (let ((f18 (get self15 4))) (let ((f19 (get self15 5))) (let ((reply$21 ($Kind.Parser.name1 reply.pst$15))) (let ((self21 reply$21)) (case (get self21 0) ('Parser.Reply.error (let ((f21 (get self21 1))) (let ((self22 f15)) (case (get self22 0) ('Maybe.none ($Parser.Reply.error f21)) ('Maybe.some (let ((f22 (get self22 1))) ($Parser.Reply.error ($Parser.Error.combine f22 f21)))))))) ('Parser.Reply.value (let ((f21 (get self21 1))) (let ((f22 (get self21 2))) (let ((self23 f21)) (case (get self23 0) ('Parser.State.new (let ((f23 (get self23 1))) (let ((f24 (get self23 2))) (let ((f25 (get self23 3))) (let ((f26 (get self23 4))) (let ((f27 (get self23 5))) (let ((reply.pst$29 ($Parser.State.new ($Parser.Error.maybe_combine f15 f23) f24 f25 f26 f27))) (let ((self29 reply.pst$29)) (case (get self29 0) ('Parser.State.new (let ((f29 (get self29 1))) (let ((f30 (get self29 2))) (let ((f31 (get self29 3))) (let ((f32 (get self29 4))) (let ((f33 (get self29 5))) (let ((reply$35 ($Kind.Parser.text "=" reply.pst$29))) (let ((self35 reply$35)) (case (get self35 0) ('Parser.Reply.error (let ((f35 (get self35 1))) (let ((self36 f29)) (case (get self36 0) ('Maybe.none ($Parser.Reply.error f35)) ('Maybe.some (let ((f36 (get self36 1))) ($Parser.Reply.error ($Parser.Error.combine f36 f35)))))))) ('Parser.Reply.value (let ((f35 (get self35 1))) (let ((f36 (get self35 2))) (let ((self37 f35)) (case (get self37 0) ('Parser.State.new (let ((f37 (get self37 1))) (let ((f38 (get self37 2))) (let ((f39 (get self37 3))) (let ((f40 (get self37 4))) (let ((f41 (get self37 5))) (let ((reply.pst$43 ($Parser.State.new ($Parser.Error.maybe_combine f29 f37) f38 f39 f40 f41))) (let ((self43 reply.pst$43)) (case (get self43 0) ('Parser.State.new (let ((f43 (get self43 1))) (let ((f44 (get self43 2))) (let ((f45 (get self43 3))) (let ((f46 (get self43 4))) (let ((f47 (get self43 5))) (let ((reply$49 ($Kind.Parser.text "for " reply.pst$43))) (let ((self49 reply$49)) (case (get self49 0) ('Parser.Reply.error (let ((f49 (get self49 1))) (let ((self50 f43)) (case (get self50 0) ('Maybe.none ($Parser.Reply.error f49)) ('Maybe.some (let ((f50 (get self50 1))) ($Parser.Reply.error ($Parser.Error.combine f50 f49)))))))) ('Parser.Reply.value (let ((f49 (get self49 1))) (let ((f50 (get self49 2))) (let ((self51 f49)) (case (get self51 0) ('Parser.State.new (let ((f51 (get self51 1))) (let ((f52 (get self51 2))) (let ((f53 (get self51 3))) (let ((f54 (get self51 4))) (let ((f55 (get self51 5))) (let ((reply.pst$57 ($Parser.State.new ($Parser.Error.maybe_combine f43 f51) f52 f53 f54 f55))) (let ((self57 reply.pst$57)) (case (get self57 0) ('Parser.State.new (let ((f57 (get self57 1))) (let ((f58 (get self57 2))) (let ((f59 (get self57 3))) (let ((f60 (get self57 4))) (let ((f61 (get self57 5))) (let ((reply$63 ($Kind.Parser.name1 reply.pst$57))) (let ((self63 reply$63)) (case (get self63 0) ('Parser.Reply.error (let ((f63 (get self63 1))) (let ((self64 f57)) (case (get self64 0) ('Maybe.none ($Parser.Reply.error f63)) ('Maybe.some (let ((f64 (get self64 1))) ($Parser.Reply.error ($Parser.Error.combine f64 f63)))))))) ('Parser.Reply.value (let ((f63 (get self63 1))) (let ((f64 (get self63 2))) (let ((self65 f63)) (case (get self65 0) ('Parser.State.new (let ((f65 (get self65 1))) (let ((f66 (get self65 2))) (let ((f67 (get self65 3))) (let ((f68 (get self65 4))) (let ((f69 (get self65 5))) (let ((reply.pst$71 ($Parser.State.new ($Parser.Error.maybe_combine f57 f65) f66 f67 f68 f69))) (let ((self71 reply.pst$71)) (case (get self71 0) ('Parser.State.new (let ((f71 (get self71 1))) (let ((f72 (get self71 2))) (let ((f73 (get self71 3))) (let ((f74 (get self71 4))) (let ((f75 (get self71 5))) (let ((reply$77 ($Kind.Parser.text "in" reply.pst$71))) (let ((self77 reply$77)) (case (get self77 0) ('Parser.Reply.error (let ((f77 (get self77 1))) (let ((self78 f71)) (case (get self78 0) ('Maybe.none ($Parser.Reply.error f77)) ('Maybe.some (let ((f78 (get self78 1))) ($Parser.Reply.error ($Parser.Error.combine f78 f77)))))))) ('Parser.Reply.value (let ((f77 (get self77 1))) (let ((f78 (get self77 2))) (let ((self79 f77)) (case (get self79 0) ('Parser.State.new (let ((f79 (get self79 1))) (let ((f80 (get self79 2))) (let ((f81 (get self79 3))) (let ((f82 (get self79 4))) (let ((f83 (get self79 5))) (let ((reply.pst$85 ($Parser.State.new ($Parser.Error.maybe_combine f71 f79) f80 f81 f82 f83))) (let ((self85 reply.pst$85)) (case (get self85 0) ('Parser.State.new (let ((f85 (get self85 1))) (let ((f86 (get self85 2))) (let ((f87 (get self85 3))) (let ((f88 (get self85 4))) (let ((f89 (get self85 5))) (let ((reply$91 (Kind.Parser.term reply.pst$85))) (let ((self91 reply$91)) (case (get self91 0) ('Parser.Reply.error (let ((f91 (get self91 1))) (let ((self92 f85)) (case (get self92 0) ('Maybe.none ($Parser.Reply.error f91)) ('Maybe.some (let ((f92 (get self92 1))) ($Parser.Reply.error ($Parser.Error.combine f92 f91)))))))) ('Parser.Reply.value (let ((f91 (get self91 1))) (let ((f92 (get self91 2))) (let ((self93 f91)) (case (get self93 0) ('Parser.State.new (let ((f93 (get self93 1))) (let ((f94 (get self93 2))) (let ((f95 (get self93 3))) (let ((f96 (get self93 4))) (let ((f97 (get self93 5))) (let ((reply.pst$99 ($Parser.State.new ($Parser.Error.maybe_combine f85 f93) f94 f95 f96 f97))) (let ((self99 reply.pst$99)) (case (get self99 0) ('Parser.State.new (let ((f99 (get self99 1))) (let ((f100 (get self99 2))) (let ((f101 (get self99 3))) (let ((f102 (get self99 4))) (let ((f103 (get self99 5))) (let ((reply$105 ($Kind.Parser.text ":" reply.pst$99))) (let ((self105 reply$105)) (case (get self105 0) ('Parser.Reply.error (let ((f105 (get self105 1))) (let ((self106 f99)) (case (get self106 0) ('Maybe.none ($Parser.Reply.error f105)) ('Maybe.some (let ((f106 (get self106 1))) ($Parser.Reply.error ($Parser.Error.combine f106 f105)))))))) ('Parser.Reply.value (let ((f105 (get self105 1))) (let ((f106 (get self105 2))) (let ((self107 f105)) (case (get self107 0) ('Parser.State.new (let ((f107 (get self107 1))) (let ((f108 (get self107 2))) (let ((f109 (get self107 3))) (let ((f110 (get self107 4))) (let ((f111 (get self107 5))) (let ((reply.pst$113 ($Parser.State.new ($Parser.Error.maybe_combine f99 f107) f108 f109 f110 f111))) (let ((self113 reply.pst$113)) (case (get self113 0) ('Parser.State.new (let ((f113 (get self113 1))) (let ((f114 (get self113 2))) (let ((f115 (get self113 3))) (let ((f116 (get self113 4))) (let ((f117 (get self113 5))) (let ((reply$119 (Kind.Parser.term reply.pst$113))) (let ((self119 reply$119)) (case (get self119 0) ('Parser.Reply.error (let ((f119 (get self119 1))) (let ((self120 f113)) (case (get self120 0) ('Maybe.none ($Parser.Reply.error f119)) ('Maybe.some (let ((f120 (get self120 1))) ($Parser.Reply.error ($Parser.Error.combine f120 f119)))))))) ('Parser.Reply.value (let ((f119 (get self119 1))) (let ((f120 (get self119 2))) (let ((self121 f119)) (case (get self121 0) ('Parser.State.new (let ((f121 (get self121 1))) (let ((f122 (get self121 2))) (let ((f123 (get self121 3))) (let ((f124 (get self121 4))) (let ((f125 (get self121 5))) (let ((reply.pst$127 ($Parser.State.new ($Parser.Error.maybe_combine f113 f121) f122 f123 f124 f125))) (let ((self127 reply.pst$127)) (case (get self127 0) ('Parser.State.new (let ((f127 (get self127 1))) (let ((f128 (get self127 2))) (let ((f129 (get self127 3))) (let ((f130 (get self127 4))) (let ((f131 (get self127 5))) (let ((reply$133 ($Parser.maybe (Kind.Parser.text ";") reply.pst$127))) (let ((self133 reply$133)) (case (get self133 0) ('Parser.Reply.error (let ((f133 (get self133 1))) (let ((self134 f127)) (case (get self134 0) ('Maybe.none ($Parser.Reply.error f133)) ('Maybe.some (let ((f134 (get self134 1))) ($Parser.Reply.error ($Parser.Error.combine f134 f133)))))))) ('Parser.Reply.value (let ((f133 (get self133 1))) (let ((f134 (get self133 2))) (let ((self135 f133)) (case (get self135 0) ('Parser.State.new (let ((f135 (get self135 1))) (let ((f136 (get self135 2))) (let ((f137 (get self135 3))) (let ((f138 (get self135 4))) (let ((f139 (get self135 5))) (let ((reply.pst$141 ($Parser.State.new ($Parser.Error.maybe_combine f127 f135) f136 f137 f138 f139))) (let ((self141 reply.pst$141)) (case (get self141 0) ('Parser.State.new (let ((f141 (get self141 1))) (let ((f142 (get self141 2))) (let ((f143 (get self141 3))) (let ((f144 (get self141 4))) (let ((f145 (get self141 5))) (let ((reply$147 ((body$0 Unit.new) reply.pst$141))) (let ((self147 reply$147)) (case (get self147 0) ('Parser.Reply.error (let ((f147 (get self147 1))) (let ((self148 f141)) (case (get self148 0) ('Maybe.none ($Parser.Reply.error f147)) ('Maybe.some (let ((f148 (get self148 1))) ($Parser.Reply.error ($Parser.Error.combine f148 f147)))))))) ('Parser.Reply.value (let ((f147 (get self147 1))) (let ((f148 (get self147 2))) (let ((self149 f147)) (case (get self149 0) ('Parser.State.new (let ((f149 (get self149 1))) (let ((f150 (get self149 2))) (let ((f151 (get self149 3))) (let ((f152 (get self149 4))) (let ((f153 (get self149 5))) (let ((reply.pst$155 ($Parser.State.new ($Parser.Error.maybe_combine f141 f149) f150 f151 f152 f153))) (let ((term$156 ($Kind.Term.ref "List.for"))) (let ((term$157 ($Kind.Term.app term$156 ($Kind.Term.hol Bits.e)))) (let ((term$158 ($Kind.Term.app term$157 f92))) (let ((term$159 ($Kind.Term.app term$158 ($Kind.Term.hol Bits.e)))) (let ((term$160 ($Kind.Term.app term$159 ($Kind.Term.ref f22)))) (let ((lamb$161 ($Kind.Term.lam f64 (lambda (i$161) ($Kind.Term.lam f22 (lambda (x$162) f120)))))) (let ((term$162 ($Kind.Term.app term$160 lamb$161))) (let ((term$163 ($Kind.Term.let f22 term$162 (lambda (x$163) f148)))) ($Parser.Reply.value reply.pst$155 term$163)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.letforin (lambda (body$0) ($Kind.Parser.letforin body$0)))
(define ($Kind.Parser.letforin.with body$0) ((Kind.Parser.block "for") (lambda (pst$1) (let ((self1 pst$1)) (case (get self1 0) ('Parser.State.new (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((reply$7 ($Kind.Parser.text "for " pst$1))) (let ((self7 reply$7)) (case (get self7 0) ('Parser.Reply.error (let ((f7 (get self7 1))) (let ((self8 f1)) (case (get self8 0) ('Maybe.none ($Parser.Reply.error f7)) ('Maybe.some (let ((f8 (get self8 1))) ($Parser.Reply.error ($Parser.Error.combine f8 f7)))))))) ('Parser.Reply.value (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((self9 f7)) (case (get self9 0) ('Parser.State.new (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) (let ((reply.pst$15 ($Parser.State.new ($Parser.Error.maybe_combine f1 f9) f10 f11 f12 f13))) (let ((self15 reply.pst$15)) (case (get self15 0) ('Parser.State.new (let ((f15 (get self15 1))) (let ((f16 (get self15 2))) (let ((f17 (get self15 3))) (let ((f18 (get self15 4))) (let ((f19 (get self15 5))) (let ((reply$21 ($Kind.Parser.name1 reply.pst$15))) (let ((self21 reply$21)) (case (get self21 0) ('Parser.Reply.error (let ((f21 (get self21 1))) (let ((self22 f15)) (case (get self22 0) ('Maybe.none ($Parser.Reply.error f21)) ('Maybe.some (let ((f22 (get self22 1))) ($Parser.Reply.error ($Parser.Error.combine f22 f21)))))))) ('Parser.Reply.value (let ((f21 (get self21 1))) (let ((f22 (get self21 2))) (let ((self23 f21)) (case (get self23 0) ('Parser.State.new (let ((f23 (get self23 1))) (let ((f24 (get self23 2))) (let ((f25 (get self23 3))) (let ((f26 (get self23 4))) (let ((f27 (get self23 5))) (let ((reply.pst$29 ($Parser.State.new ($Parser.Error.maybe_combine f15 f23) f24 f25 f26 f27))) (let ((self29 reply.pst$29)) (case (get self29 0) ('Parser.State.new (let ((f29 (get self29 1))) (let ((f30 (get self29 2))) (let ((f31 (get self29 3))) (let ((f32 (get self29 4))) (let ((f33 (get self29 5))) (let ((reply$35 ($Kind.Parser.text "in" reply.pst$29))) (let ((self35 reply$35)) (case (get self35 0) ('Parser.Reply.error (let ((f35 (get self35 1))) (let ((self36 f29)) (case (get self36 0) ('Maybe.none ($Parser.Reply.error f35)) ('Maybe.some (let ((f36 (get self36 1))) ($Parser.Reply.error ($Parser.Error.combine f36 f35)))))))) ('Parser.Reply.value (let ((f35 (get self35 1))) (let ((f36 (get self35 2))) (let ((self37 f35)) (case (get self37 0) ('Parser.State.new (let ((f37 (get self37 1))) (let ((f38 (get self37 2))) (let ((f39 (get self37 3))) (let ((f40 (get self37 4))) (let ((f41 (get self37 5))) (let ((reply.pst$43 ($Parser.State.new ($Parser.Error.maybe_combine f29 f37) f38 f39 f40 f41))) (let ((self43 reply.pst$43)) (case (get self43 0) ('Parser.State.new (let ((f43 (get self43 1))) (let ((f44 (get self43 2))) (let ((f45 (get self43 3))) (let ((f46 (get self43 4))) (let ((f47 (get self43 5))) (let ((reply$49 (Kind.Parser.term reply.pst$43))) (let ((self49 reply$49)) (case (get self49 0) ('Parser.Reply.error (let ((f49 (get self49 1))) (let ((self50 f43)) (case (get self50 0) ('Maybe.none ($Parser.Reply.error f49)) ('Maybe.some (let ((f50 (get self50 1))) ($Parser.Reply.error ($Parser.Error.combine f50 f49)))))))) ('Parser.Reply.value (let ((f49 (get self49 1))) (let ((f50 (get self49 2))) (let ((self51 f49)) (case (get self51 0) ('Parser.State.new (let ((f51 (get self51 1))) (let ((f52 (get self51 2))) (let ((f53 (get self51 3))) (let ((f54 (get self51 4))) (let ((f55 (get self51 5))) (let ((reply.pst$57 ($Parser.State.new ($Parser.Error.maybe_combine f43 f51) f52 f53 f54 f55))) (let ((self57 reply.pst$57)) (case (get self57 0) ('Parser.State.new (let ((f57 (get self57 1))) (let ((f58 (get self57 2))) (let ((f59 (get self57 3))) (let ((f60 (get self57 4))) (let ((f61 (get self57 5))) (let ((reply$63 ($Kind.Parser.text "with" reply.pst$57))) (let ((self63 reply$63)) (case (get self63 0) ('Parser.Reply.error (let ((f63 (get self63 1))) (let ((self64 f57)) (case (get self64 0) ('Maybe.none ($Parser.Reply.error f63)) ('Maybe.some (let ((f64 (get self64 1))) ($Parser.Reply.error ($Parser.Error.combine f64 f63)))))))) ('Parser.Reply.value (let ((f63 (get self63 1))) (let ((f64 (get self63 2))) (let ((self65 f63)) (case (get self65 0) ('Parser.State.new (let ((f65 (get self65 1))) (let ((f66 (get self65 2))) (let ((f67 (get self65 3))) (let ((f68 (get self65 4))) (let ((f69 (get self65 5))) (let ((reply.pst$71 ($Parser.State.new ($Parser.Error.maybe_combine f57 f65) f66 f67 f68 f69))) (let ((self71 reply.pst$71)) (case (get self71 0) ('Parser.State.new (let ((f71 (get self71 1))) (let ((f72 (get self71 2))) (let ((f73 (get self71 3))) (let ((f74 (get self71 4))) (let ((f75 (get self71 5))) (let ((reply$77 ($Kind.Parser.name1 reply.pst$71))) (let ((self77 reply$77)) (case (get self77 0) ('Parser.Reply.error (let ((f77 (get self77 1))) (let ((self78 f71)) (case (get self78 0) ('Maybe.none ($Parser.Reply.error f77)) ('Maybe.some (let ((f78 (get self78 1))) ($Parser.Reply.error ($Parser.Error.combine f78 f77)))))))) ('Parser.Reply.value (let ((f77 (get self77 1))) (let ((f78 (get self77 2))) (let ((self79 f77)) (case (get self79 0) ('Parser.State.new (let ((f79 (get self79 1))) (let ((f80 (get self79 2))) (let ((f81 (get self79 3))) (let ((f82 (get self79 4))) (let ((f83 (get self79 5))) (let ((reply.pst$85 ($Parser.State.new ($Parser.Error.maybe_combine f71 f79) f80 f81 f82 f83))) (let ((self85 reply.pst$85)) (case (get self85 0) ('Parser.State.new (let ((f85 (get self85 1))) (let ((f86 (get self85 2))) (let ((f87 (get self85 3))) (let ((f88 (get self85 4))) (let ((f89 (get self85 5))) (let ((reply$91 ($Kind.Parser.text ":" reply.pst$85))) (let ((self91 reply$91)) (case (get self91 0) ('Parser.Reply.error (let ((f91 (get self91 1))) (let ((self92 f85)) (case (get self92 0) ('Maybe.none ($Parser.Reply.error f91)) ('Maybe.some (let ((f92 (get self92 1))) ($Parser.Reply.error ($Parser.Error.combine f92 f91)))))))) ('Parser.Reply.value (let ((f91 (get self91 1))) (let ((f92 (get self91 2))) (let ((self93 f91)) (case (get self93 0) ('Parser.State.new (let ((f93 (get self93 1))) (let ((f94 (get self93 2))) (let ((f95 (get self93 3))) (let ((f96 (get self93 4))) (let ((f97 (get self93 5))) (let ((reply.pst$99 ($Parser.State.new ($Parser.Error.maybe_combine f85 f93) f94 f95 f96 f97))) (let ((self99 reply.pst$99)) (case (get self99 0) ('Parser.State.new (let ((f99 (get self99 1))) (let ((f100 (get self99 2))) (let ((f101 (get self99 3))) (let ((f102 (get self99 4))) (let ((f103 (get self99 5))) (let ((reply$105 (Kind.Parser.term reply.pst$99))) (let ((self105 reply$105)) (case (get self105 0) ('Parser.Reply.error (let ((f105 (get self105 1))) (let ((self106 f99)) (case (get self106 0) ('Maybe.none ($Parser.Reply.error f105)) ('Maybe.some (let ((f106 (get self106 1))) ($Parser.Reply.error ($Parser.Error.combine f106 f105)))))))) ('Parser.Reply.value (let ((f105 (get self105 1))) (let ((f106 (get self105 2))) (let ((self107 f105)) (case (get self107 0) ('Parser.State.new (let ((f107 (get self107 1))) (let ((f108 (get self107 2))) (let ((f109 (get self107 3))) (let ((f110 (get self107 4))) (let ((f111 (get self107 5))) (let ((reply.pst$113 ($Parser.State.new ($Parser.Error.maybe_combine f99 f107) f108 f109 f110 f111))) (let ((self113 reply.pst$113)) (case (get self113 0) ('Parser.State.new (let ((f113 (get self113 1))) (let ((f114 (get self113 2))) (let ((f115 (get self113 3))) (let ((f116 (get self113 4))) (let ((f117 (get self113 5))) (let ((reply$119 ($Parser.maybe (Kind.Parser.text ";") reply.pst$113))) (let ((self119 reply$119)) (case (get self119 0) ('Parser.Reply.error (let ((f119 (get self119 1))) (let ((self120 f113)) (case (get self120 0) ('Maybe.none ($Parser.Reply.error f119)) ('Maybe.some (let ((f120 (get self120 1))) ($Parser.Reply.error ($Parser.Error.combine f120 f119)))))))) ('Parser.Reply.value (let ((f119 (get self119 1))) (let ((f120 (get self119 2))) (let ((self121 f119)) (case (get self121 0) ('Parser.State.new (let ((f121 (get self121 1))) (let ((f122 (get self121 2))) (let ((f123 (get self121 3))) (let ((f124 (get self121 4))) (let ((f125 (get self121 5))) (let ((reply.pst$127 ($Parser.State.new ($Parser.Error.maybe_combine f113 f121) f122 f123 f124 f125))) (let ((self127 reply.pst$127)) (case (get self127 0) ('Parser.State.new (let ((f127 (get self127 1))) (let ((f128 (get self127 2))) (let ((f129 (get self127 3))) (let ((f130 (get self127 4))) (let ((f131 (get self127 5))) (let ((reply$133 ((body$0 Unit.new) reply.pst$127))) (let ((self133 reply$133)) (case (get self133 0) ('Parser.Reply.error (let ((f133 (get self133 1))) (let ((self134 f127)) (case (get self134 0) ('Maybe.none ($Parser.Reply.error f133)) ('Maybe.some (let ((f134 (get self134 1))) ($Parser.Reply.error ($Parser.Error.combine f134 f133)))))))) ('Parser.Reply.value (let ((f133 (get self133 1))) (let ((f134 (get self133 2))) (let ((self135 f133)) (case (get self135 0) ('Parser.State.new (let ((f135 (get self135 1))) (let ((f136 (get self135 2))) (let ((f137 (get self135 3))) (let ((f138 (get self135 4))) (let ((f139 (get self135 5))) (let ((reply.pst$141 ($Parser.State.new ($Parser.Error.maybe_combine f127 f135) f136 f137 f138 f139))) (let ((term$142 ($Kind.Term.ref "List.for"))) (let ((term$143 ($Kind.Term.app term$142 ($Kind.Term.hol Bits.e)))) (let ((term$144 ($Kind.Term.app term$143 f50))) (let ((term$145 ($Kind.Term.app term$144 ($Kind.Term.hol Bits.e)))) (let ((term$146 ($Kind.Term.app term$145 ($Kind.Term.ref f78)))) (let ((lamb$147 ($Kind.Term.lam f22 (lambda (i$147) ($Kind.Term.lam f78 (lambda (x$148) f106)))))) (let ((term$148 ($Kind.Term.app term$146 lamb$147))) (let ((term$149 ($Kind.Term.let f78 term$148 (lambda (x$149) f134)))) ($Parser.Reply.value reply.pst$141 term$149))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.letforin.with (lambda (body$0) ($Kind.Parser.letforin.with body$0)))
(define ($Kind.Parser.letforinmap body$0) ((Kind.Parser.block "let-for-map") (lambda (pst$1) (let ((self1 pst$1)) (case (get self1 0) ('Parser.State.new (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((reply$7 ($Kind.Parser.text "let " pst$1))) (let ((self7 reply$7)) (case (get self7 0) ('Parser.Reply.error (let ((f7 (get self7 1))) (let ((self8 f1)) (case (get self8 0) ('Maybe.none ($Parser.Reply.error f7)) ('Maybe.some (let ((f8 (get self8 1))) ($Parser.Reply.error ($Parser.Error.combine f8 f7)))))))) ('Parser.Reply.value (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((self9 f7)) (case (get self9 0) ('Parser.State.new (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) (let ((reply.pst$15 ($Parser.State.new ($Parser.Error.maybe_combine f1 f9) f10 f11 f12 f13))) (let ((self15 reply.pst$15)) (case (get self15 0) ('Parser.State.new (let ((f15 (get self15 1))) (let ((f16 (get self15 2))) (let ((f17 (get self15 3))) (let ((f18 (get self15 4))) (let ((f19 (get self15 5))) (let ((reply$21 ($Kind.Parser.name1 reply.pst$15))) (let ((self21 reply$21)) (case (get self21 0) ('Parser.Reply.error (let ((f21 (get self21 1))) (let ((self22 f15)) (case (get self22 0) ('Maybe.none ($Parser.Reply.error f21)) ('Maybe.some (let ((f22 (get self22 1))) ($Parser.Reply.error ($Parser.Error.combine f22 f21)))))))) ('Parser.Reply.value (let ((f21 (get self21 1))) (let ((f22 (get self21 2))) (let ((self23 f21)) (case (get self23 0) ('Parser.State.new (let ((f23 (get self23 1))) (let ((f24 (get self23 2))) (let ((f25 (get self23 3))) (let ((f26 (get self23 4))) (let ((f27 (get self23 5))) (let ((reply.pst$29 ($Parser.State.new ($Parser.Error.maybe_combine f15 f23) f24 f25 f26 f27))) (let ((self29 reply.pst$29)) (case (get self29 0) ('Parser.State.new (let ((f29 (get self29 1))) (let ((f30 (get self29 2))) (let ((f31 (get self29 3))) (let ((f32 (get self29 4))) (let ((f33 (get self29 5))) (let ((reply$35 ($Kind.Parser.text "=" reply.pst$29))) (let ((self35 reply$35)) (case (get self35 0) ('Parser.Reply.error (let ((f35 (get self35 1))) (let ((self36 f29)) (case (get self36 0) ('Maybe.none ($Parser.Reply.error f35)) ('Maybe.some (let ((f36 (get self36 1))) ($Parser.Reply.error ($Parser.Error.combine f36 f35)))))))) ('Parser.Reply.value (let ((f35 (get self35 1))) (let ((f36 (get self35 2))) (let ((self37 f35)) (case (get self37 0) ('Parser.State.new (let ((f37 (get self37 1))) (let ((f38 (get self37 2))) (let ((f39 (get self37 3))) (let ((f40 (get self37 4))) (let ((f41 (get self37 5))) (let ((reply.pst$43 ($Parser.State.new ($Parser.Error.maybe_combine f29 f37) f38 f39 f40 f41))) (let ((self43 reply.pst$43)) (case (get self43 0) ('Parser.State.new (let ((f43 (get self43 1))) (let ((f44 (get self43 2))) (let ((f45 (get self43 3))) (let ((f46 (get self43 4))) (let ((f47 (get self43 5))) (let ((reply$49 ($Kind.Parser.text "for " reply.pst$43))) (let ((self49 reply$49)) (case (get self49 0) ('Parser.Reply.error (let ((f49 (get self49 1))) (let ((self50 f43)) (case (get self50 0) ('Maybe.none ($Parser.Reply.error f49)) ('Maybe.some (let ((f50 (get self50 1))) ($Parser.Reply.error ($Parser.Error.combine f50 f49)))))))) ('Parser.Reply.value (let ((f49 (get self49 1))) (let ((f50 (get self49 2))) (let ((self51 f49)) (case (get self51 0) ('Parser.State.new (let ((f51 (get self51 1))) (let ((f52 (get self51 2))) (let ((f53 (get self51 3))) (let ((f54 (get self51 4))) (let ((f55 (get self51 5))) (let ((reply.pst$57 ($Parser.State.new ($Parser.Error.maybe_combine f43 f51) f52 f53 f54 f55))) (let ((self57 reply.pst$57)) (case (get self57 0) ('Parser.State.new (let ((f57 (get self57 1))) (let ((f58 (get self57 2))) (let ((f59 (get self57 3))) (let ((f60 (get self57 4))) (let ((f61 (get self57 5))) (let ((reply$63 ($Kind.Parser.name1 reply.pst$57))) (let ((self63 reply$63)) (case (get self63 0) ('Parser.Reply.error (let ((f63 (get self63 1))) (let ((self64 f57)) (case (get self64 0) ('Maybe.none ($Parser.Reply.error f63)) ('Maybe.some (let ((f64 (get self64 1))) ($Parser.Reply.error ($Parser.Error.combine f64 f63)))))))) ('Parser.Reply.value (let ((f63 (get self63 1))) (let ((f64 (get self63 2))) (let ((self65 f63)) (case (get self65 0) ('Parser.State.new (let ((f65 (get self65 1))) (let ((f66 (get self65 2))) (let ((f67 (get self65 3))) (let ((f68 (get self65 4))) (let ((f69 (get self65 5))) (let ((reply.pst$71 ($Parser.State.new ($Parser.Error.maybe_combine f57 f65) f66 f67 f68 f69))) (let ((self71 reply.pst$71)) (case (get self71 0) ('Parser.State.new (let ((f71 (get self71 1))) (let ((f72 (get self71 2))) (let ((f73 (get self71 3))) (let ((f74 (get self71 4))) (let ((f75 (get self71 5))) (let ((reply$77 ($Kind.Parser.text ":" reply.pst$71))) (let ((self77 reply$77)) (case (get self77 0) ('Parser.Reply.error (let ((f77 (get self77 1))) (let ((self78 f71)) (case (get self78 0) ('Maybe.none ($Parser.Reply.error f77)) ('Maybe.some (let ((f78 (get self78 1))) ($Parser.Reply.error ($Parser.Error.combine f78 f77)))))))) ('Parser.Reply.value (let ((f77 (get self77 1))) (let ((f78 (get self77 2))) (let ((self79 f77)) (case (get self79 0) ('Parser.State.new (let ((f79 (get self79 1))) (let ((f80 (get self79 2))) (let ((f81 (get self79 3))) (let ((f82 (get self79 4))) (let ((f83 (get self79 5))) (let ((reply.pst$85 ($Parser.State.new ($Parser.Error.maybe_combine f71 f79) f80 f81 f82 f83))) (let ((self85 reply.pst$85)) (case (get self85 0) ('Parser.State.new (let ((f85 (get self85 1))) (let ((f86 (get self85 2))) (let ((f87 (get self85 3))) (let ((f88 (get self85 4))) (let ((f89 (get self85 5))) (let ((reply$91 ($Kind.Parser.name1 reply.pst$85))) (let ((self91 reply$91)) (case (get self91 0) ('Parser.Reply.error (let ((f91 (get self91 1))) (let ((self92 f85)) (case (get self92 0) ('Maybe.none ($Parser.Reply.error f91)) ('Maybe.some (let ((f92 (get self92 1))) ($Parser.Reply.error ($Parser.Error.combine f92 f91)))))))) ('Parser.Reply.value (let ((f91 (get self91 1))) (let ((f92 (get self91 2))) (let ((self93 f91)) (case (get self93 0) ('Parser.State.new (let ((f93 (get self93 1))) (let ((f94 (get self93 2))) (let ((f95 (get self93 3))) (let ((f96 (get self93 4))) (let ((f97 (get self93 5))) (let ((reply.pst$99 ($Parser.State.new ($Parser.Error.maybe_combine f85 f93) f94 f95 f96 f97))) (let ((self99 reply.pst$99)) (case (get self99 0) ('Parser.State.new (let ((f99 (get self99 1))) (let ((f100 (get self99 2))) (let ((f101 (get self99 3))) (let ((f102 (get self99 4))) (let ((f103 (get self99 5))) (let ((reply$105 ($Kind.Parser.text "in" reply.pst$99))) (let ((self105 reply$105)) (case (get self105 0) ('Parser.Reply.error (let ((f105 (get self105 1))) (let ((self106 f99)) (case (get self106 0) ('Maybe.none ($Parser.Reply.error f105)) ('Maybe.some (let ((f106 (get self106 1))) ($Parser.Reply.error ($Parser.Error.combine f106 f105)))))))) ('Parser.Reply.value (let ((f105 (get self105 1))) (let ((f106 (get self105 2))) (let ((self107 f105)) (case (get self107 0) ('Parser.State.new (let ((f107 (get self107 1))) (let ((f108 (get self107 2))) (let ((f109 (get self107 3))) (let ((f110 (get self107 4))) (let ((f111 (get self107 5))) (let ((reply.pst$113 ($Parser.State.new ($Parser.Error.maybe_combine f99 f107) f108 f109 f110 f111))) (let ((self113 reply.pst$113)) (case (get self113 0) ('Parser.State.new (let ((f113 (get self113 1))) (let ((f114 (get self113 2))) (let ((f115 (get self113 3))) (let ((f116 (get self113 4))) (let ((f117 (get self113 5))) (let ((reply$119 (Kind.Parser.term reply.pst$113))) (let ((self119 reply$119)) (case (get self119 0) ('Parser.Reply.error (let ((f119 (get self119 1))) (let ((self120 f113)) (case (get self120 0) ('Maybe.none ($Parser.Reply.error f119)) ('Maybe.some (let ((f120 (get self120 1))) ($Parser.Reply.error ($Parser.Error.combine f120 f119)))))))) ('Parser.Reply.value (let ((f119 (get self119 1))) (let ((f120 (get self119 2))) (let ((self121 f119)) (case (get self121 0) ('Parser.State.new (let ((f121 (get self121 1))) (let ((f122 (get self121 2))) (let ((f123 (get self121 3))) (let ((f124 (get self121 4))) (let ((f125 (get self121 5))) (let ((reply.pst$127 ($Parser.State.new ($Parser.Error.maybe_combine f113 f121) f122 f123 f124 f125))) (let ((self127 reply.pst$127)) (case (get self127 0) ('Parser.State.new (let ((f127 (get self127 1))) (let ((f128 (get self127 2))) (let ((f129 (get self127 3))) (let ((f130 (get self127 4))) (let ((f131 (get self127 5))) (let ((reply$133 ($Kind.Parser.text ":" reply.pst$127))) (let ((self133 reply$133)) (case (get self133 0) ('Parser.Reply.error (let ((f133 (get self133 1))) (let ((self134 f127)) (case (get self134 0) ('Maybe.none ($Parser.Reply.error f133)) ('Maybe.some (let ((f134 (get self134 1))) ($Parser.Reply.error ($Parser.Error.combine f134 f133)))))))) ('Parser.Reply.value (let ((f133 (get self133 1))) (let ((f134 (get self133 2))) (let ((self135 f133)) (case (get self135 0) ('Parser.State.new (let ((f135 (get self135 1))) (let ((f136 (get self135 2))) (let ((f137 (get self135 3))) (let ((f138 (get self135 4))) (let ((f139 (get self135 5))) (let ((reply.pst$141 ($Parser.State.new ($Parser.Error.maybe_combine f127 f135) f136 f137 f138 f139))) (let ((self141 reply.pst$141)) (case (get self141 0) ('Parser.State.new (let ((f141 (get self141 1))) (let ((f142 (get self141 2))) (let ((f143 (get self141 3))) (let ((f144 (get self141 4))) (let ((f145 (get self141 5))) (let ((reply$147 (Kind.Parser.term reply.pst$141))) (let ((self147 reply$147)) (case (get self147 0) ('Parser.Reply.error (let ((f147 (get self147 1))) (let ((self148 f141)) (case (get self148 0) ('Maybe.none ($Parser.Reply.error f147)) ('Maybe.some (let ((f148 (get self148 1))) ($Parser.Reply.error ($Parser.Error.combine f148 f147)))))))) ('Parser.Reply.value (let ((f147 (get self147 1))) (let ((f148 (get self147 2))) (let ((self149 f147)) (case (get self149 0) ('Parser.State.new (let ((f149 (get self149 1))) (let ((f150 (get self149 2))) (let ((f151 (get self149 3))) (let ((f152 (get self149 4))) (let ((f153 (get self149 5))) (let ((reply.pst$155 ($Parser.State.new ($Parser.Error.maybe_combine f141 f149) f150 f151 f152 f153))) (let ((self155 reply.pst$155)) (case (get self155 0) ('Parser.State.new (let ((f155 (get self155 1))) (let ((f156 (get self155 2))) (let ((f157 (get self155 3))) (let ((f158 (get self155 4))) (let ((f159 (get self155 5))) (let ((reply$161 ($Parser.maybe (Kind.Parser.text ";") reply.pst$155))) (let ((self161 reply$161)) (case (get self161 0) ('Parser.Reply.error (let ((f161 (get self161 1))) (let ((self162 f155)) (case (get self162 0) ('Maybe.none ($Parser.Reply.error f161)) ('Maybe.some (let ((f162 (get self162 1))) ($Parser.Reply.error ($Parser.Error.combine f162 f161)))))))) ('Parser.Reply.value (let ((f161 (get self161 1))) (let ((f162 (get self161 2))) (let ((self163 f161)) (case (get self163 0) ('Parser.State.new (let ((f163 (get self163 1))) (let ((f164 (get self163 2))) (let ((f165 (get self163 3))) (let ((f166 (get self163 4))) (let ((f167 (get self163 5))) (let ((reply.pst$169 ($Parser.State.new ($Parser.Error.maybe_combine f155 f163) f164 f165 f166 f167))) (let ((self169 reply.pst$169)) (case (get self169 0) ('Parser.State.new (let ((f169 (get self169 1))) (let ((f170 (get self169 2))) (let ((f171 (get self169 3))) (let ((f172 (get self169 4))) (let ((f173 (get self169 5))) (let ((reply$175 ((body$0 Unit.new) reply.pst$169))) (let ((self175 reply$175)) (case (get self175 0) ('Parser.Reply.error (let ((f175 (get self175 1))) (let ((self176 f169)) (case (get self176 0) ('Maybe.none ($Parser.Reply.error f175)) ('Maybe.some (let ((f176 (get self176 1))) ($Parser.Reply.error ($Parser.Error.combine f176 f175)))))))) ('Parser.Reply.value (let ((f175 (get self175 1))) (let ((f176 (get self175 2))) (let ((self177 f175)) (case (get self177 0) ('Parser.State.new (let ((f177 (get self177 1))) (let ((f178 (get self177 2))) (let ((f179 (get self177 3))) (let ((f180 (get self177 4))) (let ((f181 (get self177 5))) (let ((reply.pst$183 ($Parser.State.new ($Parser.Error.maybe_combine f169 f177) f178 f179 f180 f181))) (let ((term$184 ($Kind.Term.ref "BBT.for"))) (let ((term$185 ($Kind.Term.app term$184 ($Kind.Term.hol Bits.e)))) (let ((term$186 ($Kind.Term.app term$185 ($Kind.Term.hol Bits.e)))) (let ((term$187 ($Kind.Term.app term$186 f120))) (let ((term$188 ($Kind.Term.app term$187 ($Kind.Term.hol Bits.e)))) (let ((term$189 ($Kind.Term.app term$188 ($Kind.Term.ref f22)))) (let ((lamb$190 ($Kind.Term.lam f64 (lambda (k$190) ($Kind.Term.lam f92 (lambda (i$191) ($Kind.Term.lam f22 (lambda (x$192) f148)))))))) (let ((term$191 ($Kind.Term.app term$189 lamb$190))) (let ((term$192 ($Kind.Term.let f22 term$191 (lambda (x$192) f176)))) ($Parser.Reply.value reply.pst$183 term$192))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.letforinmap (lambda (body$0) ($Kind.Parser.letforinmap body$0)))
(define ($Kind.Parser.letforinmap.with body$0) ((Kind.Parser.block "for-map") (lambda (pst$1) (let ((self1 pst$1)) (case (get self1 0) ('Parser.State.new (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((reply$7 ($Kind.Parser.text "for " pst$1))) (let ((self7 reply$7)) (case (get self7 0) ('Parser.Reply.error (let ((f7 (get self7 1))) (let ((self8 f1)) (case (get self8 0) ('Maybe.none ($Parser.Reply.error f7)) ('Maybe.some (let ((f8 (get self8 1))) ($Parser.Reply.error ($Parser.Error.combine f8 f7)))))))) ('Parser.Reply.value (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((self9 f7)) (case (get self9 0) ('Parser.State.new (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) (let ((reply.pst$15 ($Parser.State.new ($Parser.Error.maybe_combine f1 f9) f10 f11 f12 f13))) (let ((self15 reply.pst$15)) (case (get self15 0) ('Parser.State.new (let ((f15 (get self15 1))) (let ((f16 (get self15 2))) (let ((f17 (get self15 3))) (let ((f18 (get self15 4))) (let ((f19 (get self15 5))) (let ((reply$21 ($Kind.Parser.name1 reply.pst$15))) (let ((self21 reply$21)) (case (get self21 0) ('Parser.Reply.error (let ((f21 (get self21 1))) (let ((self22 f15)) (case (get self22 0) ('Maybe.none ($Parser.Reply.error f21)) ('Maybe.some (let ((f22 (get self22 1))) ($Parser.Reply.error ($Parser.Error.combine f22 f21)))))))) ('Parser.Reply.value (let ((f21 (get self21 1))) (let ((f22 (get self21 2))) (let ((self23 f21)) (case (get self23 0) ('Parser.State.new (let ((f23 (get self23 1))) (let ((f24 (get self23 2))) (let ((f25 (get self23 3))) (let ((f26 (get self23 4))) (let ((f27 (get self23 5))) (let ((reply.pst$29 ($Parser.State.new ($Parser.Error.maybe_combine f15 f23) f24 f25 f26 f27))) (let ((self29 reply.pst$29)) (case (get self29 0) ('Parser.State.new (let ((f29 (get self29 1))) (let ((f30 (get self29 2))) (let ((f31 (get self29 3))) (let ((f32 (get self29 4))) (let ((f33 (get self29 5))) (let ((reply$35 ($Kind.Parser.text ":" reply.pst$29))) (let ((self35 reply$35)) (case (get self35 0) ('Parser.Reply.error (let ((f35 (get self35 1))) (let ((self36 f29)) (case (get self36 0) ('Maybe.none ($Parser.Reply.error f35)) ('Maybe.some (let ((f36 (get self36 1))) ($Parser.Reply.error ($Parser.Error.combine f36 f35)))))))) ('Parser.Reply.value (let ((f35 (get self35 1))) (let ((f36 (get self35 2))) (let ((self37 f35)) (case (get self37 0) ('Parser.State.new (let ((f37 (get self37 1))) (let ((f38 (get self37 2))) (let ((f39 (get self37 3))) (let ((f40 (get self37 4))) (let ((f41 (get self37 5))) (let ((reply.pst$43 ($Parser.State.new ($Parser.Error.maybe_combine f29 f37) f38 f39 f40 f41))) (let ((self43 reply.pst$43)) (case (get self43 0) ('Parser.State.new (let ((f43 (get self43 1))) (let ((f44 (get self43 2))) (let ((f45 (get self43 3))) (let ((f46 (get self43 4))) (let ((f47 (get self43 5))) (let ((reply$49 ($Kind.Parser.name1 reply.pst$43))) (let ((self49 reply$49)) (case (get self49 0) ('Parser.Reply.error (let ((f49 (get self49 1))) (let ((self50 f43)) (case (get self50 0) ('Maybe.none ($Parser.Reply.error f49)) ('Maybe.some (let ((f50 (get self50 1))) ($Parser.Reply.error ($Parser.Error.combine f50 f49)))))))) ('Parser.Reply.value (let ((f49 (get self49 1))) (let ((f50 (get self49 2))) (let ((self51 f49)) (case (get self51 0) ('Parser.State.new (let ((f51 (get self51 1))) (let ((f52 (get self51 2))) (let ((f53 (get self51 3))) (let ((f54 (get self51 4))) (let ((f55 (get self51 5))) (let ((reply.pst$57 ($Parser.State.new ($Parser.Error.maybe_combine f43 f51) f52 f53 f54 f55))) (let ((self57 reply.pst$57)) (case (get self57 0) ('Parser.State.new (let ((f57 (get self57 1))) (let ((f58 (get self57 2))) (let ((f59 (get self57 3))) (let ((f60 (get self57 4))) (let ((f61 (get self57 5))) (let ((reply$63 ($Kind.Parser.text "in" reply.pst$57))) (let ((self63 reply$63)) (case (get self63 0) ('Parser.Reply.error (let ((f63 (get self63 1))) (let ((self64 f57)) (case (get self64 0) ('Maybe.none ($Parser.Reply.error f63)) ('Maybe.some (let ((f64 (get self64 1))) ($Parser.Reply.error ($Parser.Error.combine f64 f63)))))))) ('Parser.Reply.value (let ((f63 (get self63 1))) (let ((f64 (get self63 2))) (let ((self65 f63)) (case (get self65 0) ('Parser.State.new (let ((f65 (get self65 1))) (let ((f66 (get self65 2))) (let ((f67 (get self65 3))) (let ((f68 (get self65 4))) (let ((f69 (get self65 5))) (let ((reply.pst$71 ($Parser.State.new ($Parser.Error.maybe_combine f57 f65) f66 f67 f68 f69))) (let ((self71 reply.pst$71)) (case (get self71 0) ('Parser.State.new (let ((f71 (get self71 1))) (let ((f72 (get self71 2))) (let ((f73 (get self71 3))) (let ((f74 (get self71 4))) (let ((f75 (get self71 5))) (let ((reply$77 (Kind.Parser.term reply.pst$71))) (let ((self77 reply$77)) (case (get self77 0) ('Parser.Reply.error (let ((f77 (get self77 1))) (let ((self78 f71)) (case (get self78 0) ('Maybe.none ($Parser.Reply.error f77)) ('Maybe.some (let ((f78 (get self78 1))) ($Parser.Reply.error ($Parser.Error.combine f78 f77)))))))) ('Parser.Reply.value (let ((f77 (get self77 1))) (let ((f78 (get self77 2))) (let ((self79 f77)) (case (get self79 0) ('Parser.State.new (let ((f79 (get self79 1))) (let ((f80 (get self79 2))) (let ((f81 (get self79 3))) (let ((f82 (get self79 4))) (let ((f83 (get self79 5))) (let ((reply.pst$85 ($Parser.State.new ($Parser.Error.maybe_combine f71 f79) f80 f81 f82 f83))) (let ((self85 reply.pst$85)) (case (get self85 0) ('Parser.State.new (let ((f85 (get self85 1))) (let ((f86 (get self85 2))) (let ((f87 (get self85 3))) (let ((f88 (get self85 4))) (let ((f89 (get self85 5))) (let ((reply$91 ($Kind.Parser.text "with" reply.pst$85))) (let ((self91 reply$91)) (case (get self91 0) ('Parser.Reply.error (let ((f91 (get self91 1))) (let ((self92 f85)) (case (get self92 0) ('Maybe.none ($Parser.Reply.error f91)) ('Maybe.some (let ((f92 (get self92 1))) ($Parser.Reply.error ($Parser.Error.combine f92 f91)))))))) ('Parser.Reply.value (let ((f91 (get self91 1))) (let ((f92 (get self91 2))) (let ((self93 f91)) (case (get self93 0) ('Parser.State.new (let ((f93 (get self93 1))) (let ((f94 (get self93 2))) (let ((f95 (get self93 3))) (let ((f96 (get self93 4))) (let ((f97 (get self93 5))) (let ((reply.pst$99 ($Parser.State.new ($Parser.Error.maybe_combine f85 f93) f94 f95 f96 f97))) (let ((self99 reply.pst$99)) (case (get self99 0) ('Parser.State.new (let ((f99 (get self99 1))) (let ((f100 (get self99 2))) (let ((f101 (get self99 3))) (let ((f102 (get self99 4))) (let ((f103 (get self99 5))) (let ((reply$105 ($Kind.Parser.name1 reply.pst$99))) (let ((self105 reply$105)) (case (get self105 0) ('Parser.Reply.error (let ((f105 (get self105 1))) (let ((self106 f99)) (case (get self106 0) ('Maybe.none ($Parser.Reply.error f105)) ('Maybe.some (let ((f106 (get self106 1))) ($Parser.Reply.error ($Parser.Error.combine f106 f105)))))))) ('Parser.Reply.value (let ((f105 (get self105 1))) (let ((f106 (get self105 2))) (let ((self107 f105)) (case (get self107 0) ('Parser.State.new (let ((f107 (get self107 1))) (let ((f108 (get self107 2))) (let ((f109 (get self107 3))) (let ((f110 (get self107 4))) (let ((f111 (get self107 5))) (let ((reply.pst$113 ($Parser.State.new ($Parser.Error.maybe_combine f99 f107) f108 f109 f110 f111))) (let ((self113 reply.pst$113)) (case (get self113 0) ('Parser.State.new (let ((f113 (get self113 1))) (let ((f114 (get self113 2))) (let ((f115 (get self113 3))) (let ((f116 (get self113 4))) (let ((f117 (get self113 5))) (let ((reply$119 ($Kind.Parser.text ":" reply.pst$113))) (let ((self119 reply$119)) (case (get self119 0) ('Parser.Reply.error (let ((f119 (get self119 1))) (let ((self120 f113)) (case (get self120 0) ('Maybe.none ($Parser.Reply.error f119)) ('Maybe.some (let ((f120 (get self120 1))) ($Parser.Reply.error ($Parser.Error.combine f120 f119)))))))) ('Parser.Reply.value (let ((f119 (get self119 1))) (let ((f120 (get self119 2))) (let ((self121 f119)) (case (get self121 0) ('Parser.State.new (let ((f121 (get self121 1))) (let ((f122 (get self121 2))) (let ((f123 (get self121 3))) (let ((f124 (get self121 4))) (let ((f125 (get self121 5))) (let ((reply.pst$127 ($Parser.State.new ($Parser.Error.maybe_combine f113 f121) f122 f123 f124 f125))) (let ((self127 reply.pst$127)) (case (get self127 0) ('Parser.State.new (let ((f127 (get self127 1))) (let ((f128 (get self127 2))) (let ((f129 (get self127 3))) (let ((f130 (get self127 4))) (let ((f131 (get self127 5))) (let ((reply$133 (Kind.Parser.term reply.pst$127))) (let ((self133 reply$133)) (case (get self133 0) ('Parser.Reply.error (let ((f133 (get self133 1))) (let ((self134 f127)) (case (get self134 0) ('Maybe.none ($Parser.Reply.error f133)) ('Maybe.some (let ((f134 (get self134 1))) ($Parser.Reply.error ($Parser.Error.combine f134 f133)))))))) ('Parser.Reply.value (let ((f133 (get self133 1))) (let ((f134 (get self133 2))) (let ((self135 f133)) (case (get self135 0) ('Parser.State.new (let ((f135 (get self135 1))) (let ((f136 (get self135 2))) (let ((f137 (get self135 3))) (let ((f138 (get self135 4))) (let ((f139 (get self135 5))) (let ((reply.pst$141 ($Parser.State.new ($Parser.Error.maybe_combine f127 f135) f136 f137 f138 f139))) (let ((self141 reply.pst$141)) (case (get self141 0) ('Parser.State.new (let ((f141 (get self141 1))) (let ((f142 (get self141 2))) (let ((f143 (get self141 3))) (let ((f144 (get self141 4))) (let ((f145 (get self141 5))) (let ((reply$147 ($Parser.maybe (Kind.Parser.text ";") reply.pst$141))) (let ((self147 reply$147)) (case (get self147 0) ('Parser.Reply.error (let ((f147 (get self147 1))) (let ((self148 f141)) (case (get self148 0) ('Maybe.none ($Parser.Reply.error f147)) ('Maybe.some (let ((f148 (get self148 1))) ($Parser.Reply.error ($Parser.Error.combine f148 f147)))))))) ('Parser.Reply.value (let ((f147 (get self147 1))) (let ((f148 (get self147 2))) (let ((self149 f147)) (case (get self149 0) ('Parser.State.new (let ((f149 (get self149 1))) (let ((f150 (get self149 2))) (let ((f151 (get self149 3))) (let ((f152 (get self149 4))) (let ((f153 (get self149 5))) (let ((reply.pst$155 ($Parser.State.new ($Parser.Error.maybe_combine f141 f149) f150 f151 f152 f153))) (let ((self155 reply.pst$155)) (case (get self155 0) ('Parser.State.new (let ((f155 (get self155 1))) (let ((f156 (get self155 2))) (let ((f157 (get self155 3))) (let ((f158 (get self155 4))) (let ((f159 (get self155 5))) (let ((reply$161 ((body$0 Unit.new) reply.pst$155))) (let ((self161 reply$161)) (case (get self161 0) ('Parser.Reply.error (let ((f161 (get self161 1))) (let ((self162 f155)) (case (get self162 0) ('Maybe.none ($Parser.Reply.error f161)) ('Maybe.some (let ((f162 (get self162 1))) ($Parser.Reply.error ($Parser.Error.combine f162 f161)))))))) ('Parser.Reply.value (let ((f161 (get self161 1))) (let ((f162 (get self161 2))) (let ((self163 f161)) (case (get self163 0) ('Parser.State.new (let ((f163 (get self163 1))) (let ((f164 (get self163 2))) (let ((f165 (get self163 3))) (let ((f166 (get self163 4))) (let ((f167 (get self163 5))) (let ((reply.pst$169 ($Parser.State.new ($Parser.Error.maybe_combine f155 f163) f164 f165 f166 f167))) (let ((term$170 ($Kind.Term.ref "BBT.for"))) (let ((term$171 ($Kind.Term.app term$170 ($Kind.Term.hol Bits.e)))) (let ((term$172 ($Kind.Term.app term$171 ($Kind.Term.hol Bits.e)))) (let ((term$173 ($Kind.Term.app term$172 f78))) (let ((term$174 ($Kind.Term.app term$173 ($Kind.Term.hol Bits.e)))) (let ((term$175 ($Kind.Term.app term$174 ($Kind.Term.ref f106)))) (let ((lamb$176 ($Kind.Term.lam f22 (lambda (k$176) ($Kind.Term.lam f50 (lambda (i$177) ($Kind.Term.lam f106 (lambda (x$178) f134)))))))) (let ((term$177 ($Kind.Term.app term$175 lamb$176))) (let ((term$178 ($Kind.Term.let f106 term$177 (lambda (x$178) f162)))) ($Parser.Reply.value reply.pst$169 term$178)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.letforinmap.with (lambda (body$0) ($Kind.Parser.letforinmap.with body$0)))
(define ($Kind.Parser.letwhile body$0) ((Kind.Parser.block "let-while") (lambda (pst$1) (let ((self1 pst$1)) (case (get self1 0) ('Parser.State.new (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((reply$7 ($Kind.Parser.text "let " pst$1))) (let ((self7 reply$7)) (case (get self7 0) ('Parser.Reply.error (let ((f7 (get self7 1))) (let ((self8 f1)) (case (get self8 0) ('Maybe.none ($Parser.Reply.error f7)) ('Maybe.some (let ((f8 (get self8 1))) ($Parser.Reply.error ($Parser.Error.combine f8 f7)))))))) ('Parser.Reply.value (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((self9 f7)) (case (get self9 0) ('Parser.State.new (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) (let ((reply.pst$15 ($Parser.State.new ($Parser.Error.maybe_combine f1 f9) f10 f11 f12 f13))) (let ((self15 reply.pst$15)) (case (get self15 0) ('Parser.State.new (let ((f15 (get self15 1))) (let ((f16 (get self15 2))) (let ((f17 (get self15 3))) (let ((f18 (get self15 4))) (let ((f19 (get self15 5))) (let ((reply$21 ($Kind.Parser.name1 reply.pst$15))) (let ((self21 reply$21)) (case (get self21 0) ('Parser.Reply.error (let ((f21 (get self21 1))) (let ((self22 f15)) (case (get self22 0) ('Maybe.none ($Parser.Reply.error f21)) ('Maybe.some (let ((f22 (get self22 1))) ($Parser.Reply.error ($Parser.Error.combine f22 f21)))))))) ('Parser.Reply.value (let ((f21 (get self21 1))) (let ((f22 (get self21 2))) (let ((self23 f21)) (case (get self23 0) ('Parser.State.new (let ((f23 (get self23 1))) (let ((f24 (get self23 2))) (let ((f25 (get self23 3))) (let ((f26 (get self23 4))) (let ((f27 (get self23 5))) (let ((reply.pst$29 ($Parser.State.new ($Parser.Error.maybe_combine f15 f23) f24 f25 f26 f27))) (let ((self29 reply.pst$29)) (case (get self29 0) ('Parser.State.new (let ((f29 (get self29 1))) (let ((f30 (get self29 2))) (let ((f31 (get self29 3))) (let ((f32 (get self29 4))) (let ((f33 (get self29 5))) (let ((reply$35 ($Kind.Parser.text "=" reply.pst$29))) (let ((self35 reply$35)) (case (get self35 0) ('Parser.Reply.error (let ((f35 (get self35 1))) (let ((self36 f29)) (case (get self36 0) ('Maybe.none ($Parser.Reply.error f35)) ('Maybe.some (let ((f36 (get self36 1))) ($Parser.Reply.error ($Parser.Error.combine f36 f35)))))))) ('Parser.Reply.value (let ((f35 (get self35 1))) (let ((f36 (get self35 2))) (let ((self37 f35)) (case (get self37 0) ('Parser.State.new (let ((f37 (get self37 1))) (let ((f38 (get self37 2))) (let ((f39 (get self37 3))) (let ((f40 (get self37 4))) (let ((f41 (get self37 5))) (let ((reply.pst$43 ($Parser.State.new ($Parser.Error.maybe_combine f29 f37) f38 f39 f40 f41))) (let ((self43 reply.pst$43)) (case (get self43 0) ('Parser.State.new (let ((f43 (get self43 1))) (let ((f44 (get self43 2))) (let ((f45 (get self43 3))) (let ((f46 (get self43 4))) (let ((f47 (get self43 5))) (let ((reply$49 ($Kind.Parser.text "while " reply.pst$43))) (let ((self49 reply$49)) (case (get self49 0) ('Parser.Reply.error (let ((f49 (get self49 1))) (let ((self50 f43)) (case (get self50 0) ('Maybe.none ($Parser.Reply.error f49)) ('Maybe.some (let ((f50 (get self50 1))) ($Parser.Reply.error ($Parser.Error.combine f50 f49)))))))) ('Parser.Reply.value (let ((f49 (get self49 1))) (let ((f50 (get self49 2))) (let ((self51 f49)) (case (get self51 0) ('Parser.State.new (let ((f51 (get self51 1))) (let ((f52 (get self51 2))) (let ((f53 (get self51 3))) (let ((f54 (get self51 4))) (let ((f55 (get self51 5))) (let ((reply.pst$57 ($Parser.State.new ($Parser.Error.maybe_combine f43 f51) f52 f53 f54 f55))) (let ((self57 reply.pst$57)) (case (get self57 0) ('Parser.State.new (let ((f57 (get self57 1))) (let ((f58 (get self57 2))) (let ((f59 (get self57 3))) (let ((f60 (get self57 4))) (let ((f61 (get self57 5))) (let ((reply$63 (Kind.Parser.term reply.pst$57))) (let ((self63 reply$63)) (case (get self63 0) ('Parser.Reply.error (let ((f63 (get self63 1))) (let ((self64 f57)) (case (get self64 0) ('Maybe.none ($Parser.Reply.error f63)) ('Maybe.some (let ((f64 (get self64 1))) ($Parser.Reply.error ($Parser.Error.combine f64 f63)))))))) ('Parser.Reply.value (let ((f63 (get self63 1))) (let ((f64 (get self63 2))) (let ((self65 f63)) (case (get self65 0) ('Parser.State.new (let ((f65 (get self65 1))) (let ((f66 (get self65 2))) (let ((f67 (get self65 3))) (let ((f68 (get self65 4))) (let ((f69 (get self65 5))) (let ((reply.pst$71 ($Parser.State.new ($Parser.Error.maybe_combine f57 f65) f66 f67 f68 f69))) (let ((self71 reply.pst$71)) (case (get self71 0) ('Parser.State.new (let ((f71 (get self71 1))) (let ((f72 (get self71 2))) (let ((f73 (get self71 3))) (let ((f74 (get self71 4))) (let ((f75 (get self71 5))) (let ((reply$77 ($Kind.Parser.text ":" reply.pst$71))) (let ((self77 reply$77)) (case (get self77 0) ('Parser.Reply.error (let ((f77 (get self77 1))) (let ((self78 f71)) (case (get self78 0) ('Maybe.none ($Parser.Reply.error f77)) ('Maybe.some (let ((f78 (get self78 1))) ($Parser.Reply.error ($Parser.Error.combine f78 f77)))))))) ('Parser.Reply.value (let ((f77 (get self77 1))) (let ((f78 (get self77 2))) (let ((self79 f77)) (case (get self79 0) ('Parser.State.new (let ((f79 (get self79 1))) (let ((f80 (get self79 2))) (let ((f81 (get self79 3))) (let ((f82 (get self79 4))) (let ((f83 (get self79 5))) (let ((reply.pst$85 ($Parser.State.new ($Parser.Error.maybe_combine f71 f79) f80 f81 f82 f83))) (let ((self85 reply.pst$85)) (case (get self85 0) ('Parser.State.new (let ((f85 (get self85 1))) (let ((f86 (get self85 2))) (let ((f87 (get self85 3))) (let ((f88 (get self85 4))) (let ((f89 (get self85 5))) (let ((reply$91 (Kind.Parser.term reply.pst$85))) (let ((self91 reply$91)) (case (get self91 0) ('Parser.Reply.error (let ((f91 (get self91 1))) (let ((self92 f85)) (case (get self92 0) ('Maybe.none ($Parser.Reply.error f91)) ('Maybe.some (let ((f92 (get self92 1))) ($Parser.Reply.error ($Parser.Error.combine f92 f91)))))))) ('Parser.Reply.value (let ((f91 (get self91 1))) (let ((f92 (get self91 2))) (let ((self93 f91)) (case (get self93 0) ('Parser.State.new (let ((f93 (get self93 1))) (let ((f94 (get self93 2))) (let ((f95 (get self93 3))) (let ((f96 (get self93 4))) (let ((f97 (get self93 5))) (let ((reply.pst$99 ($Parser.State.new ($Parser.Error.maybe_combine f85 f93) f94 f95 f96 f97))) (let ((self99 reply.pst$99)) (case (get self99 0) ('Parser.State.new (let ((f99 (get self99 1))) (let ((f100 (get self99 2))) (let ((f101 (get self99 3))) (let ((f102 (get self99 4))) (let ((f103 (get self99 5))) (let ((reply$105 ($Parser.maybe (Kind.Parser.text ";") reply.pst$99))) (let ((self105 reply$105)) (case (get self105 0) ('Parser.Reply.error (let ((f105 (get self105 1))) (let ((self106 f99)) (case (get self106 0) ('Maybe.none ($Parser.Reply.error f105)) ('Maybe.some (let ((f106 (get self106 1))) ($Parser.Reply.error ($Parser.Error.combine f106 f105)))))))) ('Parser.Reply.value (let ((f105 (get self105 1))) (let ((f106 (get self105 2))) (let ((self107 f105)) (case (get self107 0) ('Parser.State.new (let ((f107 (get self107 1))) (let ((f108 (get self107 2))) (let ((f109 (get self107 3))) (let ((f110 (get self107 4))) (let ((f111 (get self107 5))) (let ((reply.pst$113 ($Parser.State.new ($Parser.Error.maybe_combine f99 f107) f108 f109 f110 f111))) (let ((self113 reply.pst$113)) (case (get self113 0) ('Parser.State.new (let ((f113 (get self113 1))) (let ((f114 (get self113 2))) (let ((f115 (get self113 3))) (let ((f116 (get self113 4))) (let ((f117 (get self113 5))) (let ((reply$119 ((body$0 Unit.new) reply.pst$113))) (let ((self119 reply$119)) (case (get self119 0) ('Parser.Reply.error (let ((f119 (get self119 1))) (let ((self120 f113)) (case (get self120 0) ('Maybe.none ($Parser.Reply.error f119)) ('Maybe.some (let ((f120 (get self120 1))) ($Parser.Reply.error ($Parser.Error.combine f120 f119)))))))) ('Parser.Reply.value (let ((f119 (get self119 1))) (let ((f120 (get self119 2))) (let ((self121 f119)) (case (get self121 0) ('Parser.State.new (let ((f121 (get self121 1))) (let ((f122 (get self121 2))) (let ((f123 (get self121 3))) (let ((f124 (get self121 4))) (let ((f125 (get self121 5))) (let ((reply.pst$127 ($Parser.State.new ($Parser.Error.maybe_combine f113 f121) f122 f123 f124 f125))) (let ((term$128 ($Kind.Term.ref "Function.while"))) (let ((term$129 ($Kind.Term.app term$128 ($Kind.Term.hol Bits.e)))) (let ((term$130 ($Kind.Term.app term$129 ($Kind.Term.ref f22)))) (let ((term$131 ($Kind.Term.app term$130 ($Kind.Term.lam f22 (lambda (s$131) f64))))) (let ((term$132 ($Kind.Term.app term$131 ($Kind.Term.lam f22 (lambda (s$132) f92))))) (let ((term$133 ($Kind.Term.let f22 term$132 (lambda (x$133) f120)))) ($Parser.Reply.value reply.pst$127 term$133)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.letwhile (lambda (body$0) ($Kind.Parser.letwhile body$0)))
(define ($Kind.Parser.letwhile.with body$0) ((Kind.Parser.block "let-while") (lambda (pst$1) (let ((self1 pst$1)) (case (get self1 0) ('Parser.State.new (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((reply$7 ($Kind.Parser.text "while " pst$1))) (let ((self7 reply$7)) (case (get self7 0) ('Parser.Reply.error (let ((f7 (get self7 1))) (let ((self8 f1)) (case (get self8 0) ('Maybe.none ($Parser.Reply.error f7)) ('Maybe.some (let ((f8 (get self8 1))) ($Parser.Reply.error ($Parser.Error.combine f8 f7)))))))) ('Parser.Reply.value (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((self9 f7)) (case (get self9 0) ('Parser.State.new (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) (let ((reply.pst$15 ($Parser.State.new ($Parser.Error.maybe_combine f1 f9) f10 f11 f12 f13))) (let ((self15 reply.pst$15)) (case (get self15 0) ('Parser.State.new (let ((f15 (get self15 1))) (let ((f16 (get self15 2))) (let ((f17 (get self15 3))) (let ((f18 (get self15 4))) (let ((f19 (get self15 5))) (let ((reply$21 (Kind.Parser.term reply.pst$15))) (let ((self21 reply$21)) (case (get self21 0) ('Parser.Reply.error (let ((f21 (get self21 1))) (let ((self22 f15)) (case (get self22 0) ('Maybe.none ($Parser.Reply.error f21)) ('Maybe.some (let ((f22 (get self22 1))) ($Parser.Reply.error ($Parser.Error.combine f22 f21)))))))) ('Parser.Reply.value (let ((f21 (get self21 1))) (let ((f22 (get self21 2))) (let ((self23 f21)) (case (get self23 0) ('Parser.State.new (let ((f23 (get self23 1))) (let ((f24 (get self23 2))) (let ((f25 (get self23 3))) (let ((f26 (get self23 4))) (let ((f27 (get self23 5))) (let ((reply.pst$29 ($Parser.State.new ($Parser.Error.maybe_combine f15 f23) f24 f25 f26 f27))) (let ((self29 reply.pst$29)) (case (get self29 0) ('Parser.State.new (let ((f29 (get self29 1))) (let ((f30 (get self29 2))) (let ((f31 (get self29 3))) (let ((f32 (get self29 4))) (let ((f33 (get self29 5))) (let ((reply$35 ($Kind.Parser.text "with " reply.pst$29))) (let ((self35 reply$35)) (case (get self35 0) ('Parser.Reply.error (let ((f35 (get self35 1))) (let ((self36 f29)) (case (get self36 0) ('Maybe.none ($Parser.Reply.error f35)) ('Maybe.some (let ((f36 (get self36 1))) ($Parser.Reply.error ($Parser.Error.combine f36 f35)))))))) ('Parser.Reply.value (let ((f35 (get self35 1))) (let ((f36 (get self35 2))) (let ((self37 f35)) (case (get self37 0) ('Parser.State.new (let ((f37 (get self37 1))) (let ((f38 (get self37 2))) (let ((f39 (get self37 3))) (let ((f40 (get self37 4))) (let ((f41 (get self37 5))) (let ((reply.pst$43 ($Parser.State.new ($Parser.Error.maybe_combine f29 f37) f38 f39 f40 f41))) (let ((self43 reply.pst$43)) (case (get self43 0) ('Parser.State.new (let ((f43 (get self43 1))) (let ((f44 (get self43 2))) (let ((f45 (get self43 3))) (let ((f46 (get self43 4))) (let ((f47 (get self43 5))) (let ((reply$49 ($Kind.Parser.name1 reply.pst$43))) (let ((self49 reply$49)) (case (get self49 0) ('Parser.Reply.error (let ((f49 (get self49 1))) (let ((self50 f43)) (case (get self50 0) ('Maybe.none ($Parser.Reply.error f49)) ('Maybe.some (let ((f50 (get self50 1))) ($Parser.Reply.error ($Parser.Error.combine f50 f49)))))))) ('Parser.Reply.value (let ((f49 (get self49 1))) (let ((f50 (get self49 2))) (let ((self51 f49)) (case (get self51 0) ('Parser.State.new (let ((f51 (get self51 1))) (let ((f52 (get self51 2))) (let ((f53 (get self51 3))) (let ((f54 (get self51 4))) (let ((f55 (get self51 5))) (let ((reply.pst$57 ($Parser.State.new ($Parser.Error.maybe_combine f43 f51) f52 f53 f54 f55))) (let ((self57 reply.pst$57)) (case (get self57 0) ('Parser.State.new (let ((f57 (get self57 1))) (let ((f58 (get self57 2))) (let ((f59 (get self57 3))) (let ((f60 (get self57 4))) (let ((f61 (get self57 5))) (let ((reply$63 ($Kind.Parser.text ":" reply.pst$57))) (let ((self63 reply$63)) (case (get self63 0) ('Parser.Reply.error (let ((f63 (get self63 1))) (let ((self64 f57)) (case (get self64 0) ('Maybe.none ($Parser.Reply.error f63)) ('Maybe.some (let ((f64 (get self64 1))) ($Parser.Reply.error ($Parser.Error.combine f64 f63)))))))) ('Parser.Reply.value (let ((f63 (get self63 1))) (let ((f64 (get self63 2))) (let ((self65 f63)) (case (get self65 0) ('Parser.State.new (let ((f65 (get self65 1))) (let ((f66 (get self65 2))) (let ((f67 (get self65 3))) (let ((f68 (get self65 4))) (let ((f69 (get self65 5))) (let ((reply.pst$71 ($Parser.State.new ($Parser.Error.maybe_combine f57 f65) f66 f67 f68 f69))) (let ((self71 reply.pst$71)) (case (get self71 0) ('Parser.State.new (let ((f71 (get self71 1))) (let ((f72 (get self71 2))) (let ((f73 (get self71 3))) (let ((f74 (get self71 4))) (let ((f75 (get self71 5))) (let ((reply$77 (Kind.Parser.term reply.pst$71))) (let ((self77 reply$77)) (case (get self77 0) ('Parser.Reply.error (let ((f77 (get self77 1))) (let ((self78 f71)) (case (get self78 0) ('Maybe.none ($Parser.Reply.error f77)) ('Maybe.some (let ((f78 (get self78 1))) ($Parser.Reply.error ($Parser.Error.combine f78 f77)))))))) ('Parser.Reply.value (let ((f77 (get self77 1))) (let ((f78 (get self77 2))) (let ((self79 f77)) (case (get self79 0) ('Parser.State.new (let ((f79 (get self79 1))) (let ((f80 (get self79 2))) (let ((f81 (get self79 3))) (let ((f82 (get self79 4))) (let ((f83 (get self79 5))) (let ((reply.pst$85 ($Parser.State.new ($Parser.Error.maybe_combine f71 f79) f80 f81 f82 f83))) (let ((self85 reply.pst$85)) (case (get self85 0) ('Parser.State.new (let ((f85 (get self85 1))) (let ((f86 (get self85 2))) (let ((f87 (get self85 3))) (let ((f88 (get self85 4))) (let ((f89 (get self85 5))) (let ((reply$91 ($Parser.maybe (Kind.Parser.text ";") reply.pst$85))) (let ((self91 reply$91)) (case (get self91 0) ('Parser.Reply.error (let ((f91 (get self91 1))) (let ((self92 f85)) (case (get self92 0) ('Maybe.none ($Parser.Reply.error f91)) ('Maybe.some (let ((f92 (get self92 1))) ($Parser.Reply.error ($Parser.Error.combine f92 f91)))))))) ('Parser.Reply.value (let ((f91 (get self91 1))) (let ((f92 (get self91 2))) (let ((self93 f91)) (case (get self93 0) ('Parser.State.new (let ((f93 (get self93 1))) (let ((f94 (get self93 2))) (let ((f95 (get self93 3))) (let ((f96 (get self93 4))) (let ((f97 (get self93 5))) (let ((reply.pst$99 ($Parser.State.new ($Parser.Error.maybe_combine f85 f93) f94 f95 f96 f97))) (let ((self99 reply.pst$99)) (case (get self99 0) ('Parser.State.new (let ((f99 (get self99 1))) (let ((f100 (get self99 2))) (let ((f101 (get self99 3))) (let ((f102 (get self99 4))) (let ((f103 (get self99 5))) (let ((reply$105 ((body$0 Unit.new) reply.pst$99))) (let ((self105 reply$105)) (case (get self105 0) ('Parser.Reply.error (let ((f105 (get self105 1))) (let ((self106 f99)) (case (get self106 0) ('Maybe.none ($Parser.Reply.error f105)) ('Maybe.some (let ((f106 (get self106 1))) ($Parser.Reply.error ($Parser.Error.combine f106 f105)))))))) ('Parser.Reply.value (let ((f105 (get self105 1))) (let ((f106 (get self105 2))) (let ((self107 f105)) (case (get self107 0) ('Parser.State.new (let ((f107 (get self107 1))) (let ((f108 (get self107 2))) (let ((f109 (get self107 3))) (let ((f110 (get self107 4))) (let ((f111 (get self107 5))) (let ((reply.pst$113 ($Parser.State.new ($Parser.Error.maybe_combine f99 f107) f108 f109 f110 f111))) (let ((term$114 ($Kind.Term.ref "Function.while"))) (let ((term$115 ($Kind.Term.app term$114 ($Kind.Term.hol Bits.e)))) (let ((term$116 ($Kind.Term.app term$115 ($Kind.Term.ref f50)))) (let ((term$117 ($Kind.Term.app term$116 ($Kind.Term.lam f50 (lambda (s$117) f22))))) (let ((term$118 ($Kind.Term.app term$117 ($Kind.Term.lam f50 (lambda (s$118) f78))))) (let ((term$119 ($Kind.Term.let f50 term$118 (lambda (x$119) f106)))) ($Parser.Reply.value reply.pst$113 term$119))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.letwhile.with (lambda (body$0) ($Kind.Parser.letwhile.with body$0)))
(define ($Kind.Parser.let.abort body$0) ((Kind.Parser.block "let") (lambda (pst$1) (let ((self1 pst$1)) (case (get self1 0) ('Parser.State.new (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((reply$7 ($Kind.Parser.text "let " pst$1))) (let ((self7 reply$7)) (case (get self7 0) ('Parser.Reply.error (let ((f7 (get self7 1))) (let ((self8 f1)) (case (get self8 0) ('Maybe.none ($Parser.Reply.error f7)) ('Maybe.some (let ((f8 (get self8 1))) ($Parser.Reply.error ($Parser.Error.combine f8 f7)))))))) ('Parser.Reply.value (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((self9 f7)) (case (get self9 0) ('Parser.State.new (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) (let ((reply.pst$15 ($Parser.State.new ($Parser.Error.maybe_combine f1 f9) f10 f11 f12 f13))) (let ((self15 reply.pst$15)) (case (get self15 0) ('Parser.State.new (let ((f15 (get self15 1))) (let ((f16 (get self15 2))) (let ((f17 (get self15 3))) (let ((f18 (get self15 4))) (let ((f19 (get self15 5))) (let ((reply$21 ($Kind.Parser.name1 reply.pst$15))) (let ((self21 reply$21)) (case (get self21 0) ('Parser.Reply.error (let ((f21 (get self21 1))) (let ((self22 f15)) (case (get self22 0) ('Maybe.none ($Parser.Reply.error f21)) ('Maybe.some (let ((f22 (get self22 1))) ($Parser.Reply.error ($Parser.Error.combine f22 f21)))))))) ('Parser.Reply.value (let ((f21 (get self21 1))) (let ((f22 (get self21 2))) (let ((self23 f21)) (case (get self23 0) ('Parser.State.new (let ((f23 (get self23 1))) (let ((f24 (get self23 2))) (let ((f25 (get self23 3))) (let ((f26 (get self23 4))) (let ((f27 (get self23 5))) (let ((reply.pst$29 ($Parser.State.new ($Parser.Error.maybe_combine f15 f23) f24 f25 f26 f27))) (let ((self29 reply.pst$29)) (case (get self29 0) ('Parser.State.new (let ((f29 (get self29 1))) (let ((f30 (get self29 2))) (let ((f31 (get self29 3))) (let ((f32 (get self29 4))) (let ((f33 (get self29 5))) (let ((reply$35 ($Kind.Parser.text "=" reply.pst$29))) (let ((self35 reply$35)) (case (get self35 0) ('Parser.Reply.error (let ((f35 (get self35 1))) (let ((self36 f29)) (case (get self36 0) ('Maybe.none ($Parser.Reply.error f35)) ('Maybe.some (let ((f36 (get self36 1))) ($Parser.Reply.error ($Parser.Error.combine f36 f35)))))))) ('Parser.Reply.value (let ((f35 (get self35 1))) (let ((f36 (get self35 2))) (let ((self37 f35)) (case (get self37 0) ('Parser.State.new (let ((f37 (get self37 1))) (let ((f38 (get self37 2))) (let ((f39 (get self37 3))) (let ((f40 (get self37 4))) (let ((f41 (get self37 5))) (let ((reply.pst$43 ($Parser.State.new ($Parser.Error.maybe_combine f29 f37) f38 f39 f40 f41))) (let ((self43 reply.pst$43)) (case (get self43 0) ('Parser.State.new (let ((f43 (get self43 1))) (let ((f44 (get self43 2))) (let ((f45 (get self43 3))) (let ((f46 (get self43 4))) (let ((f47 (get self43 5))) (let ((reply$49 (Kind.Parser.term reply.pst$43))) (let ((self49 reply$49)) (case (get self49 0) ('Parser.Reply.error (let ((f49 (get self49 1))) (let ((self50 f43)) (case (get self50 0) ('Maybe.none ($Parser.Reply.error f49)) ('Maybe.some (let ((f50 (get self50 1))) ($Parser.Reply.error ($Parser.Error.combine f50 f49)))))))) ('Parser.Reply.value (let ((f49 (get self49 1))) (let ((f50 (get self49 2))) (let ((self51 f49)) (case (get self51 0) ('Parser.State.new (let ((f51 (get self51 1))) (let ((f52 (get self51 2))) (let ((f53 (get self51 3))) (let ((f54 (get self51 4))) (let ((f55 (get self51 5))) (let ((reply.pst$57 ($Parser.State.new ($Parser.Error.maybe_combine f43 f51) f52 f53 f54 f55))) (let ((self57 reply.pst$57)) (case (get self57 0) ('Parser.State.new (let ((f57 (get self57 1))) (let ((f58 (get self57 2))) (let ((f59 (get self57 3))) (let ((f60 (get self57 4))) (let ((f61 (get self57 5))) (let ((reply$63 ($Parser.maybe (Kind.Parser.text ";") reply.pst$57))) (let ((self63 reply$63)) (case (get self63 0) ('Parser.Reply.error (let ((f63 (get self63 1))) (let ((self64 f57)) (case (get self64 0) ('Maybe.none ($Parser.Reply.error f63)) ('Maybe.some (let ((f64 (get self64 1))) ($Parser.Reply.error ($Parser.Error.combine f64 f63)))))))) ('Parser.Reply.value (let ((f63 (get self63 1))) (let ((f64 (get self63 2))) (let ((self65 f63)) (case (get self65 0) ('Parser.State.new (let ((f65 (get self65 1))) (let ((f66 (get self65 2))) (let ((f67 (get self65 3))) (let ((f68 (get self65 4))) (let ((f69 (get self65 5))) (let ((reply.pst$71 ($Parser.State.new ($Parser.Error.maybe_combine f57 f65) f66 f67 f68 f69))) (let ((self71 reply.pst$71)) (case (get self71 0) ('Parser.State.new (let ((f71 (get self71 1))) (let ((f72 (get self71 2))) (let ((f73 (get self71 3))) (let ((f74 (get self71 4))) (let ((f75 (get self71 5))) (let ((reply$77 ($Kind.Parser.text "abort" reply.pst$71))) (let ((self77 reply$77)) (case (get self77 0) ('Parser.Reply.error (let ((f77 (get self77 1))) (let ((self78 f71)) (case (get self78 0) ('Maybe.none ($Parser.Reply.error f77)) ('Maybe.some (let ((f78 (get self78 1))) ($Parser.Reply.error ($Parser.Error.combine f78 f77)))))))) ('Parser.Reply.value (let ((f77 (get self77 1))) (let ((f78 (get self77 2))) (let ((self79 f77)) (case (get self79 0) ('Parser.State.new (let ((f79 (get self79 1))) (let ((f80 (get self79 2))) (let ((f81 (get self79 3))) (let ((f82 (get self79 4))) (let ((f83 (get self79 5))) (let ((reply.pst$85 ($Parser.State.new ($Parser.Error.maybe_combine f71 f79) f80 f81 f82 f83))) (let ((self85 reply.pst$85)) (case (get self85 0) ('Parser.State.new (let ((f85 (get self85 1))) (let ((f86 (get self85 2))) (let ((f87 (get self85 3))) (let ((f88 (get self85 4))) (let ((f89 (get self85 5))) (let ((reply$91 (Kind.Parser.term reply.pst$85))) (let ((self91 reply$91)) (case (get self91 0) ('Parser.Reply.error (let ((f91 (get self91 1))) (let ((self92 f85)) (case (get self92 0) ('Maybe.none ($Parser.Reply.error f91)) ('Maybe.some (let ((f92 (get self92 1))) ($Parser.Reply.error ($Parser.Error.combine f92 f91)))))))) ('Parser.Reply.value (let ((f91 (get self91 1))) (let ((f92 (get self91 2))) (let ((self93 f91)) (case (get self93 0) ('Parser.State.new (let ((f93 (get self93 1))) (let ((f94 (get self93 2))) (let ((f95 (get self93 3))) (let ((f96 (get self93 4))) (let ((f97 (get self93 5))) (let ((reply.pst$99 ($Parser.State.new ($Parser.Error.maybe_combine f85 f93) f94 f95 f96 f97))) (let ((self99 reply.pst$99)) (case (get self99 0) ('Parser.State.new (let ((f99 (get self99 1))) (let ((f100 (get self99 2))) (let ((f101 (get self99 3))) (let ((f102 (get self99 4))) (let ((f103 (get self99 5))) (let ((reply$105 ($Parser.maybe (Kind.Parser.text ";") reply.pst$99))) (let ((self105 reply$105)) (case (get self105 0) ('Parser.Reply.error (let ((f105 (get self105 1))) (let ((self106 f99)) (case (get self106 0) ('Maybe.none ($Parser.Reply.error f105)) ('Maybe.some (let ((f106 (get self106 1))) ($Parser.Reply.error ($Parser.Error.combine f106 f105)))))))) ('Parser.Reply.value (let ((f105 (get self105 1))) (let ((f106 (get self105 2))) (let ((self107 f105)) (case (get self107 0) ('Parser.State.new (let ((f107 (get self107 1))) (let ((f108 (get self107 2))) (let ((f109 (get self107 3))) (let ((f110 (get self107 4))) (let ((f111 (get self107 5))) (let ((reply.pst$113 ($Parser.State.new ($Parser.Error.maybe_combine f99 f107) f108 f109 f110 f111))) (let ((self113 reply.pst$113)) (case (get self113 0) ('Parser.State.new (let ((f113 (get self113 1))) (let ((f114 (get self113 2))) (let ((f115 (get self113 3))) (let ((f116 (get self113 4))) (let ((f117 (get self113 5))) (let ((reply$119 ((body$0 Unit.new) reply.pst$113))) (let ((self119 reply$119)) (case (get self119 0) ('Parser.Reply.error (let ((f119 (get self119 1))) (let ((self120 f113)) (case (get self120 0) ('Maybe.none ($Parser.Reply.error f119)) ('Maybe.some (let ((f120 (get self120 1))) ($Parser.Reply.error ($Parser.Error.combine f120 f119)))))))) ('Parser.Reply.value (let ((f119 (get self119 1))) (let ((f120 (get self119 2))) (let ((self121 f119)) (case (get self121 0) ('Parser.State.new (let ((f121 (get self121 1))) (let ((f122 (get self121 2))) (let ((f123 (get self121 3))) (let ((f124 (get self121 4))) (let ((f125 (get self121 5))) (let ((reply.pst$127 ($Parser.State.new ($Parser.Error.maybe_combine f113 f121) f122 f123 f124 f125))) (let ((term$128 f50)) (let ((term$129 ($Kind.Term.app term$128 ($Kind.Term.lam "" (lambda ($129) ($Kind.Term.hol Bits.e)))))) (let ((term$130 ($Kind.Term.app term$129 f92))) (let ((term$131 ($Kind.Term.app term$130 ($Kind.Term.lam f22 (lambda ($131) f120))))) ($Parser.Reply.value reply.pst$127 term$131)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.let.abort (lambda (body$0) ($Kind.Parser.let.abort body$0)))
(define ($Kind.Parser.let body$0) ((Kind.Parser.block "let") (lambda (pst$1) (let ((self1 pst$1)) (case (get self1 0) ('Parser.State.new (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((reply$7 ($Kind.Parser.text "let " pst$1))) (let ((self7 reply$7)) (case (get self7 0) ('Parser.Reply.error (let ((f7 (get self7 1))) (let ((self8 f1)) (case (get self8 0) ('Maybe.none ($Parser.Reply.error f7)) ('Maybe.some (let ((f8 (get self8 1))) ($Parser.Reply.error ($Parser.Error.combine f8 f7)))))))) ('Parser.Reply.value (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((self9 f7)) (case (get self9 0) ('Parser.State.new (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) (let ((reply.pst$15 ($Parser.State.new ($Parser.Error.maybe_combine f1 f9) f10 f11 f12 f13))) (let ((self15 reply.pst$15)) (case (get self15 0) ('Parser.State.new (let ((f15 (get self15 1))) (let ((f16 (get self15 2))) (let ((f17 (get self15 3))) (let ((f18 (get self15 4))) (let ((f19 (get self15 5))) (let ((reply$21 ($Kind.Parser.name1 reply.pst$15))) (let ((self21 reply$21)) (case (get self21 0) ('Parser.Reply.error (let ((f21 (get self21 1))) (let ((self22 f15)) (case (get self22 0) ('Maybe.none ($Parser.Reply.error f21)) ('Maybe.some (let ((f22 (get self22 1))) ($Parser.Reply.error ($Parser.Error.combine f22 f21)))))))) ('Parser.Reply.value (let ((f21 (get self21 1))) (let ((f22 (get self21 2))) (let ((self23 f21)) (case (get self23 0) ('Parser.State.new (let ((f23 (get self23 1))) (let ((f24 (get self23 2))) (let ((f25 (get self23 3))) (let ((f26 (get self23 4))) (let ((f27 (get self23 5))) (let ((reply.pst$29 ($Parser.State.new ($Parser.Error.maybe_combine f15 f23) f24 f25 f26 f27))) (let ((self29 reply.pst$29)) (case (get self29 0) ('Parser.State.new (let ((f29 (get self29 1))) (let ((f30 (get self29 2))) (let ((f31 (get self29 3))) (let ((f32 (get self29 4))) (let ((f33 (get self29 5))) (let ((reply$35 ($Kind.Parser.text "=" reply.pst$29))) (let ((self35 reply$35)) (case (get self35 0) ('Parser.Reply.error (let ((f35 (get self35 1))) (let ((self36 f29)) (case (get self36 0) ('Maybe.none ($Parser.Reply.error f35)) ('Maybe.some (let ((f36 (get self36 1))) ($Parser.Reply.error ($Parser.Error.combine f36 f35)))))))) ('Parser.Reply.value (let ((f35 (get self35 1))) (let ((f36 (get self35 2))) (let ((self37 f35)) (case (get self37 0) ('Parser.State.new (let ((f37 (get self37 1))) (let ((f38 (get self37 2))) (let ((f39 (get self37 3))) (let ((f40 (get self37 4))) (let ((f41 (get self37 5))) (let ((reply.pst$43 ($Parser.State.new ($Parser.Error.maybe_combine f29 f37) f38 f39 f40 f41))) (let ((self43 reply.pst$43)) (case (get self43 0) ('Parser.State.new (let ((f43 (get self43 1))) (let ((f44 (get self43 2))) (let ((f45 (get self43 3))) (let ((f46 (get self43 4))) (let ((f47 (get self43 5))) (let ((reply$49 (Kind.Parser.term reply.pst$43))) (let ((self49 reply$49)) (case (get self49 0) ('Parser.Reply.error (let ((f49 (get self49 1))) (let ((self50 f43)) (case (get self50 0) ('Maybe.none ($Parser.Reply.error f49)) ('Maybe.some (let ((f50 (get self50 1))) ($Parser.Reply.error ($Parser.Error.combine f50 f49)))))))) ('Parser.Reply.value (let ((f49 (get self49 1))) (let ((f50 (get self49 2))) (let ((self51 f49)) (case (get self51 0) ('Parser.State.new (let ((f51 (get self51 1))) (let ((f52 (get self51 2))) (let ((f53 (get self51 3))) (let ((f54 (get self51 4))) (let ((f55 (get self51 5))) (let ((reply.pst$57 ($Parser.State.new ($Parser.Error.maybe_combine f43 f51) f52 f53 f54 f55))) (let ((self57 reply.pst$57)) (case (get self57 0) ('Parser.State.new (let ((f57 (get self57 1))) (let ((f58 (get self57 2))) (let ((f59 (get self57 3))) (let ((f60 (get self57 4))) (let ((f61 (get self57 5))) (let ((reply$63 ($Parser.maybe (Kind.Parser.text ";") reply.pst$57))) (let ((self63 reply$63)) (case (get self63 0) ('Parser.Reply.error (let ((f63 (get self63 1))) (let ((self64 f57)) (case (get self64 0) ('Maybe.none ($Parser.Reply.error f63)) ('Maybe.some (let ((f64 (get self64 1))) ($Parser.Reply.error ($Parser.Error.combine f64 f63)))))))) ('Parser.Reply.value (let ((f63 (get self63 1))) (let ((f64 (get self63 2))) (let ((self65 f63)) (case (get self65 0) ('Parser.State.new (let ((f65 (get self65 1))) (let ((f66 (get self65 2))) (let ((f67 (get self65 3))) (let ((f68 (get self65 4))) (let ((f69 (get self65 5))) (let ((reply.pst$71 ($Parser.State.new ($Parser.Error.maybe_combine f57 f65) f66 f67 f68 f69))) (let ((self71 reply.pst$71)) (case (get self71 0) ('Parser.State.new (let ((f71 (get self71 1))) (let ((f72 (get self71 2))) (let ((f73 (get self71 3))) (let ((f74 (get self71 4))) (let ((f75 (get self71 5))) (let ((reply$77 ((body$0 Unit.new) reply.pst$71))) (let ((self77 reply$77)) (case (get self77 0) ('Parser.Reply.error (let ((f77 (get self77 1))) (let ((self78 f71)) (case (get self78 0) ('Maybe.none ($Parser.Reply.error f77)) ('Maybe.some (let ((f78 (get self78 1))) ($Parser.Reply.error ($Parser.Error.combine f78 f77)))))))) ('Parser.Reply.value (let ((f77 (get self77 1))) (let ((f78 (get self77 2))) (let ((self79 f77)) (case (get self79 0) ('Parser.State.new (let ((f79 (get self79 1))) (let ((f80 (get self79 2))) (let ((f81 (get self79 3))) (let ((f82 (get self79 4))) (let ((f83 (get self79 5))) (let ((reply.pst$85 ($Parser.State.new ($Parser.Error.maybe_combine f71 f79) f80 f81 f82 f83))) ($Parser.Reply.value reply.pst$85 ($Kind.Term.let f22 f50 (lambda (x$86) f78))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.let (lambda (body$0) ($Kind.Parser.let body$0)))
(define ($Kind.Parser.let.omit body$0) ((Kind.Parser.block "let") (lambda (pst$1) (let ((self1 pst$1)) (case (get self1 0) ('Parser.State.new (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((reply$7 ($Kind.Parser.name1 pst$1))) (let ((self7 reply$7)) (case (get self7 0) ('Parser.Reply.error (let ((f7 (get self7 1))) (let ((self8 f1)) (case (get self8 0) ('Maybe.none ($Parser.Reply.error f7)) ('Maybe.some (let ((f8 (get self8 1))) ($Parser.Reply.error ($Parser.Error.combine f8 f7)))))))) ('Parser.Reply.value (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((self9 f7)) (case (get self9 0) ('Parser.State.new (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) (let ((reply.pst$15 ($Parser.State.new ($Parser.Error.maybe_combine f1 f9) f10 f11 f12 f13))) (let ((self15 reply.pst$15)) (case (get self15 0) ('Parser.State.new (let ((f15 (get self15 1))) (let ((f16 (get self15 2))) (let ((f17 (get self15 3))) (let ((f18 (get self15 4))) (let ((f19 (get self15 5))) (let ((reply$21 ($Kind.Parser.text "= " reply.pst$15))) (let ((self21 reply$21)) (case (get self21 0) ('Parser.Reply.error (let ((f21 (get self21 1))) (let ((self22 f15)) (case (get self22 0) ('Maybe.none ($Parser.Reply.error f21)) ('Maybe.some (let ((f22 (get self22 1))) ($Parser.Reply.error ($Parser.Error.combine f22 f21)))))))) ('Parser.Reply.value (let ((f21 (get self21 1))) (let ((f22 (get self21 2))) (let ((self23 f21)) (case (get self23 0) ('Parser.State.new (let ((f23 (get self23 1))) (let ((f24 (get self23 2))) (let ((f25 (get self23 3))) (let ((f26 (get self23 4))) (let ((f27 (get self23 5))) (let ((reply.pst$29 ($Parser.State.new ($Parser.Error.maybe_combine f15 f23) f24 f25 f26 f27))) (let ((self29 reply.pst$29)) (case (get self29 0) ('Parser.State.new (let ((f29 (get self29 1))) (let ((f30 (get self29 2))) (let ((f31 (get self29 3))) (let ((f32 (get self29 4))) (let ((f33 (get self29 5))) (let ((reply$35 (Kind.Parser.term reply.pst$29))) (let ((self35 reply$35)) (case (get self35 0) ('Parser.Reply.error (let ((f35 (get self35 1))) (let ((self36 f29)) (case (get self36 0) ('Maybe.none ($Parser.Reply.error f35)) ('Maybe.some (let ((f36 (get self36 1))) ($Parser.Reply.error ($Parser.Error.combine f36 f35)))))))) ('Parser.Reply.value (let ((f35 (get self35 1))) (let ((f36 (get self35 2))) (let ((self37 f35)) (case (get self37 0) ('Parser.State.new (let ((f37 (get self37 1))) (let ((f38 (get self37 2))) (let ((f39 (get self37 3))) (let ((f40 (get self37 4))) (let ((f41 (get self37 5))) (let ((reply.pst$43 ($Parser.State.new ($Parser.Error.maybe_combine f29 f37) f38 f39 f40 f41))) (let ((self43 reply.pst$43)) (case (get self43 0) ('Parser.State.new (let ((f43 (get self43 1))) (let ((f44 (get self43 2))) (let ((f45 (get self43 3))) (let ((f46 (get self43 4))) (let ((f47 (get self43 5))) (let ((reply$49 ($Parser.maybe (Kind.Parser.text ";") reply.pst$43))) (let ((self49 reply$49)) (case (get self49 0) ('Parser.Reply.error (let ((f49 (get self49 1))) (let ((self50 f43)) (case (get self50 0) ('Maybe.none ($Parser.Reply.error f49)) ('Maybe.some (let ((f50 (get self50 1))) ($Parser.Reply.error ($Parser.Error.combine f50 f49)))))))) ('Parser.Reply.value (let ((f49 (get self49 1))) (let ((f50 (get self49 2))) (let ((self51 f49)) (case (get self51 0) ('Parser.State.new (let ((f51 (get self51 1))) (let ((f52 (get self51 2))) (let ((f53 (get self51 3))) (let ((f54 (get self51 4))) (let ((f55 (get self51 5))) (let ((reply.pst$57 ($Parser.State.new ($Parser.Error.maybe_combine f43 f51) f52 f53 f54 f55))) (let ((self57 reply.pst$57)) (case (get self57 0) ('Parser.State.new (let ((f57 (get self57 1))) (let ((f58 (get self57 2))) (let ((f59 (get self57 3))) (let ((f60 (get self57 4))) (let ((f61 (get self57 5))) (let ((reply$63 ((body$0 Unit.new) reply.pst$57))) (let ((self63 reply$63)) (case (get self63 0) ('Parser.Reply.error (let ((f63 (get self63 1))) (let ((self64 f57)) (case (get self64 0) ('Maybe.none ($Parser.Reply.error f63)) ('Maybe.some (let ((f64 (get self64 1))) ($Parser.Reply.error ($Parser.Error.combine f64 f63)))))))) ('Parser.Reply.value (let ((f63 (get self63 1))) (let ((f64 (get self63 2))) (let ((self65 f63)) (case (get self65 0) ('Parser.State.new (let ((f65 (get self65 1))) (let ((f66 (get self65 2))) (let ((f67 (get self65 3))) (let ((f68 (get self65 4))) (let ((f69 (get self65 5))) (let ((reply.pst$71 ($Parser.State.new ($Parser.Error.maybe_combine f57 f65) f66 f67 f68 f69))) ($Parser.Reply.value reply.pst$71 ($Kind.Term.let f8 f36 (lambda (x$72) f64)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.let.omit (lambda (body$0) ($Kind.Parser.let.omit body$0)))
(define ($Kind.Parser.getwhile body$0) ((Kind.Parser.block "let-while") (lambda (pst$1) (let ((self1 pst$1)) (case (get self1 0) ('Parser.State.new (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((reply$7 ($Parser.maybe (Kind.Parser.text "let ") pst$1))) (let ((self7 reply$7)) (case (get self7 0) ('Parser.Reply.error (let ((f7 (get self7 1))) (let ((self8 f1)) (case (get self8 0) ('Maybe.none ($Parser.Reply.error f7)) ('Maybe.some (let ((f8 (get self8 1))) ($Parser.Reply.error ($Parser.Error.combine f8 f7)))))))) ('Parser.Reply.value (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((self9 f7)) (case (get self9 0) ('Parser.State.new (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) (let ((reply.pst$15 ($Parser.State.new ($Parser.Error.maybe_combine f1 f9) f10 f11 f12 f13))) (let ((self15 reply.pst$15)) (case (get self15 0) ('Parser.State.new (let ((f15 (get self15 1))) (let ((f16 (get self15 2))) (let ((f17 (get self15 3))) (let ((f18 (get self15 4))) (let ((f19 (get self15 5))) (let ((reply$21 ($Kind.Parser.text "{" reply.pst$15))) (let ((self21 reply$21)) (case (get self21 0) ('Parser.Reply.error (let ((f21 (get self21 1))) (let ((self22 f15)) (case (get self22 0) ('Maybe.none ($Parser.Reply.error f21)) ('Maybe.some (let ((f22 (get self22 1))) ($Parser.Reply.error ($Parser.Error.combine f22 f21)))))))) ('Parser.Reply.value (let ((f21 (get self21 1))) (let ((f22 (get self21 2))) (let ((self23 f21)) (case (get self23 0) ('Parser.State.new (let ((f23 (get self23 1))) (let ((f24 (get self23 2))) (let ((f25 (get self23 3))) (let ((f26 (get self23 4))) (let ((f27 (get self23 5))) (let ((reply.pst$29 ($Parser.State.new ($Parser.Error.maybe_combine f15 f23) f24 f25 f26 f27))) (let ((self29 reply.pst$29)) (case (get self29 0) ('Parser.State.new (let ((f29 (get self29 1))) (let ((f30 (get self29 2))) (let ((f31 (get self29 3))) (let ((f32 (get self29 4))) (let ((f33 (get self29 5))) (let ((reply$35 ($Kind.Parser.name1 reply.pst$29))) (let ((self35 reply$35)) (case (get self35 0) ('Parser.Reply.error (let ((f35 (get self35 1))) (let ((self36 f29)) (case (get self36 0) ('Maybe.none ($Parser.Reply.error f35)) ('Maybe.some (let ((f36 (get self36 1))) ($Parser.Reply.error ($Parser.Error.combine f36 f35)))))))) ('Parser.Reply.value (let ((f35 (get self35 1))) (let ((f36 (get self35 2))) (let ((self37 f35)) (case (get self37 0) ('Parser.State.new (let ((f37 (get self37 1))) (let ((f38 (get self37 2))) (let ((f39 (get self37 3))) (let ((f40 (get self37 4))) (let ((f41 (get self37 5))) (let ((reply.pst$43 ($Parser.State.new ($Parser.Error.maybe_combine f29 f37) f38 f39 f40 f41))) (let ((self43 reply.pst$43)) (case (get self43 0) ('Parser.State.new (let ((f43 (get self43 1))) (let ((f44 (get self43 2))) (let ((f45 (get self43 3))) (let ((f46 (get self43 4))) (let ((f47 (get self43 5))) (let ((reply$49 ($Kind.Parser.text "," reply.pst$43))) (let ((self49 reply$49)) (case (get self49 0) ('Parser.Reply.error (let ((f49 (get self49 1))) (let ((self50 f43)) (case (get self50 0) ('Maybe.none ($Parser.Reply.error f49)) ('Maybe.some (let ((f50 (get self50 1))) ($Parser.Reply.error ($Parser.Error.combine f50 f49)))))))) ('Parser.Reply.value (let ((f49 (get self49 1))) (let ((f50 (get self49 2))) (let ((self51 f49)) (case (get self51 0) ('Parser.State.new (let ((f51 (get self51 1))) (let ((f52 (get self51 2))) (let ((f53 (get self51 3))) (let ((f54 (get self51 4))) (let ((f55 (get self51 5))) (let ((reply.pst$57 ($Parser.State.new ($Parser.Error.maybe_combine f43 f51) f52 f53 f54 f55))) (let ((self57 reply.pst$57)) (case (get self57 0) ('Parser.State.new (let ((f57 (get self57 1))) (let ((f58 (get self57 2))) (let ((f59 (get self57 3))) (let ((f60 (get self57 4))) (let ((f61 (get self57 5))) (let ((reply$63 ($Kind.Parser.name1 reply.pst$57))) (let ((self63 reply$63)) (case (get self63 0) ('Parser.Reply.error (let ((f63 (get self63 1))) (let ((self64 f57)) (case (get self64 0) ('Maybe.none ($Parser.Reply.error f63)) ('Maybe.some (let ((f64 (get self64 1))) ($Parser.Reply.error ($Parser.Error.combine f64 f63)))))))) ('Parser.Reply.value (let ((f63 (get self63 1))) (let ((f64 (get self63 2))) (let ((self65 f63)) (case (get self65 0) ('Parser.State.new (let ((f65 (get self65 1))) (let ((f66 (get self65 2))) (let ((f67 (get self65 3))) (let ((f68 (get self65 4))) (let ((f69 (get self65 5))) (let ((reply.pst$71 ($Parser.State.new ($Parser.Error.maybe_combine f57 f65) f66 f67 f68 f69))) (let ((self71 reply.pst$71)) (case (get self71 0) ('Parser.State.new (let ((f71 (get self71 1))) (let ((f72 (get self71 2))) (let ((f73 (get self71 3))) (let ((f74 (get self71 4))) (let ((f75 (get self71 5))) (let ((reply$77 ($Kind.Parser.text "}" reply.pst$71))) (let ((self77 reply$77)) (case (get self77 0) ('Parser.Reply.error (let ((f77 (get self77 1))) (let ((self78 f71)) (case (get self78 0) ('Maybe.none ($Parser.Reply.error f77)) ('Maybe.some (let ((f78 (get self78 1))) ($Parser.Reply.error ($Parser.Error.combine f78 f77)))))))) ('Parser.Reply.value (let ((f77 (get self77 1))) (let ((f78 (get self77 2))) (let ((self79 f77)) (case (get self79 0) ('Parser.State.new (let ((f79 (get self79 1))) (let ((f80 (get self79 2))) (let ((f81 (get self79 3))) (let ((f82 (get self79 4))) (let ((f83 (get self79 5))) (let ((reply.pst$85 ($Parser.State.new ($Parser.Error.maybe_combine f71 f79) f80 f81 f82 f83))) (let ((self85 reply.pst$85)) (case (get self85 0) ('Parser.State.new (let ((f85 (get self85 1))) (let ((f86 (get self85 2))) (let ((f87 (get self85 3))) (let ((f88 (get self85 4))) (let ((f89 (get self85 5))) (let ((reply$91 ($Kind.Parser.text "=" reply.pst$85))) (let ((self91 reply$91)) (case (get self91 0) ('Parser.Reply.error (let ((f91 (get self91 1))) (let ((self92 f85)) (case (get self92 0) ('Maybe.none ($Parser.Reply.error f91)) ('Maybe.some (let ((f92 (get self92 1))) ($Parser.Reply.error ($Parser.Error.combine f92 f91)))))))) ('Parser.Reply.value (let ((f91 (get self91 1))) (let ((f92 (get self91 2))) (let ((self93 f91)) (case (get self93 0) ('Parser.State.new (let ((f93 (get self93 1))) (let ((f94 (get self93 2))) (let ((f95 (get self93 3))) (let ((f96 (get self93 4))) (let ((f97 (get self93 5))) (let ((reply.pst$99 ($Parser.State.new ($Parser.Error.maybe_combine f85 f93) f94 f95 f96 f97))) (let ((self99 reply.pst$99)) (case (get self99 0) ('Parser.State.new (let ((f99 (get self99 1))) (let ((f100 (get self99 2))) (let ((f101 (get self99 3))) (let ((f102 (get self99 4))) (let ((f103 (get self99 5))) (let ((reply$105 ($Kind.Parser.text "while " reply.pst$99))) (let ((self105 reply$105)) (case (get self105 0) ('Parser.Reply.error (let ((f105 (get self105 1))) (let ((self106 f99)) (case (get self106 0) ('Maybe.none ($Parser.Reply.error f105)) ('Maybe.some (let ((f106 (get self106 1))) ($Parser.Reply.error ($Parser.Error.combine f106 f105)))))))) ('Parser.Reply.value (let ((f105 (get self105 1))) (let ((f106 (get self105 2))) (let ((self107 f105)) (case (get self107 0) ('Parser.State.new (let ((f107 (get self107 1))) (let ((f108 (get self107 2))) (let ((f109 (get self107 3))) (let ((f110 (get self107 4))) (let ((f111 (get self107 5))) (let ((reply.pst$113 ($Parser.State.new ($Parser.Error.maybe_combine f99 f107) f108 f109 f110 f111))) (let ((self113 reply.pst$113)) (case (get self113 0) ('Parser.State.new (let ((f113 (get self113 1))) (let ((f114 (get self113 2))) (let ((f115 (get self113 3))) (let ((f116 (get self113 4))) (let ((f117 (get self113 5))) (let ((reply$119 (Kind.Parser.term reply.pst$113))) (let ((self119 reply$119)) (case (get self119 0) ('Parser.Reply.error (let ((f119 (get self119 1))) (let ((self120 f113)) (case (get self120 0) ('Maybe.none ($Parser.Reply.error f119)) ('Maybe.some (let ((f120 (get self120 1))) ($Parser.Reply.error ($Parser.Error.combine f120 f119)))))))) ('Parser.Reply.value (let ((f119 (get self119 1))) (let ((f120 (get self119 2))) (let ((self121 f119)) (case (get self121 0) ('Parser.State.new (let ((f121 (get self121 1))) (let ((f122 (get self121 2))) (let ((f123 (get self121 3))) (let ((f124 (get self121 4))) (let ((f125 (get self121 5))) (let ((reply.pst$127 ($Parser.State.new ($Parser.Error.maybe_combine f113 f121) f122 f123 f124 f125))) (let ((self127 reply.pst$127)) (case (get self127 0) ('Parser.State.new (let ((f127 (get self127 1))) (let ((f128 (get self127 2))) (let ((f129 (get self127 3))) (let ((f130 (get self127 4))) (let ((f131 (get self127 5))) (let ((reply$133 ($Kind.Parser.text ":" reply.pst$127))) (let ((self133 reply$133)) (case (get self133 0) ('Parser.Reply.error (let ((f133 (get self133 1))) (let ((self134 f127)) (case (get self134 0) ('Maybe.none ($Parser.Reply.error f133)) ('Maybe.some (let ((f134 (get self134 1))) ($Parser.Reply.error ($Parser.Error.combine f134 f133)))))))) ('Parser.Reply.value (let ((f133 (get self133 1))) (let ((f134 (get self133 2))) (let ((self135 f133)) (case (get self135 0) ('Parser.State.new (let ((f135 (get self135 1))) (let ((f136 (get self135 2))) (let ((f137 (get self135 3))) (let ((f138 (get self135 4))) (let ((f139 (get self135 5))) (let ((reply.pst$141 ($Parser.State.new ($Parser.Error.maybe_combine f127 f135) f136 f137 f138 f139))) (let ((self141 reply.pst$141)) (case (get self141 0) ('Parser.State.new (let ((f141 (get self141 1))) (let ((f142 (get self141 2))) (let ((f143 (get self141 3))) (let ((f144 (get self141 4))) (let ((f145 (get self141 5))) (let ((reply$147 (Kind.Parser.term reply.pst$141))) (let ((self147 reply$147)) (case (get self147 0) ('Parser.Reply.error (let ((f147 (get self147 1))) (let ((self148 f141)) (case (get self148 0) ('Maybe.none ($Parser.Reply.error f147)) ('Maybe.some (let ((f148 (get self148 1))) ($Parser.Reply.error ($Parser.Error.combine f148 f147)))))))) ('Parser.Reply.value (let ((f147 (get self147 1))) (let ((f148 (get self147 2))) (let ((self149 f147)) (case (get self149 0) ('Parser.State.new (let ((f149 (get self149 1))) (let ((f150 (get self149 2))) (let ((f151 (get self149 3))) (let ((f152 (get self149 4))) (let ((f153 (get self149 5))) (let ((reply.pst$155 ($Parser.State.new ($Parser.Error.maybe_combine f141 f149) f150 f151 f152 f153))) (let ((self155 reply.pst$155)) (case (get self155 0) ('Parser.State.new (let ((f155 (get self155 1))) (let ((f156 (get self155 2))) (let ((f157 (get self155 3))) (let ((f158 (get self155 4))) (let ((f159 (get self155 5))) (let ((reply$161 ($Parser.maybe (Kind.Parser.text ";") reply.pst$155))) (let ((self161 reply$161)) (case (get self161 0) ('Parser.Reply.error (let ((f161 (get self161 1))) (let ((self162 f155)) (case (get self162 0) ('Maybe.none ($Parser.Reply.error f161)) ('Maybe.some (let ((f162 (get self162 1))) ($Parser.Reply.error ($Parser.Error.combine f162 f161)))))))) ('Parser.Reply.value (let ((f161 (get self161 1))) (let ((f162 (get self161 2))) (let ((self163 f161)) (case (get self163 0) ('Parser.State.new (let ((f163 (get self163 1))) (let ((f164 (get self163 2))) (let ((f165 (get self163 3))) (let ((f166 (get self163 4))) (let ((f167 (get self163 5))) (let ((reply.pst$169 ($Parser.State.new ($Parser.Error.maybe_combine f155 f163) f164 f165 f166 f167))) (let ((self169 reply.pst$169)) (case (get self169 0) ('Parser.State.new (let ((f169 (get self169 1))) (let ((f170 (get self169 2))) (let ((f171 (get self169 3))) (let ((f172 (get self169 4))) (let ((f173 (get self169 5))) (let ((reply$175 ((body$0 Unit.new) reply.pst$169))) (let ((self175 reply$175)) (case (get self175 0) ('Parser.Reply.error (let ((f175 (get self175 1))) (let ((self176 f169)) (case (get self176 0) ('Maybe.none ($Parser.Reply.error f175)) ('Maybe.some (let ((f176 (get self176 1))) ($Parser.Reply.error ($Parser.Error.combine f176 f175)))))))) ('Parser.Reply.value (let ((f175 (get self175 1))) (let ((f176 (get self175 2))) (let ((self177 f175)) (case (get self177 0) ('Parser.State.new (let ((f177 (get self177 1))) (let ((f178 (get self177 2))) (let ((f179 (get self177 3))) (let ((f180 (get self177 4))) (let ((f181 (get self177 5))) (let ((reply.pst$183 ($Parser.State.new ($Parser.Error.maybe_combine f169 f177) f178 f179 f180 f181))) (let ((moti$184 ($Kind.Term.lam "" (lambda (x$184) ($Kind.Term.hol Bits.e))))) (let ((term$185 ($Kind.Term.ref "Function.while"))) (let ((term$186 ($Kind.Term.app term$185 ($Kind.Term.hol Bits.e)))) (let ((init$187 ($Kind.Term.ref "Pair.new"))) (let ((init$188 ($Kind.Term.app init$187 ($Kind.Term.hol Bits.e)))) (let ((init$189 ($Kind.Term.app init$188 ($Kind.Term.hol Bits.e)))) (let ((init$190 ($Kind.Term.app init$189 ($Kind.Term.ref f36)))) (let ((init$191 ($Kind.Term.app init$190 ($Kind.Term.ref f64)))) (let ((term$192 ($Kind.Term.app term$186 init$191))) (let ((term$193 ($Kind.Term.app term$192 ($Kind.Term.lam "s" (lambda (s$193) ($Kind.Term.app ($Kind.Term.app s$193 moti$184) ($Kind.Term.lam f36 (lambda (x$194) ($Kind.Term.lam f64 (lambda (y$195) f120)))))))))) (let ((term$194 ($Kind.Term.app term$193 ($Kind.Term.lam "s" (lambda (s$194) ($Kind.Term.app ($Kind.Term.app s$194 moti$184) ($Kind.Term.lam f36 (lambda (x$195) ($Kind.Term.lam f64 (lambda (y$196) f148)))))))))) (let ((term$195 ($Kind.Term.app ($Kind.Term.app term$194 moti$184) ($Kind.Term.lam f36 (lambda (x$195) ($Kind.Term.lam f64 (lambda (y$196) f176))))))) ($Parser.Reply.value reply.pst$183 term$195)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.getwhile (lambda (body$0) ($Kind.Parser.getwhile body$0)))
(define ($Kind.Parser.getwhile.with body$0 pst$1) (let ((self0 pst$1)) (case (get self0 0) ('Parser.State.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((reply$7 ($Kind.Parser.text "while " pst$1))) (let ((self6 reply$7)) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))) (let ((self7 f0)) (case (get self7 0) ('Maybe.none ($Parser.Reply.error f6)) ('Maybe.some (let ((f7 (get self7 1))) ($Parser.Reply.error ($Parser.Error.combine f7 f6)))))))) ('Parser.Reply.value (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((self8 f6)) (case (get self8 0) ('Parser.State.new (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) (let ((f11 (get self8 4))) (let ((f12 (get self8 5))) (let ((reply.pst$15 ($Parser.State.new ($Parser.Error.maybe_combine f0 f8) f9 f10 f11 f12))) (let ((self14 reply.pst$15)) (case (get self14 0) ('Parser.State.new (let ((f14 (get self14 1))) (let ((f15 (get self14 2))) (let ((f16 (get self14 3))) (let ((f17 (get self14 4))) (let ((f18 (get self14 5))) (let ((reply$21 (Kind.Parser.term reply.pst$15))) (let ((self20 reply$21)) (case (get self20 0) ('Parser.Reply.error (let ((f20 (get self20 1))) (let ((self21 f14)) (case (get self21 0) ('Maybe.none ($Parser.Reply.error f20)) ('Maybe.some (let ((f21 (get self21 1))) ($Parser.Reply.error ($Parser.Error.combine f21 f20)))))))) ('Parser.Reply.value (let ((f20 (get self20 1))) (let ((f21 (get self20 2))) (let ((self22 f20)) (case (get self22 0) ('Parser.State.new (let ((f22 (get self22 1))) (let ((f23 (get self22 2))) (let ((f24 (get self22 3))) (let ((f25 (get self22 4))) (let ((f26 (get self22 5))) (let ((reply.pst$29 ($Parser.State.new ($Parser.Error.maybe_combine f14 f22) f23 f24 f25 f26))) (let ((self28 reply.pst$29)) (case (get self28 0) ('Parser.State.new (let ((f28 (get self28 1))) (let ((f29 (get self28 2))) (let ((f30 (get self28 3))) (let ((f31 (get self28 4))) (let ((f32 (get self28 5))) (let ((reply$35 ($Kind.Parser.text "with " reply.pst$29))) (let ((self34 reply$35)) (case (get self34 0) ('Parser.Reply.error (let ((f34 (get self34 1))) (let ((self35 f28)) (case (get self35 0) ('Maybe.none ($Parser.Reply.error f34)) ('Maybe.some (let ((f35 (get self35 1))) ($Parser.Reply.error ($Parser.Error.combine f35 f34)))))))) ('Parser.Reply.value (let ((f34 (get self34 1))) (let ((f35 (get self34 2))) (let ((self36 f34)) (case (get self36 0) ('Parser.State.new (let ((f36 (get self36 1))) (let ((f37 (get self36 2))) (let ((f38 (get self36 3))) (let ((f39 (get self36 4))) (let ((f40 (get self36 5))) (let ((reply.pst$43 ($Parser.State.new ($Parser.Error.maybe_combine f28 f36) f37 f38 f39 f40))) (let ((self42 reply.pst$43)) (case (get self42 0) ('Parser.State.new (let ((f42 (get self42 1))) (let ((f43 (get self42 2))) (let ((f44 (get self42 3))) (let ((f45 (get self42 4))) (let ((f46 (get self42 5))) (let ((reply$49 ($Kind.Parser.text "{" reply.pst$43))) (let ((self48 reply$49)) (case (get self48 0) ('Parser.Reply.error (let ((f48 (get self48 1))) (let ((self49 f42)) (case (get self49 0) ('Maybe.none ($Parser.Reply.error f48)) ('Maybe.some (let ((f49 (get self49 1))) ($Parser.Reply.error ($Parser.Error.combine f49 f48)))))))) ('Parser.Reply.value (let ((f48 (get self48 1))) (let ((f49 (get self48 2))) (let ((self50 f48)) (case (get self50 0) ('Parser.State.new (let ((f50 (get self50 1))) (let ((f51 (get self50 2))) (let ((f52 (get self50 3))) (let ((f53 (get self50 4))) (let ((f54 (get self50 5))) (let ((reply.pst$57 ($Parser.State.new ($Parser.Error.maybe_combine f42 f50) f51 f52 f53 f54))) (let ((self56 reply.pst$57)) (case (get self56 0) ('Parser.State.new (let ((f56 (get self56 1))) (let ((f57 (get self56 2))) (let ((f58 (get self56 3))) (let ((f59 (get self56 4))) (let ((f60 (get self56 5))) (let ((reply$63 ($Kind.Parser.name1 reply.pst$57))) (let ((self62 reply$63)) (case (get self62 0) ('Parser.Reply.error (let ((f62 (get self62 1))) (let ((self63 f56)) (case (get self63 0) ('Maybe.none ($Parser.Reply.error f62)) ('Maybe.some (let ((f63 (get self63 1))) ($Parser.Reply.error ($Parser.Error.combine f63 f62)))))))) ('Parser.Reply.value (let ((f62 (get self62 1))) (let ((f63 (get self62 2))) (let ((self64 f62)) (case (get self64 0) ('Parser.State.new (let ((f64 (get self64 1))) (let ((f65 (get self64 2))) (let ((f66 (get self64 3))) (let ((f67 (get self64 4))) (let ((f68 (get self64 5))) (let ((reply.pst$71 ($Parser.State.new ($Parser.Error.maybe_combine f56 f64) f65 f66 f67 f68))) (let ((self70 reply.pst$71)) (case (get self70 0) ('Parser.State.new (let ((f70 (get self70 1))) (let ((f71 (get self70 2))) (let ((f72 (get self70 3))) (let ((f73 (get self70 4))) (let ((f74 (get self70 5))) (let ((reply$77 ($Kind.Parser.text "," reply.pst$71))) (let ((self76 reply$77)) (case (get self76 0) ('Parser.Reply.error (let ((f76 (get self76 1))) (let ((self77 f70)) (case (get self77 0) ('Maybe.none ($Parser.Reply.error f76)) ('Maybe.some (let ((f77 (get self77 1))) ($Parser.Reply.error ($Parser.Error.combine f77 f76)))))))) ('Parser.Reply.value (let ((f76 (get self76 1))) (let ((f77 (get self76 2))) (let ((self78 f76)) (case (get self78 0) ('Parser.State.new (let ((f78 (get self78 1))) (let ((f79 (get self78 2))) (let ((f80 (get self78 3))) (let ((f81 (get self78 4))) (let ((f82 (get self78 5))) (let ((reply.pst$85 ($Parser.State.new ($Parser.Error.maybe_combine f70 f78) f79 f80 f81 f82))) (let ((self84 reply.pst$85)) (case (get self84 0) ('Parser.State.new (let ((f84 (get self84 1))) (let ((f85 (get self84 2))) (let ((f86 (get self84 3))) (let ((f87 (get self84 4))) (let ((f88 (get self84 5))) (let ((reply$91 ($Kind.Parser.name1 reply.pst$85))) (let ((self90 reply$91)) (case (get self90 0) ('Parser.Reply.error (let ((f90 (get self90 1))) (let ((self91 f84)) (case (get self91 0) ('Maybe.none ($Parser.Reply.error f90)) ('Maybe.some (let ((f91 (get self91 1))) ($Parser.Reply.error ($Parser.Error.combine f91 f90)))))))) ('Parser.Reply.value (let ((f90 (get self90 1))) (let ((f91 (get self90 2))) (let ((self92 f90)) (case (get self92 0) ('Parser.State.new (let ((f92 (get self92 1))) (let ((f93 (get self92 2))) (let ((f94 (get self92 3))) (let ((f95 (get self92 4))) (let ((f96 (get self92 5))) (let ((reply.pst$99 ($Parser.State.new ($Parser.Error.maybe_combine f84 f92) f93 f94 f95 f96))) (let ((self98 reply.pst$99)) (case (get self98 0) ('Parser.State.new (let ((f98 (get self98 1))) (let ((f99 (get self98 2))) (let ((f100 (get self98 3))) (let ((f101 (get self98 4))) (let ((f102 (get self98 5))) (let ((reply$105 ($Kind.Parser.text "}" reply.pst$99))) (let ((self104 reply$105)) (case (get self104 0) ('Parser.Reply.error (let ((f104 (get self104 1))) (let ((self105 f98)) (case (get self105 0) ('Maybe.none ($Parser.Reply.error f104)) ('Maybe.some (let ((f105 (get self105 1))) ($Parser.Reply.error ($Parser.Error.combine f105 f104)))))))) ('Parser.Reply.value (let ((f104 (get self104 1))) (let ((f105 (get self104 2))) (let ((self106 f104)) (case (get self106 0) ('Parser.State.new (let ((f106 (get self106 1))) (let ((f107 (get self106 2))) (let ((f108 (get self106 3))) (let ((f109 (get self106 4))) (let ((f110 (get self106 5))) (let ((reply.pst$113 ($Parser.State.new ($Parser.Error.maybe_combine f98 f106) f107 f108 f109 f110))) (let ((self112 reply.pst$113)) (case (get self112 0) ('Parser.State.new (let ((f112 (get self112 1))) (let ((f113 (get self112 2))) (let ((f114 (get self112 3))) (let ((f115 (get self112 4))) (let ((f116 (get self112 5))) (let ((reply$119 ($Kind.Parser.text ":" reply.pst$113))) (let ((self118 reply$119)) (case (get self118 0) ('Parser.Reply.error (let ((f118 (get self118 1))) (let ((self119 f112)) (case (get self119 0) ('Maybe.none ($Parser.Reply.error f118)) ('Maybe.some (let ((f119 (get self119 1))) ($Parser.Reply.error ($Parser.Error.combine f119 f118)))))))) ('Parser.Reply.value (let ((f118 (get self118 1))) (let ((f119 (get self118 2))) (let ((self120 f118)) (case (get self120 0) ('Parser.State.new (let ((f120 (get self120 1))) (let ((f121 (get self120 2))) (let ((f122 (get self120 3))) (let ((f123 (get self120 4))) (let ((f124 (get self120 5))) (let ((reply.pst$127 ($Parser.State.new ($Parser.Error.maybe_combine f112 f120) f121 f122 f123 f124))) (let ((self126 reply.pst$127)) (case (get self126 0) ('Parser.State.new (let ((f126 (get self126 1))) (let ((f127 (get self126 2))) (let ((f128 (get self126 3))) (let ((f129 (get self126 4))) (let ((f130 (get self126 5))) (let ((reply$133 (Kind.Parser.term reply.pst$127))) (let ((self132 reply$133)) (case (get self132 0) ('Parser.Reply.error (let ((f132 (get self132 1))) (let ((self133 f126)) (case (get self133 0) ('Maybe.none ($Parser.Reply.error f132)) ('Maybe.some (let ((f133 (get self133 1))) ($Parser.Reply.error ($Parser.Error.combine f133 f132)))))))) ('Parser.Reply.value (let ((f132 (get self132 1))) (let ((f133 (get self132 2))) (let ((self134 f132)) (case (get self134 0) ('Parser.State.new (let ((f134 (get self134 1))) (let ((f135 (get self134 2))) (let ((f136 (get self134 3))) (let ((f137 (get self134 4))) (let ((f138 (get self134 5))) (let ((reply.pst$141 ($Parser.State.new ($Parser.Error.maybe_combine f126 f134) f135 f136 f137 f138))) (let ((self140 reply.pst$141)) (case (get self140 0) ('Parser.State.new (let ((f140 (get self140 1))) (let ((f141 (get self140 2))) (let ((f142 (get self140 3))) (let ((f143 (get self140 4))) (let ((f144 (get self140 5))) (let ((reply$147 ($Parser.maybe (Kind.Parser.text ";") reply.pst$141))) (let ((self146 reply$147)) (case (get self146 0) ('Parser.Reply.error (let ((f146 (get self146 1))) (let ((self147 f140)) (case (get self147 0) ('Maybe.none ($Parser.Reply.error f146)) ('Maybe.some (let ((f147 (get self147 1))) ($Parser.Reply.error ($Parser.Error.combine f147 f146)))))))) ('Parser.Reply.value (let ((f146 (get self146 1))) (let ((f147 (get self146 2))) (let ((self148 f146)) (case (get self148 0) ('Parser.State.new (let ((f148 (get self148 1))) (let ((f149 (get self148 2))) (let ((f150 (get self148 3))) (let ((f151 (get self148 4))) (let ((f152 (get self148 5))) (let ((reply.pst$155 ($Parser.State.new ($Parser.Error.maybe_combine f140 f148) f149 f150 f151 f152))) (let ((self154 reply.pst$155)) (case (get self154 0) ('Parser.State.new (let ((f154 (get self154 1))) (let ((f155 (get self154 2))) (let ((f156 (get self154 3))) (let ((f157 (get self154 4))) (let ((f158 (get self154 5))) (let ((reply$161 ((body$0 Unit.new) reply.pst$155))) (let ((self160 reply$161)) (case (get self160 0) ('Parser.Reply.error (let ((f160 (get self160 1))) (let ((self161 f154)) (case (get self161 0) ('Maybe.none ($Parser.Reply.error f160)) ('Maybe.some (let ((f161 (get self161 1))) ($Parser.Reply.error ($Parser.Error.combine f161 f160)))))))) ('Parser.Reply.value (let ((f160 (get self160 1))) (let ((f161 (get self160 2))) (let ((self162 f160)) (case (get self162 0) ('Parser.State.new (let ((f162 (get self162 1))) (let ((f163 (get self162 2))) (let ((f164 (get self162 3))) (let ((f165 (get self162 4))) (let ((f166 (get self162 5))) (let ((reply.pst$169 ($Parser.State.new ($Parser.Error.maybe_combine f154 f162) f163 f164 f165 f166))) (let ((moti$170 ($Kind.Term.lam "" (lambda (x$170) ($Kind.Term.hol Bits.e))))) (let ((term$171 ($Kind.Term.ref "Function.while"))) (let ((term$172 ($Kind.Term.app term$171 ($Kind.Term.hol Bits.e)))) (let ((init$173 ($Kind.Term.ref "Pair.new"))) (let ((init$174 ($Kind.Term.app init$173 ($Kind.Term.hol Bits.e)))) (let ((init$175 ($Kind.Term.app init$174 ($Kind.Term.hol Bits.e)))) (let ((init$176 ($Kind.Term.app init$175 ($Kind.Term.ref f63)))) (let ((init$177 ($Kind.Term.app init$176 ($Kind.Term.ref f91)))) (let ((term$178 ($Kind.Term.app term$172 init$177))) (let ((term$179 ($Kind.Term.app term$178 ($Kind.Term.lam "s" (lambda (s$179) ($Kind.Term.app ($Kind.Term.app s$179 moti$170) ($Kind.Term.lam f63 (lambda (x$180) ($Kind.Term.lam f91 (lambda (y$181) f21)))))))))) (let ((term$180 ($Kind.Term.app term$179 ($Kind.Term.lam "s" (lambda (s$180) ($Kind.Term.app ($Kind.Term.app s$180 moti$170) ($Kind.Term.lam f63 (lambda (x$181) ($Kind.Term.lam f91 (lambda (y$182) f133)))))))))) (let ((term$181 ($Kind.Term.app ($Kind.Term.app term$180 moti$170) ($Kind.Term.lam f63 (lambda (x$181) ($Kind.Term.lam f91 (lambda (y$182) f161))))))) ($Parser.Reply.value reply.pst$169 term$181))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.getwhile.with (lambda (body$0) (lambda (pst$1) ($Kind.Parser.getwhile.with body$0 pst$1))))
(define ($Kind.Parser.get body$0) ((Kind.Parser.block "let") (lambda (pst$1) (let ((self1 pst$1)) (case (get self1 0) ('Parser.State.new (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((reply$7 ($Kind.Parser.text "let " pst$1))) (let ((self7 reply$7)) (case (get self7 0) ('Parser.Reply.error (let ((f7 (get self7 1))) (let ((self8 f1)) (case (get self8 0) ('Maybe.none ($Parser.Reply.error f7)) ('Maybe.some (let ((f8 (get self8 1))) ($Parser.Reply.error ($Parser.Error.combine f8 f7)))))))) ('Parser.Reply.value (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((self9 f7)) (case (get self9 0) ('Parser.State.new (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) (let ((reply.pst$15 ($Parser.State.new ($Parser.Error.maybe_combine f1 f9) f10 f11 f12 f13))) (let ((self15 reply.pst$15)) (case (get self15 0) ('Parser.State.new (let ((f15 (get self15 1))) (let ((f16 (get self15 2))) (let ((f17 (get self15 3))) (let ((f18 (get self15 4))) (let ((f19 (get self15 5))) (let ((reply$21 ($Kind.Parser.text "{" reply.pst$15))) (let ((self21 reply$21)) (case (get self21 0) ('Parser.Reply.error (let ((f21 (get self21 1))) (let ((self22 f15)) (case (get self22 0) ('Maybe.none ($Parser.Reply.error f21)) ('Maybe.some (let ((f22 (get self22 1))) ($Parser.Reply.error ($Parser.Error.combine f22 f21)))))))) ('Parser.Reply.value (let ((f21 (get self21 1))) (let ((f22 (get self21 2))) (let ((self23 f21)) (case (get self23 0) ('Parser.State.new (let ((f23 (get self23 1))) (let ((f24 (get self23 2))) (let ((f25 (get self23 3))) (let ((f26 (get self23 4))) (let ((f27 (get self23 5))) (let ((reply.pst$29 ($Parser.State.new ($Parser.Error.maybe_combine f15 f23) f24 f25 f26 f27))) (let ((self29 reply.pst$29)) (case (get self29 0) ('Parser.State.new (let ((f29 (get self29 1))) (let ((f30 (get self29 2))) (let ((f31 (get self29 3))) (let ((f32 (get self29 4))) (let ((f33 (get self29 5))) (let ((reply$35 ($Kind.Parser.name1 reply.pst$29))) (let ((self35 reply$35)) (case (get self35 0) ('Parser.Reply.error (let ((f35 (get self35 1))) (let ((self36 f29)) (case (get self36 0) ('Maybe.none ($Parser.Reply.error f35)) ('Maybe.some (let ((f36 (get self36 1))) ($Parser.Reply.error ($Parser.Error.combine f36 f35)))))))) ('Parser.Reply.value (let ((f35 (get self35 1))) (let ((f36 (get self35 2))) (let ((self37 f35)) (case (get self37 0) ('Parser.State.new (let ((f37 (get self37 1))) (let ((f38 (get self37 2))) (let ((f39 (get self37 3))) (let ((f40 (get self37 4))) (let ((f41 (get self37 5))) (let ((reply.pst$43 ($Parser.State.new ($Parser.Error.maybe_combine f29 f37) f38 f39 f40 f41))) (let ((self43 reply.pst$43)) (case (get self43 0) ('Parser.State.new (let ((f43 (get self43 1))) (let ((f44 (get self43 2))) (let ((f45 (get self43 3))) (let ((f46 (get self43 4))) (let ((f47 (get self43 5))) (let ((reply$49 ($Kind.Parser.text "," reply.pst$43))) (let ((self49 reply$49)) (case (get self49 0) ('Parser.Reply.error (let ((f49 (get self49 1))) (let ((self50 f43)) (case (get self50 0) ('Maybe.none ($Parser.Reply.error f49)) ('Maybe.some (let ((f50 (get self50 1))) ($Parser.Reply.error ($Parser.Error.combine f50 f49)))))))) ('Parser.Reply.value (let ((f49 (get self49 1))) (let ((f50 (get self49 2))) (let ((self51 f49)) (case (get self51 0) ('Parser.State.new (let ((f51 (get self51 1))) (let ((f52 (get self51 2))) (let ((f53 (get self51 3))) (let ((f54 (get self51 4))) (let ((f55 (get self51 5))) (let ((reply.pst$57 ($Parser.State.new ($Parser.Error.maybe_combine f43 f51) f52 f53 f54 f55))) (let ((self57 reply.pst$57)) (case (get self57 0) ('Parser.State.new (let ((f57 (get self57 1))) (let ((f58 (get self57 2))) (let ((f59 (get self57 3))) (let ((f60 (get self57 4))) (let ((f61 (get self57 5))) (let ((reply$63 ($Kind.Parser.name1 reply.pst$57))) (let ((self63 reply$63)) (case (get self63 0) ('Parser.Reply.error (let ((f63 (get self63 1))) (let ((self64 f57)) (case (get self64 0) ('Maybe.none ($Parser.Reply.error f63)) ('Maybe.some (let ((f64 (get self64 1))) ($Parser.Reply.error ($Parser.Error.combine f64 f63)))))))) ('Parser.Reply.value (let ((f63 (get self63 1))) (let ((f64 (get self63 2))) (let ((self65 f63)) (case (get self65 0) ('Parser.State.new (let ((f65 (get self65 1))) (let ((f66 (get self65 2))) (let ((f67 (get self65 3))) (let ((f68 (get self65 4))) (let ((f69 (get self65 5))) (let ((reply.pst$71 ($Parser.State.new ($Parser.Error.maybe_combine f57 f65) f66 f67 f68 f69))) (let ((self71 reply.pst$71)) (case (get self71 0) ('Parser.State.new (let ((f71 (get self71 1))) (let ((f72 (get self71 2))) (let ((f73 (get self71 3))) (let ((f74 (get self71 4))) (let ((f75 (get self71 5))) (let ((reply$77 ($Kind.Parser.text "}" reply.pst$71))) (let ((self77 reply$77)) (case (get self77 0) ('Parser.Reply.error (let ((f77 (get self77 1))) (let ((self78 f71)) (case (get self78 0) ('Maybe.none ($Parser.Reply.error f77)) ('Maybe.some (let ((f78 (get self78 1))) ($Parser.Reply.error ($Parser.Error.combine f78 f77)))))))) ('Parser.Reply.value (let ((f77 (get self77 1))) (let ((f78 (get self77 2))) (let ((self79 f77)) (case (get self79 0) ('Parser.State.new (let ((f79 (get self79 1))) (let ((f80 (get self79 2))) (let ((f81 (get self79 3))) (let ((f82 (get self79 4))) (let ((f83 (get self79 5))) (let ((reply.pst$85 ($Parser.State.new ($Parser.Error.maybe_combine f71 f79) f80 f81 f82 f83))) (let ((self85 reply.pst$85)) (case (get self85 0) ('Parser.State.new (let ((f85 (get self85 1))) (let ((f86 (get self85 2))) (let ((f87 (get self85 3))) (let ((f88 (get self85 4))) (let ((f89 (get self85 5))) (let ((reply$91 ($Kind.Parser.text "=" reply.pst$85))) (let ((self91 reply$91)) (case (get self91 0) ('Parser.Reply.error (let ((f91 (get self91 1))) (let ((self92 f85)) (case (get self92 0) ('Maybe.none ($Parser.Reply.error f91)) ('Maybe.some (let ((f92 (get self92 1))) ($Parser.Reply.error ($Parser.Error.combine f92 f91)))))))) ('Parser.Reply.value (let ((f91 (get self91 1))) (let ((f92 (get self91 2))) (let ((self93 f91)) (case (get self93 0) ('Parser.State.new (let ((f93 (get self93 1))) (let ((f94 (get self93 2))) (let ((f95 (get self93 3))) (let ((f96 (get self93 4))) (let ((f97 (get self93 5))) (let ((reply.pst$99 ($Parser.State.new ($Parser.Error.maybe_combine f85 f93) f94 f95 f96 f97))) (let ((self99 reply.pst$99)) (case (get self99 0) ('Parser.State.new (let ((f99 (get self99 1))) (let ((f100 (get self99 2))) (let ((f101 (get self99 3))) (let ((f102 (get self99 4))) (let ((f103 (get self99 5))) (let ((reply$105 (Kind.Parser.term reply.pst$99))) (let ((self105 reply$105)) (case (get self105 0) ('Parser.Reply.error (let ((f105 (get self105 1))) (let ((self106 f99)) (case (get self106 0) ('Maybe.none ($Parser.Reply.error f105)) ('Maybe.some (let ((f106 (get self106 1))) ($Parser.Reply.error ($Parser.Error.combine f106 f105)))))))) ('Parser.Reply.value (let ((f105 (get self105 1))) (let ((f106 (get self105 2))) (let ((self107 f105)) (case (get self107 0) ('Parser.State.new (let ((f107 (get self107 1))) (let ((f108 (get self107 2))) (let ((f109 (get self107 3))) (let ((f110 (get self107 4))) (let ((f111 (get self107 5))) (let ((reply.pst$113 ($Parser.State.new ($Parser.Error.maybe_combine f99 f107) f108 f109 f110 f111))) (let ((self113 reply.pst$113)) (case (get self113 0) ('Parser.State.new (let ((f113 (get self113 1))) (let ((f114 (get self113 2))) (let ((f115 (get self113 3))) (let ((f116 (get self113 4))) (let ((f117 (get self113 5))) (let ((reply$119 ($Parser.maybe (Kind.Parser.text ";") reply.pst$113))) (let ((self119 reply$119)) (case (get self119 0) ('Parser.Reply.error (let ((f119 (get self119 1))) (let ((self120 f113)) (case (get self120 0) ('Maybe.none ($Parser.Reply.error f119)) ('Maybe.some (let ((f120 (get self120 1))) ($Parser.Reply.error ($Parser.Error.combine f120 f119)))))))) ('Parser.Reply.value (let ((f119 (get self119 1))) (let ((f120 (get self119 2))) (let ((self121 f119)) (case (get self121 0) ('Parser.State.new (let ((f121 (get self121 1))) (let ((f122 (get self121 2))) (let ((f123 (get self121 3))) (let ((f124 (get self121 4))) (let ((f125 (get self121 5))) (let ((reply.pst$127 ($Parser.State.new ($Parser.Error.maybe_combine f113 f121) f122 f123 f124 f125))) (let ((self127 reply.pst$127)) (case (get self127 0) ('Parser.State.new (let ((f127 (get self127 1))) (let ((f128 (get self127 2))) (let ((f129 (get self127 3))) (let ((f130 (get self127 4))) (let ((f131 (get self127 5))) (let ((reply$133 ((body$0 Unit.new) reply.pst$127))) (let ((self133 reply$133)) (case (get self133 0) ('Parser.Reply.error (let ((f133 (get self133 1))) (let ((self134 f127)) (case (get self134 0) ('Maybe.none ($Parser.Reply.error f133)) ('Maybe.some (let ((f134 (get self134 1))) ($Parser.Reply.error ($Parser.Error.combine f134 f133)))))))) ('Parser.Reply.value (let ((f133 (get self133 1))) (let ((f134 (get self133 2))) (let ((self135 f133)) (case (get self135 0) ('Parser.State.new (let ((f135 (get self135 1))) (let ((f136 (get self135 2))) (let ((f137 (get self135 3))) (let ((f138 (get self135 4))) (let ((f139 (get self135 5))) (let ((reply.pst$141 ($Parser.State.new ($Parser.Error.maybe_combine f127 f135) f136 f137 f138 f139))) (let ((term$142 f106)) (let ((term$143 ($Kind.Term.app term$142 ($Kind.Term.lam "" (lambda (x$143) ($Kind.Term.hol Bits.e)))))) (let ((term$144 ($Kind.Term.app term$143 ($Kind.Term.lam f36 (lambda (x$144) ($Kind.Term.lam f64 (lambda (y$145) f134))))))) ($Parser.Reply.value reply.pst$141 term$144)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.get (lambda (body$0) ($Kind.Parser.get body$0)))
(define ($Kind.Parser.get.omit body$0) ((Kind.Parser.block "let") (lambda (pst$1) (let ((self1 pst$1)) (case (get self1 0) ('Parser.State.new (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((reply$7 ($Kind.Parser.text "{" pst$1))) (let ((self7 reply$7)) (case (get self7 0) ('Parser.Reply.error (let ((f7 (get self7 1))) (let ((self8 f1)) (case (get self8 0) ('Maybe.none ($Parser.Reply.error f7)) ('Maybe.some (let ((f8 (get self8 1))) ($Parser.Reply.error ($Parser.Error.combine f8 f7)))))))) ('Parser.Reply.value (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((self9 f7)) (case (get self9 0) ('Parser.State.new (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) (let ((reply.pst$15 ($Parser.State.new ($Parser.Error.maybe_combine f1 f9) f10 f11 f12 f13))) (let ((self15 reply.pst$15)) (case (get self15 0) ('Parser.State.new (let ((f15 (get self15 1))) (let ((f16 (get self15 2))) (let ((f17 (get self15 3))) (let ((f18 (get self15 4))) (let ((f19 (get self15 5))) (let ((reply$21 ($Kind.Parser.name1 reply.pst$15))) (let ((self21 reply$21)) (case (get self21 0) ('Parser.Reply.error (let ((f21 (get self21 1))) (let ((self22 f15)) (case (get self22 0) ('Maybe.none ($Parser.Reply.error f21)) ('Maybe.some (let ((f22 (get self22 1))) ($Parser.Reply.error ($Parser.Error.combine f22 f21)))))))) ('Parser.Reply.value (let ((f21 (get self21 1))) (let ((f22 (get self21 2))) (let ((self23 f21)) (case (get self23 0) ('Parser.State.new (let ((f23 (get self23 1))) (let ((f24 (get self23 2))) (let ((f25 (get self23 3))) (let ((f26 (get self23 4))) (let ((f27 (get self23 5))) (let ((reply.pst$29 ($Parser.State.new ($Parser.Error.maybe_combine f15 f23) f24 f25 f26 f27))) (let ((self29 reply.pst$29)) (case (get self29 0) ('Parser.State.new (let ((f29 (get self29 1))) (let ((f30 (get self29 2))) (let ((f31 (get self29 3))) (let ((f32 (get self29 4))) (let ((f33 (get self29 5))) (let ((reply$35 ($Kind.Parser.text "," reply.pst$29))) (let ((self35 reply$35)) (case (get self35 0) ('Parser.Reply.error (let ((f35 (get self35 1))) (let ((self36 f29)) (case (get self36 0) ('Maybe.none ($Parser.Reply.error f35)) ('Maybe.some (let ((f36 (get self36 1))) ($Parser.Reply.error ($Parser.Error.combine f36 f35)))))))) ('Parser.Reply.value (let ((f35 (get self35 1))) (let ((f36 (get self35 2))) (let ((self37 f35)) (case (get self37 0) ('Parser.State.new (let ((f37 (get self37 1))) (let ((f38 (get self37 2))) (let ((f39 (get self37 3))) (let ((f40 (get self37 4))) (let ((f41 (get self37 5))) (let ((reply.pst$43 ($Parser.State.new ($Parser.Error.maybe_combine f29 f37) f38 f39 f40 f41))) (let ((self43 reply.pst$43)) (case (get self43 0) ('Parser.State.new (let ((f43 (get self43 1))) (let ((f44 (get self43 2))) (let ((f45 (get self43 3))) (let ((f46 (get self43 4))) (let ((f47 (get self43 5))) (let ((reply$49 ($Kind.Parser.name1 reply.pst$43))) (let ((self49 reply$49)) (case (get self49 0) ('Parser.Reply.error (let ((f49 (get self49 1))) (let ((self50 f43)) (case (get self50 0) ('Maybe.none ($Parser.Reply.error f49)) ('Maybe.some (let ((f50 (get self50 1))) ($Parser.Reply.error ($Parser.Error.combine f50 f49)))))))) ('Parser.Reply.value (let ((f49 (get self49 1))) (let ((f50 (get self49 2))) (let ((self51 f49)) (case (get self51 0) ('Parser.State.new (let ((f51 (get self51 1))) (let ((f52 (get self51 2))) (let ((f53 (get self51 3))) (let ((f54 (get self51 4))) (let ((f55 (get self51 5))) (let ((reply.pst$57 ($Parser.State.new ($Parser.Error.maybe_combine f43 f51) f52 f53 f54 f55))) (let ((self57 reply.pst$57)) (case (get self57 0) ('Parser.State.new (let ((f57 (get self57 1))) (let ((f58 (get self57 2))) (let ((f59 (get self57 3))) (let ((f60 (get self57 4))) (let ((f61 (get self57 5))) (let ((reply$63 ($Kind.Parser.text "}" reply.pst$57))) (let ((self63 reply$63)) (case (get self63 0) ('Parser.Reply.error (let ((f63 (get self63 1))) (let ((self64 f57)) (case (get self64 0) ('Maybe.none ($Parser.Reply.error f63)) ('Maybe.some (let ((f64 (get self64 1))) ($Parser.Reply.error ($Parser.Error.combine f64 f63)))))))) ('Parser.Reply.value (let ((f63 (get self63 1))) (let ((f64 (get self63 2))) (let ((self65 f63)) (case (get self65 0) ('Parser.State.new (let ((f65 (get self65 1))) (let ((f66 (get self65 2))) (let ((f67 (get self65 3))) (let ((f68 (get self65 4))) (let ((f69 (get self65 5))) (let ((reply.pst$71 ($Parser.State.new ($Parser.Error.maybe_combine f57 f65) f66 f67 f68 f69))) (let ((self71 reply.pst$71)) (case (get self71 0) ('Parser.State.new (let ((f71 (get self71 1))) (let ((f72 (get self71 2))) (let ((f73 (get self71 3))) (let ((f74 (get self71 4))) (let ((f75 (get self71 5))) (let ((reply$77 ($Kind.Parser.text "= " reply.pst$71))) (let ((self77 reply$77)) (case (get self77 0) ('Parser.Reply.error (let ((f77 (get self77 1))) (let ((self78 f71)) (case (get self78 0) ('Maybe.none ($Parser.Reply.error f77)) ('Maybe.some (let ((f78 (get self78 1))) ($Parser.Reply.error ($Parser.Error.combine f78 f77)))))))) ('Parser.Reply.value (let ((f77 (get self77 1))) (let ((f78 (get self77 2))) (let ((self79 f77)) (case (get self79 0) ('Parser.State.new (let ((f79 (get self79 1))) (let ((f80 (get self79 2))) (let ((f81 (get self79 3))) (let ((f82 (get self79 4))) (let ((f83 (get self79 5))) (let ((reply.pst$85 ($Parser.State.new ($Parser.Error.maybe_combine f71 f79) f80 f81 f82 f83))) (let ((self85 reply.pst$85)) (case (get self85 0) ('Parser.State.new (let ((f85 (get self85 1))) (let ((f86 (get self85 2))) (let ((f87 (get self85 3))) (let ((f88 (get self85 4))) (let ((f89 (get self85 5))) (let ((reply$91 (Kind.Parser.term reply.pst$85))) (let ((self91 reply$91)) (case (get self91 0) ('Parser.Reply.error (let ((f91 (get self91 1))) (let ((self92 f85)) (case (get self92 0) ('Maybe.none ($Parser.Reply.error f91)) ('Maybe.some (let ((f92 (get self92 1))) ($Parser.Reply.error ($Parser.Error.combine f92 f91)))))))) ('Parser.Reply.value (let ((f91 (get self91 1))) (let ((f92 (get self91 2))) (let ((self93 f91)) (case (get self93 0) ('Parser.State.new (let ((f93 (get self93 1))) (let ((f94 (get self93 2))) (let ((f95 (get self93 3))) (let ((f96 (get self93 4))) (let ((f97 (get self93 5))) (let ((reply.pst$99 ($Parser.State.new ($Parser.Error.maybe_combine f85 f93) f94 f95 f96 f97))) (let ((self99 reply.pst$99)) (case (get self99 0) ('Parser.State.new (let ((f99 (get self99 1))) (let ((f100 (get self99 2))) (let ((f101 (get self99 3))) (let ((f102 (get self99 4))) (let ((f103 (get self99 5))) (let ((reply$105 ($Parser.maybe (Kind.Parser.text ";") reply.pst$99))) (let ((self105 reply$105)) (case (get self105 0) ('Parser.Reply.error (let ((f105 (get self105 1))) (let ((self106 f99)) (case (get self106 0) ('Maybe.none ($Parser.Reply.error f105)) ('Maybe.some (let ((f106 (get self106 1))) ($Parser.Reply.error ($Parser.Error.combine f106 f105)))))))) ('Parser.Reply.value (let ((f105 (get self105 1))) (let ((f106 (get self105 2))) (let ((self107 f105)) (case (get self107 0) ('Parser.State.new (let ((f107 (get self107 1))) (let ((f108 (get self107 2))) (let ((f109 (get self107 3))) (let ((f110 (get self107 4))) (let ((f111 (get self107 5))) (let ((reply.pst$113 ($Parser.State.new ($Parser.Error.maybe_combine f99 f107) f108 f109 f110 f111))) (let ((self113 reply.pst$113)) (case (get self113 0) ('Parser.State.new (let ((f113 (get self113 1))) (let ((f114 (get self113 2))) (let ((f115 (get self113 3))) (let ((f116 (get self113 4))) (let ((f117 (get self113 5))) (let ((reply$119 ((body$0 Unit.new) reply.pst$113))) (let ((self119 reply$119)) (case (get self119 0) ('Parser.Reply.error (let ((f119 (get self119 1))) (let ((self120 f113)) (case (get self120 0) ('Maybe.none ($Parser.Reply.error f119)) ('Maybe.some (let ((f120 (get self120 1))) ($Parser.Reply.error ($Parser.Error.combine f120 f119)))))))) ('Parser.Reply.value (let ((f119 (get self119 1))) (let ((f120 (get self119 2))) (let ((self121 f119)) (case (get self121 0) ('Parser.State.new (let ((f121 (get self121 1))) (let ((f122 (get self121 2))) (let ((f123 (get self121 3))) (let ((f124 (get self121 4))) (let ((f125 (get self121 5))) (let ((reply.pst$127 ($Parser.State.new ($Parser.Error.maybe_combine f113 f121) f122 f123 f124 f125))) (let ((term$128 f92)) (let ((term$129 ($Kind.Term.app term$128 ($Kind.Term.lam "" (lambda (x$129) ($Kind.Term.hol Bits.e)))))) (let ((term$130 ($Kind.Term.app term$129 ($Kind.Term.lam f22 (lambda (x$130) ($Kind.Term.lam f50 (lambda (y$131) f120))))))) ($Parser.Reply.value reply.pst$127 term$130))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.get.omit (lambda (body$0) ($Kind.Parser.get.omit body$0)))
(define ($Kind.Parser.def body$0) ((Kind.Parser.block "def") (lambda (pst$1) (let ((self1 pst$1)) (case (get self1 0) ('Parser.State.new (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((reply$7 ($Kind.Parser.text "def " pst$1))) (let ((self7 reply$7)) (case (get self7 0) ('Parser.Reply.error (let ((f7 (get self7 1))) (let ((self8 f1)) (case (get self8 0) ('Maybe.none ($Parser.Reply.error f7)) ('Maybe.some (let ((f8 (get self8 1))) ($Parser.Reply.error ($Parser.Error.combine f8 f7)))))))) ('Parser.Reply.value (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((self9 f7)) (case (get self9 0) ('Parser.State.new (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) (let ((reply.pst$15 ($Parser.State.new ($Parser.Error.maybe_combine f1 f9) f10 f11 f12 f13))) (let ((self15 reply.pst$15)) (case (get self15 0) ('Parser.State.new (let ((f15 (get self15 1))) (let ((f16 (get self15 2))) (let ((f17 (get self15 3))) (let ((f18 (get self15 4))) (let ((f19 (get self15 5))) (let ((reply$21 ($Kind.Parser.name1 reply.pst$15))) (let ((self21 reply$21)) (case (get self21 0) ('Parser.Reply.error (let ((f21 (get self21 1))) (let ((self22 f15)) (case (get self22 0) ('Maybe.none ($Parser.Reply.error f21)) ('Maybe.some (let ((f22 (get self22 1))) ($Parser.Reply.error ($Parser.Error.combine f22 f21)))))))) ('Parser.Reply.value (let ((f21 (get self21 1))) (let ((f22 (get self21 2))) (let ((self23 f21)) (case (get self23 0) ('Parser.State.new (let ((f23 (get self23 1))) (let ((f24 (get self23 2))) (let ((f25 (get self23 3))) (let ((f26 (get self23 4))) (let ((f27 (get self23 5))) (let ((reply.pst$29 ($Parser.State.new ($Parser.Error.maybe_combine f15 f23) f24 f25 f26 f27))) (let ((self29 reply.pst$29)) (case (get self29 0) ('Parser.State.new (let ((f29 (get self29 1))) (let ((f30 (get self29 2))) (let ((f31 (get self29 3))) (let ((f32 (get self29 4))) (let ((f33 (get self29 5))) (let ((reply$35 ($Kind.Parser.text "=" reply.pst$29))) (let ((self35 reply$35)) (case (get self35 0) ('Parser.Reply.error (let ((f35 (get self35 1))) (let ((self36 f29)) (case (get self36 0) ('Maybe.none ($Parser.Reply.error f35)) ('Maybe.some (let ((f36 (get self36 1))) ($Parser.Reply.error ($Parser.Error.combine f36 f35)))))))) ('Parser.Reply.value (let ((f35 (get self35 1))) (let ((f36 (get self35 2))) (let ((self37 f35)) (case (get self37 0) ('Parser.State.new (let ((f37 (get self37 1))) (let ((f38 (get self37 2))) (let ((f39 (get self37 3))) (let ((f40 (get self37 4))) (let ((f41 (get self37 5))) (let ((reply.pst$43 ($Parser.State.new ($Parser.Error.maybe_combine f29 f37) f38 f39 f40 f41))) (let ((self43 reply.pst$43)) (case (get self43 0) ('Parser.State.new (let ((f43 (get self43 1))) (let ((f44 (get self43 2))) (let ((f45 (get self43 3))) (let ((f46 (get self43 4))) (let ((f47 (get self43 5))) (let ((reply$49 (Kind.Parser.term reply.pst$43))) (let ((self49 reply$49)) (case (get self49 0) ('Parser.Reply.error (let ((f49 (get self49 1))) (let ((self50 f43)) (case (get self50 0) ('Maybe.none ($Parser.Reply.error f49)) ('Maybe.some (let ((f50 (get self50 1))) ($Parser.Reply.error ($Parser.Error.combine f50 f49)))))))) ('Parser.Reply.value (let ((f49 (get self49 1))) (let ((f50 (get self49 2))) (let ((self51 f49)) (case (get self51 0) ('Parser.State.new (let ((f51 (get self51 1))) (let ((f52 (get self51 2))) (let ((f53 (get self51 3))) (let ((f54 (get self51 4))) (let ((f55 (get self51 5))) (let ((reply.pst$57 ($Parser.State.new ($Parser.Error.maybe_combine f43 f51) f52 f53 f54 f55))) (let ((self57 reply.pst$57)) (case (get self57 0) ('Parser.State.new (let ((f57 (get self57 1))) (let ((f58 (get self57 2))) (let ((f59 (get self57 3))) (let ((f60 (get self57 4))) (let ((f61 (get self57 5))) (let ((reply$63 ($Parser.maybe (Kind.Parser.text ";") reply.pst$57))) (let ((self63 reply$63)) (case (get self63 0) ('Parser.Reply.error (let ((f63 (get self63 1))) (let ((self64 f57)) (case (get self64 0) ('Maybe.none ($Parser.Reply.error f63)) ('Maybe.some (let ((f64 (get self64 1))) ($Parser.Reply.error ($Parser.Error.combine f64 f63)))))))) ('Parser.Reply.value (let ((f63 (get self63 1))) (let ((f64 (get self63 2))) (let ((self65 f63)) (case (get self65 0) ('Parser.State.new (let ((f65 (get self65 1))) (let ((f66 (get self65 2))) (let ((f67 (get self65 3))) (let ((f68 (get self65 4))) (let ((f69 (get self65 5))) (let ((reply.pst$71 ($Parser.State.new ($Parser.Error.maybe_combine f57 f65) f66 f67 f68 f69))) (let ((self71 reply.pst$71)) (case (get self71 0) ('Parser.State.new (let ((f71 (get self71 1))) (let ((f72 (get self71 2))) (let ((f73 (get self71 3))) (let ((f74 (get self71 4))) (let ((f75 (get self71 5))) (let ((reply$77 ((body$0 Unit.new) reply.pst$71))) (let ((self77 reply$77)) (case (get self77 0) ('Parser.Reply.error (let ((f77 (get self77 1))) (let ((self78 f71)) (case (get self78 0) ('Maybe.none ($Parser.Reply.error f77)) ('Maybe.some (let ((f78 (get self78 1))) ($Parser.Reply.error ($Parser.Error.combine f78 f77)))))))) ('Parser.Reply.value (let ((f77 (get self77 1))) (let ((f78 (get self77 2))) (let ((self79 f77)) (case (get self79 0) ('Parser.State.new (let ((f79 (get self79 1))) (let ((f80 (get self79 2))) (let ((f81 (get self79 3))) (let ((f82 (get self79 4))) (let ((f83 (get self79 5))) (let ((reply.pst$85 ($Parser.State.new ($Parser.Error.maybe_combine f71 f79) f80 f81 f82 f83))) ($Parser.Reply.value reply.pst$85 ($Kind.Term.def f22 f50 (lambda (x$86) f78))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.def (lambda (body$0) ($Kind.Parser.def body$0)))
(define ($Kind.Term.cse path$0 expr$1 name$2 with$3 cses$4 moti$5) (vector 'Kind.Term.cse path$0 expr$1 name$2 with$3 cses$4 moti$5))
(define Kind.Term.cse (lambda (path$0) (lambda (expr$1) (lambda (name$2) (lambda (with$3) (lambda (cses$4) (lambda (moti$5) ($Kind.Term.cse path$0 expr$1 name$2 with$3 cses$4 moti$5))))))))
(define ($Kind.Parser.use.abort body$0) ((Kind.Parser.block "use") (lambda (pst$1) (let ((self1 pst$1)) (case (get self1 0) ('Parser.State.new (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((reply$7 ($Kind.Parser.text "use " pst$1))) (let ((self7 reply$7)) (case (get self7 0) ('Parser.Reply.error (let ((f7 (get self7 1))) (let ((self8 f1)) (case (get self8 0) ('Maybe.none ($Parser.Reply.error f7)) ('Maybe.some (let ((f8 (get self8 1))) ($Parser.Reply.error ($Parser.Error.combine f8 f7)))))))) ('Parser.Reply.value (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((self9 f7)) (case (get self9 0) ('Parser.State.new (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) (let ((reply.pst$15 ($Parser.State.new ($Parser.Error.maybe_combine f1 f9) f10 f11 f12 f13))) (let ((self15 reply.pst$15)) (case (get self15 0) ('Parser.State.new (let ((f15 (get self15 1))) (let ((f16 (get self15 2))) (let ((f17 (get self15 3))) (let ((f18 (get self15 4))) (let ((f19 (get self15 5))) (let ((reply$21 ($Kind.Parser.name1 reply.pst$15))) (let ((self21 reply$21)) (case (get self21 0) ('Parser.Reply.error (let ((f21 (get self21 1))) (let ((self22 f15)) (case (get self22 0) ('Maybe.none ($Parser.Reply.error f21)) ('Maybe.some (let ((f22 (get self22 1))) ($Parser.Reply.error ($Parser.Error.combine f22 f21)))))))) ('Parser.Reply.value (let ((f21 (get self21 1))) (let ((f22 (get self21 2))) (let ((self23 f21)) (case (get self23 0) ('Parser.State.new (let ((f23 (get self23 1))) (let ((f24 (get self23 2))) (let ((f25 (get self23 3))) (let ((f26 (get self23 4))) (let ((f27 (get self23 5))) (let ((reply.pst$29 ($Parser.State.new ($Parser.Error.maybe_combine f15 f23) f24 f25 f26 f27))) (let ((self29 reply.pst$29)) (case (get self29 0) ('Parser.State.new (let ((f29 (get self29 1))) (let ((f30 (get self29 2))) (let ((f31 (get self29 3))) (let ((f32 (get self29 4))) (let ((f33 (get self29 5))) (let ((reply$35 ($Kind.Parser.text "=" reply.pst$29))) (let ((self35 reply$35)) (case (get self35 0) ('Parser.Reply.error (let ((f35 (get self35 1))) (let ((self36 f29)) (case (get self36 0) ('Maybe.none ($Parser.Reply.error f35)) ('Maybe.some (let ((f36 (get self36 1))) ($Parser.Reply.error ($Parser.Error.combine f36 f35)))))))) ('Parser.Reply.value (let ((f35 (get self35 1))) (let ((f36 (get self35 2))) (let ((self37 f35)) (case (get self37 0) ('Parser.State.new (let ((f37 (get self37 1))) (let ((f38 (get self37 2))) (let ((f39 (get self37 3))) (let ((f40 (get self37 4))) (let ((f41 (get self37 5))) (let ((reply.pst$43 ($Parser.State.new ($Parser.Error.maybe_combine f29 f37) f38 f39 f40 f41))) (let ((self43 reply.pst$43)) (case (get self43 0) ('Parser.State.new (let ((f43 (get self43 1))) (let ((f44 (get self43 2))) (let ((f45 (get self43 3))) (let ((f46 (get self43 4))) (let ((f47 (get self43 5))) (let ((reply$49 (Kind.Parser.term reply.pst$43))) (let ((self49 reply$49)) (case (get self49 0) ('Parser.Reply.error (let ((f49 (get self49 1))) (let ((self50 f43)) (case (get self50 0) ('Maybe.none ($Parser.Reply.error f49)) ('Maybe.some (let ((f50 (get self50 1))) ($Parser.Reply.error ($Parser.Error.combine f50 f49)))))))) ('Parser.Reply.value (let ((f49 (get self49 1))) (let ((f50 (get self49 2))) (let ((self51 f49)) (case (get self51 0) ('Parser.State.new (let ((f51 (get self51 1))) (let ((f52 (get self51 2))) (let ((f53 (get self51 3))) (let ((f54 (get self51 4))) (let ((f55 (get self51 5))) (let ((reply.pst$57 ($Parser.State.new ($Parser.Error.maybe_combine f43 f51) f52 f53 f54 f55))) (let ((self57 reply.pst$57)) (case (get self57 0) ('Parser.State.new (let ((f57 (get self57 1))) (let ((f58 (get self57 2))) (let ((f59 (get self57 3))) (let ((f60 (get self57 4))) (let ((f61 (get self57 5))) (let ((reply$63 ($Kind.Parser.text "abort " reply.pst$57))) (let ((self63 reply$63)) (case (get self63 0) ('Parser.Reply.error (let ((f63 (get self63 1))) (let ((self64 f57)) (case (get self64 0) ('Maybe.none ($Parser.Reply.error f63)) ('Maybe.some (let ((f64 (get self64 1))) ($Parser.Reply.error ($Parser.Error.combine f64 f63)))))))) ('Parser.Reply.value (let ((f63 (get self63 1))) (let ((f64 (get self63 2))) (let ((self65 f63)) (case (get self65 0) ('Parser.State.new (let ((f65 (get self65 1))) (let ((f66 (get self65 2))) (let ((f67 (get self65 3))) (let ((f68 (get self65 4))) (let ((f69 (get self65 5))) (let ((reply.pst$71 ($Parser.State.new ($Parser.Error.maybe_combine f57 f65) f66 f67 f68 f69))) (let ((self71 reply.pst$71)) (case (get self71 0) ('Parser.State.new (let ((f71 (get self71 1))) (let ((f72 (get self71 2))) (let ((f73 (get self71 3))) (let ((f74 (get self71 4))) (let ((f75 (get self71 5))) (let ((reply$77 (Kind.Parser.term reply.pst$71))) (let ((self77 reply$77)) (case (get self77 0) ('Parser.Reply.error (let ((f77 (get self77 1))) (let ((self78 f71)) (case (get self78 0) ('Maybe.none ($Parser.Reply.error f77)) ('Maybe.some (let ((f78 (get self78 1))) ($Parser.Reply.error ($Parser.Error.combine f78 f77)))))))) ('Parser.Reply.value (let ((f77 (get self77 1))) (let ((f78 (get self77 2))) (let ((self79 f77)) (case (get self79 0) ('Parser.State.new (let ((f79 (get self79 1))) (let ((f80 (get self79 2))) (let ((f81 (get self79 3))) (let ((f82 (get self79 4))) (let ((f83 (get self79 5))) (let ((reply.pst$85 ($Parser.State.new ($Parser.Error.maybe_combine f71 f79) f80 f81 f82 f83))) (let ((self85 reply.pst$85)) (case (get self85 0) ('Parser.State.new (let ((f85 (get self85 1))) (let ((f86 (get self85 2))) (let ((f87 (get self85 3))) (let ((f88 (get self85 4))) (let ((f89 (get self85 5))) (let ((reply$91 ($Parser.maybe (Kind.Parser.text ";") reply.pst$85))) (let ((self91 reply$91)) (case (get self91 0) ('Parser.Reply.error (let ((f91 (get self91 1))) (let ((self92 f85)) (case (get self92 0) ('Maybe.none ($Parser.Reply.error f91)) ('Maybe.some (let ((f92 (get self92 1))) ($Parser.Reply.error ($Parser.Error.combine f92 f91)))))))) ('Parser.Reply.value (let ((f91 (get self91 1))) (let ((f92 (get self91 2))) (let ((self93 f91)) (case (get self93 0) ('Parser.State.new (let ((f93 (get self93 1))) (let ((f94 (get self93 2))) (let ((f95 (get self93 3))) (let ((f96 (get self93 4))) (let ((f97 (get self93 5))) (let ((reply.pst$99 ($Parser.State.new ($Parser.Error.maybe_combine f85 f93) f94 f95 f96 f97))) (let ((self99 reply.pst$99)) (case (get self99 0) ('Parser.State.new (let ((f99 (get self99 1))) (let ((f100 (get self99 2))) (let ((f101 (get self99 3))) (let ((f102 (get self99 4))) (let ((f103 (get self99 5))) (let ((reply$105 ((body$0 Unit.new) reply.pst$99))) (let ((self105 reply$105)) (case (get self105 0) ('Parser.Reply.error (let ((f105 (get self105 1))) (let ((self106 f99)) (case (get self106 0) ('Maybe.none ($Parser.Reply.error f105)) ('Maybe.some (let ((f106 (get self106 1))) ($Parser.Reply.error ($Parser.Error.combine f106 f105)))))))) ('Parser.Reply.value (let ((f105 (get self105 1))) (let ((f106 (get self105 2))) (let ((self107 f105)) (case (get self107 0) ('Parser.State.new (let ((f107 (get self107 1))) (let ((f108 (get self107 2))) (let ((f109 (get self107 3))) (let ((f110 (get self107 4))) (let ((f111 (get self107 5))) (let ((reply.pst$113 ($Parser.State.new ($Parser.Error.maybe_combine f99 f107) f108 f109 f110 f111))) (let ((term$114 f50)) (let ((term$115 ($Kind.Term.app term$114 ($Kind.Term.lam "" (lambda ($115) ($Kind.Term.hol Bits.e)))))) (let ((term$116 ($Kind.Term.app term$115 f78))) (let ((term$117 ($Kind.Term.app term$116 ($Kind.Term.lam f22 (lambda ($117) (let ((wyth$118 List.nil)) (let ((cses$119 ($Kind.Map.set "_" f106 Kind.Map.new))) (let ((moti$120 ($Maybe.some ($Kind.Term.hol Bits.e)))) (let ((term$121 ($Kind.Term.let f22 ($Kind.Term.ref f22) (lambda ($121) ($Kind.Term.cse Bits.e ($Kind.Term.ref f22) f22 wyth$118 cses$119 moti$120))))) term$121))))))))) ($Parser.Reply.value reply.pst$113 term$117))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.use.abort (lambda (body$0) ($Kind.Parser.use.abort body$0)))
(define ($Kind.Parser.use body$0) ((Kind.Parser.block "use") (lambda (pst$1) (let ((self1 pst$1)) (case (get self1 0) ('Parser.State.new (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((reply$7 ($Kind.Parser.text "use " pst$1))) (let ((self7 reply$7)) (case (get self7 0) ('Parser.Reply.error (let ((f7 (get self7 1))) (let ((self8 f1)) (case (get self8 0) ('Maybe.none ($Parser.Reply.error f7)) ('Maybe.some (let ((f8 (get self8 1))) ($Parser.Reply.error ($Parser.Error.combine f8 f7)))))))) ('Parser.Reply.value (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((self9 f7)) (case (get self9 0) ('Parser.State.new (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) (let ((reply.pst$15 ($Parser.State.new ($Parser.Error.maybe_combine f1 f9) f10 f11 f12 f13))) (let ((self15 reply.pst$15)) (case (get self15 0) ('Parser.State.new (let ((f15 (get self15 1))) (let ((f16 (get self15 2))) (let ((f17 (get self15 3))) (let ((f18 (get self15 4))) (let ((f19 (get self15 5))) (let ((reply$21 ($Kind.Parser.name1 reply.pst$15))) (let ((self21 reply$21)) (case (get self21 0) ('Parser.Reply.error (let ((f21 (get self21 1))) (let ((self22 f15)) (case (get self22 0) ('Maybe.none ($Parser.Reply.error f21)) ('Maybe.some (let ((f22 (get self22 1))) ($Parser.Reply.error ($Parser.Error.combine f22 f21)))))))) ('Parser.Reply.value (let ((f21 (get self21 1))) (let ((f22 (get self21 2))) (let ((self23 f21)) (case (get self23 0) ('Parser.State.new (let ((f23 (get self23 1))) (let ((f24 (get self23 2))) (let ((f25 (get self23 3))) (let ((f26 (get self23 4))) (let ((f27 (get self23 5))) (let ((reply.pst$29 ($Parser.State.new ($Parser.Error.maybe_combine f15 f23) f24 f25 f26 f27))) (let ((self29 reply.pst$29)) (case (get self29 0) ('Parser.State.new (let ((f29 (get self29 1))) (let ((f30 (get self29 2))) (let ((f31 (get self29 3))) (let ((f32 (get self29 4))) (let ((f33 (get self29 5))) (let ((reply$35 ($Kind.Parser.text "=" reply.pst$29))) (let ((self35 reply$35)) (case (get self35 0) ('Parser.Reply.error (let ((f35 (get self35 1))) (let ((self36 f29)) (case (get self36 0) ('Maybe.none ($Parser.Reply.error f35)) ('Maybe.some (let ((f36 (get self36 1))) ($Parser.Reply.error ($Parser.Error.combine f36 f35)))))))) ('Parser.Reply.value (let ((f35 (get self35 1))) (let ((f36 (get self35 2))) (let ((self37 f35)) (case (get self37 0) ('Parser.State.new (let ((f37 (get self37 1))) (let ((f38 (get self37 2))) (let ((f39 (get self37 3))) (let ((f40 (get self37 4))) (let ((f41 (get self37 5))) (let ((reply.pst$43 ($Parser.State.new ($Parser.Error.maybe_combine f29 f37) f38 f39 f40 f41))) (let ((self43 reply.pst$43)) (case (get self43 0) ('Parser.State.new (let ((f43 (get self43 1))) (let ((f44 (get self43 2))) (let ((f45 (get self43 3))) (let ((f46 (get self43 4))) (let ((f47 (get self43 5))) (let ((reply$49 (Kind.Parser.term reply.pst$43))) (let ((self49 reply$49)) (case (get self49 0) ('Parser.Reply.error (let ((f49 (get self49 1))) (let ((self50 f43)) (case (get self50 0) ('Maybe.none ($Parser.Reply.error f49)) ('Maybe.some (let ((f50 (get self50 1))) ($Parser.Reply.error ($Parser.Error.combine f50 f49)))))))) ('Parser.Reply.value (let ((f49 (get self49 1))) (let ((f50 (get self49 2))) (let ((self51 f49)) (case (get self51 0) ('Parser.State.new (let ((f51 (get self51 1))) (let ((f52 (get self51 2))) (let ((f53 (get self51 3))) (let ((f54 (get self51 4))) (let ((f55 (get self51 5))) (let ((reply.pst$57 ($Parser.State.new ($Parser.Error.maybe_combine f43 f51) f52 f53 f54 f55))) (let ((self57 reply.pst$57)) (case (get self57 0) ('Parser.State.new (let ((f57 (get self57 1))) (let ((f58 (get self57 2))) (let ((f59 (get self57 3))) (let ((f60 (get self57 4))) (let ((f61 (get self57 5))) (let ((reply$63 ($Parser.maybe (Kind.Parser.text ";") reply.pst$57))) (let ((self63 reply$63)) (case (get self63 0) ('Parser.Reply.error (let ((f63 (get self63 1))) (let ((self64 f57)) (case (get self64 0) ('Maybe.none ($Parser.Reply.error f63)) ('Maybe.some (let ((f64 (get self64 1))) ($Parser.Reply.error ($Parser.Error.combine f64 f63)))))))) ('Parser.Reply.value (let ((f63 (get self63 1))) (let ((f64 (get self63 2))) (let ((self65 f63)) (case (get self65 0) ('Parser.State.new (let ((f65 (get self65 1))) (let ((f66 (get self65 2))) (let ((f67 (get self65 3))) (let ((f68 (get self65 4))) (let ((f69 (get self65 5))) (let ((reply.pst$71 ($Parser.State.new ($Parser.Error.maybe_combine f57 f65) f66 f67 f68 f69))) (let ((self71 reply.pst$71)) (case (get self71 0) ('Parser.State.new (let ((f71 (get self71 1))) (let ((f72 (get self71 2))) (let ((f73 (get self71 3))) (let ((f74 (get self71 4))) (let ((f75 (get self71 5))) (let ((reply$77 ((body$0 Unit.new) reply.pst$71))) (let ((self77 reply$77)) (case (get self77 0) ('Parser.Reply.error (let ((f77 (get self77 1))) (let ((self78 f71)) (case (get self78 0) ('Maybe.none ($Parser.Reply.error f77)) ('Maybe.some (let ((f78 (get self78 1))) ($Parser.Reply.error ($Parser.Error.combine f78 f77)))))))) ('Parser.Reply.value (let ((f77 (get self77 1))) (let ((f78 (get self77 2))) (let ((self79 f77)) (case (get self79 0) ('Parser.State.new (let ((f79 (get self79 1))) (let ((f80 (get self79 2))) (let ((f81 (get self79 3))) (let ((f82 (get self79 4))) (let ((f83 (get self79 5))) (let ((reply.pst$85 ($Parser.State.new ($Parser.Error.maybe_combine f71 f79) f80 f81 f82 f83))) (let ((wyth$86 List.nil)) (let ((cses$87 ($Kind.Map.set "_" f78 Kind.Map.new))) (let ((moti$88 ($Maybe.some ($Kind.Term.hol Bits.e)))) (let ((term$89 ($Kind.Term.let f22 f50 (lambda ($89) ($Kind.Term.cse Bits.e ($Kind.Term.ref f22) f22 wyth$86 cses$87 moti$88))))) ($Parser.Reply.value reply.pst$85 term$89))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.use (lambda (body$0) ($Kind.Parser.use body$0)))
(define Kind.Parser.goal_rewrite ((Kind.Parser.block "goal-rewrite") (lambda (pst$0) (let ((self1 pst$0)) (case (get self1 0) ('Parser.State.new (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((reply$6 ($Kind.Parser.text "rewrite " pst$0))) (let ((self7 reply$6)) (case (get self7 0) ('Parser.Reply.error (let ((f7 (get self7 1))) (let ((self8 f1)) (case (get self8 0) ('Maybe.none ($Parser.Reply.error f7)) ('Maybe.some (let ((f8 (get self8 1))) ($Parser.Reply.error ($Parser.Error.combine f8 f7)))))))) ('Parser.Reply.value (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((self9 f7)) (case (get self9 0) ('Parser.State.new (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) (let ((reply.pst$14 ($Parser.State.new ($Parser.Error.maybe_combine f1 f9) f10 f11 f12 f13))) (let ((self15 reply.pst$14)) (case (get self15 0) ('Parser.State.new (let ((f15 (get self15 1))) (let ((f16 (get self15 2))) (let ((f17 (get self15 3))) (let ((f18 (get self15 4))) (let ((f19 (get self15 5))) (let ((reply$20 ($Kind.Parser.name1 reply.pst$14))) (let ((self21 reply$20)) (case (get self21 0) ('Parser.Reply.error (let ((f21 (get self21 1))) (let ((self22 f15)) (case (get self22 0) ('Maybe.none ($Parser.Reply.error f21)) ('Maybe.some (let ((f22 (get self22 1))) ($Parser.Reply.error ($Parser.Error.combine f22 f21)))))))) ('Parser.Reply.value (let ((f21 (get self21 1))) (let ((f22 (get self21 2))) (let ((self23 f21)) (case (get self23 0) ('Parser.State.new (let ((f23 (get self23 1))) (let ((f24 (get self23 2))) (let ((f25 (get self23 3))) (let ((f26 (get self23 4))) (let ((f27 (get self23 5))) (let ((reply.pst$28 ($Parser.State.new ($Parser.Error.maybe_combine f15 f23) f24 f25 f26 f27))) (let ((self29 reply.pst$28)) (case (get self29 0) ('Parser.State.new (let ((f29 (get self29 1))) (let ((f30 (get self29 2))) (let ((f31 (get self29 3))) (let ((f32 (get self29 4))) (let ((f33 (get self29 5))) (let ((reply$34 ($Kind.Parser.text "in" reply.pst$28))) (let ((self35 reply$34)) (case (get self35 0) ('Parser.Reply.error (let ((f35 (get self35 1))) (let ((self36 f29)) (case (get self36 0) ('Maybe.none ($Parser.Reply.error f35)) ('Maybe.some (let ((f36 (get self36 1))) ($Parser.Reply.error ($Parser.Error.combine f36 f35)))))))) ('Parser.Reply.value (let ((f35 (get self35 1))) (let ((f36 (get self35 2))) (let ((self37 f35)) (case (get self37 0) ('Parser.State.new (let ((f37 (get self37 1))) (let ((f38 (get self37 2))) (let ((f39 (get self37 3))) (let ((f40 (get self37 4))) (let ((f41 (get self37 5))) (let ((reply.pst$42 ($Parser.State.new ($Parser.Error.maybe_combine f29 f37) f38 f39 f40 f41))) (let ((self43 reply.pst$42)) (case (get self43 0) ('Parser.State.new (let ((f43 (get self43 1))) (let ((f44 (get self43 2))) (let ((f45 (get self43 3))) (let ((f46 (get self43 4))) (let ((f47 (get self43 5))) (let ((reply$48 (Kind.Parser.term reply.pst$42))) (let ((self49 reply$48)) (case (get self49 0) ('Parser.Reply.error (let ((f49 (get self49 1))) (let ((self50 f43)) (case (get self50 0) ('Maybe.none ($Parser.Reply.error f49)) ('Maybe.some (let ((f50 (get self50 1))) ($Parser.Reply.error ($Parser.Error.combine f50 f49)))))))) ('Parser.Reply.value (let ((f49 (get self49 1))) (let ((f50 (get self49 2))) (let ((self51 f49)) (case (get self51 0) ('Parser.State.new (let ((f51 (get self51 1))) (let ((f52 (get self51 2))) (let ((f53 (get self51 3))) (let ((f54 (get self51 4))) (let ((f55 (get self51 5))) (let ((reply.pst$56 ($Parser.State.new ($Parser.Error.maybe_combine f43 f51) f52 f53 f54 f55))) (let ((self57 reply.pst$56)) (case (get self57 0) ('Parser.State.new (let ((f57 (get self57 1))) (let ((f58 (get self57 2))) (let ((f59 (get self57 3))) (let ((f60 (get self57 4))) (let ((f61 (get self57 5))) (let ((reply$62 ($Kind.Parser.text "with" reply.pst$56))) (let ((self63 reply$62)) (case (get self63 0) ('Parser.Reply.error (let ((f63 (get self63 1))) (let ((self64 f57)) (case (get self64 0) ('Maybe.none ($Parser.Reply.error f63)) ('Maybe.some (let ((f64 (get self64 1))) ($Parser.Reply.error ($Parser.Error.combine f64 f63)))))))) ('Parser.Reply.value (let ((f63 (get self63 1))) (let ((f64 (get self63 2))) (let ((self65 f63)) (case (get self65 0) ('Parser.State.new (let ((f65 (get self65 1))) (let ((f66 (get self65 2))) (let ((f67 (get self65 3))) (let ((f68 (get self65 4))) (let ((f69 (get self65 5))) (let ((reply.pst$70 ($Parser.State.new ($Parser.Error.maybe_combine f57 f65) f66 f67 f68 f69))) (let ((self71 reply.pst$70)) (case (get self71 0) ('Parser.State.new (let ((f71 (get self71 1))) (let ((f72 (get self71 2))) (let ((f73 (get self71 3))) (let ((f74 (get self71 4))) (let ((f75 (get self71 5))) (let ((reply$76 (Kind.Parser.term reply.pst$70))) (let ((self77 reply$76)) (case (get self77 0) ('Parser.Reply.error (let ((f77 (get self77 1))) (let ((self78 f71)) (case (get self78 0) ('Maybe.none ($Parser.Reply.error f77)) ('Maybe.some (let ((f78 (get self78 1))) ($Parser.Reply.error ($Parser.Error.combine f78 f77)))))))) ('Parser.Reply.value (let ((f77 (get self77 1))) (let ((f78 (get self77 2))) (let ((self79 f77)) (case (get self79 0) ('Parser.State.new (let ((f79 (get self79 1))) (let ((f80 (get self79 2))) (let ((f81 (get self79 3))) (let ((f82 (get self79 4))) (let ((f83 (get self79 5))) (let ((reply.pst$84 ($Parser.State.new ($Parser.Error.maybe_combine f71 f79) f80 f81 f82 f83))) (let ((self85 reply.pst$84)) (case (get self85 0) ('Parser.State.new (let ((f85 (get self85 1))) (let ((f86 (get self85 2))) (let ((f87 (get self85 3))) (let ((f88 (get self85 4))) (let ((f89 (get self85 5))) (let ((reply$90 (Kind.Parser.term reply.pst$84))) (let ((self91 reply$90)) (case (get self91 0) ('Parser.Reply.error (let ((f91 (get self91 1))) (let ((self92 f85)) (case (get self92 0) ('Maybe.none ($Parser.Reply.error f91)) ('Maybe.some (let ((f92 (get self92 1))) ($Parser.Reply.error ($Parser.Error.combine f92 f91)))))))) ('Parser.Reply.value (let ((f91 (get self91 1))) (let ((f92 (get self91 2))) (let ((self93 f91)) (case (get self93 0) ('Parser.State.new (let ((f93 (get self93 1))) (let ((f94 (get self93 2))) (let ((f95 (get self93 3))) (let ((f96 (get self93 4))) (let ((f97 (get self93 5))) (let ((reply.pst$98 ($Parser.State.new ($Parser.Error.maybe_combine f85 f93) f94 f95 f96 f97))) (let ((moti$99 ($Kind.Term.lam f22 (lambda (s$99) ($Kind.Term.lam "" (lambda (x$100) f50)))))) (let ((term$100 ($Kind.Term.ref "Equal.mirror"))) (let ((term$101 ($Kind.Term.app term$100 ($Kind.Term.hol Bits.e)))) (let ((term$102 ($Kind.Term.app term$101 ($Kind.Term.hol Bits.e)))) (let ((term$103 ($Kind.Term.app term$102 ($Kind.Term.hol Bits.e)))) (let ((term$104 ($Kind.Term.app term$103 f78))) (let ((term$105 ($Kind.Term.app term$104 moti$99))) (let ((term$106 ($Kind.Term.app term$105 f92))) ($Parser.Reply.value reply.pst$98 term$106)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.if ((Kind.Parser.block "if") (lambda (pst$0) (let ((self1 pst$0)) (case (get self1 0) ('Parser.State.new (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((reply$6 ($Kind.Parser.text "if " pst$0))) (let ((self7 reply$6)) (case (get self7 0) ('Parser.Reply.error (let ((f7 (get self7 1))) (let ((self8 f1)) (case (get self8 0) ('Maybe.none ($Parser.Reply.error f7)) ('Maybe.some (let ((f8 (get self8 1))) ($Parser.Reply.error ($Parser.Error.combine f8 f7)))))))) ('Parser.Reply.value (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((self9 f7)) (case (get self9 0) ('Parser.State.new (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) (let ((reply.pst$14 ($Parser.State.new ($Parser.Error.maybe_combine f1 f9) f10 f11 f12 f13))) (let ((self15 reply.pst$14)) (case (get self15 0) ('Parser.State.new (let ((f15 (get self15 1))) (let ((f16 (get self15 2))) (let ((f17 (get self15 3))) (let ((f18 (get self15 4))) (let ((f19 (get self15 5))) (let ((reply$20 (Kind.Parser.term reply.pst$14))) (let ((self21 reply$20)) (case (get self21 0) ('Parser.Reply.error (let ((f21 (get self21 1))) (let ((self22 f15)) (case (get self22 0) ('Maybe.none ($Parser.Reply.error f21)) ('Maybe.some (let ((f22 (get self22 1))) ($Parser.Reply.error ($Parser.Error.combine f22 f21)))))))) ('Parser.Reply.value (let ((f21 (get self21 1))) (let ((f22 (get self21 2))) (let ((self23 f21)) (case (get self23 0) ('Parser.State.new (let ((f23 (get self23 1))) (let ((f24 (get self23 2))) (let ((f25 (get self23 3))) (let ((f26 (get self23 4))) (let ((f27 (get self23 5))) (let ((reply.pst$28 ($Parser.State.new ($Parser.Error.maybe_combine f15 f23) f24 f25 f26 f27))) (let ((self29 reply.pst$28)) (case (get self29 0) ('Parser.State.new (let ((f29 (get self29 1))) (let ((f30 (get self29 2))) (let ((f31 (get self29 3))) (let ((f32 (get self29 4))) (let ((f33 (get self29 5))) (let ((reply$34 ($Kind.Parser.text "then" reply.pst$28))) (let ((self35 reply$34)) (case (get self35 0) ('Parser.Reply.error (let ((f35 (get self35 1))) (let ((self36 f29)) (case (get self36 0) ('Maybe.none ($Parser.Reply.error f35)) ('Maybe.some (let ((f36 (get self36 1))) ($Parser.Reply.error ($Parser.Error.combine f36 f35)))))))) ('Parser.Reply.value (let ((f35 (get self35 1))) (let ((f36 (get self35 2))) (let ((self37 f35)) (case (get self37 0) ('Parser.State.new (let ((f37 (get self37 1))) (let ((f38 (get self37 2))) (let ((f39 (get self37 3))) (let ((f40 (get self37 4))) (let ((f41 (get self37 5))) (let ((reply.pst$42 ($Parser.State.new ($Parser.Error.maybe_combine f29 f37) f38 f39 f40 f41))) (let ((self43 reply.pst$42)) (case (get self43 0) ('Parser.State.new (let ((f43 (get self43 1))) (let ((f44 (get self43 2))) (let ((f45 (get self43 3))) (let ((f46 (get self43 4))) (let ((f47 (get self43 5))) (let ((reply$48 (Kind.Parser.term reply.pst$42))) (let ((self49 reply$48)) (case (get self49 0) ('Parser.Reply.error (let ((f49 (get self49 1))) (let ((self50 f43)) (case (get self50 0) ('Maybe.none ($Parser.Reply.error f49)) ('Maybe.some (let ((f50 (get self50 1))) ($Parser.Reply.error ($Parser.Error.combine f50 f49)))))))) ('Parser.Reply.value (let ((f49 (get self49 1))) (let ((f50 (get self49 2))) (let ((self51 f49)) (case (get self51 0) ('Parser.State.new (let ((f51 (get self51 1))) (let ((f52 (get self51 2))) (let ((f53 (get self51 3))) (let ((f54 (get self51 4))) (let ((f55 (get self51 5))) (let ((reply.pst$56 ($Parser.State.new ($Parser.Error.maybe_combine f43 f51) f52 f53 f54 f55))) (let ((self57 reply.pst$56)) (case (get self57 0) ('Parser.State.new (let ((f57 (get self57 1))) (let ((f58 (get self57 2))) (let ((f59 (get self57 3))) (let ((f60 (get self57 4))) (let ((f61 (get self57 5))) (let ((reply$62 ($Kind.Parser.text "else" reply.pst$56))) (let ((self63 reply$62)) (case (get self63 0) ('Parser.Reply.error (let ((f63 (get self63 1))) (let ((self64 f57)) (case (get self64 0) ('Maybe.none ($Parser.Reply.error f63)) ('Maybe.some (let ((f64 (get self64 1))) ($Parser.Reply.error ($Parser.Error.combine f64 f63)))))))) ('Parser.Reply.value (let ((f63 (get self63 1))) (let ((f64 (get self63 2))) (let ((self65 f63)) (case (get self65 0) ('Parser.State.new (let ((f65 (get self65 1))) (let ((f66 (get self65 2))) (let ((f67 (get self65 3))) (let ((f68 (get self65 4))) (let ((f69 (get self65 5))) (let ((reply.pst$70 ($Parser.State.new ($Parser.Error.maybe_combine f57 f65) f66 f67 f68 f69))) (let ((self71 reply.pst$70)) (case (get self71 0) ('Parser.State.new (let ((f71 (get self71 1))) (let ((f72 (get self71 2))) (let ((f73 (get self71 3))) (let ((f74 (get self71 4))) (let ((f75 (get self71 5))) (let ((reply$76 (Kind.Parser.term reply.pst$70))) (let ((self77 reply$76)) (case (get self77 0) ('Parser.Reply.error (let ((f77 (get self77 1))) (let ((self78 f71)) (case (get self78 0) ('Maybe.none ($Parser.Reply.error f77)) ('Maybe.some (let ((f78 (get self78 1))) ($Parser.Reply.error ($Parser.Error.combine f78 f77)))))))) ('Parser.Reply.value (let ((f77 (get self77 1))) (let ((f78 (get self77 2))) (let ((self79 f77)) (case (get self79 0) ('Parser.State.new (let ((f79 (get self79 1))) (let ((f80 (get self79 2))) (let ((f81 (get self79 3))) (let ((f82 (get self79 4))) (let ((f83 (get self79 5))) (let ((reply.pst$84 ($Parser.State.new ($Parser.Error.maybe_combine f71 f79) f80 f81 f82 f83))) (let ((term$85 f22)) (let ((term$86 ($Kind.Term.app term$85 ($Kind.Term.lam "" (lambda (x$86) ($Kind.Term.hol Bits.e)))))) (let ((term$87 ($Kind.Term.app term$86 f50))) (let ((term$88 ($Kind.Term.app term$87 f78))) ($Parser.Reply.value reply.pst$84 term$88))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Code.backslash ($Nat.to_u16 92))
(define Kind.Code.escapes ($List.cons ($Pair.new "\\b" 8) ($List.cons ($Pair.new "\\f" 12) ($List.cons ($Pair.new "\\n" 10) ($List.cons ($Pair.new "\\r" 13) ($List.cons ($Pair.new "\\t" 9) ($List.cons ($Pair.new "\\v" 11) ($List.cons ($Pair.new ($String.cons Kind.Code.backslash ($String.cons Kind.Code.backslash String.nil)) Kind.Code.backslash) ($List.cons ($Pair.new "\\\"" 34) ($List.cons ($Pair.new "\\0" 0) ($List.cons ($Pair.new "\\'" 39) List.nil)))))))))))
(define Kind.Parser.char.single (Parser.choice ($List.cons (Parser.choice ($List.mapped Kind.Code.escapes (lambda (esc$0) (let ((self1 esc$0)) (case (get self1 0) ('Pair.new (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (lambda (pst$3) (let ((self4 pst$3)) (case (get self4 0) ('Parser.State.new (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((f6 (get self4 3))) (let ((f7 (get self4 4))) (let ((f8 (get self4 5))) (let ((reply$9 ($Parser.text f1 pst$3))) (let ((self10 reply$9)) (case (get self10 0) ('Parser.Reply.error (let ((f10 (get self10 1))) (let ((self11 f4)) (case (get self11 0) ('Maybe.none ($Parser.Reply.error f10)) ('Maybe.some (let ((f11 (get self11 1))) ($Parser.Reply.error ($Parser.Error.combine f11 f10)))))))) ('Parser.Reply.value (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((self12 f10)) (case (get self12 0) ('Parser.State.new (let ((f12 (get self12 1))) (let ((f13 (get self12 2))) (let ((f14 (get self12 3))) (let ((f15 (get self12 4))) (let ((f16 (get self12 5))) (let ((reply.pst$17 ($Parser.State.new ($Parser.Error.maybe_combine f4 f12) f13 f14 f15 f16))) ($Parser.Reply.value reply.pst$17 f2))))))))))))))))))))))))))))))))) ($List.cons Parser.one List.nil))))
(define Kind.Parser.char ((Kind.Parser.block "char") (lambda (pst$0) (let ((self1 pst$0)) (case (get self1 0) ('Parser.State.new (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((reply$6 ($Kind.Parser.text "'" pst$0))) (let ((self7 reply$6)) (case (get self7 0) ('Parser.Reply.error (let ((f7 (get self7 1))) (let ((self8 f1)) (case (get self8 0) ('Maybe.none ($Parser.Reply.error f7)) ('Maybe.some (let ((f8 (get self8 1))) ($Parser.Reply.error ($Parser.Error.combine f8 f7)))))))) ('Parser.Reply.value (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((self9 f7)) (case (get self9 0) ('Parser.State.new (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) (let ((reply.pst$14 ($Parser.State.new ($Parser.Error.maybe_combine f1 f9) f10 f11 f12 f13))) (let ((self15 reply.pst$14)) (case (get self15 0) ('Parser.State.new (let ((f15 (get self15 1))) (let ((f16 (get self15 2))) (let ((f17 (get self15 3))) (let ((f18 (get self15 4))) (let ((f19 (get self15 5))) (let ((reply$20 (Kind.Parser.char.single reply.pst$14))) (let ((self21 reply$20)) (case (get self21 0) ('Parser.Reply.error (let ((f21 (get self21 1))) (let ((self22 f15)) (case (get self22 0) ('Maybe.none ($Parser.Reply.error f21)) ('Maybe.some (let ((f22 (get self22 1))) ($Parser.Reply.error ($Parser.Error.combine f22 f21)))))))) ('Parser.Reply.value (let ((f21 (get self21 1))) (let ((f22 (get self21 2))) (let ((self23 f21)) (case (get self23 0) ('Parser.State.new (let ((f23 (get self23 1))) (let ((f24 (get self23 2))) (let ((f25 (get self23 3))) (let ((f26 (get self23 4))) (let ((f27 (get self23 5))) (let ((reply.pst$28 ($Parser.State.new ($Parser.Error.maybe_combine f15 f23) f24 f25 f26 f27))) (let ((self29 reply.pst$28)) (case (get self29 0) ('Parser.State.new (let ((f29 (get self29 1))) (let ((f30 (get self29 2))) (let ((f31 (get self29 3))) (let ((f32 (get self29 4))) (let ((f33 (get self29 5))) (let ((reply$34 ($Kind.Parser.text "'" reply.pst$28))) (let ((self35 reply$34)) (case (get self35 0) ('Parser.Reply.error (let ((f35 (get self35 1))) (let ((self36 f29)) (case (get self36 0) ('Maybe.none ($Parser.Reply.error f35)) ('Maybe.some (let ((f36 (get self36 1))) ($Parser.Reply.error ($Parser.Error.combine f36 f35)))))))) ('Parser.Reply.value (let ((f35 (get self35 1))) (let ((f36 (get self35 2))) (let ((self37 f35)) (case (get self37 0) ('Parser.State.new (let ((f37 (get self37 1))) (let ((f38 (get self37 2))) (let ((f39 (get self37 3))) (let ((f40 (get self37 4))) (let ((f41 (get self37 5))) (let ((reply.pst$42 ($Parser.State.new ($Parser.Error.maybe_combine f29 f37) f38 f39 f40 f41))) ($Parser.Reply.value reply.pst$42 ($Kind.Term.chr f22))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(define ($String.reverse.go xs$0 res$1) (let ((self0 xs$0)) (case (<= (kstring-length self0) 0) (#t res$1) (#f (let ((f0 (char->integer (kstring-head self0)))) (let ((f1 (kstring-tail self0))) ($String.reverse.go f1 ($String.cons f0 res$1))))))))
(define String.reverse.go (lambda (xs$0) (lambda (res$1) ($String.reverse.go xs$0 res$1))))
(define ($String.reverse xs$0) ($String.reverse.go xs$0 String.nil))
(define String.reverse (lambda (xs$0) ($String.reverse xs$0)))
(define ($Kind.Parser.string.go delim$0 str$1 pst$2) (let ((self0 pst$2)) (case (get self0 0) ('Parser.State.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((self5 f4)) (case (<= (kstring-length self5) 0) (#t ($Parser.Reply.fail f1 f2 f3 "Non-terminating string.")) (#f (let ((f5 (char->integer (kstring-head self5)))) (let ((f6 (kstring-tail self5))) (let ((self7 ($U16.eql f5 delim$0))) (case self7 (#t (let ((pst$10 ($Parser.State.new f0 f1 f2 ($Nat.succ f3) f6))) ($Parser.Reply.value pst$10 ($String.reverse str$1)))) (#f (let ((self7 (Kind.Parser.char.single pst$2))) (case (get self7 0) ('Parser.Reply.error (let ((f7 (get self7 1))) ($Parser.Reply.error f7))) ('Parser.Reply.value (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) ($Kind.Parser.string.go delim$0 ($String.cons f8 str$1) f7)))))))))))))))))))))))
(define Kind.Parser.string.go (lambda (delim$0) (lambda (str$1) (lambda (pst$2) ($Kind.Parser.string.go delim$0 str$1 pst$2)))))
(define ($Kind.Parser.string delim$0) ((Kind.Parser.block "string") (lambda (pst$1) (let ((self1 pst$1)) (case (get self1 0) ('Parser.State.new (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((reply$7 ($Kind.Parser.text ($String.cons delim$0 String.nil) pst$1))) (let ((self7 reply$7)) (case (get self7 0) ('Parser.Reply.error (let ((f7 (get self7 1))) (let ((self8 f1)) (case (get self8 0) ('Maybe.none ($Parser.Reply.error f7)) ('Maybe.some (let ((f8 (get self8 1))) ($Parser.Reply.error ($Parser.Error.combine f8 f7)))))))) ('Parser.Reply.value (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((self9 f7)) (case (get self9 0) ('Parser.State.new (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) (let ((reply.pst$15 ($Parser.State.new ($Parser.Error.maybe_combine f1 f9) f10 f11 f12 f13))) (let ((self15 reply.pst$15)) (case (get self15 0) ('Parser.State.new (let ((f15 (get self15 1))) (let ((f16 (get self15 2))) (let ((f17 (get self15 3))) (let ((f18 (get self15 4))) (let ((f19 (get self15 5))) (let ((reply$21 ($Kind.Parser.string.go delim$0 "" reply.pst$15))) (let ((self21 reply$21)) (case (get self21 0) ('Parser.Reply.error (let ((f21 (get self21 1))) (let ((self22 f15)) (case (get self22 0) ('Maybe.none ($Parser.Reply.error f21)) ('Maybe.some (let ((f22 (get self22 1))) ($Parser.Reply.error ($Parser.Error.combine f22 f21)))))))) ('Parser.Reply.value (let ((f21 (get self21 1))) (let ((f22 (get self21 2))) (let ((self23 f21)) (case (get self23 0) ('Parser.State.new (let ((f23 (get self23 1))) (let ((f24 (get self23 2))) (let ((f25 (get self23 3))) (let ((f26 (get self23 4))) (let ((f27 (get self23 5))) (let ((reply.pst$29 ($Parser.State.new ($Parser.Error.maybe_combine f15 f23) f24 f25 f26 f27))) ($Parser.Reply.value reply.pst$29 ($Kind.Term.str f22)))))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.string (lambda (delim$0) ($Kind.Parser.string delim$0)))
(define ($Kind.Term.new args$0) (vector 'Kind.Term.new args$0))
(define Kind.Term.new (lambda (args$0) ($Kind.Term.new args$0)))
(define Kind.Parser.new ((Kind.Parser.block "new-struct") (lambda (pst$0) (let ((self1 pst$0)) (case (get self1 0) ('Parser.State.new (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((reply$6 (($Kind.Parser.items1 "{" Kind.Parser.term "}") pst$0))) (let ((self7 reply$6)) (case (get self7 0) ('Parser.Reply.error (let ((f7 (get self7 1))) (let ((self8 f1)) (case (get self8 0) ('Maybe.none ($Parser.Reply.error f7)) ('Maybe.some (let ((f8 (get self8 1))) ($Parser.Reply.error ($Parser.Error.combine f8 f7)))))))) ('Parser.Reply.value (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((self9 f7)) (case (get self9 0) ('Parser.State.new (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) (let ((reply.pst$14 ($Parser.State.new ($Parser.Error.maybe_combine f1 f9) f10 f11 f12 f13))) ($Parser.Reply.value reply.pst$14 ($Kind.Term.new f8))))))))))))))))))))))))))))
(define Kind.Parser.sigma.type ((Kind.Parser.block "sigma") (lambda (pst$0) (let ((self1 pst$0)) (case (get self1 0) ('Parser.State.new (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((reply$6 ($Kind.Parser.text "[" pst$0))) (let ((self7 reply$6)) (case (get self7 0) ('Parser.Reply.error (let ((f7 (get self7 1))) (let ((self8 f1)) (case (get self8 0) ('Maybe.none ($Parser.Reply.error f7)) ('Maybe.some (let ((f8 (get self8 1))) ($Parser.Reply.error ($Parser.Error.combine f8 f7)))))))) ('Parser.Reply.value (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((self9 f7)) (case (get self9 0) ('Parser.State.new (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) (let ((reply.pst$14 ($Parser.State.new ($Parser.Error.maybe_combine f1 f9) f10 f11 f12 f13))) (let ((self15 reply.pst$14)) (case (get self15 0) ('Parser.State.new (let ((f15 (get self15 1))) (let ((f16 (get self15 2))) (let ((f17 (get self15 3))) (let ((f18 (get self15 4))) (let ((f19 (get self15 5))) (let ((reply$20 ($Kind.Parser.name1 reply.pst$14))) (let ((self21 reply$20)) (case (get self21 0) ('Parser.Reply.error (let ((f21 (get self21 1))) (let ((self22 f15)) (case (get self22 0) ('Maybe.none ($Parser.Reply.error f21)) ('Maybe.some (let ((f22 (get self22 1))) ($Parser.Reply.error ($Parser.Error.combine f22 f21)))))))) ('Parser.Reply.value (let ((f21 (get self21 1))) (let ((f22 (get self21 2))) (let ((self23 f21)) (case (get self23 0) ('Parser.State.new (let ((f23 (get self23 1))) (let ((f24 (get self23 2))) (let ((f25 (get self23 3))) (let ((f26 (get self23 4))) (let ((f27 (get self23 5))) (let ((reply.pst$28 ($Parser.State.new ($Parser.Error.maybe_combine f15 f23) f24 f25 f26 f27))) (let ((self29 reply.pst$28)) (case (get self29 0) ('Parser.State.new (let ((f29 (get self29 1))) (let ((f30 (get self29 2))) (let ((f31 (get self29 3))) (let ((f32 (get self29 4))) (let ((f33 (get self29 5))) (let ((reply$34 ($Kind.Parser.text ":" reply.pst$28))) (let ((self35 reply$34)) (case (get self35 0) ('Parser.Reply.error (let ((f35 (get self35 1))) (let ((self36 f29)) (case (get self36 0) ('Maybe.none ($Parser.Reply.error f35)) ('Maybe.some (let ((f36 (get self36 1))) ($Parser.Reply.error ($Parser.Error.combine f36 f35)))))))) ('Parser.Reply.value (let ((f35 (get self35 1))) (let ((f36 (get self35 2))) (let ((self37 f35)) (case (get self37 0) ('Parser.State.new (let ((f37 (get self37 1))) (let ((f38 (get self37 2))) (let ((f39 (get self37 3))) (let ((f40 (get self37 4))) (let ((f41 (get self37 5))) (let ((reply.pst$42 ($Parser.State.new ($Parser.Error.maybe_combine f29 f37) f38 f39 f40 f41))) (let ((self43 reply.pst$42)) (case (get self43 0) ('Parser.State.new (let ((f43 (get self43 1))) (let ((f44 (get self43 2))) (let ((f45 (get self43 3))) (let ((f46 (get self43 4))) (let ((f47 (get self43 5))) (let ((reply$48 (Kind.Parser.term reply.pst$42))) (let ((self49 reply$48)) (case (get self49 0) ('Parser.Reply.error (let ((f49 (get self49 1))) (let ((self50 f43)) (case (get self50 0) ('Maybe.none ($Parser.Reply.error f49)) ('Maybe.some (let ((f50 (get self50 1))) ($Parser.Reply.error ($Parser.Error.combine f50 f49)))))))) ('Parser.Reply.value (let ((f49 (get self49 1))) (let ((f50 (get self49 2))) (let ((self51 f49)) (case (get self51 0) ('Parser.State.new (let ((f51 (get self51 1))) (let ((f52 (get self51 2))) (let ((f53 (get self51 3))) (let ((f54 (get self51 4))) (let ((f55 (get self51 5))) (let ((reply.pst$56 ($Parser.State.new ($Parser.Error.maybe_combine f43 f51) f52 f53 f54 f55))) (let ((self57 reply.pst$56)) (case (get self57 0) ('Parser.State.new (let ((f57 (get self57 1))) (let ((f58 (get self57 2))) (let ((f59 (get self57 3))) (let ((f60 (get self57 4))) (let ((f61 (get self57 5))) (let ((reply$62 ($Kind.Parser.text "]" reply.pst$56))) (let ((self63 reply$62)) (case (get self63 0) ('Parser.Reply.error (let ((f63 (get self63 1))) (let ((self64 f57)) (case (get self64 0) ('Maybe.none ($Parser.Reply.error f63)) ('Maybe.some (let ((f64 (get self64 1))) ($Parser.Reply.error ($Parser.Error.combine f64 f63)))))))) ('Parser.Reply.value (let ((f63 (get self63 1))) (let ((f64 (get self63 2))) (let ((self65 f63)) (case (get self65 0) ('Parser.State.new (let ((f65 (get self65 1))) (let ((f66 (get self65 2))) (let ((f67 (get self65 3))) (let ((f68 (get self65 4))) (let ((f69 (get self65 5))) (let ((reply.pst$70 ($Parser.State.new ($Parser.Error.maybe_combine f57 f65) f66 f67 f68 f69))) (let ((self71 reply.pst$70)) (case (get self71 0) ('Parser.State.new (let ((f71 (get self71 1))) (let ((f72 (get self71 2))) (let ((f73 (get self71 3))) (let ((f74 (get self71 4))) (let ((f75 (get self71 5))) (let ((reply$76 (Kind.Parser.term reply.pst$70))) (let ((self77 reply$76)) (case (get self77 0) ('Parser.Reply.error (let ((f77 (get self77 1))) (let ((self78 f71)) (case (get self78 0) ('Maybe.none ($Parser.Reply.error f77)) ('Maybe.some (let ((f78 (get self78 1))) ($Parser.Reply.error ($Parser.Error.combine f78 f77)))))))) ('Parser.Reply.value (let ((f77 (get self77 1))) (let ((f78 (get self77 2))) (let ((self79 f77)) (case (get self79 0) ('Parser.State.new (let ((f79 (get self79 1))) (let ((f80 (get self79 2))) (let ((f81 (get self79 3))) (let ((f82 (get self79 4))) (let ((f83 (get self79 5))) (let ((reply.pst$84 ($Parser.State.new ($Parser.Error.maybe_combine f71 f79) f80 f81 f82 f83))) (let ((term$85 ($Kind.Term.ref "Sigma"))) (let ((term$86 ($Kind.Term.app term$85 f50))) (let ((term$87 ($Kind.Term.app term$86 ($Kind.Term.lam f22 (lambda (x$87) f78))))) ($Parser.Reply.value reply.pst$84 term$87)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.some ((Kind.Parser.block "some") (lambda (pst$0) (let ((self1 pst$0)) (case (get self1 0) ('Parser.State.new (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((reply$6 ($Kind.Parser.text "some(" pst$0))) (let ((self7 reply$6)) (case (get self7 0) ('Parser.Reply.error (let ((f7 (get self7 1))) (let ((self8 f1)) (case (get self8 0) ('Maybe.none ($Parser.Reply.error f7)) ('Maybe.some (let ((f8 (get self8 1))) ($Parser.Reply.error ($Parser.Error.combine f8 f7)))))))) ('Parser.Reply.value (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((self9 f7)) (case (get self9 0) ('Parser.State.new (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) (let ((reply.pst$14 ($Parser.State.new ($Parser.Error.maybe_combine f1 f9) f10 f11 f12 f13))) (let ((self15 reply.pst$14)) (case (get self15 0) ('Parser.State.new (let ((f15 (get self15 1))) (let ((f16 (get self15 2))) (let ((f17 (get self15 3))) (let ((f18 (get self15 4))) (let ((f19 (get self15 5))) (let ((reply$20 (Kind.Parser.term reply.pst$14))) (let ((self21 reply$20)) (case (get self21 0) ('Parser.Reply.error (let ((f21 (get self21 1))) (let ((self22 f15)) (case (get self22 0) ('Maybe.none ($Parser.Reply.error f21)) ('Maybe.some (let ((f22 (get self22 1))) ($Parser.Reply.error ($Parser.Error.combine f22 f21)))))))) ('Parser.Reply.value (let ((f21 (get self21 1))) (let ((f22 (get self21 2))) (let ((self23 f21)) (case (get self23 0) ('Parser.State.new (let ((f23 (get self23 1))) (let ((f24 (get self23 2))) (let ((f25 (get self23 3))) (let ((f26 (get self23 4))) (let ((f27 (get self23 5))) (let ((reply.pst$28 ($Parser.State.new ($Parser.Error.maybe_combine f15 f23) f24 f25 f26 f27))) (let ((self29 reply.pst$28)) (case (get self29 0) ('Parser.State.new (let ((f29 (get self29 1))) (let ((f30 (get self29 2))) (let ((f31 (get self29 3))) (let ((f32 (get self29 4))) (let ((f33 (get self29 5))) (let ((reply$34 ($Kind.Parser.text ")" reply.pst$28))) (let ((self35 reply$34)) (case (get self35 0) ('Parser.Reply.error (let ((f35 (get self35 1))) (let ((self36 f29)) (case (get self36 0) ('Maybe.none ($Parser.Reply.error f35)) ('Maybe.some (let ((f36 (get self36 1))) ($Parser.Reply.error ($Parser.Error.combine f36 f35)))))))) ('Parser.Reply.value (let ((f35 (get self35 1))) (let ((f36 (get self35 2))) (let ((self37 f35)) (case (get self37 0) ('Parser.State.new (let ((f37 (get self37 1))) (let ((f38 (get self37 2))) (let ((f39 (get self37 3))) (let ((f40 (get self37 4))) (let ((f41 (get self37 5))) (let ((reply.pst$42 ($Parser.State.new ($Parser.Error.maybe_combine f29 f37) f38 f39 f40 f41))) (let ((term$43 ($Kind.Term.ref "Maybe.some"))) (let ((term$44 ($Kind.Term.app term$43 ($Kind.Term.hol Bits.e)))) (let ((term$45 ($Kind.Term.app term$44 f22))) ($Parser.Reply.value reply.pst$42 term$45))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.not ((Kind.Parser.block "not") (lambda (pst$0) (let ((self1 pst$0)) (case (get self1 0) ('Parser.State.new (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((reply$6 ($Kind.Parser.text "not(" pst$0))) (let ((self7 reply$6)) (case (get self7 0) ('Parser.Reply.error (let ((f7 (get self7 1))) (let ((self8 f1)) (case (get self8 0) ('Maybe.none ($Parser.Reply.error f7)) ('Maybe.some (let ((f8 (get self8 1))) ($Parser.Reply.error ($Parser.Error.combine f8 f7)))))))) ('Parser.Reply.value (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((self9 f7)) (case (get self9 0) ('Parser.State.new (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) (let ((reply.pst$14 ($Parser.State.new ($Parser.Error.maybe_combine f1 f9) f10 f11 f12 f13))) (let ((self15 reply.pst$14)) (case (get self15 0) ('Parser.State.new (let ((f15 (get self15 1))) (let ((f16 (get self15 2))) (let ((f17 (get self15 3))) (let ((f18 (get self15 4))) (let ((f19 (get self15 5))) (let ((reply$20 (Kind.Parser.term reply.pst$14))) (let ((self21 reply$20)) (case (get self21 0) ('Parser.Reply.error (let ((f21 (get self21 1))) (let ((self22 f15)) (case (get self22 0) ('Maybe.none ($Parser.Reply.error f21)) ('Maybe.some (let ((f22 (get self22 1))) ($Parser.Reply.error ($Parser.Error.combine f22 f21)))))))) ('Parser.Reply.value (let ((f21 (get self21 1))) (let ((f22 (get self21 2))) (let ((self23 f21)) (case (get self23 0) ('Parser.State.new (let ((f23 (get self23 1))) (let ((f24 (get self23 2))) (let ((f25 (get self23 3))) (let ((f26 (get self23 4))) (let ((f27 (get self23 5))) (let ((reply.pst$28 ($Parser.State.new ($Parser.Error.maybe_combine f15 f23) f24 f25 f26 f27))) (let ((self29 reply.pst$28)) (case (get self29 0) ('Parser.State.new (let ((f29 (get self29 1))) (let ((f30 (get self29 2))) (let ((f31 (get self29 3))) (let ((f32 (get self29 4))) (let ((f33 (get self29 5))) (let ((reply$34 ($Kind.Parser.text ")" reply.pst$28))) (let ((self35 reply$34)) (case (get self35 0) ('Parser.Reply.error (let ((f35 (get self35 1))) (let ((self36 f29)) (case (get self36 0) ('Maybe.none ($Parser.Reply.error f35)) ('Maybe.some (let ((f36 (get self36 1))) ($Parser.Reply.error ($Parser.Error.combine f36 f35)))))))) ('Parser.Reply.value (let ((f35 (get self35 1))) (let ((f36 (get self35 2))) (let ((self37 f35)) (case (get self37 0) ('Parser.State.new (let ((f37 (get self37 1))) (let ((f38 (get self37 2))) (let ((f39 (get self37 3))) (let ((f40 (get self37 4))) (let ((f41 (get self37 5))) (let ((reply.pst$42 ($Parser.State.new ($Parser.Error.maybe_combine f29 f37) f38 f39 f40 f41))) (let ((term$43 ($Kind.Term.ref "Bool.not"))) (let ((term$44 ($Kind.Term.app term$43 f22))) ($Parser.Reply.value reply.pst$42 term$44)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.left ((Kind.Parser.block "left") (lambda (pst$0) (let ((self1 pst$0)) (case (get self1 0) ('Parser.State.new (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((reply$6 ($Kind.Parser.text "left(" pst$0))) (let ((self7 reply$6)) (case (get self7 0) ('Parser.Reply.error (let ((f7 (get self7 1))) (let ((self8 f1)) (case (get self8 0) ('Maybe.none ($Parser.Reply.error f7)) ('Maybe.some (let ((f8 (get self8 1))) ($Parser.Reply.error ($Parser.Error.combine f8 f7)))))))) ('Parser.Reply.value (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((self9 f7)) (case (get self9 0) ('Parser.State.new (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) (let ((reply.pst$14 ($Parser.State.new ($Parser.Error.maybe_combine f1 f9) f10 f11 f12 f13))) (let ((self15 reply.pst$14)) (case (get self15 0) ('Parser.State.new (let ((f15 (get self15 1))) (let ((f16 (get self15 2))) (let ((f17 (get self15 3))) (let ((f18 (get self15 4))) (let ((f19 (get self15 5))) (let ((reply$20 (Kind.Parser.term reply.pst$14))) (let ((self21 reply$20)) (case (get self21 0) ('Parser.Reply.error (let ((f21 (get self21 1))) (let ((self22 f15)) (case (get self22 0) ('Maybe.none ($Parser.Reply.error f21)) ('Maybe.some (let ((f22 (get self22 1))) ($Parser.Reply.error ($Parser.Error.combine f22 f21)))))))) ('Parser.Reply.value (let ((f21 (get self21 1))) (let ((f22 (get self21 2))) (let ((self23 f21)) (case (get self23 0) ('Parser.State.new (let ((f23 (get self23 1))) (let ((f24 (get self23 2))) (let ((f25 (get self23 3))) (let ((f26 (get self23 4))) (let ((f27 (get self23 5))) (let ((reply.pst$28 ($Parser.State.new ($Parser.Error.maybe_combine f15 f23) f24 f25 f26 f27))) (let ((self29 reply.pst$28)) (case (get self29 0) ('Parser.State.new (let ((f29 (get self29 1))) (let ((f30 (get self29 2))) (let ((f31 (get self29 3))) (let ((f32 (get self29 4))) (let ((f33 (get self29 5))) (let ((reply$34 ($Kind.Parser.text ")" reply.pst$28))) (let ((self35 reply$34)) (case (get self35 0) ('Parser.Reply.error (let ((f35 (get self35 1))) (let ((self36 f29)) (case (get self36 0) ('Maybe.none ($Parser.Reply.error f35)) ('Maybe.some (let ((f36 (get self36 1))) ($Parser.Reply.error ($Parser.Error.combine f36 f35)))))))) ('Parser.Reply.value (let ((f35 (get self35 1))) (let ((f36 (get self35 2))) (let ((self37 f35)) (case (get self37 0) ('Parser.State.new (let ((f37 (get self37 1))) (let ((f38 (get self37 2))) (let ((f39 (get self37 3))) (let ((f40 (get self37 4))) (let ((f41 (get self37 5))) (let ((reply.pst$42 ($Parser.State.new ($Parser.Error.maybe_combine f29 f37) f38 f39 f40 f41))) (let ((term$43 ($Kind.Term.ref "Either.left"))) (let ((term$44 ($Kind.Term.app term$43 ($Kind.Term.hol Bits.e)))) (let ((term$45 ($Kind.Term.app term$44 ($Kind.Term.hol Bits.e)))) (let ((term$46 ($Kind.Term.app term$45 f22))) ($Parser.Reply.value reply.pst$42 term$46)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.right ((Kind.Parser.block "right") (lambda (pst$0) (let ((self1 pst$0)) (case (get self1 0) ('Parser.State.new (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((reply$6 ($Kind.Parser.text "right(" pst$0))) (let ((self7 reply$6)) (case (get self7 0) ('Parser.Reply.error (let ((f7 (get self7 1))) (let ((self8 f1)) (case (get self8 0) ('Maybe.none ($Parser.Reply.error f7)) ('Maybe.some (let ((f8 (get self8 1))) ($Parser.Reply.error ($Parser.Error.combine f8 f7)))))))) ('Parser.Reply.value (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((self9 f7)) (case (get self9 0) ('Parser.State.new (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) (let ((reply.pst$14 ($Parser.State.new ($Parser.Error.maybe_combine f1 f9) f10 f11 f12 f13))) (let ((self15 reply.pst$14)) (case (get self15 0) ('Parser.State.new (let ((f15 (get self15 1))) (let ((f16 (get self15 2))) (let ((f17 (get self15 3))) (let ((f18 (get self15 4))) (let ((f19 (get self15 5))) (let ((reply$20 (Kind.Parser.term reply.pst$14))) (let ((self21 reply$20)) (case (get self21 0) ('Parser.Reply.error (let ((f21 (get self21 1))) (let ((self22 f15)) (case (get self22 0) ('Maybe.none ($Parser.Reply.error f21)) ('Maybe.some (let ((f22 (get self22 1))) ($Parser.Reply.error ($Parser.Error.combine f22 f21)))))))) ('Parser.Reply.value (let ((f21 (get self21 1))) (let ((f22 (get self21 2))) (let ((self23 f21)) (case (get self23 0) ('Parser.State.new (let ((f23 (get self23 1))) (let ((f24 (get self23 2))) (let ((f25 (get self23 3))) (let ((f26 (get self23 4))) (let ((f27 (get self23 5))) (let ((reply.pst$28 ($Parser.State.new ($Parser.Error.maybe_combine f15 f23) f24 f25 f26 f27))) (let ((self29 reply.pst$28)) (case (get self29 0) ('Parser.State.new (let ((f29 (get self29 1))) (let ((f30 (get self29 2))) (let ((f31 (get self29 3))) (let ((f32 (get self29 4))) (let ((f33 (get self29 5))) (let ((reply$34 ($Kind.Parser.text ")" reply.pst$28))) (let ((self35 reply$34)) (case (get self35 0) ('Parser.Reply.error (let ((f35 (get self35 1))) (let ((self36 f29)) (case (get self36 0) ('Maybe.none ($Parser.Reply.error f35)) ('Maybe.some (let ((f36 (get self36 1))) ($Parser.Reply.error ($Parser.Error.combine f36 f35)))))))) ('Parser.Reply.value (let ((f35 (get self35 1))) (let ((f36 (get self35 2))) (let ((self37 f35)) (case (get self37 0) ('Parser.State.new (let ((f37 (get self37 1))) (let ((f38 (get self37 2))) (let ((f39 (get self37 3))) (let ((f40 (get self37 4))) (let ((f41 (get self37 5))) (let ((reply.pst$42 ($Parser.State.new ($Parser.Error.maybe_combine f29 f37) f38 f39 f40 f41))) (let ((term$43 ($Kind.Term.ref "Either.right"))) (let ((term$44 ($Kind.Term.app term$43 ($Kind.Term.hol Bits.e)))) (let ((term$45 ($Kind.Term.app term$44 ($Kind.Term.hol Bits.e)))) (let ((term$46 ($Kind.Term.app term$45 f22))) ($Parser.Reply.value reply.pst$42 term$46)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.apply ((Kind.Parser.block "apply") (lambda (pst$0) (let ((self1 pst$0)) (case (get self1 0) ('Parser.State.new (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((reply$6 ($Kind.Parser.text "apply(" pst$0))) (let ((self7 reply$6)) (case (get self7 0) ('Parser.Reply.error (let ((f7 (get self7 1))) (let ((self8 f1)) (case (get self8 0) ('Maybe.none ($Parser.Reply.error f7)) ('Maybe.some (let ((f8 (get self8 1))) ($Parser.Reply.error ($Parser.Error.combine f8 f7)))))))) ('Parser.Reply.value (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((self9 f7)) (case (get self9 0) ('Parser.State.new (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) (let ((reply.pst$14 ($Parser.State.new ($Parser.Error.maybe_combine f1 f9) f10 f11 f12 f13))) (let ((self15 reply.pst$14)) (case (get self15 0) ('Parser.State.new (let ((f15 (get self15 1))) (let ((f16 (get self15 2))) (let ((f17 (get self15 3))) (let ((f18 (get self15 4))) (let ((f19 (get self15 5))) (let ((reply$20 (Kind.Parser.term reply.pst$14))) (let ((self21 reply$20)) (case (get self21 0) ('Parser.Reply.error (let ((f21 (get self21 1))) (let ((self22 f15)) (case (get self22 0) ('Maybe.none ($Parser.Reply.error f21)) ('Maybe.some (let ((f22 (get self22 1))) ($Parser.Reply.error ($Parser.Error.combine f22 f21)))))))) ('Parser.Reply.value (let ((f21 (get self21 1))) (let ((f22 (get self21 2))) (let ((self23 f21)) (case (get self23 0) ('Parser.State.new (let ((f23 (get self23 1))) (let ((f24 (get self23 2))) (let ((f25 (get self23 3))) (let ((f26 (get self23 4))) (let ((f27 (get self23 5))) (let ((reply.pst$28 ($Parser.State.new ($Parser.Error.maybe_combine f15 f23) f24 f25 f26 f27))) (let ((self29 reply.pst$28)) (case (get self29 0) ('Parser.State.new (let ((f29 (get self29 1))) (let ((f30 (get self29 2))) (let ((f31 (get self29 3))) (let ((f32 (get self29 4))) (let ((f33 (get self29 5))) (let ((reply$34 ($Kind.Parser.text "," reply.pst$28))) (let ((self35 reply$34)) (case (get self35 0) ('Parser.Reply.error (let ((f35 (get self35 1))) (let ((self36 f29)) (case (get self36 0) ('Maybe.none ($Parser.Reply.error f35)) ('Maybe.some (let ((f36 (get self36 1))) ($Parser.Reply.error ($Parser.Error.combine f36 f35)))))))) ('Parser.Reply.value (let ((f35 (get self35 1))) (let ((f36 (get self35 2))) (let ((self37 f35)) (case (get self37 0) ('Parser.State.new (let ((f37 (get self37 1))) (let ((f38 (get self37 2))) (let ((f39 (get self37 3))) (let ((f40 (get self37 4))) (let ((f41 (get self37 5))) (let ((reply.pst$42 ($Parser.State.new ($Parser.Error.maybe_combine f29 f37) f38 f39 f40 f41))) (let ((self43 reply.pst$42)) (case (get self43 0) ('Parser.State.new (let ((f43 (get self43 1))) (let ((f44 (get self43 2))) (let ((f45 (get self43 3))) (let ((f46 (get self43 4))) (let ((f47 (get self43 5))) (let ((reply$48 (Kind.Parser.term reply.pst$42))) (let ((self49 reply$48)) (case (get self49 0) ('Parser.Reply.error (let ((f49 (get self49 1))) (let ((self50 f43)) (case (get self50 0) ('Maybe.none ($Parser.Reply.error f49)) ('Maybe.some (let ((f50 (get self50 1))) ($Parser.Reply.error ($Parser.Error.combine f50 f49)))))))) ('Parser.Reply.value (let ((f49 (get self49 1))) (let ((f50 (get self49 2))) (let ((self51 f49)) (case (get self51 0) ('Parser.State.new (let ((f51 (get self51 1))) (let ((f52 (get self51 2))) (let ((f53 (get self51 3))) (let ((f54 (get self51 4))) (let ((f55 (get self51 5))) (let ((reply.pst$56 ($Parser.State.new ($Parser.Error.maybe_combine f43 f51) f52 f53 f54 f55))) (let ((self57 reply.pst$56)) (case (get self57 0) ('Parser.State.new (let ((f57 (get self57 1))) (let ((f58 (get self57 2))) (let ((f59 (get self57 3))) (let ((f60 (get self57 4))) (let ((f61 (get self57 5))) (let ((reply$62 ($Kind.Parser.text ")" reply.pst$56))) (let ((self63 reply$62)) (case (get self63 0) ('Parser.Reply.error (let ((f63 (get self63 1))) (let ((self64 f57)) (case (get self64 0) ('Maybe.none ($Parser.Reply.error f63)) ('Maybe.some (let ((f64 (get self64 1))) ($Parser.Reply.error ($Parser.Error.combine f64 f63)))))))) ('Parser.Reply.value (let ((f63 (get self63 1))) (let ((f64 (get self63 2))) (let ((self65 f63)) (case (get self65 0) ('Parser.State.new (let ((f65 (get self65 1))) (let ((f66 (get self65 2))) (let ((f67 (get self65 3))) (let ((f68 (get self65 4))) (let ((f69 (get self65 5))) (let ((reply.pst$70 ($Parser.State.new ($Parser.Error.maybe_combine f57 f65) f66 f67 f68 f69))) (let ((term$71 ($Kind.Term.ref "Equal.apply"))) (let ((term$72 ($Kind.Term.app term$71 ($Kind.Term.hol Bits.e)))) (let ((term$73 ($Kind.Term.app term$72 ($Kind.Term.hol Bits.e)))) (let ((term$74 ($Kind.Term.app term$73 ($Kind.Term.hol Bits.e)))) (let ((term$75 ($Kind.Term.app term$74 ($Kind.Term.hol Bits.e)))) (let ((term$76 ($Kind.Term.app term$75 f22))) (let ((term$77 ($Kind.Term.app term$76 f50))) ($Parser.Reply.value reply.pst$70 term$77))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.chain ((Kind.Parser.block "chain") (lambda (pst$0) (let ((self1 pst$0)) (case (get self1 0) ('Parser.State.new (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((reply$6 ($Kind.Parser.text "chain(" pst$0))) (let ((self7 reply$6)) (case (get self7 0) ('Parser.Reply.error (let ((f7 (get self7 1))) (let ((self8 f1)) (case (get self8 0) ('Maybe.none ($Parser.Reply.error f7)) ('Maybe.some (let ((f8 (get self8 1))) ($Parser.Reply.error ($Parser.Error.combine f8 f7)))))))) ('Parser.Reply.value (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((self9 f7)) (case (get self9 0) ('Parser.State.new (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) (let ((reply.pst$14 ($Parser.State.new ($Parser.Error.maybe_combine f1 f9) f10 f11 f12 f13))) (let ((self15 reply.pst$14)) (case (get self15 0) ('Parser.State.new (let ((f15 (get self15 1))) (let ((f16 (get self15 2))) (let ((f17 (get self15 3))) (let ((f18 (get self15 4))) (let ((f19 (get self15 5))) (let ((reply$20 (Kind.Parser.term reply.pst$14))) (let ((self21 reply$20)) (case (get self21 0) ('Parser.Reply.error (let ((f21 (get self21 1))) (let ((self22 f15)) (case (get self22 0) ('Maybe.none ($Parser.Reply.error f21)) ('Maybe.some (let ((f22 (get self22 1))) ($Parser.Reply.error ($Parser.Error.combine f22 f21)))))))) ('Parser.Reply.value (let ((f21 (get self21 1))) (let ((f22 (get self21 2))) (let ((self23 f21)) (case (get self23 0) ('Parser.State.new (let ((f23 (get self23 1))) (let ((f24 (get self23 2))) (let ((f25 (get self23 3))) (let ((f26 (get self23 4))) (let ((f27 (get self23 5))) (let ((reply.pst$28 ($Parser.State.new ($Parser.Error.maybe_combine f15 f23) f24 f25 f26 f27))) (let ((self29 reply.pst$28)) (case (get self29 0) ('Parser.State.new (let ((f29 (get self29 1))) (let ((f30 (get self29 2))) (let ((f31 (get self29 3))) (let ((f32 (get self29 4))) (let ((f33 (get self29 5))) (let ((reply$34 ($Kind.Parser.text "," reply.pst$28))) (let ((self35 reply$34)) (case (get self35 0) ('Parser.Reply.error (let ((f35 (get self35 1))) (let ((self36 f29)) (case (get self36 0) ('Maybe.none ($Parser.Reply.error f35)) ('Maybe.some (let ((f36 (get self36 1))) ($Parser.Reply.error ($Parser.Error.combine f36 f35)))))))) ('Parser.Reply.value (let ((f35 (get self35 1))) (let ((f36 (get self35 2))) (let ((self37 f35)) (case (get self37 0) ('Parser.State.new (let ((f37 (get self37 1))) (let ((f38 (get self37 2))) (let ((f39 (get self37 3))) (let ((f40 (get self37 4))) (let ((f41 (get self37 5))) (let ((reply.pst$42 ($Parser.State.new ($Parser.Error.maybe_combine f29 f37) f38 f39 f40 f41))) (let ((self43 reply.pst$42)) (case (get self43 0) ('Parser.State.new (let ((f43 (get self43 1))) (let ((f44 (get self43 2))) (let ((f45 (get self43 3))) (let ((f46 (get self43 4))) (let ((f47 (get self43 5))) (let ((reply$48 (Kind.Parser.term reply.pst$42))) (let ((self49 reply$48)) (case (get self49 0) ('Parser.Reply.error (let ((f49 (get self49 1))) (let ((self50 f43)) (case (get self50 0) ('Maybe.none ($Parser.Reply.error f49)) ('Maybe.some (let ((f50 (get self50 1))) ($Parser.Reply.error ($Parser.Error.combine f50 f49)))))))) ('Parser.Reply.value (let ((f49 (get self49 1))) (let ((f50 (get self49 2))) (let ((self51 f49)) (case (get self51 0) ('Parser.State.new (let ((f51 (get self51 1))) (let ((f52 (get self51 2))) (let ((f53 (get self51 3))) (let ((f54 (get self51 4))) (let ((f55 (get self51 5))) (let ((reply.pst$56 ($Parser.State.new ($Parser.Error.maybe_combine f43 f51) f52 f53 f54 f55))) (let ((self57 reply.pst$56)) (case (get self57 0) ('Parser.State.new (let ((f57 (get self57 1))) (let ((f58 (get self57 2))) (let ((f59 (get self57 3))) (let ((f60 (get self57 4))) (let ((f61 (get self57 5))) (let ((reply$62 ($Kind.Parser.text ")" reply.pst$56))) (let ((self63 reply$62)) (case (get self63 0) ('Parser.Reply.error (let ((f63 (get self63 1))) (let ((self64 f57)) (case (get self64 0) ('Maybe.none ($Parser.Reply.error f63)) ('Maybe.some (let ((f64 (get self64 1))) ($Parser.Reply.error ($Parser.Error.combine f64 f63)))))))) ('Parser.Reply.value (let ((f63 (get self63 1))) (let ((f64 (get self63 2))) (let ((self65 f63)) (case (get self65 0) ('Parser.State.new (let ((f65 (get self65 1))) (let ((f66 (get self65 2))) (let ((f67 (get self65 3))) (let ((f68 (get self65 4))) (let ((f69 (get self65 5))) (let ((reply.pst$70 ($Parser.State.new ($Parser.Error.maybe_combine f57 f65) f66 f67 f68 f69))) (let ((term$71 ($Kind.Term.ref "Equal.chain"))) (let ((term$72 ($Kind.Term.app term$71 ($Kind.Term.hol Bits.e)))) (let ((term$73 ($Kind.Term.app term$72 ($Kind.Term.hol Bits.e)))) (let ((term$74 ($Kind.Term.app term$73 ($Kind.Term.hol Bits.e)))) (let ((term$75 ($Kind.Term.app term$74 ($Kind.Term.hol Bits.e)))) (let ((term$76 ($Kind.Term.app term$75 f22))) (let ((term$77 ($Kind.Term.app term$76 f50))) ($Parser.Reply.value reply.pst$70 term$77))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.mirror ((Kind.Parser.block "mirror") (lambda (pst$0) (let ((self1 pst$0)) (case (get self1 0) ('Parser.State.new (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((reply$6 ($Kind.Parser.text "mirror(" pst$0))) (let ((self7 reply$6)) (case (get self7 0) ('Parser.Reply.error (let ((f7 (get self7 1))) (let ((self8 f1)) (case (get self8 0) ('Maybe.none ($Parser.Reply.error f7)) ('Maybe.some (let ((f8 (get self8 1))) ($Parser.Reply.error ($Parser.Error.combine f8 f7)))))))) ('Parser.Reply.value (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((self9 f7)) (case (get self9 0) ('Parser.State.new (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) (let ((reply.pst$14 ($Parser.State.new ($Parser.Error.maybe_combine f1 f9) f10 f11 f12 f13))) (let ((self15 reply.pst$14)) (case (get self15 0) ('Parser.State.new (let ((f15 (get self15 1))) (let ((f16 (get self15 2))) (let ((f17 (get self15 3))) (let ((f18 (get self15 4))) (let ((f19 (get self15 5))) (let ((reply$20 (Kind.Parser.term reply.pst$14))) (let ((self21 reply$20)) (case (get self21 0) ('Parser.Reply.error (let ((f21 (get self21 1))) (let ((self22 f15)) (case (get self22 0) ('Maybe.none ($Parser.Reply.error f21)) ('Maybe.some (let ((f22 (get self22 1))) ($Parser.Reply.error ($Parser.Error.combine f22 f21)))))))) ('Parser.Reply.value (let ((f21 (get self21 1))) (let ((f22 (get self21 2))) (let ((self23 f21)) (case (get self23 0) ('Parser.State.new (let ((f23 (get self23 1))) (let ((f24 (get self23 2))) (let ((f25 (get self23 3))) (let ((f26 (get self23 4))) (let ((f27 (get self23 5))) (let ((reply.pst$28 ($Parser.State.new ($Parser.Error.maybe_combine f15 f23) f24 f25 f26 f27))) (let ((self29 reply.pst$28)) (case (get self29 0) ('Parser.State.new (let ((f29 (get self29 1))) (let ((f30 (get self29 2))) (let ((f31 (get self29 3))) (let ((f32 (get self29 4))) (let ((f33 (get self29 5))) (let ((reply$34 ($Kind.Parser.text ")" reply.pst$28))) (let ((self35 reply$34)) (case (get self35 0) ('Parser.Reply.error (let ((f35 (get self35 1))) (let ((self36 f29)) (case (get self36 0) ('Maybe.none ($Parser.Reply.error f35)) ('Maybe.some (let ((f36 (get self36 1))) ($Parser.Reply.error ($Parser.Error.combine f36 f35)))))))) ('Parser.Reply.value (let ((f35 (get self35 1))) (let ((f36 (get self35 2))) (let ((self37 f35)) (case (get self37 0) ('Parser.State.new (let ((f37 (get self37 1))) (let ((f38 (get self37 2))) (let ((f39 (get self37 3))) (let ((f40 (get self37 4))) (let ((f41 (get self37 5))) (let ((reply.pst$42 ($Parser.State.new ($Parser.Error.maybe_combine f29 f37) f38 f39 f40 f41))) (let ((term$43 ($Kind.Term.ref "Equal.mirror"))) (let ((term$44 ($Kind.Term.app term$43 ($Kind.Term.hol Bits.e)))) (let ((term$45 ($Kind.Term.app term$44 ($Kind.Term.hol Bits.e)))) (let ((term$46 ($Kind.Term.app term$45 ($Kind.Term.hol Bits.e)))) (let ((term$47 ($Kind.Term.app term$46 f22))) ($Parser.Reply.value reply.pst$42 term$47))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(define ($Kind.Parser.comprehension.and_all a$0) (let ((self0 a$0)) (case (get self0 0) ('List.nil ($Kind.Term.ref "Bool.true")) ('List.cons (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((and$3 ($Kind.Term.ref "Bool.and"))) (let ((and$4 ($Kind.Term.app and$3 f0))) (let ((and$5 ($Kind.Term.app and$4 ($Kind.Parser.comprehension.and_all f1)))) and$5)))))))))
(define Kind.Parser.comprehension.and_all (lambda (a$0) ($Kind.Parser.comprehension.and_all a$0)))
(define ($Kind.Parser.comprehension pst$0) (let ((self0 pst$0)) (case (get self0 0) ('Parser.State.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((reply$6 ($Kind.Parser.text "[" pst$0))) (let ((self6 reply$6)) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))) (let ((self7 f0)) (case (get self7 0) ('Maybe.none ($Parser.Reply.error f6)) ('Maybe.some (let ((f7 (get self7 1))) ($Parser.Reply.error ($Parser.Error.combine f7 f6)))))))) ('Parser.Reply.value (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((self8 f6)) (case (get self8 0) ('Parser.State.new (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) (let ((f11 (get self8 4))) (let ((f12 (get self8 5))) (let ((reply.pst$14 ($Parser.State.new ($Parser.Error.maybe_combine f0 f8) f9 f10 f11 f12))) (let ((self14 reply.pst$14)) (case (get self14 0) ('Parser.State.new (let ((f14 (get self14 1))) (let ((f15 (get self14 2))) (let ((f16 (get self14 3))) (let ((f17 (get self14 4))) (let ((f18 (get self14 5))) (let ((reply$20 (Kind.Parser.term reply.pst$14))) (let ((self20 reply$20)) (case (get self20 0) ('Parser.Reply.error (let ((f20 (get self20 1))) (let ((self21 f14)) (case (get self21 0) ('Maybe.none ($Parser.Reply.error f20)) ('Maybe.some (let ((f21 (get self21 1))) ($Parser.Reply.error ($Parser.Error.combine f21 f20)))))))) ('Parser.Reply.value (let ((f20 (get self20 1))) (let ((f21 (get self20 2))) (let ((self22 f20)) (case (get self22 0) ('Parser.State.new (let ((f22 (get self22 1))) (let ((f23 (get self22 2))) (let ((f24 (get self22 3))) (let ((f25 (get self22 4))) (let ((f26 (get self22 5))) (let ((reply.pst$28 ($Parser.State.new ($Parser.Error.maybe_combine f14 f22) f23 f24 f25 f26))) (let ((self28 reply.pst$28)) (case (get self28 0) ('Parser.State.new (let ((f28 (get self28 1))) (let ((f29 (get self28 2))) (let ((f30 (get self28 3))) (let ((f31 (get self28 4))) (let ((f32 (get self28 5))) (let ((reply$34 ($Kind.Parser.text "for" reply.pst$28))) (let ((self34 reply$34)) (case (get self34 0) ('Parser.Reply.error (let ((f34 (get self34 1))) (let ((self35 f28)) (case (get self35 0) ('Maybe.none ($Parser.Reply.error f34)) ('Maybe.some (let ((f35 (get self35 1))) ($Parser.Reply.error ($Parser.Error.combine f35 f34)))))))) ('Parser.Reply.value (let ((f34 (get self34 1))) (let ((f35 (get self34 2))) (let ((self36 f34)) (case (get self36 0) ('Parser.State.new (let ((f36 (get self36 1))) (let ((f37 (get self36 2))) (let ((f38 (get self36 3))) (let ((f39 (get self36 4))) (let ((f40 (get self36 5))) (let ((reply.pst$42 ($Parser.State.new ($Parser.Error.maybe_combine f28 f36) f37 f38 f39 f40))) (let ((self42 reply.pst$42)) (case (get self42 0) ('Parser.State.new (let ((f42 (get self42 1))) (let ((f43 (get self42 2))) (let ((f44 (get self42 3))) (let ((f45 (get self42 4))) (let ((f46 (get self42 5))) (let ((reply$48 ($Kind.Parser.name1 reply.pst$42))) (let ((self48 reply$48)) (case (get self48 0) ('Parser.Reply.error (let ((f48 (get self48 1))) (let ((self49 f42)) (case (get self49 0) ('Maybe.none ($Parser.Reply.error f48)) ('Maybe.some (let ((f49 (get self49 1))) ($Parser.Reply.error ($Parser.Error.combine f49 f48)))))))) ('Parser.Reply.value (let ((f48 (get self48 1))) (let ((f49 (get self48 2))) (let ((self50 f48)) (case (get self50 0) ('Parser.State.new (let ((f50 (get self50 1))) (let ((f51 (get self50 2))) (let ((f52 (get self50 3))) (let ((f53 (get self50 4))) (let ((f54 (get self50 5))) (let ((reply.pst$56 ($Parser.State.new ($Parser.Error.maybe_combine f42 f50) f51 f52 f53 f54))) (let ((self56 reply.pst$56)) (case (get self56 0) ('Parser.State.new (let ((f56 (get self56 1))) (let ((f57 (get self56 2))) (let ((f58 (get self56 3))) (let ((f59 (get self56 4))) (let ((f60 (get self56 5))) (let ((reply$62 ($Kind.Parser.text "in" reply.pst$56))) (let ((self62 reply$62)) (case (get self62 0) ('Parser.Reply.error (let ((f62 (get self62 1))) (let ((self63 f56)) (case (get self63 0) ('Maybe.none ($Parser.Reply.error f62)) ('Maybe.some (let ((f63 (get self63 1))) ($Parser.Reply.error ($Parser.Error.combine f63 f62)))))))) ('Parser.Reply.value (let ((f62 (get self62 1))) (let ((f63 (get self62 2))) (let ((self64 f62)) (case (get self64 0) ('Parser.State.new (let ((f64 (get self64 1))) (let ((f65 (get self64 2))) (let ((f66 (get self64 3))) (let ((f67 (get self64 4))) (let ((f68 (get self64 5))) (let ((reply.pst$70 ($Parser.State.new ($Parser.Error.maybe_combine f56 f64) f65 f66 f67 f68))) (let ((self70 reply.pst$70)) (case (get self70 0) ('Parser.State.new (let ((f70 (get self70 1))) (let ((f71 (get self70 2))) (let ((f72 (get self70 3))) (let ((f73 (get self70 4))) (let ((f74 (get self70 5))) (let ((reply$76 (Kind.Parser.term reply.pst$70))) (let ((self76 reply$76)) (case (get self76 0) ('Parser.Reply.error (let ((f76 (get self76 1))) (let ((self77 f70)) (case (get self77 0) ('Maybe.none ($Parser.Reply.error f76)) ('Maybe.some (let ((f77 (get self77 1))) ($Parser.Reply.error ($Parser.Error.combine f77 f76)))))))) ('Parser.Reply.value (let ((f76 (get self76 1))) (let ((f77 (get self76 2))) (let ((self78 f76)) (case (get self78 0) ('Parser.State.new (let ((f78 (get self78 1))) (let ((f79 (get self78 2))) (let ((f80 (get self78 3))) (let ((f81 (get self78 4))) (let ((f82 (get self78 5))) (let ((reply.pst$84 ($Parser.State.new ($Parser.Error.maybe_combine f70 f78) f79 f80 f81 f82))) (let ((self84 reply.pst$84)) (case (get self84 0) ('Parser.State.new (let ((f84 (get self84 1))) (let ((f85 (get self84 2))) (let ((f86 (get self84 3))) (let ((f87 (get self84 4))) (let ((f88 (get self84 5))) (let ((reply$90 ($Parser.maybe (Kind.Parser.text "where") reply.pst$84))) (let ((self90 reply$90)) (case (get self90 0) ('Parser.Reply.error (let ((f90 (get self90 1))) (let ((self91 f84)) (case (get self91 0) ('Maybe.none ($Parser.Reply.error f90)) ('Maybe.some (let ((f91 (get self91 1))) ($Parser.Reply.error ($Parser.Error.combine f91 f90)))))))) ('Parser.Reply.value (let ((f90 (get self90 1))) (let ((f91 (get self90 2))) (let ((self92 f90)) (case (get self92 0) ('Parser.State.new (let ((f92 (get self92 1))) (let ((f93 (get self92 2))) (let ((f94 (get self92 3))) (let ((f95 (get self92 4))) (let ((f96 (get self92 5))) (let ((reply.pst$98 ($Parser.State.new ($Parser.Error.maybe_combine f84 f92) f93 f94 f95 f96))) (let ((self98 reply.pst$98)) (case (get self98 0) ('Parser.State.new (let ((f98 (get self98 1))) (let ((f99 (get self98 2))) (let ((f100 (get self98 3))) (let ((f101 (get self98 4))) (let ((f102 (get self98 5))) (let ((reply$104 (($Parser.until (Kind.Parser.text "]") (lambda (pst$104) (let ((self104 pst$104)) (case (get self104 0) ('Parser.State.new (let ((f104 (get self104 1))) (let ((f105 (get self104 2))) (let ((f106 (get self104 3))) (let ((f107 (get self104 4))) (let ((f108 (get self104 5))) (let ((reply$110 (Kind.Parser.spaces pst$104))) (let ((self110 reply$110)) (case (get self110 0) ('Parser.Reply.error (let ((f110 (get self110 1))) (let ((self111 f104)) (case (get self111 0) ('Maybe.none ($Parser.Reply.error f110)) ('Maybe.some (let ((f111 (get self111 1))) ($Parser.Reply.error ($Parser.Error.combine f111 f110)))))))) ('Parser.Reply.value (let ((f110 (get self110 1))) (let ((f111 (get self110 2))) (let ((self112 f110)) (case (get self112 0) ('Parser.State.new (let ((f112 (get self112 1))) (let ((f113 (get self112 2))) (let ((f114 (get self112 3))) (let ((f115 (get self112 4))) (let ((f116 (get self112 5))) (let ((reply.pst$118 ($Parser.State.new ($Parser.Error.maybe_combine f104 f112) f113 f114 f115 f116))) (let ((self118 reply.pst$118)) (case (get self118 0) ('Parser.State.new (let ((f118 (get self118 1))) (let ((f119 (get self118 2))) (let ((f120 (get self118 3))) (let ((f121 (get self118 4))) (let ((f122 (get self118 5))) (let ((reply$124 (Kind.Parser.term reply.pst$118))) (let ((self124 reply$124)) (case (get self124 0) ('Parser.Reply.error (let ((f124 (get self124 1))) (let ((self125 f118)) (case (get self125 0) ('Maybe.none ($Parser.Reply.error f124)) ('Maybe.some (let ((f125 (get self125 1))) ($Parser.Reply.error ($Parser.Error.combine f125 f124)))))))) ('Parser.Reply.value (let ((f124 (get self124 1))) (let ((f125 (get self124 2))) (let ((self126 f124)) (case (get self126 0) ('Parser.State.new (let ((f126 (get self126 1))) (let ((f127 (get self126 2))) (let ((f128 (get self126 3))) (let ((f129 (get self126 4))) (let ((f130 (get self126 5))) (let ((reply.pst$132 ($Parser.State.new ($Parser.Error.maybe_combine f118 f126) f127 f128 f129 f130))) (let ((self132 reply.pst$132)) (case (get self132 0) ('Parser.State.new (let ((f132 (get self132 1))) (let ((f133 (get self132 2))) (let ((f134 (get self132 3))) (let ((f135 (get self132 4))) (let ((f136 (get self132 5))) (let ((reply$138 ($Parser.maybe (Kind.Parser.text ",") reply.pst$132))) (let ((self138 reply$138)) (case (get self138 0) ('Parser.Reply.error (let ((f138 (get self138 1))) (let ((self139 f132)) (case (get self139 0) ('Maybe.none ($Parser.Reply.error f138)) ('Maybe.some (let ((f139 (get self139 1))) ($Parser.Reply.error ($Parser.Error.combine f139 f138)))))))) ('Parser.Reply.value (let ((f138 (get self138 1))) (let ((f139 (get self138 2))) (let ((self140 f138)) (case (get self140 0) ('Parser.State.new (let ((f140 (get self140 1))) (let ((f141 (get self140 2))) (let ((f142 (get self140 3))) (let ((f143 (get self140 4))) (let ((f144 (get self140 5))) (let ((reply.pst$146 ($Parser.State.new ($Parser.Error.maybe_combine f132 f140) f141 f142 f143 f144))) ($Parser.Reply.value reply.pst$146 f125)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) reply.pst$98))) (let ((self104 reply$104)) (case (get self104 0) ('Parser.Reply.error (let ((f104 (get self104 1))) (let ((self105 f98)) (case (get self105 0) ('Maybe.none ($Parser.Reply.error f104)) ('Maybe.some (let ((f105 (get self105 1))) ($Parser.Reply.error ($Parser.Error.combine f105 f104)))))))) ('Parser.Reply.value (let ((f104 (get self104 1))) (let ((f105 (get self104 2))) (let ((self106 f104)) (case (get self106 0) ('Parser.State.new (let ((f106 (get self106 1))) (let ((f107 (get self106 2))) (let ((f108 (get self106 3))) (let ((f109 (get self106 4))) (let ((f110 (get self106 5))) (let ((reply.pst$112 ($Parser.State.new ($Parser.Error.maybe_combine f98 f106) f107 f108 f109 f110))) (let ((and$113 ($Kind.Parser.comprehension.and_all f105))) (let ((filter_fun$114 ($Kind.Term.ref "List.filter"))) (let ((filter_fun$115 ($Kind.Term.app filter_fun$114 ($Kind.Term.hol Bits.e)))) (let ((lamb_filter$116 ($Kind.Term.lam f49 (lambda (i$116) and$113)))) (let ((filter_fun$117 ($Kind.Term.app filter_fun$115 lamb_filter$116))) (let ((filter_fun$118 ($Kind.Term.app filter_fun$117 f77))) (let ((term$119 ($Kind.Term.ref "List.map"))) (let ((term$120 ($Kind.Term.app term$119 ($Kind.Term.hol Bits.e)))) (let ((term$121 ($Kind.Term.app term$120 ($Kind.Term.hol Bits.e)))) (let ((lamb$122 ($Kind.Term.lam f49 (lambda (i$122) f21)))) (let ((term$123 ($Kind.Term.app term$121 lamb$122))) (let ((term$124 ($Kind.Term.app term$123 filter_fun$118))) ($Parser.Reply.value reply.pst$112 term$124))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.comprehension (lambda (pst$0) ($Kind.Parser.comprehension pst$0)))
(define ($Kind.Parser.comprehension_range.go typename$0) ((Kind.Parser.block "comprehension_range") (lambda (pst$1) (let ((self1 pst$1)) (case (get self1 0) ('Parser.State.new (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((reply$7 ($Kind.Parser.text "[" pst$1))) (let ((self7 reply$7)) (case (get self7 0) ('Parser.Reply.error (let ((f7 (get self7 1))) (let ((self8 f1)) (case (get self8 0) ('Maybe.none ($Parser.Reply.error f7)) ('Maybe.some (let ((f8 (get self8 1))) ($Parser.Reply.error ($Parser.Error.combine f8 f7)))))))) ('Parser.Reply.value (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((self9 f7)) (case (get self9 0) ('Parser.State.new (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) (let ((reply.pst$15 ($Parser.State.new ($Parser.Error.maybe_combine f1 f9) f10 f11 f12 f13))) (let ((self15 reply.pst$15)) (case (get self15 0) ('Parser.State.new (let ((f15 (get self15 1))) (let ((f16 (get self15 2))) (let ((f17 (get self15 3))) (let ((f18 (get self15 4))) (let ((f19 (get self15 5))) (let ((reply$21 (Kind.Parser.term reply.pst$15))) (let ((self21 reply$21)) (case (get self21 0) ('Parser.Reply.error (let ((f21 (get self21 1))) (let ((self22 f15)) (case (get self22 0) ('Maybe.none ($Parser.Reply.error f21)) ('Maybe.some (let ((f22 (get self22 1))) ($Parser.Reply.error ($Parser.Error.combine f22 f21)))))))) ('Parser.Reply.value (let ((f21 (get self21 1))) (let ((f22 (get self21 2))) (let ((self23 f21)) (case (get self23 0) ('Parser.State.new (let ((f23 (get self23 1))) (let ((f24 (get self23 2))) (let ((f25 (get self23 3))) (let ((f26 (get self23 4))) (let ((f27 (get self23 5))) (let ((reply.pst$29 ($Parser.State.new ($Parser.Error.maybe_combine f15 f23) f24 f25 f26 f27))) (let ((self29 reply.pst$29)) (case (get self29 0) ('Parser.State.new (let ((f29 (get self29 1))) (let ((f30 (get self29 2))) (let ((f31 (get self29 3))) (let ((f32 (get self29 4))) (let ((f33 (get self29 5))) (let ((reply$35 ($Kind.Parser.text "to" reply.pst$29))) (let ((self35 reply$35)) (case (get self35 0) ('Parser.Reply.error (let ((f35 (get self35 1))) (let ((self36 f29)) (case (get self36 0) ('Maybe.none ($Parser.Reply.error f35)) ('Maybe.some (let ((f36 (get self36 1))) ($Parser.Reply.error ($Parser.Error.combine f36 f35)))))))) ('Parser.Reply.value (let ((f35 (get self35 1))) (let ((f36 (get self35 2))) (let ((self37 f35)) (case (get self37 0) ('Parser.State.new (let ((f37 (get self37 1))) (let ((f38 (get self37 2))) (let ((f39 (get self37 3))) (let ((f40 (get self37 4))) (let ((f41 (get self37 5))) (let ((reply.pst$43 ($Parser.State.new ($Parser.Error.maybe_combine f29 f37) f38 f39 f40 f41))) (let ((self43 reply.pst$43)) (case (get self43 0) ('Parser.State.new (let ((f43 (get self43 1))) (let ((f44 (get self43 2))) (let ((f45 (get self43 3))) (let ((f46 (get self43 4))) (let ((f47 (get self43 5))) (let ((reply$49 (Kind.Parser.term reply.pst$43))) (let ((self49 reply$49)) (case (get self49 0) ('Parser.Reply.error (let ((f49 (get self49 1))) (let ((self50 f43)) (case (get self50 0) ('Maybe.none ($Parser.Reply.error f49)) ('Maybe.some (let ((f50 (get self50 1))) ($Parser.Reply.error ($Parser.Error.combine f50 f49)))))))) ('Parser.Reply.value (let ((f49 (get self49 1))) (let ((f50 (get self49 2))) (let ((self51 f49)) (case (get self51 0) ('Parser.State.new (let ((f51 (get self51 1))) (let ((f52 (get self51 2))) (let ((f53 (get self51 3))) (let ((f54 (get self51 4))) (let ((f55 (get self51 5))) (let ((reply.pst$57 ($Parser.State.new ($Parser.Error.maybe_combine f43 f51) f52 f53 f54 f55))) (let ((list$58 (lambda (x$58) (let ((term$59 ($Kind.Term.ref ($String.concat x$58 ".range")))) (let ((term$60 ($Kind.Term.app term$59 f22))) (let ((term$61 ($Kind.Term.app term$60 f50))) term$61)))))) ((let ((self58 typename$0)) (case (get self58 0) ('Maybe.none (lambda (pst$59) (let ((self59 pst$59)) (case (get self59 0) ('Parser.State.new (let ((f59 (get self59 1))) (let ((f60 (get self59 2))) (let ((f61 (get self59 3))) (let ((f62 (get self59 4))) (let ((f63 (get self59 5))) (let ((reply$65 ($Parser.maybe (lambda (pst$65) (let ((self65 pst$65)) (case (get self65 0) ('Parser.State.new (let ((f65 (get self65 1))) (let ((f66 (get self65 2))) (let ((f67 (get self65 3))) (let ((f68 (get self65 4))) (let ((f69 (get self65 5))) (let ((reply$71 ($Kind.Parser.text ":" pst$65))) (let ((self71 reply$71)) (case (get self71 0) ('Parser.Reply.error (let ((f71 (get self71 1))) (let ((self72 f65)) (case (get self72 0) ('Maybe.none ($Parser.Reply.error f71)) ('Maybe.some (let ((f72 (get self72 1))) ($Parser.Reply.error ($Parser.Error.combine f72 f71)))))))) ('Parser.Reply.value (let ((f71 (get self71 1))) (let ((f72 (get self71 2))) (let ((self73 f71)) (case (get self73 0) ('Parser.State.new (let ((f73 (get self73 1))) (let ((f74 (get self73 2))) (let ((f75 (get self73 3))) (let ((f76 (get self73 4))) (let ((f77 (get self73 5))) (let ((reply.pst$79 ($Parser.State.new ($Parser.Error.maybe_combine f65 f73) f74 f75 f76 f77))) ($Kind.Parser.text "Nat" reply.pst$79))))))))))))))))))))))))) pst$59))) (let ((self65 reply$65)) (case (get self65 0) ('Parser.Reply.error (let ((f65 (get self65 1))) (let ((self66 f59)) (case (get self66 0) ('Maybe.none ($Parser.Reply.error f65)) ('Maybe.some (let ((f66 (get self66 1))) ($Parser.Reply.error ($Parser.Error.combine f66 f65)))))))) ('Parser.Reply.value (let ((f65 (get self65 1))) (let ((f66 (get self65 2))) (let ((self67 f65)) (case (get self67 0) ('Parser.State.new (let ((f67 (get self67 1))) (let ((f68 (get self67 2))) (let ((f69 (get self67 3))) (let ((f70 (get self67 4))) (let ((f71 (get self67 5))) (let ((reply.pst$73 ($Parser.State.new ($Parser.Error.maybe_combine f59 f67) f68 f69 f70 f71))) (let ((self73 reply.pst$73)) (case (get self73 0) ('Parser.State.new (let ((f73 (get self73 1))) (let ((f74 (get self73 2))) (let ((f75 (get self73 3))) (let ((f76 (get self73 4))) (let ((f77 (get self73 5))) (let ((reply$79 ($Kind.Parser.text "]" reply.pst$73))) (let ((self79 reply$79)) (case (get self79 0) ('Parser.Reply.error (let ((f79 (get self79 1))) (let ((self80 f73)) (case (get self80 0) ('Maybe.none ($Parser.Reply.error f79)) ('Maybe.some (let ((f80 (get self80 1))) ($Parser.Reply.error ($Parser.Error.combine f80 f79)))))))) ('Parser.Reply.value (let ((f79 (get self79 1))) (let ((f80 (get self79 2))) (let ((self81 f79)) (case (get self81 0) ('Parser.State.new (let ((f81 (get self81 1))) (let ((f82 (get self81 2))) (let ((f83 (get self81 3))) (let ((f84 (get self81 4))) (let ((f85 (get self81 5))) (let ((reply.pst$87 ($Parser.State.new ($Parser.Error.maybe_combine f73 f81) f82 f83 f84 f85))) ($Parser.Reply.value reply.pst$87 (list$58 "Nat")))))))))))))))))))))))))))))))))))))))))))))))))) ('Maybe.some (let ((f58 (get self58 1))) (lambda (pst$60) (let ((self60 pst$60)) (case (get self60 0) ('Parser.State.new (let ((f60 (get self60 1))) (let ((f61 (get self60 2))) (let ((f62 (get self60 3))) (let ((f63 (get self60 4))) (let ((f64 (get self60 5))) (let ((reply$66 ($Kind.Parser.text ":" pst$60))) (let ((self66 reply$66)) (case (get self66 0) ('Parser.Reply.error (let ((f66 (get self66 1))) (let ((self67 f60)) (case (get self67 0) ('Maybe.none ($Parser.Reply.error f66)) ('Maybe.some (let ((f67 (get self67 1))) ($Parser.Reply.error ($Parser.Error.combine f67 f66)))))))) ('Parser.Reply.value (let ((f66 (get self66 1))) (let ((f67 (get self66 2))) (let ((self68 f66)) (case (get self68 0) ('Parser.State.new (let ((f68 (get self68 1))) (let ((f69 (get self68 2))) (let ((f70 (get self68 3))) (let ((f71 (get self68 4))) (let ((f72 (get self68 5))) (let ((reply.pst$74 ($Parser.State.new ($Parser.Error.maybe_combine f60 f68) f69 f70 f71 f72))) (let ((self74 reply.pst$74)) (case (get self74 0) ('Parser.State.new (let ((f74 (get self74 1))) (let ((f75 (get self74 2))) (let ((f76 (get self74 3))) (let ((f77 (get self74 4))) (let ((f78 (get self74 5))) (let ((reply$80 ($Kind.Parser.text f58 reply.pst$74))) (let ((self80 reply$80)) (case (get self80 0) ('Parser.Reply.error (let ((f80 (get self80 1))) (let ((self81 f74)) (case (get self81 0) ('Maybe.none ($Parser.Reply.error f80)) ('Maybe.some (let ((f81 (get self81 1))) ($Parser.Reply.error ($Parser.Error.combine f81 f80)))))))) ('Parser.Reply.value (let ((f80 (get self80 1))) (let ((f81 (get self80 2))) (let ((self82 f80)) (case (get self82 0) ('Parser.State.new (let ((f82 (get self82 1))) (let ((f83 (get self82 2))) (let ((f84 (get self82 3))) (let ((f85 (get self82 4))) (let ((f86 (get self82 5))) (let ((reply.pst$88 ($Parser.State.new ($Parser.Error.maybe_combine f74 f82) f83 f84 f85 f86))) (let ((self88 reply.pst$88)) (case (get self88 0) ('Parser.State.new (let ((f88 (get self88 1))) (let ((f89 (get self88 2))) (let ((f90 (get self88 3))) (let ((f91 (get self88 4))) (let ((f92 (get self88 5))) (let ((reply$94 ($Kind.Parser.text "]" reply.pst$88))) (let ((self94 reply$94)) (case (get self94 0) ('Parser.Reply.error (let ((f94 (get self94 1))) (let ((self95 f88)) (case (get self95 0) ('Maybe.none ($Parser.Reply.error f94)) ('Maybe.some (let ((f95 (get self95 1))) ($Parser.Reply.error ($Parser.Error.combine f95 f94)))))))) ('Parser.Reply.value (let ((f94 (get self94 1))) (let ((f95 (get self94 2))) (let ((self96 f94)) (case (get self96 0) ('Parser.State.new (let ((f96 (get self96 1))) (let ((f97 (get self96 2))) (let ((f98 (get self96 3))) (let ((f99 (get self96 4))) (let ((f100 (get self96 5))) (let ((reply.pst$102 ($Parser.State.new ($Parser.Error.maybe_combine f88 f96) f97 f98 f99 f100))) ($Parser.Reply.value reply.pst$102 (list$58 f58)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) reply.pst$57)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.comprehension_range.go (lambda (typename$0) ($Kind.Parser.comprehension_range.go typename$0)))
(define Kind.Parser.comprehension_range (Parser.choice ($List.cons ($Kind.Parser.comprehension_range.go Maybe.none) ($List.cons ($Kind.Parser.comprehension_range.go ($Maybe.some "I32")) ($List.cons ($Kind.Parser.comprehension_range.go ($Maybe.some "U32")) List.nil)))))
(define ($Kind.Name.read str$0) str$0)
(define Kind.Name.read (lambda (str$0) ($Kind.Name.read str$0)))
(define Kind.Parser.list ((Kind.Parser.block "list") (lambda (pst$0) (let ((self1 pst$0)) (case (get self1 0) ('Parser.State.new (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((reply$6 (($Kind.Parser.items "[" Kind.Parser.term "]") pst$0))) (let ((self7 reply$6)) (case (get self7 0) ('Parser.Reply.error (let ((f7 (get self7 1))) (let ((self8 f1)) (case (get self8 0) ('Maybe.none ($Parser.Reply.error f7)) ('Maybe.some (let ((f8 (get self8 1))) ($Parser.Reply.error ($Parser.Error.combine f8 f7)))))))) ('Parser.Reply.value (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((self9 f7)) (case (get self9 0) ('Parser.State.new (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) (let ((reply.pst$14 ($Parser.State.new ($Parser.Error.maybe_combine f1 f9) f10 f11 f12 f13))) ($Parser.Reply.value reply.pst$14 ($List.fold f8 ($Kind.Term.app ($Kind.Term.ref ($Kind.Name.read "List.nil")) ($Kind.Term.hol Bits.e)) (lambda (x$15) (lambda (xs$16) (let ((term$17 ($Kind.Term.ref ($Kind.Name.read "List.cons")))) (let ((term$18 ($Kind.Term.app term$17 ($Kind.Term.hol Bits.e)))) (let ((term$19 ($Kind.Term.app term$18 x$15))) (let ((term$20 ($Kind.Term.app term$19 xs$16))) term$20))))))))))))))))))))))))))))))))))
(define Kind.Parser.map ((Kind.Parser.block "map") (lambda (pst$0) (let ((self1 pst$0)) (case (get self1 0) ('Parser.State.new (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((reply$6 (($Kind.Parser.items "{" (lambda (pst$6) (let ((self7 pst$6)) (case (get self7 0) ('Parser.State.new (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((f9 (get self7 3))) (let ((f10 (get self7 4))) (let ((f11 (get self7 5))) (let ((reply$12 (Kind.Parser.term pst$6))) (let ((self13 reply$12)) (case (get self13 0) ('Parser.Reply.error (let ((f13 (get self13 1))) (let ((self14 f7)) (case (get self14 0) ('Maybe.none ($Parser.Reply.error f13)) ('Maybe.some (let ((f14 (get self14 1))) ($Parser.Reply.error ($Parser.Error.combine f14 f13)))))))) ('Parser.Reply.value (let ((f13 (get self13 1))) (let ((f14 (get self13 2))) (let ((self15 f13)) (case (get self15 0) ('Parser.State.new (let ((f15 (get self15 1))) (let ((f16 (get self15 2))) (let ((f17 (get self15 3))) (let ((f18 (get self15 4))) (let ((f19 (get self15 5))) (let ((reply.pst$20 ($Parser.State.new ($Parser.Error.maybe_combine f7 f15) f16 f17 f18 f19))) (let ((self21 reply.pst$20)) (case (get self21 0) ('Parser.State.new (let ((f21 (get self21 1))) (let ((f22 (get self21 2))) (let ((f23 (get self21 3))) (let ((f24 (get self21 4))) (let ((f25 (get self21 5))) (let ((reply$26 ($Kind.Parser.text ":" reply.pst$20))) (let ((self27 reply$26)) (case (get self27 0) ('Parser.Reply.error (let ((f27 (get self27 1))) (let ((self28 f21)) (case (get self28 0) ('Maybe.none ($Parser.Reply.error f27)) ('Maybe.some (let ((f28 (get self28 1))) ($Parser.Reply.error ($Parser.Error.combine f28 f27)))))))) ('Parser.Reply.value (let ((f27 (get self27 1))) (let ((f28 (get self27 2))) (let ((self29 f27)) (case (get self29 0) ('Parser.State.new (let ((f29 (get self29 1))) (let ((f30 (get self29 2))) (let ((f31 (get self29 3))) (let ((f32 (get self29 4))) (let ((f33 (get self29 5))) (let ((reply.pst$34 ($Parser.State.new ($Parser.Error.maybe_combine f21 f29) f30 f31 f32 f33))) (let ((self35 reply.pst$34)) (case (get self35 0) ('Parser.State.new (let ((f35 (get self35 1))) (let ((f36 (get self35 2))) (let ((f37 (get self35 3))) (let ((f38 (get self35 4))) (let ((f39 (get self35 5))) (let ((reply$40 (Kind.Parser.term reply.pst$34))) (let ((self41 reply$40)) (case (get self41 0) ('Parser.Reply.error (let ((f41 (get self41 1))) (let ((self42 f35)) (case (get self42 0) ('Maybe.none ($Parser.Reply.error f41)) ('Maybe.some (let ((f42 (get self42 1))) ($Parser.Reply.error ($Parser.Error.combine f42 f41)))))))) ('Parser.Reply.value (let ((f41 (get self41 1))) (let ((f42 (get self41 2))) (let ((self43 f41)) (case (get self43 0) ('Parser.State.new (let ((f43 (get self43 1))) (let ((f44 (get self43 2))) (let ((f45 (get self43 3))) (let ((f46 (get self43 4))) (let ((f47 (get self43 5))) (let ((reply.pst$48 ($Parser.State.new ($Parser.Error.maybe_combine f35 f43) f44 f45 f46 f47))) ($Parser.Reply.value reply.pst$48 ($Pair.new f14 f42)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) "}") pst$0))) (let ((self7 reply$6)) (case (get self7 0) ('Parser.Reply.error (let ((f7 (get self7 1))) (let ((self8 f1)) (case (get self8 0) ('Maybe.none ($Parser.Reply.error f7)) ('Maybe.some (let ((f8 (get self8 1))) ($Parser.Reply.error ($Parser.Error.combine f8 f7)))))))) ('Parser.Reply.value (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((self9 f7)) (case (get self9 0) ('Parser.State.new (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) (let ((reply.pst$14 ($Parser.State.new ($Parser.Error.maybe_combine f1 f9) f10 f11 f12 f13))) (let ((list$15 ($List.fold f8 ($Kind.Term.app ($Kind.Term.ref "List.nil") ($Kind.Term.hol Bits.e)) (lambda (kv$15) (lambda (xs$16) (let ((self17 kv$15)) (case (get self17 0) ('Pair.new (let ((f17 (get self17 1))) (let ((f18 (get self17 2))) (let ((pair$19 ($Kind.Term.ref "Pair.new"))) (let ((pair$20 ($Kind.Term.app pair$19 ($Kind.Term.hol Bits.e)))) (let ((pair$21 ($Kind.Term.app pair$20 ($Kind.Term.hol Bits.e)))) (let ((pair$22 ($Kind.Term.app pair$21 f17))) (let ((pair$23 ($Kind.Term.app pair$22 f18))) (let ((term$24 ($Kind.Term.ref "List.cons"))) (let ((term$25 ($Kind.Term.app term$24 ($Kind.Term.hol Bits.e)))) (let ((term$26 ($Kind.Term.app term$25 pair$23))) (let ((term$27 ($Kind.Term.app term$26 xs$16))) term$27))))))))))))))))))) (let ((term$16 ($Kind.Term.ref "Map.from_list"))) (let ((term$17 ($Kind.Term.app term$16 ($Kind.Term.hol Bits.e)))) (let ((term$18 ($Kind.Term.app term$17 list$15))) ($Parser.Reply.value reply.pst$14 term$18)))))))))))))))))))))))))))))))
(define ($Kind.Parser.log body$0) ((Kind.Parser.block "log") (lambda (pst$1) (let ((self1 pst$1)) (case (get self1 0) ('Parser.State.new (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((reply$7 ($Kind.Parser.text "log(" pst$1))) (let ((self7 reply$7)) (case (get self7 0) ('Parser.Reply.error (let ((f7 (get self7 1))) (let ((self8 f1)) (case (get self8 0) ('Maybe.none ($Parser.Reply.error f7)) ('Maybe.some (let ((f8 (get self8 1))) ($Parser.Reply.error ($Parser.Error.combine f8 f7)))))))) ('Parser.Reply.value (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((self9 f7)) (case (get self9 0) ('Parser.State.new (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) (let ((reply.pst$15 ($Parser.State.new ($Parser.Error.maybe_combine f1 f9) f10 f11 f12 f13))) (let ((self15 reply.pst$15)) (case (get self15 0) ('Parser.State.new (let ((f15 (get self15 1))) (let ((f16 (get self15 2))) (let ((f17 (get self15 3))) (let ((f18 (get self15 4))) (let ((f19 (get self15 5))) (let ((reply$21 (Kind.Parser.term reply.pst$15))) (let ((self21 reply$21)) (case (get self21 0) ('Parser.Reply.error (let ((f21 (get self21 1))) (let ((self22 f15)) (case (get self22 0) ('Maybe.none ($Parser.Reply.error f21)) ('Maybe.some (let ((f22 (get self22 1))) ($Parser.Reply.error ($Parser.Error.combine f22 f21)))))))) ('Parser.Reply.value (let ((f21 (get self21 1))) (let ((f22 (get self21 2))) (let ((self23 f21)) (case (get self23 0) ('Parser.State.new (let ((f23 (get self23 1))) (let ((f24 (get self23 2))) (let ((f25 (get self23 3))) (let ((f26 (get self23 4))) (let ((f27 (get self23 5))) (let ((reply.pst$29 ($Parser.State.new ($Parser.Error.maybe_combine f15 f23) f24 f25 f26 f27))) (let ((self29 reply.pst$29)) (case (get self29 0) ('Parser.State.new (let ((f29 (get self29 1))) (let ((f30 (get self29 2))) (let ((f31 (get self29 3))) (let ((f32 (get self29 4))) (let ((f33 (get self29 5))) (let ((reply$35 ($Kind.Parser.text ")" reply.pst$29))) (let ((self35 reply$35)) (case (get self35 0) ('Parser.Reply.error (let ((f35 (get self35 1))) (let ((self36 f29)) (case (get self36 0) ('Maybe.none ($Parser.Reply.error f35)) ('Maybe.some (let ((f36 (get self36 1))) ($Parser.Reply.error ($Parser.Error.combine f36 f35)))))))) ('Parser.Reply.value (let ((f35 (get self35 1))) (let ((f36 (get self35 2))) (let ((self37 f35)) (case (get self37 0) ('Parser.State.new (let ((f37 (get self37 1))) (let ((f38 (get self37 2))) (let ((f39 (get self37 3))) (let ((f40 (get self37 4))) (let ((f41 (get self37 5))) (let ((reply.pst$43 ($Parser.State.new ($Parser.Error.maybe_combine f29 f37) f38 f39 f40 f41))) (let ((self43 reply.pst$43)) (case (get self43 0) ('Parser.State.new (let ((f43 (get self43 1))) (let ((f44 (get self43 2))) (let ((f45 (get self43 3))) (let ((f46 (get self43 4))) (let ((f47 (get self43 5))) (let ((reply$49 ((body$0 Unit.new) reply.pst$43))) (let ((self49 reply$49)) (case (get self49 0) ('Parser.Reply.error (let ((f49 (get self49 1))) (let ((self50 f43)) (case (get self50 0) ('Maybe.none ($Parser.Reply.error f49)) ('Maybe.some (let ((f50 (get self50 1))) ($Parser.Reply.error ($Parser.Error.combine f50 f49)))))))) ('Parser.Reply.value (let ((f49 (get self49 1))) (let ((f50 (get self49 2))) (let ((self51 f49)) (case (get self51 0) ('Parser.State.new (let ((f51 (get self51 1))) (let ((f52 (get self51 2))) (let ((f53 (get self51 3))) (let ((f54 (get self51 4))) (let ((f55 (get self51 5))) (let ((reply.pst$57 ($Parser.State.new ($Parser.Error.maybe_combine f43 f51) f52 f53 f54 f55))) (let ((term$58 ($Kind.Term.ref "Debug.log"))) (let ((term$59 ($Kind.Term.app term$58 ($Kind.Term.hol Bits.e)))) (let ((term$60 ($Kind.Term.app term$59 f22))) (let ((term$61 ($Kind.Term.app term$60 ($Kind.Term.lam "" (lambda (x$61) f50))))) ($Parser.Reply.value reply.pst$57 term$61))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.log (lambda (body$0) ($Kind.Parser.log body$0)))
(define ($String.map f$0 as$1) (let ((self0 as$1)) (case (<= (kstring-length self0) 0) (#t String.nil) (#f (let ((f0 (char->integer (kstring-head self0)))) (let ((f1 (kstring-tail self0))) ($String.cons (f$0 f0) ($String.map f$0 f1))))))))
(define String.map (lambda (f$0) (lambda (as$1) ($String.map f$0 as$1))))
(define ($Char.to_upper char$0) (let ((self0 ($Bool.and ($U16.gte char$0 97) ($U16.lte char$0 122)))) (case self0 (#t ($U16.sub char$0 ($Nat.to_u16 32))) (#f char$0))))
(define Char.to_upper (lambda (char$0) ($Char.to_upper char$0)))
(define ($String.to_upper str$0) ($String.map Char.to_upper str$0))
(define String.to_upper (lambda (str$0) ($String.to_upper str$0)))
(define ($String.is_upper str$0) ($String.eql ($String.to_upper str$0) str$0))
(define String.is_upper (lambda (str$0) ($String.is_upper str$0)))
(define ($String.take n$0 xs$1) (let ((self0 xs$1)) (case (<= (kstring-length self0) 0) (#t String.nil) (#f (let ((f0 (char->integer (kstring-head self0)))) (let ((f1 (kstring-tail self0))) (let ((self2 n$0)) (case (= self2 0) (#t String.nil) (#f (let ((f2 (- self2 1))) ($String.cons f0 ($String.take f2 f1))))))))))))
(define String.take (lambda (n$0) (lambda (xs$1) ($String.take n$0 xs$1))))
(define ($Nat.sub n$0 m$1) (max (- n$0 m$1) 0))
(define Nat.sub (lambda (n$0) (lambda (m$1) ($Nat.sub n$0 m$1))))
(define ($String.slice i$0 j$1 xs$2) ($String.take ($Nat.sub j$1 i$0) ($String.drop i$0 xs$2)))
(define String.slice (lambda (i$0) (lambda (j$1) (lambda (xs$2) ($String.slice i$0 j$1 xs$2)))))
(define ($Kind.Term.unroll_nat natx$0) (let ((self0 natx$0)) (case (= self0 0) (#t ($Kind.Term.ref ($Kind.Name.read "Nat.zero"))) (#f (let ((f0 (- self0 1))) (let ((func$2 ($Kind.Term.ref ($Kind.Name.read "Nat.succ")))) (let ((argm$3 ($Kind.Term.nat f0))) ($Kind.Term.app func$2 argm$3))))))))
(define Kind.Term.unroll_nat (lambda (natx$0) ($Kind.Term.unroll_nat natx$0)))
(define ($Word.to_bits a$1) (let ((self0 a$1)) (case (get self0 0) ('Word.e Bits.e) ('Word.o (let ((f0 (get self0 1))) ($Bits.o ($Word.to_bits f0)))) ('Word.i (let ((f0 (get self0 1))) ($Bits.i ($Word.to_bits f0)))))))
(define Word.to_bits (lambda (a$1) ($Word.to_bits a$1)))
(define ($U16.to_bits a$0) (let ((self0 a$0)) (case #t (#t (let ((f0 (u16-to-word self0))) ($Word.to_bits f0))))))
(define U16.to_bits (lambda (a$0) ($U16.to_bits a$0)))
(define ($Kind.Term.unroll_chr.bits bits$0) (let ((self0 bits$0)) (case (if (eq? self0 #b1) 2 (bitwise-and self0 #b1)) (2 ($Kind.Term.ref ($Kind.Name.read "Bits.e"))) (0 (let ((f0 (bitwise-arithmetic-shift-right self0 #b1))) ($Kind.Term.app ($Kind.Term.ref ($Kind.Name.read "Bits.o")) ($Kind.Term.unroll_chr.bits f0)))) (1 (let ((f0 (bitwise-arithmetic-shift-right self0 #b1))) ($Kind.Term.app ($Kind.Term.ref ($Kind.Name.read "Bits.i")) ($Kind.Term.unroll_chr.bits f0)))))))
(define Kind.Term.unroll_chr.bits (lambda (bits$0) ($Kind.Term.unroll_chr.bits bits$0)))
(define ($Kind.Term.unroll_chr chrx$0) (let ((bits$1 ($U16.to_bits chrx$0))) (let ((term$2 ($Kind.Term.ref ($Kind.Name.read "Word.from_bits")))) (let ((term$3 ($Kind.Term.app term$2 ($Kind.Term.nat 16)))) (let ((term$4 ($Kind.Term.app term$3 ($Kind.Term.unroll_chr.bits bits$1)))) (let ((term$5 ($Kind.Term.app ($Kind.Term.ref ($Kind.Name.read "U16.new")) term$4))) term$5))))))
(define Kind.Term.unroll_chr (lambda (chrx$0) ($Kind.Term.unroll_chr chrx$0)))
(define ($Kind.Term.unroll_str strx$0) (let ((self0 strx$0)) (case (<= (kstring-length self0) 0) (#t ($Kind.Term.ref ($Kind.Name.read "String.nil"))) (#f (let ((f0 (char->integer (kstring-head self0)))) (let ((f1 (kstring-tail self0))) (let ((char$3 ($Kind.Term.chr f0))) (let ((term$4 ($Kind.Term.ref ($Kind.Name.read "String.cons")))) (let ((term$5 ($Kind.Term.app term$4 char$3))) (let ((term$6 ($Kind.Term.app term$5 ($Kind.Term.str f1)))) term$6))))))))))
(define Kind.Term.unroll_str (lambda (strx$0) ($Kind.Term.unroll_str strx$0)))
(define ($Kind.Term.reduce term$0 defs$1) (let ((self0 term$0)) (case (get self0 0) ('Kind.Term.var (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) term$0))) ('Kind.Term.ref (let ((f0 (get self0 1))) (let ((self1 ($Kind.Map.get f0 defs$1))) (case (get self1 0) ('Maybe.none ($Kind.Term.ref f0)) ('Maybe.some (let ((f1 (get self1 1))) (let ((self2 f1)) (case (get self2 0) ('Kind.Def.new (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) (let ((f5 (get self2 4))) (let ((f6 (get self2 5))) (let ((f7 (get self2 6))) (let ((f8 (get self2 7))) (let ((f9 (get self2 8))) (let ((f10 (get self2 9))) ($Kind.Term.reduce f6 defs$1))))))))))))))))))) ('Kind.Term.typ term$0) ('Kind.Term.all (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) term$0)))))) ('Kind.Term.lam (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) term$0))) ('Kind.Term.app (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((func$4 ($Kind.Term.reduce f0 defs$1))) (let ((self3 func$4)) (case (get self3 0) ('Kind.Term.var (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) term$0))) ('Kind.Term.ref (let ((f3 (get self3 1))) term$0)) ('Kind.Term.typ term$0) ('Kind.Term.all (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) (let ((f7 (get self3 5))) term$0)))))) ('Kind.Term.lam (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) ($Kind.Term.reduce (f4 f1) defs$1)))) ('Kind.Term.app (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) term$0))) ('Kind.Term.let (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) term$0)))) ('Kind.Term.def (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) term$0)))) ('Kind.Term.ann (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) term$0)))) ('Kind.Term.gol (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) term$0)))) ('Kind.Term.hol (let ((f3 (get self3 1))) term$0)) ('Kind.Term.nat (let ((f3 (get self3 1))) term$0)) ('Kind.Term.chr (let ((f3 (get self3 1))) term$0)) ('Kind.Term.str (let ((f3 (get self3 1))) term$0)) ('Kind.Term.num (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) term$0)))) ('Kind.Term.cse (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) (let ((f7 (get self3 5))) (let ((f8 (get self3 6))) term$0))))))) ('Kind.Term.new (let ((f3 (get self3 1))) term$0)) ('Kind.Term.get (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) term$0))) ('Kind.Term.set (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) term$0)))) ('Kind.Term.ope (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) term$0)))) ('Kind.Term.ori (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) term$0))))))))) ('Kind.Term.let (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) ($Kind.Term.reduce (f2 f1) defs$1))))) ('Kind.Term.def (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) ($Kind.Term.reduce (f2 f1) defs$1))))) ('Kind.Term.ann (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) ($Kind.Term.reduce f1 defs$1))))) ('Kind.Term.gol (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) term$0)))) ('Kind.Term.hol (let ((f0 (get self0 1))) term$0)) ('Kind.Term.nat (let ((f0 (get self0 1))) ($Kind.Term.reduce ($Kind.Term.unroll_nat f0) defs$1))) ('Kind.Term.chr (let ((f0 (get self0 1))) ($Kind.Term.reduce ($Kind.Term.unroll_chr f0) defs$1))) ('Kind.Term.str (let ((f0 (get self0 1))) ($Kind.Term.reduce ($Kind.Term.unroll_str f0) defs$1))) ('Kind.Term.num (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) term$0)))) ('Kind.Term.cse (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((f5 (get self0 6))) term$0))))))) ('Kind.Term.new (let ((f0 (get self0 1))) term$0)) ('Kind.Term.get (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) term$0))) ('Kind.Term.set (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) term$0)))) ('Kind.Term.ope (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) term$0)))) ('Kind.Term.ori (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($Kind.Term.reduce f1 defs$1)))))))
(define Kind.Term.reduce (lambda (term$0) (lambda (defs$1) ($Kind.Term.reduce term$0 defs$1))))
(define ($Kind.Parser.open body$0) ((Kind.Parser.block "open") (lambda (pst$1) (let ((self1 pst$1)) (case (get self1 0) ('Parser.State.new (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((reply$7 ($Kind.Parser.text "open " pst$1))) (let ((self7 reply$7)) (case (get self7 0) ('Parser.Reply.error (let ((f7 (get self7 1))) (let ((self8 f1)) (case (get self8 0) ('Maybe.none ($Parser.Reply.error f7)) ('Maybe.some (let ((f8 (get self8 1))) ($Parser.Reply.error ($Parser.Error.combine f8 f7)))))))) ('Parser.Reply.value (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((self9 f7)) (case (get self9 0) ('Parser.State.new (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) (let ((reply.pst$15 ($Parser.State.new ($Parser.Error.maybe_combine f1 f9) f10 f11 f12 f13))) (let ((self15 reply.pst$15)) (case (get self15 0) ('Parser.State.new (let ((f15 (get self15 1))) (let ((f16 (get self15 2))) (let ((f17 (get self15 3))) (let ((f18 (get self15 4))) (let ((f19 (get self15 5))) (let ((reply$21 (Kind.Parser.term reply.pst$15))) (let ((self21 reply$21)) (case (get self21 0) ('Parser.Reply.error (let ((f21 (get self21 1))) (let ((self22 f15)) (case (get self22 0) ('Maybe.none ($Parser.Reply.error f21)) ('Maybe.some (let ((f22 (get self22 1))) ($Parser.Reply.error ($Parser.Error.combine f22 f21)))))))) ('Parser.Reply.value (let ((f21 (get self21 1))) (let ((f22 (get self21 2))) (let ((self23 f21)) (case (get self23 0) ('Parser.State.new (let ((f23 (get self23 1))) (let ((f24 (get self23 2))) (let ((f25 (get self23 3))) (let ((f26 (get self23 4))) (let ((f27 (get self23 5))) (let ((reply.pst$29 ($Parser.State.new ($Parser.Error.maybe_combine f15 f23) f24 f25 f26 f27))) (let ((self29 reply.pst$29)) (case (get self29 0) ('Parser.State.new (let ((f29 (get self29 1))) (let ((f30 (get self29 2))) (let ((f31 (get self29 3))) (let ((f32 (get self29 4))) (let ((f33 (get self29 5))) (let ((reply$35 ($Parser.maybe (lambda (pst$35) (let ((self35 pst$35)) (case (get self35 0) ('Parser.State.new (let ((f35 (get self35 1))) (let ((f36 (get self35 2))) (let ((f37 (get self35 3))) (let ((f38 (get self35 4))) (let ((f39 (get self35 5))) (let ((reply$41 ($Kind.Parser.text "as" pst$35))) (let ((self41 reply$41)) (case (get self41 0) ('Parser.Reply.error (let ((f41 (get self41 1))) (let ((self42 f35)) (case (get self42 0) ('Maybe.none ($Parser.Reply.error f41)) ('Maybe.some (let ((f42 (get self42 1))) ($Parser.Reply.error ($Parser.Error.combine f42 f41)))))))) ('Parser.Reply.value (let ((f41 (get self41 1))) (let ((f42 (get self41 2))) (let ((self43 f41)) (case (get self43 0) ('Parser.State.new (let ((f43 (get self43 1))) (let ((f44 (get self43 2))) (let ((f45 (get self43 3))) (let ((f46 (get self43 4))) (let ((f47 (get self43 5))) (let ((reply.pst$49 ($Parser.State.new ($Parser.Error.maybe_combine f35 f43) f44 f45 f46 f47))) ($Kind.Parser.name1 reply.pst$49))))))))))))))))))))))))) reply.pst$29))) (let ((self35 reply$35)) (case (get self35 0) ('Parser.Reply.error (let ((f35 (get self35 1))) (let ((self36 f29)) (case (get self36 0) ('Maybe.none ($Parser.Reply.error f35)) ('Maybe.some (let ((f36 (get self36 1))) ($Parser.Reply.error ($Parser.Error.combine f36 f35)))))))) ('Parser.Reply.value (let ((f35 (get self35 1))) (let ((f36 (get self35 2))) (let ((self37 f35)) (case (get self37 0) ('Parser.State.new (let ((f37 (get self37 1))) (let ((f38 (get self37 2))) (let ((f39 (get self37 3))) (let ((f40 (get self37 4))) (let ((f41 (get self37 5))) (let ((reply.pst$43 ($Parser.State.new ($Parser.Error.maybe_combine f29 f37) f38 f39 f40 f41))) (let ((self43 reply.pst$43)) (case (get self43 0) ('Parser.State.new (let ((f43 (get self43 1))) (let ((f44 (get self43 2))) (let ((f45 (get self43 3))) (let ((f46 (get self43 4))) (let ((f47 (get self43 5))) (let ((reply$49 ($Parser.maybe (Kind.Parser.text ";") reply.pst$43))) (let ((self49 reply$49)) (case (get self49 0) ('Parser.Reply.error (let ((f49 (get self49 1))) (let ((self50 f43)) (case (get self50 0) ('Maybe.none ($Parser.Reply.error f49)) ('Maybe.some (let ((f50 (get self50 1))) ($Parser.Reply.error ($Parser.Error.combine f50 f49)))))))) ('Parser.Reply.value (let ((f49 (get self49 1))) (let ((f50 (get self49 2))) (let ((self51 f49)) (case (get self51 0) ('Parser.State.new (let ((f51 (get self51 1))) (let ((f52 (get self51 2))) (let ((f53 (get self51 3))) (let ((f54 (get self51 4))) (let ((f55 (get self51 5))) (let ((reply.pst$57 ($Parser.State.new ($Parser.Error.maybe_combine f43 f51) f52 f53 f54 f55))) (let ((name$58 (let ((self57 f36)) (case (get self57 0) ('Maybe.none (let ((self57 ($Kind.Term.reduce f22 Kind.Map.new))) (case (get self57 0) ('Kind.Term.var (let ((f57 (get self57 1))) (let ((f58 (get self57 2))) f57))) ('Kind.Term.ref (let ((f57 (get self57 1))) f57)) ('Kind.Term.typ ($Kind.Name.read "self")) ('Kind.Term.all (let ((f57 (get self57 1))) (let ((f58 (get self57 2))) (let ((f59 (get self57 3))) (let ((f60 (get self57 4))) (let ((f61 (get self57 5))) ($Kind.Name.read "self"))))))) ('Kind.Term.lam (let ((f57 (get self57 1))) (let ((f58 (get self57 2))) ($Kind.Name.read "self")))) ('Kind.Term.app (let ((f57 (get self57 1))) (let ((f58 (get self57 2))) ($Kind.Name.read "self")))) ('Kind.Term.let (let ((f57 (get self57 1))) (let ((f58 (get self57 2))) (let ((f59 (get self57 3))) ($Kind.Name.read "self"))))) ('Kind.Term.def (let ((f57 (get self57 1))) (let ((f58 (get self57 2))) (let ((f59 (get self57 3))) ($Kind.Name.read "self"))))) ('Kind.Term.ann (let ((f57 (get self57 1))) (let ((f58 (get self57 2))) (let ((f59 (get self57 3))) ($Kind.Name.read "self"))))) ('Kind.Term.gol (let ((f57 (get self57 1))) (let ((f58 (get self57 2))) (let ((f59 (get self57 3))) ($Kind.Name.read "self"))))) ('Kind.Term.hol (let ((f57 (get self57 1))) ($Kind.Name.read "self"))) ('Kind.Term.nat (let ((f57 (get self57 1))) ($Kind.Name.read "self"))) ('Kind.Term.chr (let ((f57 (get self57 1))) ($Kind.Name.read "self"))) ('Kind.Term.str (let ((f57 (get self57 1))) ($Kind.Name.read "self"))) ('Kind.Term.num (let ((f57 (get self57 1))) (let ((f58 (get self57 2))) (let ((f59 (get self57 3))) ($Kind.Name.read "self"))))) ('Kind.Term.cse (let ((f57 (get self57 1))) (let ((f58 (get self57 2))) (let ((f59 (get self57 3))) (let ((f60 (get self57 4))) (let ((f61 (get self57 5))) (let ((f62 (get self57 6))) ($Kind.Name.read "self")))))))) ('Kind.Term.new (let ((f57 (get self57 1))) ($Kind.Name.read "self"))) ('Kind.Term.get (let ((f57 (get self57 1))) (let ((f58 (get self57 2))) ($Kind.Name.read "self")))) ('Kind.Term.set (let ((f57 (get self57 1))) (let ((f58 (get self57 2))) (let ((f59 (get self57 3))) ($Kind.Name.read "self"))))) ('Kind.Term.ope (let ((f57 (get self57 1))) (let ((f58 (get self57 2))) (let ((f59 (get self57 3))) ($Kind.Name.read "self"))))) ('Kind.Term.ori (let ((f57 (get self57 1))) (let ((f58 (get self57 2))) ($Kind.Name.read "self"))))))) ('Maybe.some (let ((f57 (get self57 1))) f57)))))) (let ((wyth$59 List.nil)) (let ((self59 reply.pst$57)) (case (get self59 0) ('Parser.State.new (let ((f59 (get self59 1))) (let ((f60 (get self59 2))) (let ((f61 (get self59 3))) (let ((f62 (get self59 4))) (let ((f63 (get self59 5))) (let ((reply$65 ((body$0 Unit.new) reply.pst$57))) (let ((self65 reply$65)) (case (get self65 0) ('Parser.Reply.error (let ((f65 (get self65 1))) (let ((self66 f59)) (case (get self66 0) ('Maybe.none ($Parser.Reply.error f65)) ('Maybe.some (let ((f66 (get self66 1))) ($Parser.Reply.error ($Parser.Error.combine f66 f65)))))))) ('Parser.Reply.value (let ((f65 (get self65 1))) (let ((f66 (get self65 2))) (let ((self67 f65)) (case (get self67 0) ('Parser.State.new (let ((f67 (get self67 1))) (let ((f68 (get self67 2))) (let ((f69 (get self67 3))) (let ((f70 (get self67 4))) (let ((f71 (get self67 5))) (let ((reply.pst$73 ($Parser.State.new ($Parser.Error.maybe_combine f59 f67) f68 f69 f70 f71))) (let ((cses$74 ($Kind.Map.set "_" f66 Kind.Map.new))) (let ((moti$75 ($Maybe.some ($Kind.Term.hol Bits.e)))) ($Parser.Reply.value reply.pst$73 ($Kind.Term.cse Bits.e f22 name$58 wyth$59 cses$74 moti$75))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.open (lambda (body$0) ($Kind.Parser.open body$0)))
(define ($Kind.Parser.do.statements monad_name$0) (Parser.choice ($List.cons ((Kind.Parser.block "do-get") (lambda (pst$1) (let ((self1 pst$1)) (case (get self1 0) ('Parser.State.new (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((reply$7 ($Parser.choice ($List.cons (Kind.Parser.text "var ") ($List.cons (Kind.Parser.text "get ") List.nil)) pst$1))) (let ((self7 reply$7)) (case (get self7 0) ('Parser.Reply.error (let ((f7 (get self7 1))) (let ((self8 f1)) (case (get self8 0) ('Maybe.none ($Parser.Reply.error f7)) ('Maybe.some (let ((f8 (get self8 1))) ($Parser.Reply.error ($Parser.Error.combine f8 f7)))))))) ('Parser.Reply.value (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((self9 f7)) (case (get self9 0) ('Parser.State.new (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) (let ((reply.pst$15 ($Parser.State.new ($Parser.Error.maybe_combine f1 f9) f10 f11 f12 f13))) (let ((self15 reply.pst$15)) (case (get self15 0) ('Parser.State.new (let ((f15 (get self15 1))) (let ((f16 (get self15 2))) (let ((f17 (get self15 3))) (let ((f18 (get self15 4))) (let ((f19 (get self15 5))) (let ((reply$21 ($Kind.Parser.name1 reply.pst$15))) (let ((self21 reply$21)) (case (get self21 0) ('Parser.Reply.error (let ((f21 (get self21 1))) (let ((self22 f15)) (case (get self22 0) ('Maybe.none ($Parser.Reply.error f21)) ('Maybe.some (let ((f22 (get self22 1))) ($Parser.Reply.error ($Parser.Error.combine f22 f21)))))))) ('Parser.Reply.value (let ((f21 (get self21 1))) (let ((f22 (get self21 2))) (let ((self23 f21)) (case (get self23 0) ('Parser.State.new (let ((f23 (get self23 1))) (let ((f24 (get self23 2))) (let ((f25 (get self23 3))) (let ((f26 (get self23 4))) (let ((f27 (get self23 5))) (let ((reply.pst$29 ($Parser.State.new ($Parser.Error.maybe_combine f15 f23) f24 f25 f26 f27))) (let ((self29 reply.pst$29)) (case (get self29 0) ('Parser.State.new (let ((f29 (get self29 1))) (let ((f30 (get self29 2))) (let ((f31 (get self29 3))) (let ((f32 (get self29 4))) (let ((f33 (get self29 5))) (let ((reply$35 ($Kind.Parser.text "=" reply.pst$29))) (let ((self35 reply$35)) (case (get self35 0) ('Parser.Reply.error (let ((f35 (get self35 1))) (let ((self36 f29)) (case (get self36 0) ('Maybe.none ($Parser.Reply.error f35)) ('Maybe.some (let ((f36 (get self36 1))) ($Parser.Reply.error ($Parser.Error.combine f36 f35)))))))) ('Parser.Reply.value (let ((f35 (get self35 1))) (let ((f36 (get self35 2))) (let ((self37 f35)) (case (get self37 0) ('Parser.State.new (let ((f37 (get self37 1))) (let ((f38 (get self37 2))) (let ((f39 (get self37 3))) (let ((f40 (get self37 4))) (let ((f41 (get self37 5))) (let ((reply.pst$43 ($Parser.State.new ($Parser.Error.maybe_combine f29 f37) f38 f39 f40 f41))) (let ((self43 reply.pst$43)) (case (get self43 0) ('Parser.State.new (let ((f43 (get self43 1))) (let ((f44 (get self43 2))) (let ((f45 (get self43 3))) (let ((f46 (get self43 4))) (let ((f47 (get self43 5))) (let ((reply$49 (Kind.Parser.term reply.pst$43))) (let ((self49 reply$49)) (case (get self49 0) ('Parser.Reply.error (let ((f49 (get self49 1))) (let ((self50 f43)) (case (get self50 0) ('Maybe.none ($Parser.Reply.error f49)) ('Maybe.some (let ((f50 (get self50 1))) ($Parser.Reply.error ($Parser.Error.combine f50 f49)))))))) ('Parser.Reply.value (let ((f49 (get self49 1))) (let ((f50 (get self49 2))) (let ((self51 f49)) (case (get self51 0) ('Parser.State.new (let ((f51 (get self51 1))) (let ((f52 (get self51 2))) (let ((f53 (get self51 3))) (let ((f54 (get self51 4))) (let ((f55 (get self51 5))) (let ((reply.pst$57 ($Parser.State.new ($Parser.Error.maybe_combine f43 f51) f52 f53 f54 f55))) (let ((self57 reply.pst$57)) (case (get self57 0) ('Parser.State.new (let ((f57 (get self57 1))) (let ((f58 (get self57 2))) (let ((f59 (get self57 3))) (let ((f60 (get self57 4))) (let ((f61 (get self57 5))) (let ((reply$63 ($Parser.maybe (Kind.Parser.text ";") reply.pst$57))) (let ((self63 reply$63)) (case (get self63 0) ('Parser.Reply.error (let ((f63 (get self63 1))) (let ((self64 f57)) (case (get self64 0) ('Maybe.none ($Parser.Reply.error f63)) ('Maybe.some (let ((f64 (get self64 1))) ($Parser.Reply.error ($Parser.Error.combine f64 f63)))))))) ('Parser.Reply.value (let ((f63 (get self63 1))) (let ((f64 (get self63 2))) (let ((self65 f63)) (case (get self65 0) ('Parser.State.new (let ((f65 (get self65 1))) (let ((f66 (get self65 2))) (let ((f67 (get self65 3))) (let ((f68 (get self65 4))) (let ((f69 (get self65 5))) (let ((reply.pst$71 ($Parser.State.new ($Parser.Error.maybe_combine f57 f65) f66 f67 f68 f69))) (let ((self71 reply.pst$71)) (case (get self71 0) ('Parser.State.new (let ((f71 (get self71 1))) (let ((f72 (get self71 2))) (let ((f73 (get self71 3))) (let ((f74 (get self71 4))) (let ((f75 (get self71 5))) (let ((reply$77 (($Kind.Parser.do.statements monad_name$0) reply.pst$71))) (let ((self77 reply$77)) (case (get self77 0) ('Parser.Reply.error (let ((f77 (get self77 1))) (let ((self78 f71)) (case (get self78 0) ('Maybe.none ($Parser.Reply.error f77)) ('Maybe.some (let ((f78 (get self78 1))) ($Parser.Reply.error ($Parser.Error.combine f78 f77)))))))) ('Parser.Reply.value (let ((f77 (get self77 1))) (let ((f78 (get self77 2))) (let ((self79 f77)) (case (get self79 0) ('Parser.State.new (let ((f79 (get self79 1))) (let ((f80 (get self79 2))) (let ((f81 (get self79 3))) (let ((f82 (get self79 4))) (let ((f83 (get self79 5))) (let ((reply.pst$85 ($Parser.State.new ($Parser.Error.maybe_combine f71 f79) f80 f81 f82 f83))) (let ((term$86 ($Kind.Term.app ($Kind.Term.ref "Monad.bind") ($Kind.Term.ref monad_name$0)))) (let ((term$87 ($Kind.Term.app term$86 ($Kind.Term.ref ($String.concat monad_name$0 ".monad"))))) (let ((term$88 ($Kind.Term.app term$87 ($Kind.Term.hol Bits.e)))) (let ((term$89 ($Kind.Term.app term$88 ($Kind.Term.hol Bits.e)))) (let ((term$90 ($Kind.Term.app term$89 f50))) (let ((term$91 ($Kind.Term.app term$90 ($Kind.Term.lam f22 (lambda (x$91) f78))))) ($Parser.Reply.value reply.pst$85 term$91))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) ($List.cons ((Kind.Parser.block "do-return") (lambda (pst$1) (let ((self1 pst$1)) (case (get self1 0) ('Parser.State.new (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((reply$7 ($Kind.Parser.text "return " pst$1))) (let ((self7 reply$7)) (case (get self7 0) ('Parser.Reply.error (let ((f7 (get self7 1))) (let ((self8 f1)) (case (get self8 0) ('Maybe.none ($Parser.Reply.error f7)) ('Maybe.some (let ((f8 (get self8 1))) ($Parser.Reply.error ($Parser.Error.combine f8 f7)))))))) ('Parser.Reply.value (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((self9 f7)) (case (get self9 0) ('Parser.State.new (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) (let ((reply.pst$15 ($Parser.State.new ($Parser.Error.maybe_combine f1 f9) f10 f11 f12 f13))) (let ((self15 reply.pst$15)) (case (get self15 0) ('Parser.State.new (let ((f15 (get self15 1))) (let ((f16 (get self15 2))) (let ((f17 (get self15 3))) (let ((f18 (get self15 4))) (let ((f19 (get self15 5))) (let ((reply$21 (Kind.Parser.term reply.pst$15))) (let ((self21 reply$21)) (case (get self21 0) ('Parser.Reply.error (let ((f21 (get self21 1))) (let ((self22 f15)) (case (get self22 0) ('Maybe.none ($Parser.Reply.error f21)) ('Maybe.some (let ((f22 (get self22 1))) ($Parser.Reply.error ($Parser.Error.combine f22 f21)))))))) ('Parser.Reply.value (let ((f21 (get self21 1))) (let ((f22 (get self21 2))) (let ((self23 f21)) (case (get self23 0) ('Parser.State.new (let ((f23 (get self23 1))) (let ((f24 (get self23 2))) (let ((f25 (get self23 3))) (let ((f26 (get self23 4))) (let ((f27 (get self23 5))) (let ((reply.pst$29 ($Parser.State.new ($Parser.Error.maybe_combine f15 f23) f24 f25 f26 f27))) (let ((self29 reply.pst$29)) (case (get self29 0) ('Parser.State.new (let ((f29 (get self29 1))) (let ((f30 (get self29 2))) (let ((f31 (get self29 3))) (let ((f32 (get self29 4))) (let ((f33 (get self29 5))) (let ((reply$35 ($Parser.maybe (Kind.Parser.text ";") reply.pst$29))) (let ((self35 reply$35)) (case (get self35 0) ('Parser.Reply.error (let ((f35 (get self35 1))) (let ((self36 f29)) (case (get self36 0) ('Maybe.none ($Parser.Reply.error f35)) ('Maybe.some (let ((f36 (get self36 1))) ($Parser.Reply.error ($Parser.Error.combine f36 f35)))))))) ('Parser.Reply.value (let ((f35 (get self35 1))) (let ((f36 (get self35 2))) (let ((self37 f35)) (case (get self37 0) ('Parser.State.new (let ((f37 (get self37 1))) (let ((f38 (get self37 2))) (let ((f39 (get self37 3))) (let ((f40 (get self37 4))) (let ((f41 (get self37 5))) (let ((reply.pst$43 ($Parser.State.new ($Parser.Error.maybe_combine f29 f37) f38 f39 f40 f41))) (let ((term$44 ($Kind.Term.app ($Kind.Term.ref "Monad.pure") ($Kind.Term.ref monad_name$0)))) (let ((term$45 ($Kind.Term.app term$44 ($Kind.Term.ref ($String.concat monad_name$0 ".monad"))))) (let ((term$46 ($Kind.Term.app term$45 ($Kind.Term.hol Bits.e)))) (let ((term$47 ($Kind.Term.app term$46 f22))) ($Parser.Reply.value reply.pst$43 term$47)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) ($List.cons ((Kind.Parser.block "do-for") (lambda (pst$1) (let ((self1 pst$1)) (case (get self1 0) ('Parser.State.new (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((reply$7 ($Kind.Parser.text "for " pst$1))) (let ((self7 reply$7)) (case (get self7 0) ('Parser.Reply.error (let ((f7 (get self7 1))) (let ((self8 f1)) (case (get self8 0) ('Maybe.none ($Parser.Reply.error f7)) ('Maybe.some (let ((f8 (get self8 1))) ($Parser.Reply.error ($Parser.Error.combine f8 f7)))))))) ('Parser.Reply.value (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((self9 f7)) (case (get self9 0) ('Parser.State.new (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) (let ((reply.pst$15 ($Parser.State.new ($Parser.Error.maybe_combine f1 f9) f10 f11 f12 f13))) (let ((self15 reply.pst$15)) (case (get self15 0) ('Parser.State.new (let ((f15 (get self15 1))) (let ((f16 (get self15 2))) (let ((f17 (get self15 3))) (let ((f18 (get self15 4))) (let ((f19 (get self15 5))) (let ((reply$21 ($Kind.Parser.name1 reply.pst$15))) (let ((self21 reply$21)) (case (get self21 0) ('Parser.Reply.error (let ((f21 (get self21 1))) (let ((self22 f15)) (case (get self22 0) ('Maybe.none ($Parser.Reply.error f21)) ('Maybe.some (let ((f22 (get self22 1))) ($Parser.Reply.error ($Parser.Error.combine f22 f21)))))))) ('Parser.Reply.value (let ((f21 (get self21 1))) (let ((f22 (get self21 2))) (let ((self23 f21)) (case (get self23 0) ('Parser.State.new (let ((f23 (get self23 1))) (let ((f24 (get self23 2))) (let ((f25 (get self23 3))) (let ((f26 (get self23 4))) (let ((f27 (get self23 5))) (let ((reply.pst$29 ($Parser.State.new ($Parser.Error.maybe_combine f15 f23) f24 f25 f26 f27))) (let ((self29 reply.pst$29)) (case (get self29 0) ('Parser.State.new (let ((f29 (get self29 1))) (let ((f30 (get self29 2))) (let ((f31 (get self29 3))) (let ((f32 (get self29 4))) (let ((f33 (get self29 5))) (let ((reply$35 ($Kind.Parser.text "from" reply.pst$29))) (let ((self35 reply$35)) (case (get self35 0) ('Parser.Reply.error (let ((f35 (get self35 1))) (let ((self36 f29)) (case (get self36 0) ('Maybe.none ($Parser.Reply.error f35)) ('Maybe.some (let ((f36 (get self36 1))) ($Parser.Reply.error ($Parser.Error.combine f36 f35)))))))) ('Parser.Reply.value (let ((f35 (get self35 1))) (let ((f36 (get self35 2))) (let ((self37 f35)) (case (get self37 0) ('Parser.State.new (let ((f37 (get self37 1))) (let ((f38 (get self37 2))) (let ((f39 (get self37 3))) (let ((f40 (get self37 4))) (let ((f41 (get self37 5))) (let ((reply.pst$43 ($Parser.State.new ($Parser.Error.maybe_combine f29 f37) f38 f39 f40 f41))) (let ((self43 reply.pst$43)) (case (get self43 0) ('Parser.State.new (let ((f43 (get self43 1))) (let ((f44 (get self43 2))) (let ((f45 (get self43 3))) (let ((f46 (get self43 4))) (let ((f47 (get self43 5))) (let ((reply$49 (Kind.Parser.term reply.pst$43))) (let ((self49 reply$49)) (case (get self49 0) ('Parser.Reply.error (let ((f49 (get self49 1))) (let ((self50 f43)) (case (get self50 0) ('Maybe.none ($Parser.Reply.error f49)) ('Maybe.some (let ((f50 (get self50 1))) ($Parser.Reply.error ($Parser.Error.combine f50 f49)))))))) ('Parser.Reply.value (let ((f49 (get self49 1))) (let ((f50 (get self49 2))) (let ((self51 f49)) (case (get self51 0) ('Parser.State.new (let ((f51 (get self51 1))) (let ((f52 (get self51 2))) (let ((f53 (get self51 3))) (let ((f54 (get self51 4))) (let ((f55 (get self51 5))) (let ((reply.pst$57 ($Parser.State.new ($Parser.Error.maybe_combine f43 f51) f52 f53 f54 f55))) (let ((self57 reply.pst$57)) (case (get self57 0) ('Parser.State.new (let ((f57 (get self57 1))) (let ((f58 (get self57 2))) (let ((f59 (get self57 3))) (let ((f60 (get self57 4))) (let ((f61 (get self57 5))) (let ((reply$63 ($Kind.Parser.text "to" reply.pst$57))) (let ((self63 reply$63)) (case (get self63 0) ('Parser.Reply.error (let ((f63 (get self63 1))) (let ((self64 f57)) (case (get self64 0) ('Maybe.none ($Parser.Reply.error f63)) ('Maybe.some (let ((f64 (get self64 1))) ($Parser.Reply.error ($Parser.Error.combine f64 f63)))))))) ('Parser.Reply.value (let ((f63 (get self63 1))) (let ((f64 (get self63 2))) (let ((self65 f63)) (case (get self65 0) ('Parser.State.new (let ((f65 (get self65 1))) (let ((f66 (get self65 2))) (let ((f67 (get self65 3))) (let ((f68 (get self65 4))) (let ((f69 (get self65 5))) (let ((reply.pst$71 ($Parser.State.new ($Parser.Error.maybe_combine f57 f65) f66 f67 f68 f69))) (let ((self71 reply.pst$71)) (case (get self71 0) ('Parser.State.new (let ((f71 (get self71 1))) (let ((f72 (get self71 2))) (let ((f73 (get self71 3))) (let ((f74 (get self71 4))) (let ((f75 (get self71 5))) (let ((reply$77 (Kind.Parser.term reply.pst$71))) (let ((self77 reply$77)) (case (get self77 0) ('Parser.Reply.error (let ((f77 (get self77 1))) (let ((self78 f71)) (case (get self78 0) ('Maybe.none ($Parser.Reply.error f77)) ('Maybe.some (let ((f78 (get self78 1))) ($Parser.Reply.error ($Parser.Error.combine f78 f77)))))))) ('Parser.Reply.value (let ((f77 (get self77 1))) (let ((f78 (get self77 2))) (let ((self79 f77)) (case (get self79 0) ('Parser.State.new (let ((f79 (get self79 1))) (let ((f80 (get self79 2))) (let ((f81 (get self79 3))) (let ((f82 (get self79 4))) (let ((f83 (get self79 5))) (let ((reply.pst$85 ($Parser.State.new ($Parser.Error.maybe_combine f71 f79) f80 f81 f82 f83))) (let ((self85 reply.pst$85)) (case (get self85 0) ('Parser.State.new (let ((f85 (get self85 1))) (let ((f86 (get self85 2))) (let ((f87 (get self85 3))) (let ((f88 (get self85 4))) (let ((f89 (get self85 5))) (let ((reply$91 ($Kind.Parser.text ":" reply.pst$85))) (let ((self91 reply$91)) (case (get self91 0) ('Parser.Reply.error (let ((f91 (get self91 1))) (let ((self92 f85)) (case (get self92 0) ('Maybe.none ($Parser.Reply.error f91)) ('Maybe.some (let ((f92 (get self92 1))) ($Parser.Reply.error ($Parser.Error.combine f92 f91)))))))) ('Parser.Reply.value (let ((f91 (get self91 1))) (let ((f92 (get self91 2))) (let ((self93 f91)) (case (get self93 0) ('Parser.State.new (let ((f93 (get self93 1))) (let ((f94 (get self93 2))) (let ((f95 (get self93 3))) (let ((f96 (get self93 4))) (let ((f97 (get self93 5))) (let ((reply.pst$99 ($Parser.State.new ($Parser.Error.maybe_combine f85 f93) f94 f95 f96 f97))) (let ((self99 reply.pst$99)) (case (get self99 0) ('Parser.State.new (let ((f99 (get self99 1))) (let ((f100 (get self99 2))) (let ((f101 (get self99 3))) (let ((f102 (get self99 4))) (let ((f103 (get self99 5))) (let ((reply$105 (Kind.Parser.term reply.pst$99))) (let ((self105 reply$105)) (case (get self105 0) ('Parser.Reply.error (let ((f105 (get self105 1))) (let ((self106 f99)) (case (get self106 0) ('Maybe.none ($Parser.Reply.error f105)) ('Maybe.some (let ((f106 (get self106 1))) ($Parser.Reply.error ($Parser.Error.combine f106 f105)))))))) ('Parser.Reply.value (let ((f105 (get self105 1))) (let ((f106 (get self105 2))) (let ((self107 f105)) (case (get self107 0) ('Parser.State.new (let ((f107 (get self107 1))) (let ((f108 (get self107 2))) (let ((f109 (get self107 3))) (let ((f110 (get self107 4))) (let ((f111 (get self107 5))) (let ((reply.pst$113 ($Parser.State.new ($Parser.Error.maybe_combine f99 f107) f108 f109 f110 f111))) (let ((self113 reply.pst$113)) (case (get self113 0) ('Parser.State.new (let ((f113 (get self113 1))) (let ((f114 (get self113 2))) (let ((f115 (get self113 3))) (let ((f116 (get self113 4))) (let ((f117 (get self113 5))) (let ((reply$119 ($Parser.maybe ($Kind.Parser.do.statements monad_name$0) reply.pst$113))) (let ((self119 reply$119)) (case (get self119 0) ('Parser.Reply.error (let ((f119 (get self119 1))) (let ((self120 f113)) (case (get self120 0) ('Maybe.none ($Parser.Reply.error f119)) ('Maybe.some (let ((f120 (get self120 1))) ($Parser.Reply.error ($Parser.Error.combine f120 f119)))))))) ('Parser.Reply.value (let ((f119 (get self119 1))) (let ((f120 (get self119 2))) (let ((self121 f119)) (case (get self121 0) ('Parser.State.new (let ((f121 (get self121 1))) (let ((f122 (get self121 2))) (let ((f123 (get self121 3))) (let ((f124 (get self121 4))) (let ((f125 (get self121 5))) (let ((reply.pst$127 ($Parser.State.new ($Parser.Error.maybe_combine f113 f121) f122 f123 f124 f125))) (let ((expr$128 ($Kind.Term.ref "Nat.for.io"))) (let ((expr$129 ($Kind.Term.app expr$128 f50))) (let ((expr$130 ($Kind.Term.app expr$129 f78))) (let ((expr$131 ($Kind.Term.app expr$130 ($Kind.Term.lam f22 (lambda (x$131) f106))))) ((let ((self131 f120)) (case (get self131 0) ('Maybe.none (lambda (pst$132) ($Parser.Reply.value pst$132 expr$131))) ('Maybe.some (let ((f131 (get self131 1))) (let ((term$133 ($Kind.Term.app ($Kind.Term.ref "Monad.bind") ($Kind.Term.ref monad_name$0)))) (let ((term$134 ($Kind.Term.app term$133 ($Kind.Term.ref ($String.concat monad_name$0 ".monad"))))) (let ((term$135 ($Kind.Term.app term$134 ($Kind.Term.hol Bits.e)))) (let ((term$136 ($Kind.Term.app term$135 ($Kind.Term.hol Bits.e)))) (let ((term$137 ($Kind.Term.app term$136 expr$131))) (let ((term$138 ($Kind.Term.app term$137 ($Kind.Term.lam "" (lambda (x$138) f131))))) (lambda (pst$139) ($Parser.Reply.value pst$139 term$138)))))))))))) reply.pst$127)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) ($List.cons ($Kind.Parser.letforrange.u32 (lambda (x$1) ($Kind.Parser.do.statements monad_name$0))) ($List.cons ($Kind.Parser.letforrange.u32.with (lambda (x$1) ($Kind.Parser.do.statements monad_name$0))) ($List.cons ($Kind.Parser.letforrange.nat (lambda (x$1) ($Kind.Parser.do.statements monad_name$0))) ($List.cons ($Kind.Parser.letforrange.nat.with (lambda (x$1) ($Kind.Parser.do.statements monad_name$0))) ($List.cons ($Kind.Parser.letforin (lambda (x$1) ($Kind.Parser.do.statements monad_name$0))) ($List.cons ($Kind.Parser.letforin.with (lambda (x$1) ($Kind.Parser.do.statements monad_name$0))) ($List.cons ($Kind.Parser.letwhile (lambda (x$1) ($Kind.Parser.do.statements monad_name$0))) ($List.cons ($Kind.Parser.letwhile.with (lambda (x$1) ($Kind.Parser.do.statements monad_name$0))) ($List.cons ($Kind.Parser.let.abort (lambda (x$1) ($Kind.Parser.do.statements monad_name$0))) ($List.cons ($Kind.Parser.let (lambda (x$1) ($Kind.Parser.do.statements monad_name$0))) ($List.cons ($Kind.Parser.getwhile (lambda (x$1) ($Kind.Parser.do.statements monad_name$0))) ($List.cons (Kind.Parser.getwhile.with (lambda (x$1) ($Kind.Parser.do.statements monad_name$0))) ($List.cons ($Kind.Parser.get (lambda (x$1) ($Kind.Parser.do.statements monad_name$0))) ($List.cons ($Kind.Parser.def (lambda (x$1) ($Kind.Parser.do.statements monad_name$0))) ($List.cons ($Kind.Parser.use.abort (lambda (x$1) ($Kind.Parser.do.statements monad_name$0))) ($List.cons ($Kind.Parser.use (lambda (x$1) ($Kind.Parser.do.statements monad_name$0))) ($List.cons ($Kind.Parser.log (lambda (x$1) ($Kind.Parser.do.statements monad_name$0))) ($List.cons ($Kind.Parser.open (lambda (x$1) ($Kind.Parser.do.statements monad_name$0))) ($List.cons ((Kind.Parser.block "do-statement") (lambda (pst$1) (let ((self1 pst$1)) (case (get self1 0) ('Parser.State.new (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((reply$7 (Kind.Parser.term pst$1))) (let ((self7 reply$7)) (case (get self7 0) ('Parser.Reply.error (let ((f7 (get self7 1))) (let ((self8 f1)) (case (get self8 0) ('Maybe.none ($Parser.Reply.error f7)) ('Maybe.some (let ((f8 (get self8 1))) ($Parser.Reply.error ($Parser.Error.combine f8 f7)))))))) ('Parser.Reply.value (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((self9 f7)) (case (get self9 0) ('Parser.State.new (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) (let ((reply.pst$15 ($Parser.State.new ($Parser.Error.maybe_combine f1 f9) f10 f11 f12 f13))) (let ((self15 reply.pst$15)) (case (get self15 0) ('Parser.State.new (let ((f15 (get self15 1))) (let ((f16 (get self15 2))) (let ((f17 (get self15 3))) (let ((f18 (get self15 4))) (let ((f19 (get self15 5))) (let ((reply$21 ($Parser.maybe (Kind.Parser.text ";") reply.pst$15))) (let ((self21 reply$21)) (case (get self21 0) ('Parser.Reply.error (let ((f21 (get self21 1))) (let ((self22 f15)) (case (get self22 0) ('Maybe.none ($Parser.Reply.error f21)) ('Maybe.some (let ((f22 (get self22 1))) ($Parser.Reply.error ($Parser.Error.combine f22 f21)))))))) ('Parser.Reply.value (let ((f21 (get self21 1))) (let ((f22 (get self21 2))) (let ((self23 f21)) (case (get self23 0) ('Parser.State.new (let ((f23 (get self23 1))) (let ((f24 (get self23 2))) (let ((f25 (get self23 3))) (let ((f26 (get self23 4))) (let ((f27 (get self23 5))) (let ((reply.pst$29 ($Parser.State.new ($Parser.Error.maybe_combine f15 f23) f24 f25 f26 f27))) (let ((self29 reply.pst$29)) (case (get self29 0) ('Parser.State.new (let ((f29 (get self29 1))) (let ((f30 (get self29 2))) (let ((f31 (get self29 3))) (let ((f32 (get self29 4))) (let ((f33 (get self29 5))) (let ((reply$35 (($Kind.Parser.do.statements monad_name$0) reply.pst$29))) (let ((self35 reply$35)) (case (get self35 0) ('Parser.Reply.error (let ((f35 (get self35 1))) (let ((self36 f29)) (case (get self36 0) ('Maybe.none ($Parser.Reply.error f35)) ('Maybe.some (let ((f36 (get self36 1))) ($Parser.Reply.error ($Parser.Error.combine f36 f35)))))))) ('Parser.Reply.value (let ((f35 (get self35 1))) (let ((f36 (get self35 2))) (let ((self37 f35)) (case (get self37 0) ('Parser.State.new (let ((f37 (get self37 1))) (let ((f38 (get self37 2))) (let ((f39 (get self37 3))) (let ((f40 (get self37 4))) (let ((f41 (get self37 5))) (let ((reply.pst$43 ($Parser.State.new ($Parser.Error.maybe_combine f29 f37) f38 f39 f40 f41))) (let ((term$44 ($Kind.Term.app ($Kind.Term.ref "Monad.bind") ($Kind.Term.ref monad_name$0)))) (let ((term$45 ($Kind.Term.app term$44 ($Kind.Term.ref ($String.concat monad_name$0 ".monad"))))) (let ((term$46 ($Kind.Term.app term$45 ($Kind.Term.hol Bits.e)))) (let ((term$47 ($Kind.Term.app term$46 ($Kind.Term.hol Bits.e)))) (let ((term$48 ($Kind.Term.app term$47 f8))) (let ((term$49 ($Kind.Term.app term$48 ($Kind.Term.lam "" (lambda (x$49) f36))))) ($Parser.Reply.value reply.pst$43 term$49)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) ($List.cons ((Kind.Parser.block "do-end") (lambda (pst$1) (let ((self1 pst$1)) (case (get self1 0) ('Parser.State.new (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((reply$7 (Kind.Parser.term pst$1))) (let ((self7 reply$7)) (case (get self7 0) ('Parser.Reply.error (let ((f7 (get self7 1))) (let ((self8 f1)) (case (get self8 0) ('Maybe.none ($Parser.Reply.error f7)) ('Maybe.some (let ((f8 (get self8 1))) ($Parser.Reply.error ($Parser.Error.combine f8 f7)))))))) ('Parser.Reply.value (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((self9 f7)) (case (get self9 0) ('Parser.State.new (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) (let ((reply.pst$15 ($Parser.State.new ($Parser.Error.maybe_combine f1 f9) f10 f11 f12 f13))) (let ((self15 reply.pst$15)) (case (get self15 0) ('Parser.State.new (let ((f15 (get self15 1))) (let ((f16 (get self15 2))) (let ((f17 (get self15 3))) (let ((f18 (get self15 4))) (let ((f19 (get self15 5))) (let ((reply$21 ($Parser.maybe (Kind.Parser.text ";") reply.pst$15))) (let ((self21 reply$21)) (case (get self21 0) ('Parser.Reply.error (let ((f21 (get self21 1))) (let ((self22 f15)) (case (get self22 0) ('Maybe.none ($Parser.Reply.error f21)) ('Maybe.some (let ((f22 (get self22 1))) ($Parser.Reply.error ($Parser.Error.combine f22 f21)))))))) ('Parser.Reply.value (let ((f21 (get self21 1))) (let ((f22 (get self21 2))) (let ((self23 f21)) (case (get self23 0) ('Parser.State.new (let ((f23 (get self23 1))) (let ((f24 (get self23 2))) (let ((f25 (get self23 3))) (let ((f26 (get self23 4))) (let ((f27 (get self23 5))) (let ((reply.pst$29 ($Parser.State.new ($Parser.Error.maybe_combine f15 f23) f24 f25 f26 f27))) ($Parser.Reply.value reply.pst$29 f8))))))))))))))))))))))))))))))))))))))))))))))))) List.nil)))))))))))))))))))))))))
(define Kind.Parser.do.statements (lambda (monad_name$0) ($Kind.Parser.do.statements monad_name$0)))
(define Kind.Parser.do ((Kind.Parser.block "do") (lambda (pst$0) (let ((self1 pst$0)) (case (get self1 0) ('Parser.State.new (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((reply$6 ($Parser.maybe (Kind.Parser.text "do ") pst$0))) (let ((self7 reply$6)) (case (get self7 0) ('Parser.Reply.error (let ((f7 (get self7 1))) (let ((self8 f1)) (case (get self8 0) ('Maybe.none ($Parser.Reply.error f7)) ('Maybe.some (let ((f8 (get self8 1))) ($Parser.Reply.error ($Parser.Error.combine f8 f7)))))))) ('Parser.Reply.value (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((self9 f7)) (case (get self9 0) ('Parser.State.new (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) (let ((reply.pst$14 ($Parser.State.new ($Parser.Error.maybe_combine f1 f9) f10 f11 f12 f13))) (let ((self15 reply.pst$14)) (case (get self15 0) ('Parser.State.new (let ((f15 (get self15 1))) (let ((f16 (get self15 2))) (let ((f17 (get self15 3))) (let ((f18 (get self15 4))) (let ((f19 (get self15 5))) (let ((reply$20 ($Kind.Parser.name1 reply.pst$14))) (let ((self21 reply$20)) (case (get self21 0) ('Parser.Reply.error (let ((f21 (get self21 1))) (let ((self22 f15)) (case (get self22 0) ('Maybe.none ($Parser.Reply.error f21)) ('Maybe.some (let ((f22 (get self22 1))) ($Parser.Reply.error ($Parser.Error.combine f22 f21)))))))) ('Parser.Reply.value (let ((f21 (get self21 1))) (let ((f22 (get self21 2))) (let ((self23 f21)) (case (get self23 0) ('Parser.State.new (let ((f23 (get self23 1))) (let ((f24 (get self23 2))) (let ((f25 (get self23 3))) (let ((f26 (get self23 4))) (let ((f27 (get self23 5))) (let ((reply.pst$28 ($Parser.State.new ($Parser.Error.maybe_combine f15 f23) f24 f25 f26 f27))) ((let ((self29 ($String.is_upper ($String.slice 0 1 f22)))) (case self29 (#t (lambda (pst$29) (let ((self30 pst$29)) (case (get self30 0) ('Parser.State.new (let ((f30 (get self30 1))) (let ((f31 (get self30 2))) (let ((f32 (get self30 3))) (let ((f33 (get self30 4))) (let ((f34 (get self30 5))) (let ((reply$35 ($Parser.text " {" pst$29))) (let ((self36 reply$35)) (case (get self36 0) ('Parser.Reply.error (let ((f36 (get self36 1))) (let ((self37 f30)) (case (get self37 0) ('Maybe.none ($Parser.Reply.error f36)) ('Maybe.some (let ((f37 (get self37 1))) ($Parser.Reply.error ($Parser.Error.combine f37 f36)))))))) ('Parser.Reply.value (let ((f36 (get self36 1))) (let ((f37 (get self36 2))) (let ((self38 f36)) (case (get self38 0) ('Parser.State.new (let ((f38 (get self38 1))) (let ((f39 (get self38 2))) (let ((f40 (get self38 3))) (let ((f41 (get self38 4))) (let ((f42 (get self38 5))) (let ((reply.pst$43 ($Parser.State.new ($Parser.Error.maybe_combine f30 f38) f39 f40 f41 f42))) (let ((self44 reply.pst$43)) (case (get self44 0) ('Parser.State.new (let ((f44 (get self44 1))) (let ((f45 (get self44 2))) (let ((f46 (get self44 3))) (let ((f47 (get self44 4))) (let ((f48 (get self44 5))) (let ((reply$49 (($Kind.Parser.do.statements f22) reply.pst$43))) (let ((self50 reply$49)) (case (get self50 0) ('Parser.Reply.error (let ((f50 (get self50 1))) (let ((self51 f44)) (case (get self51 0) ('Maybe.none ($Parser.Reply.error f50)) ('Maybe.some (let ((f51 (get self51 1))) ($Parser.Reply.error ($Parser.Error.combine f51 f50)))))))) ('Parser.Reply.value (let ((f50 (get self50 1))) (let ((f51 (get self50 2))) (let ((self52 f50)) (case (get self52 0) ('Parser.State.new (let ((f52 (get self52 1))) (let ((f53 (get self52 2))) (let ((f54 (get self52 3))) (let ((f55 (get self52 4))) (let ((f56 (get self52 5))) (let ((reply.pst$57 ($Parser.State.new ($Parser.Error.maybe_combine f44 f52) f53 f54 f55 f56))) (let ((self58 reply.pst$57)) (case (get self58 0) ('Parser.State.new (let ((f58 (get self58 1))) (let ((f59 (get self58 2))) (let ((f60 (get self58 3))) (let ((f61 (get self58 4))) (let ((f62 (get self58 5))) (let ((reply$63 ($Kind.Parser.text "}" reply.pst$57))) (let ((self64 reply$63)) (case (get self64 0) ('Parser.Reply.error (let ((f64 (get self64 1))) (let ((self65 f58)) (case (get self65 0) ('Maybe.none ($Parser.Reply.error f64)) ('Maybe.some (let ((f65 (get self65 1))) ($Parser.Reply.error ($Parser.Error.combine f65 f64)))))))) ('Parser.Reply.value (let ((f64 (get self64 1))) (let ((f65 (get self64 2))) (let ((self66 f64)) (case (get self66 0) ('Parser.State.new (let ((f66 (get self66 1))) (let ((f67 (get self66 2))) (let ((f68 (get self66 3))) (let ((f69 (get self66 4))) (let ((f70 (get self66 5))) (let ((reply.pst$71 ($Parser.State.new ($Parser.Error.maybe_combine f58 f66) f67 f68 f69 f70))) ($Parser.Reply.value reply.pst$71 f51)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) (#f (Parser.fail "Not a do-block.")))) reply.pst$28))))))))))))))))))))))))))))))))))))))))))))))))))
(define ($Kind.Term.extract_name term$0) (let ((term$1 ($Kind.Term.reduce term$0 Kind.Map.new))) (let ((self1 term$1)) (case (get self1 0) ('Kind.Term.var (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) f1))) ('Kind.Term.ref (let ((f1 (get self1 1))) f1)) ('Kind.Term.typ "self") ('Kind.Term.all (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) "self")))))) ('Kind.Term.lam (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) "self"))) ('Kind.Term.app (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) "self"))) ('Kind.Term.let (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) "self")))) ('Kind.Term.def (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) "self")))) ('Kind.Term.ann (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) "self")))) ('Kind.Term.gol (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) "self")))) ('Kind.Term.hol (let ((f1 (get self1 1))) "self")) ('Kind.Term.nat (let ((f1 (get self1 1))) "self")) ('Kind.Term.chr (let ((f1 (get self1 1))) "self")) ('Kind.Term.str (let ((f1 (get self1 1))) "self")) ('Kind.Term.num (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) "self")))) ('Kind.Term.cse (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((f6 (get self1 6))) "self"))))))) ('Kind.Term.new (let ((f1 (get self1 1))) "self")) ('Kind.Term.get (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) "self"))) ('Kind.Term.set (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) "self")))) ('Kind.Term.ope (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) "self")))) ('Kind.Term.ori (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) "self")))))))
(define Kind.Term.extract_name (lambda (term$0) ($Kind.Term.extract_name term$0)))
(define ($Kind.Ann.new name$0 term$1 type$2) (vector 'Kind.Ann.new name$0 term$1 type$2))
(define Kind.Ann.new (lambda (name$0) (lambda (term$1) (lambda (type$2) ($Kind.Ann.new name$0 term$1 type$2)))))
(define Kind.Parser.case.with (Parser.choice ($List.cons (lambda (pst$0) (let ((self1 pst$0)) (case (get self1 0) ('Parser.State.new (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((reply$6 ($Kind.Parser.text "with " pst$0))) (let ((self7 reply$6)) (case (get self7 0) ('Parser.Reply.error (let ((f7 (get self7 1))) (let ((self8 f1)) (case (get self8 0) ('Maybe.none ($Parser.Reply.error f7)) ('Maybe.some (let ((f8 (get self8 1))) ($Parser.Reply.error ($Parser.Error.combine f8 f7)))))))) ('Parser.Reply.value (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((self9 f7)) (case (get self9 0) ('Parser.State.new (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) (let ((reply.pst$14 ($Parser.State.new ($Parser.Error.maybe_combine f1 f9) f10 f11 f12 f13))) (($Parser.many (lambda (pst$15) (let ((self16 pst$15)) (case (get self16 0) ('Parser.State.new (let ((f16 (get self16 1))) (let ((f17 (get self16 2))) (let ((f18 (get self16 3))) (let ((f19 (get self16 4))) (let ((f20 (get self16 5))) (let ((reply$21 ($Kind.Parser.name1 pst$15))) (let ((self22 reply$21)) (case (get self22 0) ('Parser.Reply.error (let ((f22 (get self22 1))) (let ((self23 f16)) (case (get self23 0) ('Maybe.none ($Parser.Reply.error f22)) ('Maybe.some (let ((f23 (get self23 1))) ($Parser.Reply.error ($Parser.Error.combine f23 f22)))))))) ('Parser.Reply.value (let ((f22 (get self22 1))) (let ((f23 (get self22 2))) (let ((self24 f22)) (case (get self24 0) ('Parser.State.new (let ((f24 (get self24 1))) (let ((f25 (get self24 2))) (let ((f26 (get self24 3))) (let ((f27 (get self24 4))) (let ((f28 (get self24 5))) (let ((reply.pst$29 ($Parser.State.new ($Parser.Error.maybe_combine f16 f24) f25 f26 f27 f28))) (let ((self30 reply.pst$29)) (case (get self30 0) ('Parser.State.new (let ((f30 (get self30 1))) (let ((f31 (get self30 2))) (let ((f32 (get self30 3))) (let ((f33 (get self30 4))) (let ((f34 (get self30 5))) (let ((reply$35 ($Parser.maybe (lambda (pst$35) (let ((self36 pst$35)) (case (get self36 0) ('Parser.State.new (let ((f36 (get self36 1))) (let ((f37 (get self36 2))) (let ((f38 (get self36 3))) (let ((f39 (get self36 4))) (let ((f40 (get self36 5))) (let ((reply$41 ($Kind.Parser.text ":" pst$35))) (let ((self42 reply$41)) (case (get self42 0) ('Parser.Reply.error (let ((f42 (get self42 1))) (let ((self43 f36)) (case (get self43 0) ('Maybe.none ($Parser.Reply.error f42)) ('Maybe.some (let ((f43 (get self43 1))) ($Parser.Reply.error ($Parser.Error.combine f43 f42)))))))) ('Parser.Reply.value (let ((f42 (get self42 1))) (let ((f43 (get self42 2))) (let ((self44 f42)) (case (get self44 0) ('Parser.State.new (let ((f44 (get self44 1))) (let ((f45 (get self44 2))) (let ((f46 (get self44 3))) (let ((f47 (get self44 4))) (let ((f48 (get self44 5))) (let ((reply.pst$49 ($Parser.State.new ($Parser.Error.maybe_combine f36 f44) f45 f46 f47 f48))) (let ((self50 reply.pst$49)) (case (get self50 0) ('Parser.State.new (let ((f50 (get self50 1))) (let ((f51 (get self50 2))) (let ((f52 (get self50 3))) (let ((f53 (get self50 4))) (let ((f54 (get self50 5))) (let ((reply$55 (Kind.Parser.term reply.pst$49))) (let ((self56 reply$55)) (case (get self56 0) ('Parser.Reply.error (let ((f56 (get self56 1))) (let ((self57 f50)) (case (get self57 0) ('Maybe.none ($Parser.Reply.error f56)) ('Maybe.some (let ((f57 (get self57 1))) ($Parser.Reply.error ($Parser.Error.combine f57 f56)))))))) ('Parser.Reply.value (let ((f56 (get self56 1))) (let ((f57 (get self56 2))) (let ((self58 f56)) (case (get self58 0) ('Parser.State.new (let ((f58 (get self58 1))) (let ((f59 (get self58 2))) (let ((f60 (get self58 3))) (let ((f61 (get self58 4))) (let ((f62 (get self58 5))) (let ((reply.pst$63 ($Parser.State.new ($Parser.Error.maybe_combine f50 f58) f59 f60 f61 f62))) (let ((self64 reply.pst$63)) (case (get self64 0) ('Parser.State.new (let ((f64 (get self64 1))) (let ((f65 (get self64 2))) (let ((f66 (get self64 3))) (let ((f67 (get self64 4))) (let ((f68 (get self64 5))) (let ((reply$69 ($Parser.maybe (Kind.Parser.text ";") reply.pst$63))) (let ((self70 reply$69)) (case (get self70 0) ('Parser.Reply.error (let ((f70 (get self70 1))) (let ((self71 f64)) (case (get self71 0) ('Maybe.none ($Parser.Reply.error f70)) ('Maybe.some (let ((f71 (get self71 1))) ($Parser.Reply.error ($Parser.Error.combine f71 f70)))))))) ('Parser.Reply.value (let ((f70 (get self70 1))) (let ((f71 (get self70 2))) (let ((self72 f70)) (case (get self72 0) ('Parser.State.new (let ((f72 (get self72 1))) (let ((f73 (get self72 2))) (let ((f74 (get self72 3))) (let ((f75 (get self72 4))) (let ((f76 (get self72 5))) (let ((reply.pst$77 ($Parser.State.new ($Parser.Error.maybe_combine f64 f72) f73 f74 f75 f76))) ($Parser.Reply.value reply.pst$77 f57))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) reply.pst$29))) (let ((self36 reply$35)) (case (get self36 0) ('Parser.Reply.error (let ((f36 (get self36 1))) (let ((self37 f30)) (case (get self37 0) ('Maybe.none ($Parser.Reply.error f36)) ('Maybe.some (let ((f37 (get self37 1))) ($Parser.Reply.error ($Parser.Error.combine f37 f36)))))))) ('Parser.Reply.value (let ((f36 (get self36 1))) (let ((f37 (get self36 2))) (let ((self38 f36)) (case (get self38 0) ('Parser.State.new (let ((f38 (get self38 1))) (let ((f39 (get self38 2))) (let ((f40 (get self38 3))) (let ((f41 (get self38 4))) (let ((f42 (get self38 5))) (let ((reply.pst$43 ($Parser.State.new ($Parser.Error.maybe_combine f30 f38) f39 f40 f41 f42))) ($Parser.Reply.value reply.pst$43 ($Kind.Ann.new f23 ($Kind.Term.ref f23) f37)))))))))))))))))))))))))))))))))))))))))))))))))) reply.pst$14))))))))))))))))))))))))) ($List.cons (lambda (pst$0) ($Parser.Reply.value pst$0 List.nil)) List.nil))))
(define ($Kind.Parser.case.case pst$0) (let ((self0 pst$0)) (case (get self0 0) ('Parser.State.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((reply$6 ($Parser.try (Kind.Parser.text ":") pst$0))) (let ((self6 reply$6)) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))) (let ((self7 f0)) (case (get self7 0) ('Maybe.none ($Parser.Reply.error f6)) ('Maybe.some (let ((f7 (get self7 1))) ($Parser.Reply.error ($Parser.Error.combine f7 f6)))))))) ('Parser.Reply.value (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((self8 f6)) (case (get self8 0) ('Parser.State.new (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) (let ((f11 (get self8 4))) (let ((f12 (get self8 5))) (let ((reply.pst$14 ($Parser.State.new ($Parser.Error.maybe_combine f0 f8) f9 f10 f11 f12))) ((let ((self14 f7)) (case self14 (#t (lambda (pst$15) (let ((self15 pst$15)) (case (get self15 0) ('Parser.State.new (let ((f15 (get self15 1))) (let ((f16 (get self15 2))) (let ((f17 (get self15 3))) (let ((f18 (get self15 4))) (let ((f19 (get self15 5))) (let ((reply$21 (Kind.Parser.spaces pst$15))) (let ((self21 reply$21)) (case (get self21 0) ('Parser.Reply.error (let ((f21 (get self21 1))) (let ((self22 f15)) (case (get self22 0) ('Maybe.none ($Parser.Reply.error f21)) ('Maybe.some (let ((f22 (get self22 1))) ($Parser.Reply.error ($Parser.Error.combine f22 f21)))))))) ('Parser.Reply.value (let ((f21 (get self21 1))) (let ((f22 (get self21 2))) (let ((self23 f21)) (case (get self23 0) ('Parser.State.new (let ((f23 (get self23 1))) (let ((f24 (get self23 2))) (let ((f25 (get self23 3))) (let ((f26 (get self23 4))) (let ((f27 (get self23 5))) (let ((reply.pst$29 ($Parser.State.new ($Parser.Error.maybe_combine f15 f23) f24 f25 f26 f27))) ($Parser.fail "Expected constructor names." reply.pst$29)))))))))))))))))))))))))) (#f (lambda (pst$15) (let ((self15 pst$15)) (case (get self15 0) ('Parser.State.new (let ((f15 (get self15 1))) (let ((f16 (get self15 2))) (let ((f17 (get self15 3))) (let ((f18 (get self15 4))) (let ((f19 (get self15 5))) (let ((reply$21 (($Parser.until (Kind.Parser.text ":") Kind.Parser.name1) pst$15))) (let ((self21 reply$21)) (case (get self21 0) ('Parser.Reply.error (let ((f21 (get self21 1))) (let ((self22 f15)) (case (get self22 0) ('Maybe.none ($Parser.Reply.error f21)) ('Maybe.some (let ((f22 (get self22 1))) ($Parser.Reply.error ($Parser.Error.combine f22 f21)))))))) ('Parser.Reply.value (let ((f21 (get self21 1))) (let ((f22 (get self21 2))) (let ((self23 f21)) (case (get self23 0) ('Parser.State.new (let ((f23 (get self23 1))) (let ((f24 (get self23 2))) (let ((f25 (get self23 3))) (let ((f26 (get self23 4))) (let ((f27 (get self23 5))) (let ((reply.pst$29 ($Parser.State.new ($Parser.Error.maybe_combine f15 f23) f24 f25 f26 f27))) (let ((self29 reply.pst$29)) (case (get self29 0) ('Parser.State.new (let ((f29 (get self29 1))) (let ((f30 (get self29 2))) (let ((f31 (get self29 3))) (let ((f32 (get self29 4))) (let ((f33 (get self29 5))) (let ((reply$35 (Kind.Parser.term reply.pst$29))) (let ((self35 reply$35)) (case (get self35 0) ('Parser.Reply.error (let ((f35 (get self35 1))) (let ((self36 f29)) (case (get self36 0) ('Maybe.none ($Parser.Reply.error f35)) ('Maybe.some (let ((f36 (get self36 1))) ($Parser.Reply.error ($Parser.Error.combine f36 f35)))))))) ('Parser.Reply.value (let ((f35 (get self35 1))) (let ((f36 (get self35 2))) (let ((self37 f35)) (case (get self37 0) ('Parser.State.new (let ((f37 (get self37 1))) (let ((f38 (get self37 2))) (let ((f39 (get self37 3))) (let ((f40 (get self37 4))) (let ((f41 (get self37 5))) (let ((reply.pst$43 ($Parser.State.new ($Parser.Error.maybe_combine f29 f37) f38 f39 f40 f41))) (let ((self43 reply.pst$43)) (case (get self43 0) ('Parser.State.new (let ((f43 (get self43 1))) (let ((f44 (get self43 2))) (let ((f45 (get self43 3))) (let ((f46 (get self43 4))) (let ((f47 (get self43 5))) (let ((reply$49 ($Parser.maybe (Kind.Parser.text ",") reply.pst$43))) (let ((self49 reply$49)) (case (get self49 0) ('Parser.Reply.error (let ((f49 (get self49 1))) (let ((self50 f43)) (case (get self50 0) ('Maybe.none ($Parser.Reply.error f49)) ('Maybe.some (let ((f50 (get self50 1))) ($Parser.Reply.error ($Parser.Error.combine f50 f49)))))))) ('Parser.Reply.value (let ((f49 (get self49 1))) (let ((f50 (get self49 2))) (let ((self51 f49)) (case (get self51 0) ('Parser.State.new (let ((f51 (get self51 1))) (let ((f52 (get self51 2))) (let ((f53 (get self51 3))) (let ((f54 (get self51 4))) (let ((f55 (get self51 5))) (let ((reply.pst$57 ($Parser.State.new ($Parser.Error.maybe_combine f43 f51) f52 f53 f54 f55))) ($Parser.Reply.value reply.pst$57 ($Pair.new f22 f36))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) reply.pst$14)))))))))))))))))))))))))
(define Kind.Parser.case.case (lambda (pst$0) ($Kind.Parser.case.case pst$0)))
(define ($Parser.append_error parse$1 msg$2 pst$3) (let ((reply$4 (parse$1 pst$3))) (let ((self1 reply$4)) (case (get self1 0) ('Parser.Reply.error (let ((f1 (get self1 1))) (let ((self2 f1)) (case (get self2 0) ('Parser.Error.new (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) (let ((f5 (get self2 4))) ($Parser.Reply.fail f2 f3 f4 ($String.concat f5 msg$2))))))))))) ('Parser.Reply.value (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) reply$4)))))))
(define Parser.append_error (lambda (parse$1) (lambda (msg$2) (lambda (pst$3) ($Parser.append_error parse$1 msg$2 pst$3)))))
(define ($Kind.Parser.case.group dflt$0 cses$1) (let ((self0 cses$1)) (case (get self0 0) ('List.nil (let ((self0 dflt$0)) (case (get self0 0) ('Maybe.none Kind.Map.new) ('Maybe.some (let ((f0 (get self0 1))) ($Kind.Map.set "_" ($List.cons ($Pair.new List.nil f0) List.nil) Kind.Map.new)))))) ('List.cons (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((map$4 ($Kind.Parser.case.group dflt$0 f1))) (let ((self3 f0)) (case (get self3 0) ('Pair.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((self5 f3)) (case (get self5 0) ('List.nil map$4) ('List.cons (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((rest$9 ($Maybe.default ($Kind.Map.get f5 map$4) List.nil))) ($Kind.Map.set f5 ($List.cons ($Pair.new f6 f4) rest$9) map$4)))))))))))))))))))
(define Kind.Parser.case.group (lambda (dflt$0) (lambda (cses$1) ($Kind.Parser.case.group dflt$0 cses$1))))
(define ($BitsMap.map fn$2 map$3) (let ((self0 map$3)) (case (get self0 0) ('BitsMap.new BitsMap.new) ('BitsMap.tie (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((val$7 (let ((self3 f0)) (case (get self3 0) ('Maybe.none Maybe.none) ('Maybe.some (let ((f3 (get self3 1))) ($Maybe.some (fn$2 f3)))))))) (let ((lft$8 ($BitsMap.map fn$2 f1))) (let ((rgt$9 ($BitsMap.map fn$2 f2))) ($BitsMap.tie val$7 lft$8 rgt$9)))))))))))
(define BitsMap.map (lambda (fn$2) (lambda (map$3) ($BitsMap.map fn$2 map$3))))
(define ($Kind.Map.map fn$2 map$3) ($BitsMap.map fn$2 map$3))
(define Kind.Map.map (lambda (fn$2) (lambda (map$3) ($Kind.Map.map fn$2 map$3))))
(define ($Kind.Parser.case.build vals$0 wyth$1 cses$2 dflt$3 moti$4) (let ((self0 vals$0)) (case (get self0 0) ('List.nil (let ((self0 cses$2)) (case (get self0 0) ('List.nil ($Kind.Term.ref "missing_case")) ('List.cons (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($Pair.snd f0))))))) ('List.cons (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((group$7 ($Kind.Parser.case.group dflt$3 cses$2))) (let ((name$8 ($Pair.fst f0))) (let ((expr$9 ($Pair.snd f0))) (let ((cses$10 ($Kind.Map.map (lambda (cses$10) ($Kind.Parser.case.build f1 wyth$1 cses$10 dflt$3 moti$4)) group$7))) ($Kind.Term.cse Bits.e expr$9 name$8 wyth$1 cses$10 moti$4)))))))))))
(define Kind.Parser.case.build (lambda (vals$0) (lambda (wyth$1) (lambda (cses$2) (lambda (dflt$3) (lambda (moti$4) ($Kind.Parser.case.build vals$0 wyth$1 cses$2 dflt$3 moti$4)))))))
(define Kind.Parser.case ((Kind.Parser.block "case") (lambda (pst$0) (let ((self1 pst$0)) (case (get self1 0) ('Parser.State.new (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((reply$6 ($Kind.Parser.text "case " pst$0))) (let ((self7 reply$6)) (case (get self7 0) ('Parser.Reply.error (let ((f7 (get self7 1))) (let ((self8 f1)) (case (get self8 0) ('Maybe.none ($Parser.Reply.error f7)) ('Maybe.some (let ((f8 (get self8 1))) ($Parser.Reply.error ($Parser.Error.combine f8 f7)))))))) ('Parser.Reply.value (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((self9 f7)) (case (get self9 0) ('Parser.State.new (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) (let ((reply.pst$14 ($Parser.State.new ($Parser.Error.maybe_combine f1 f9) f10 f11 f12 f13))) (let ((self15 reply.pst$14)) (case (get self15 0) ('Parser.State.new (let ((f15 (get self15 1))) (let ((f16 (get self15 2))) (let ((f17 (get self15 3))) (let ((f18 (get self15 4))) (let ((f19 (get self15 5))) (let ((reply$20 ($Parser.many1 (lambda (pst$20) (let ((self21 pst$20)) (case (get self21 0) ('Parser.State.new (let ((f21 (get self21 1))) (let ((f22 (get self21 2))) (let ((f23 (get self21 3))) (let ((f24 (get self21 4))) (let ((f25 (get self21 5))) (let ((reply$26 ($Parser.avoiding (Kind.Parser.text "{") Kind.Parser.term pst$20))) (let ((self27 reply$26)) (case (get self27 0) ('Parser.Reply.error (let ((f27 (get self27 1))) (let ((self28 f21)) (case (get self28 0) ('Maybe.none ($Parser.Reply.error f27)) ('Maybe.some (let ((f28 (get self28 1))) ($Parser.Reply.error ($Parser.Error.combine f28 f27)))))))) ('Parser.Reply.value (let ((f27 (get self27 1))) (let ((f28 (get self27 2))) (let ((self29 f27)) (case (get self29 0) ('Parser.State.new (let ((f29 (get self29 1))) (let ((f30 (get self29 2))) (let ((f31 (get self29 3))) (let ((f32 (get self29 4))) (let ((f33 (get self29 5))) (let ((reply.pst$34 ($Parser.State.new ($Parser.Error.maybe_combine f21 f29) f30 f31 f32 f33))) (let ((self35 reply.pst$34)) (case (get self35 0) ('Parser.State.new (let ((f35 (get self35 1))) (let ((f36 (get self35 2))) (let ((f37 (get self35 3))) (let ((f38 (get self35 4))) (let ((f39 (get self35 5))) (let ((reply$40 ($Parser.maybe (lambda (pst$40) (let ((self41 pst$40)) (case (get self41 0) ('Parser.State.new (let ((f41 (get self41 1))) (let ((f42 (get self41 2))) (let ((f43 (get self41 3))) (let ((f44 (get self41 4))) (let ((f45 (get self41 5))) (let ((reply$46 ($Kind.Parser.text "as" pst$40))) (let ((self47 reply$46)) (case (get self47 0) ('Parser.Reply.error (let ((f47 (get self47 1))) (let ((self48 f41)) (case (get self48 0) ('Maybe.none ($Parser.Reply.error f47)) ('Maybe.some (let ((f48 (get self48 1))) ($Parser.Reply.error ($Parser.Error.combine f48 f47)))))))) ('Parser.Reply.value (let ((f47 (get self47 1))) (let ((f48 (get self47 2))) (let ((self49 f47)) (case (get self49 0) ('Parser.State.new (let ((f49 (get self49 1))) (let ((f50 (get self49 2))) (let ((f51 (get self49 3))) (let ((f52 (get self49 4))) (let ((f53 (get self49 5))) (let ((reply.pst$54 ($Parser.State.new ($Parser.Error.maybe_combine f41 f49) f50 f51 f52 f53))) (let ((self55 reply.pst$54)) (case (get self55 0) ('Parser.State.new (let ((f55 (get self55 1))) (let ((f56 (get self55 2))) (let ((f57 (get self55 3))) (let ((f58 (get self55 4))) (let ((f59 (get self55 5))) (let ((reply$60 ($Kind.Parser.name1 reply.pst$54))) (let ((self61 reply$60)) (case (get self61 0) ('Parser.Reply.error (let ((f61 (get self61 1))) (let ((self62 f55)) (case (get self62 0) ('Maybe.none ($Parser.Reply.error f61)) ('Maybe.some (let ((f62 (get self62 1))) ($Parser.Reply.error ($Parser.Error.combine f62 f61)))))))) ('Parser.Reply.value (let ((f61 (get self61 1))) (let ((f62 (get self61 2))) (let ((self63 f61)) (case (get self63 0) ('Parser.State.new (let ((f63 (get self63 1))) (let ((f64 (get self63 2))) (let ((f65 (get self63 3))) (let ((f66 (get self63 4))) (let ((f67 (get self63 5))) (let ((reply.pst$68 ($Parser.State.new ($Parser.Error.maybe_combine f55 f63) f64 f65 f66 f67))) (let ((self69 reply.pst$68)) (case (get self69 0) ('Parser.State.new (let ((f69 (get self69 1))) (let ((f70 (get self69 2))) (let ((f71 (get self69 3))) (let ((f72 (get self69 4))) (let ((f73 (get self69 5))) (let ((reply$74 ($Parser.maybe (Kind.Parser.text ";") reply.pst$68))) (let ((self75 reply$74)) (case (get self75 0) ('Parser.Reply.error (let ((f75 (get self75 1))) (let ((self76 f69)) (case (get self76 0) ('Maybe.none ($Parser.Reply.error f75)) ('Maybe.some (let ((f76 (get self76 1))) ($Parser.Reply.error ($Parser.Error.combine f76 f75)))))))) ('Parser.Reply.value (let ((f75 (get self75 1))) (let ((f76 (get self75 2))) (let ((self77 f75)) (case (get self77 0) ('Parser.State.new (let ((f77 (get self77 1))) (let ((f78 (get self77 2))) (let ((f79 (get self77 3))) (let ((f80 (get self77 4))) (let ((f81 (get self77 5))) (let ((reply.pst$82 ($Parser.State.new ($Parser.Error.maybe_combine f69 f77) f78 f79 f80 f81))) ($Parser.Reply.value reply.pst$82 f62))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) reply.pst$34))) (let ((self41 reply$40)) (case (get self41 0) ('Parser.Reply.error (let ((f41 (get self41 1))) (let ((self42 f35)) (case (get self42 0) ('Maybe.none ($Parser.Reply.error f41)) ('Maybe.some (let ((f42 (get self42 1))) ($Parser.Reply.error ($Parser.Error.combine f42 f41)))))))) ('Parser.Reply.value (let ((f41 (get self41 1))) (let ((f42 (get self41 2))) (let ((self43 f41)) (case (get self43 0) ('Parser.State.new (let ((f43 (get self43 1))) (let ((f44 (get self43 2))) (let ((f45 (get self43 3))) (let ((f46 (get self43 4))) (let ((f47 (get self43 5))) (let ((reply.pst$48 ($Parser.State.new ($Parser.Error.maybe_combine f35 f43) f44 f45 f46 f47))) (let ((name$49 ($Maybe.default f42 ($Kind.Term.extract_name f28)))) ($Parser.Reply.value reply.pst$48 ($Pair.new name$49 f28)))))))))))))))))))))))))))))))))))))))))))))))))) reply.pst$14))) (let ((self21 reply$20)) (case (get self21 0) ('Parser.Reply.error (let ((f21 (get self21 1))) (let ((self22 f15)) (case (get self22 0) ('Maybe.none ($Parser.Reply.error f21)) ('Maybe.some (let ((f22 (get self22 1))) ($Parser.Reply.error ($Parser.Error.combine f22 f21)))))))) ('Parser.Reply.value (let ((f21 (get self21 1))) (let ((f22 (get self21 2))) (let ((self23 f21)) (case (get self23 0) ('Parser.State.new (let ((f23 (get self23 1))) (let ((f24 (get self23 2))) (let ((f25 (get self23 3))) (let ((f26 (get self23 4))) (let ((f27 (get self23 5))) (let ((reply.pst$28 ($Parser.State.new ($Parser.Error.maybe_combine f15 f23) f24 f25 f26 f27))) (let ((self29 reply.pst$28)) (case (get self29 0) ('Parser.State.new (let ((f29 (get self29 1))) (let ((f30 (get self29 2))) (let ((f31 (get self29 3))) (let ((f32 (get self29 4))) (let ((f33 (get self29 5))) (let ((reply$34 (Kind.Parser.case.with reply.pst$28))) (let ((self35 reply$34)) (case (get self35 0) ('Parser.Reply.error (let ((f35 (get self35 1))) (let ((self36 f29)) (case (get self36 0) ('Maybe.none ($Parser.Reply.error f35)) ('Maybe.some (let ((f36 (get self36 1))) ($Parser.Reply.error ($Parser.Error.combine f36 f35)))))))) ('Parser.Reply.value (let ((f35 (get self35 1))) (let ((f36 (get self35 2))) (let ((self37 f35)) (case (get self37 0) ('Parser.State.new (let ((f37 (get self37 1))) (let ((f38 (get self37 2))) (let ((f39 (get self37 3))) (let ((f40 (get self37 4))) (let ((f41 (get self37 5))) (let ((reply.pst$42 ($Parser.State.new ($Parser.Error.maybe_combine f29 f37) f38 f39 f40 f41))) (let ((self43 reply.pst$42)) (case (get self43 0) ('Parser.State.new (let ((f43 (get self43 1))) (let ((f44 (get self43 2))) (let ((f45 (get self43 3))) (let ((f46 (get self43 4))) (let ((f47 (get self43 5))) (let ((reply$48 (($Kind.Parser.items "{" Kind.Parser.case.case "}") reply.pst$42))) (let ((self49 reply$48)) (case (get self49 0) ('Parser.Reply.error (let ((f49 (get self49 1))) (let ((self50 f43)) (case (get self50 0) ('Maybe.none ($Parser.Reply.error f49)) ('Maybe.some (let ((f50 (get self50 1))) ($Parser.Reply.error ($Parser.Error.combine f50 f49)))))))) ('Parser.Reply.value (let ((f49 (get self49 1))) (let ((f50 (get self49 2))) (let ((self51 f49)) (case (get self51 0) ('Parser.State.new (let ((f51 (get self51 1))) (let ((f52 (get self51 2))) (let ((f53 (get self51 3))) (let ((f54 (get self51 4))) (let ((f55 (get self51 5))) (let ((reply.pst$56 ($Parser.State.new ($Parser.Error.maybe_combine f43 f51) f52 f53 f54 f55))) (let ((self57 reply.pst$56)) (case (get self57 0) ('Parser.State.new (let ((f57 (get self57 1))) (let ((f58 (get self57 2))) (let ((f59 (get self57 3))) (let ((f60 (get self57 4))) (let ((f61 (get self57 5))) (let ((reply$62 ($Parser.maybe (Kind.Parser.text "!") reply.pst$56))) (let ((self63 reply$62)) (case (get self63 0) ('Parser.Reply.error (let ((f63 (get self63 1))) (let ((self64 f57)) (case (get self64 0) ('Maybe.none ($Parser.Reply.error f63)) ('Maybe.some (let ((f64 (get self64 1))) ($Parser.Reply.error ($Parser.Error.combine f64 f63)))))))) ('Parser.Reply.value (let ((f63 (get self63 1))) (let ((f64 (get self63 2))) (let ((self65 f63)) (case (get self65 0) ('Parser.State.new (let ((f65 (get self65 1))) (let ((f66 (get self65 2))) (let ((f67 (get self65 3))) (let ((f68 (get self65 4))) (let ((f69 (get self65 5))) (let ((reply.pst$70 ($Parser.State.new ($Parser.Error.maybe_combine f57 f65) f66 f67 f68 f69))) (let ((self71 reply.pst$70)) (case (get self71 0) ('Parser.State.new (let ((f71 (get self71 1))) (let ((f72 (get self71 2))) (let ((f73 (get self71 3))) (let ((f74 (get self71 4))) (let ((f75 (get self71 5))) (let ((reply$76 ($Parser.maybe (lambda (pst$76) (let ((self77 pst$76)) (case (get self77 0) ('Parser.State.new (let ((f77 (get self77 1))) (let ((f78 (get self77 2))) (let ((f79 (get self77 3))) (let ((f80 (get self77 4))) (let ((f81 (get self77 5))) (let ((reply$82 ($Kind.Parser.text "default" pst$76))) (let ((self83 reply$82)) (case (get self83 0) ('Parser.Reply.error (let ((f83 (get self83 1))) (let ((self84 f77)) (case (get self84 0) ('Maybe.none ($Parser.Reply.error f83)) ('Maybe.some (let ((f84 (get self84 1))) ($Parser.Reply.error ($Parser.Error.combine f84 f83)))))))) ('Parser.Reply.value (let ((f83 (get self83 1))) (let ((f84 (get self83 2))) (let ((self85 f83)) (case (get self85 0) ('Parser.State.new (let ((f85 (get self85 1))) (let ((f86 (get self85 2))) (let ((f87 (get self85 3))) (let ((f88 (get self85 4))) (let ((f89 (get self85 5))) (let ((reply.pst$90 ($Parser.State.new ($Parser.Error.maybe_combine f77 f85) f86 f87 f88 f89))) (let ((self91 reply.pst$90)) (case (get self91 0) ('Parser.State.new (let ((f91 (get self91 1))) (let ((f92 (get self91 2))) (let ((f93 (get self91 3))) (let ((f94 (get self91 4))) (let ((f95 (get self91 5))) (let ((reply$96 (Kind.Parser.term reply.pst$90))) (let ((self97 reply$96)) (case (get self97 0) ('Parser.Reply.error (let ((f97 (get self97 1))) (let ((self98 f91)) (case (get self98 0) ('Maybe.none ($Parser.Reply.error f97)) ('Maybe.some (let ((f98 (get self98 1))) ($Parser.Reply.error ($Parser.Error.combine f98 f97)))))))) ('Parser.Reply.value (let ((f97 (get self97 1))) (let ((f98 (get self97 2))) (let ((self99 f97)) (case (get self99 0) ('Parser.State.new (let ((f99 (get self99 1))) (let ((f100 (get self99 2))) (let ((f101 (get self99 3))) (let ((f102 (get self99 4))) (let ((f103 (get self99 5))) (let ((reply.pst$104 ($Parser.State.new ($Parser.Error.maybe_combine f91 f99) f100 f101 f102 f103))) ($Parser.Reply.value reply.pst$104 f98)))))))))))))))))))))))))))))))))))))))))))))))) reply.pst$70))) (let ((self77 reply$76)) (case (get self77 0) ('Parser.Reply.error (let ((f77 (get self77 1))) (let ((self78 f71)) (case (get self78 0) ('Maybe.none ($Parser.Reply.error f77)) ('Maybe.some (let ((f78 (get self78 1))) ($Parser.Reply.error ($Parser.Error.combine f78 f77)))))))) ('Parser.Reply.value (let ((f77 (get self77 1))) (let ((f78 (get self77 2))) (let ((self79 f77)) (case (get self79 0) ('Parser.State.new (let ((f79 (get self79 1))) (let ((f80 (get self79 2))) (let ((f81 (get self79 3))) (let ((f82 (get self79 4))) (let ((f83 (get self79 5))) (let ((reply.pst$84 ($Parser.State.new ($Parser.Error.maybe_combine f71 f79) f80 f81 f82 f83))) (let ((self85 reply.pst$84)) (case (get self85 0) ('Parser.State.new (let ((f85 (get self85 1))) (let ((f86 (get self85 2))) (let ((f87 (get self85 3))) (let ((f88 (get self85 4))) (let ((f89 (get self85 5))) (let ((reply$90 ($Parser.maybe (lambda (pst$90) (let ((self91 pst$90)) (case (get self91 0) ('Parser.State.new (let ((f91 (get self91 1))) (let ((f92 (get self91 2))) (let ((f93 (get self91 3))) (let ((f94 (get self91 4))) (let ((f95 (get self91 5))) (let ((reply$96 ($Kind.Parser.text ":" pst$90))) (let ((self97 reply$96)) (case (get self97 0) ('Parser.Reply.error (let ((f97 (get self97 1))) (let ((self98 f91)) (case (get self98 0) ('Maybe.none ($Parser.Reply.error f97)) ('Maybe.some (let ((f98 (get self98 1))) ($Parser.Reply.error ($Parser.Error.combine f98 f97)))))))) ('Parser.Reply.value (let ((f97 (get self97 1))) (let ((f98 (get self97 2))) (let ((self99 f97)) (case (get self99 0) ('Parser.State.new (let ((f99 (get self99 1))) (let ((f100 (get self99 2))) (let ((f101 (get self99 3))) (let ((f102 (get self99 4))) (let ((f103 (get self99 5))) (let ((reply.pst$104 ($Parser.State.new ($Parser.Error.maybe_combine f91 f99) f100 f101 f102 f103))) ($Parser.append_error Kind.Parser.term "\xa;Inside motive." reply.pst$104))))))))))))))))))))))))) reply.pst$84))) (let ((self91 reply$90)) (case (get self91 0) ('Parser.Reply.error (let ((f91 (get self91 1))) (let ((self92 f85)) (case (get self92 0) ('Maybe.none ($Parser.Reply.error f91)) ('Maybe.some (let ((f92 (get self92 1))) ($Parser.Reply.error ($Parser.Error.combine f92 f91)))))))) ('Parser.Reply.value (let ((f91 (get self91 1))) (let ((f92 (get self91 2))) (let ((self93 f91)) (case (get self93 0) ('Parser.State.new (let ((f93 (get self93 1))) (let ((f94 (get self93 2))) (let ((f95 (get self93 3))) (let ((f96 (get self93 4))) (let ((f97 (get self93 5))) (let ((reply.pst$98 ($Parser.State.new ($Parser.Error.maybe_combine f85 f93) f94 f95 f96 f97))) (let ((moti$99 (let ((self99 f92)) (case (get self99 0) ('Maybe.none (let ((self99 f64)) (case (get self99 0) ('Maybe.none ($Maybe.some ($Kind.Term.hol Bits.e))) ('Maybe.some (let ((f99 (get self99 1))) Maybe.none))))) ('Maybe.some (let ((f99 (get self99 1))) ($Maybe.some f99))))))) ($Parser.Reply.value reply.pst$98 ($Kind.Parser.case.build f22 f36 f50 f78 moti$99)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.without ((Kind.Parser.block "without") (lambda (pst$0) (let ((self1 pst$0)) (case (get self1 0) ('Parser.State.new (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((reply$6 ($Kind.Parser.text "without " pst$0))) (let ((self7 reply$6)) (case (get self7 0) ('Parser.Reply.error (let ((f7 (get self7 1))) (let ((self8 f1)) (case (get self8 0) ('Maybe.none ($Parser.Reply.error f7)) ('Maybe.some (let ((f8 (get self8 1))) ($Parser.Reply.error ($Parser.Error.combine f8 f7)))))))) ('Parser.Reply.value (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((self9 f7)) (case (get self9 0) ('Parser.State.new (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) (let ((reply.pst$14 ($Parser.State.new ($Parser.Error.maybe_combine f1 f9) f10 f11 f12 f13))) (let ((self15 reply.pst$14)) (case (get self15 0) ('Parser.State.new (let ((f15 (get self15 1))) (let ((f16 (get self15 2))) (let ((f17 (get self15 3))) (let ((f18 (get self15 4))) (let ((f19 (get self15 5))) (let ((reply$20 ($Kind.Parser.name1 reply.pst$14))) (let ((self21 reply$20)) (case (get self21 0) ('Parser.Reply.error (let ((f21 (get self21 1))) (let ((self22 f15)) (case (get self22 0) ('Maybe.none ($Parser.Reply.error f21)) ('Maybe.some (let ((f22 (get self22 1))) ($Parser.Reply.error ($Parser.Error.combine f22 f21)))))))) ('Parser.Reply.value (let ((f21 (get self21 1))) (let ((f22 (get self21 2))) (let ((self23 f21)) (case (get self23 0) ('Parser.State.new (let ((f23 (get self23 1))) (let ((f24 (get self23 2))) (let ((f25 (get self23 3))) (let ((f26 (get self23 4))) (let ((f27 (get self23 5))) (let ((reply.pst$28 ($Parser.State.new ($Parser.Error.maybe_combine f15 f23) f24 f25 f26 f27))) (let ((self29 reply.pst$28)) (case (get self29 0) ('Parser.State.new (let ((f29 (get self29 1))) (let ((f30 (get self29 2))) (let ((f31 (get self29 3))) (let ((f32 (get self29 4))) (let ((f33 (get self29 5))) (let ((reply$34 ($Kind.Parser.text ":" reply.pst$28))) (let ((self35 reply$34)) (case (get self35 0) ('Parser.Reply.error (let ((f35 (get self35 1))) (let ((self36 f29)) (case (get self36 0) ('Maybe.none ($Parser.Reply.error f35)) ('Maybe.some (let ((f36 (get self36 1))) ($Parser.Reply.error ($Parser.Error.combine f36 f35)))))))) ('Parser.Reply.value (let ((f35 (get self35 1))) (let ((f36 (get self35 2))) (let ((self37 f35)) (case (get self37 0) ('Parser.State.new (let ((f37 (get self37 1))) (let ((f38 (get self37 2))) (let ((f39 (get self37 3))) (let ((f40 (get self37 4))) (let ((f41 (get self37 5))) (let ((reply.pst$42 ($Parser.State.new ($Parser.Error.maybe_combine f29 f37) f38 f39 f40 f41))) (let ((self43 reply.pst$42)) (case (get self43 0) ('Parser.State.new (let ((f43 (get self43 1))) (let ((f44 (get self43 2))) (let ((f45 (get self43 3))) (let ((f46 (get self43 4))) (let ((f47 (get self43 5))) (let ((reply$48 (Kind.Parser.term reply.pst$42))) (let ((self49 reply$48)) (case (get self49 0) ('Parser.Reply.error (let ((f49 (get self49 1))) (let ((self50 f43)) (case (get self50 0) ('Maybe.none ($Parser.Reply.error f49)) ('Maybe.some (let ((f50 (get self50 1))) ($Parser.Reply.error ($Parser.Error.combine f50 f49)))))))) ('Parser.Reply.value (let ((f49 (get self49 1))) (let ((f50 (get self49 2))) (let ((self51 f49)) (case (get self51 0) ('Parser.State.new (let ((f51 (get self51 1))) (let ((f52 (get self51 2))) (let ((f53 (get self51 3))) (let ((f54 (get self51 4))) (let ((f55 (get self51 5))) (let ((reply.pst$56 ($Parser.State.new ($Parser.Error.maybe_combine f43 f51) f52 f53 f54 f55))) (let ((self57 reply.pst$56)) (case (get self57 0) ('Parser.State.new (let ((f57 (get self57 1))) (let ((f58 (get self57 2))) (let ((f59 (get self57 3))) (let ((f60 (get self57 4))) (let ((f61 (get self57 5))) (let ((reply$62 (Kind.Parser.term reply.pst$56))) (let ((self63 reply$62)) (case (get self63 0) ('Parser.Reply.error (let ((f63 (get self63 1))) (let ((self64 f57)) (case (get self64 0) ('Maybe.none ($Parser.Reply.error f63)) ('Maybe.some (let ((f64 (get self64 1))) ($Parser.Reply.error ($Parser.Error.combine f64 f63)))))))) ('Parser.Reply.value (let ((f63 (get self63 1))) (let ((f64 (get self63 2))) (let ((self65 f63)) (case (get self65 0) ('Parser.State.new (let ((f65 (get self65 1))) (let ((f66 (get self65 2))) (let ((f67 (get self65 3))) (let ((f68 (get self65 4))) (let ((f69 (get self65 5))) (let ((reply.pst$70 ($Parser.State.new ($Parser.Error.maybe_combine f57 f65) f66 f67 f68 f69))) (let ((term$71 ($Kind.Term.ref f22))) (let ((term$72 ($Kind.Term.app term$71 ($Kind.Term.lam "" (lambda (x$72) ($Kind.Term.hol Bits.e)))))) (let ((term$73 ($Kind.Term.app term$72 f50))) (let ((term$74 ($Kind.Term.app term$73 ($Kind.Term.lam f22 (lambda (x$74) f64))))) ($Parser.Reply.value reply.pst$70 term$74)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(define ($Kind.Parser.switch.case pst$0) (let ((self0 pst$0)) (case (get self0 0) ('Parser.State.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((reply$6 (Kind.Parser.term pst$0))) (let ((self6 reply$6)) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))) (let ((self7 f0)) (case (get self7 0) ('Maybe.none ($Parser.Reply.error f6)) ('Maybe.some (let ((f7 (get self7 1))) ($Parser.Reply.error ($Parser.Error.combine f7 f6)))))))) ('Parser.Reply.value (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((self8 f6)) (case (get self8 0) ('Parser.State.new (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) (let ((f11 (get self8 4))) (let ((f12 (get self8 5))) (let ((reply.pst$14 ($Parser.State.new ($Parser.Error.maybe_combine f0 f8) f9 f10 f11 f12))) (let ((self14 reply.pst$14)) (case (get self14 0) ('Parser.State.new (let ((f14 (get self14 1))) (let ((f15 (get self14 2))) (let ((f16 (get self14 3))) (let ((f17 (get self14 4))) (let ((f18 (get self14 5))) (let ((reply$20 ($Kind.Parser.text ":" reply.pst$14))) (let ((self20 reply$20)) (case (get self20 0) ('Parser.Reply.error (let ((f20 (get self20 1))) (let ((self21 f14)) (case (get self21 0) ('Maybe.none ($Parser.Reply.error f20)) ('Maybe.some (let ((f21 (get self21 1))) ($Parser.Reply.error ($Parser.Error.combine f21 f20)))))))) ('Parser.Reply.value (let ((f20 (get self20 1))) (let ((f21 (get self20 2))) (let ((self22 f20)) (case (get self22 0) ('Parser.State.new (let ((f22 (get self22 1))) (let ((f23 (get self22 2))) (let ((f24 (get self22 3))) (let ((f25 (get self22 4))) (let ((f26 (get self22 5))) (let ((reply.pst$28 ($Parser.State.new ($Parser.Error.maybe_combine f14 f22) f23 f24 f25 f26))) (let ((self28 reply.pst$28)) (case (get self28 0) ('Parser.State.new (let ((f28 (get self28 1))) (let ((f29 (get self28 2))) (let ((f30 (get self28 3))) (let ((f31 (get self28 4))) (let ((f32 (get self28 5))) (let ((reply$34 (Kind.Parser.term reply.pst$28))) (let ((self34 reply$34)) (case (get self34 0) ('Parser.Reply.error (let ((f34 (get self34 1))) (let ((self35 f28)) (case (get self35 0) ('Maybe.none ($Parser.Reply.error f34)) ('Maybe.some (let ((f35 (get self35 1))) ($Parser.Reply.error ($Parser.Error.combine f35 f34)))))))) ('Parser.Reply.value (let ((f34 (get self34 1))) (let ((f35 (get self34 2))) (let ((self36 f34)) (case (get self36 0) ('Parser.State.new (let ((f36 (get self36 1))) (let ((f37 (get self36 2))) (let ((f38 (get self36 3))) (let ((f39 (get self36 4))) (let ((f40 (get self36 5))) (let ((reply.pst$42 ($Parser.State.new ($Parser.Error.maybe_combine f28 f36) f37 f38 f39 f40))) ($Parser.Reply.value reply.pst$42 ($Pair.new f7 f35))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.switch.case (lambda (pst$0) ($Kind.Parser.switch.case pst$0)))
(define Kind.Parser.switch ((Kind.Parser.block "switch") (lambda (pst$0) (let ((self1 pst$0)) (case (get self1 0) ('Parser.State.new (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((reply$6 ($Kind.Parser.text "switch" pst$0))) (let ((self7 reply$6)) (case (get self7 0) ('Parser.Reply.error (let ((f7 (get self7 1))) (let ((self8 f1)) (case (get self8 0) ('Maybe.none ($Parser.Reply.error f7)) ('Maybe.some (let ((f8 (get self8 1))) ($Parser.Reply.error ($Parser.Error.combine f8 f7)))))))) ('Parser.Reply.value (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((self9 f7)) (case (get self9 0) ('Parser.State.new (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) (let ((reply.pst$14 ($Parser.State.new ($Parser.Error.maybe_combine f1 f9) f10 f11 f12 f13))) (let ((self15 reply.pst$14)) (case (get self15 0) ('Parser.State.new (let ((f15 (get self15 1))) (let ((f16 (get self15 2))) (let ((f17 (get self15 3))) (let ((f18 (get self15 4))) (let ((f19 (get self15 5))) (let ((reply$20 (Kind.Parser.term reply.pst$14))) (let ((self21 reply$20)) (case (get self21 0) ('Parser.Reply.error (let ((f21 (get self21 1))) (let ((self22 f15)) (case (get self22 0) ('Maybe.none ($Parser.Reply.error f21)) ('Maybe.some (let ((f22 (get self22 1))) ($Parser.Reply.error ($Parser.Error.combine f22 f21)))))))) ('Parser.Reply.value (let ((f21 (get self21 1))) (let ((f22 (get self21 2))) (let ((self23 f21)) (case (get self23 0) ('Parser.State.new (let ((f23 (get self23 1))) (let ((f24 (get self23 2))) (let ((f25 (get self23 3))) (let ((f26 (get self23 4))) (let ((f27 (get self23 5))) (let ((reply.pst$28 ($Parser.State.new ($Parser.Error.maybe_combine f15 f23) f24 f25 f26 f27))) (let ((self29 reply.pst$28)) (case (get self29 0) ('Parser.State.new (let ((f29 (get self29 1))) (let ((f30 (get self29 2))) (let ((f31 (get self29 3))) (let ((f32 (get self29 4))) (let ((f33 (get self29 5))) (let ((reply$34 (($Kind.Parser.items "{" Kind.Parser.switch.case "}") reply.pst$28))) (let ((self35 reply$34)) (case (get self35 0) ('Parser.Reply.error (let ((f35 (get self35 1))) (let ((self36 f29)) (case (get self36 0) ('Maybe.none ($Parser.Reply.error f35)) ('Maybe.some (let ((f36 (get self36 1))) ($Parser.Reply.error ($Parser.Error.combine f36 f35)))))))) ('Parser.Reply.value (let ((f35 (get self35 1))) (let ((f36 (get self35 2))) (let ((self37 f35)) (case (get self37 0) ('Parser.State.new (let ((f37 (get self37 1))) (let ((f38 (get self37 2))) (let ((f39 (get self37 3))) (let ((f40 (get self37 4))) (let ((f41 (get self37 5))) (let ((reply.pst$42 ($Parser.State.new ($Parser.Error.maybe_combine f29 f37) f38 f39 f40 f41))) (let ((self43 reply.pst$42)) (case (get self43 0) ('Parser.State.new (let ((f43 (get self43 1))) (let ((f44 (get self43 2))) (let ((f45 (get self43 3))) (let ((f46 (get self43 4))) (let ((f47 (get self43 5))) (let ((reply$48 ($Kind.Parser.text "default" reply.pst$42))) (let ((self49 reply$48)) (case (get self49 0) ('Parser.Reply.error (let ((f49 (get self49 1))) (let ((self50 f43)) (case (get self50 0) ('Maybe.none ($Parser.Reply.error f49)) ('Maybe.some (let ((f50 (get self50 1))) ($Parser.Reply.error ($Parser.Error.combine f50 f49)))))))) ('Parser.Reply.value (let ((f49 (get self49 1))) (let ((f50 (get self49 2))) (let ((self51 f49)) (case (get self51 0) ('Parser.State.new (let ((f51 (get self51 1))) (let ((f52 (get self51 2))) (let ((f53 (get self51 3))) (let ((f54 (get self51 4))) (let ((f55 (get self51 5))) (let ((reply.pst$56 ($Parser.State.new ($Parser.Error.maybe_combine f43 f51) f52 f53 f54 f55))) (let ((self57 reply.pst$56)) (case (get self57 0) ('Parser.State.new (let ((f57 (get self57 1))) (let ((f58 (get self57 2))) (let ((f59 (get self57 3))) (let ((f60 (get self57 4))) (let ((f61 (get self57 5))) (let ((reply$62 (Kind.Parser.term reply.pst$56))) (let ((self63 reply$62)) (case (get self63 0) ('Parser.Reply.error (let ((f63 (get self63 1))) (let ((self64 f57)) (case (get self64 0) ('Maybe.none ($Parser.Reply.error f63)) ('Maybe.some (let ((f64 (get self64 1))) ($Parser.Reply.error ($Parser.Error.combine f64 f63)))))))) ('Parser.Reply.value (let ((f63 (get self63 1))) (let ((f64 (get self63 2))) (let ((self65 f63)) (case (get self65 0) ('Parser.State.new (let ((f65 (get self65 1))) (let ((f66 (get self65 2))) (let ((f67 (get self65 3))) (let ((f68 (get self65 4))) (let ((f69 (get self65 5))) (let ((reply.pst$70 ($Parser.State.new ($Parser.Error.maybe_combine f57 f65) f66 f67 f68 f69))) (let ((term$71 ($List.fold f36 f64 (lambda (cse$71) (lambda (rest$72) (let ((self73 cse$71)) (case (get self73 0) ('Pair.new (let ((f73 (get self73 1))) (let ((f74 (get self73 2))) (let ((term$75 ($Kind.Term.app f22 f73))) (let ((term$76 ($Kind.Term.app term$75 ($Kind.Term.lam "" (lambda (x$76) ($Kind.Term.hol Bits.e)))))) (let ((term$77 ($Kind.Term.app term$76 f74))) (let ((term$78 ($Kind.Term.app term$77 rest$72))) term$78)))))))))))))) ($Parser.Reply.value reply.pst$70 term$71))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(define ($Bits.tail a$0) (let ((self0 a$0)) (case (if (eq? self0 #b1) 2 (bitwise-and self0 #b1)) (2 Bits.e) (0 (let ((f0 (bitwise-arithmetic-shift-right self0 #b1))) f0)) (1 (let ((f0 (bitwise-arithmetic-shift-right self0 #b1))) f0)))))
(define Bits.tail (lambda (a$0) ($Bits.tail a$0)))
(define ($Bits.inc a$0) (let ((self0 a$0)) (case (if (eq? self0 #b1) 2 (bitwise-and self0 #b1)) (2 ($Bits.i Bits.e)) (0 (let ((f0 (bitwise-arithmetic-shift-right self0 #b1))) ($Bits.i f0))) (1 (let ((f0 (bitwise-arithmetic-shift-right self0 #b1))) ($Bits.o ($Bits.inc f0)))))))
(define Bits.inc (lambda (a$0) ($Bits.inc a$0)))
(define ($Nat.to_bits n$0) (let ((self0 n$0)) (case (= self0 0) (#t ($Bits.o Bits.e)) (#f (let ((f0 (- self0 1))) ($Bits.inc ($Nat.to_bits f0)))))))
(define Nat.to_bits (lambda (n$0) ($Nat.to_bits n$0)))
(define ($Maybe.is_some m$1) (let ((self0 m$1)) (case (get self0 0) ('Maybe.none Bool.false) ('Maybe.some (let ((f0 (get self0 1))) Bool.true)))))
(define Maybe.is_some (lambda (m$1) ($Maybe.is_some m$1)))
(define ($Kind.Term.gol name$0 dref$1 verb$2) (vector 'Kind.Term.gol name$0 dref$1 verb$2))
(define Kind.Term.gol (lambda (name$0) (lambda (dref$1) (lambda (verb$2) ($Kind.Term.gol name$0 dref$1 verb$2)))))
(define Kind.Parser.goal ((Kind.Parser.block "goal") (lambda (pst$0) (let ((self1 pst$0)) (case (get self1 0) ('Parser.State.new (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((reply$6 ($Kind.Parser.text "?" pst$0))) (let ((self7 reply$6)) (case (get self7 0) ('Parser.Reply.error (let ((f7 (get self7 1))) (let ((self8 f1)) (case (get self8 0) ('Maybe.none ($Parser.Reply.error f7)) ('Maybe.some (let ((f8 (get self8 1))) ($Parser.Reply.error ($Parser.Error.combine f8 f7)))))))) ('Parser.Reply.value (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((self9 f7)) (case (get self9 0) ('Parser.State.new (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) (let ((reply.pst$14 ($Parser.State.new ($Parser.Error.maybe_combine f1 f9) f10 f11 f12 f13))) (let ((self15 reply.pst$14)) (case (get self15 0) ('Parser.State.new (let ((f15 (get self15 1))) (let ((f16 (get self15 2))) (let ((f17 (get self15 3))) (let ((f18 (get self15 4))) (let ((f19 (get self15 5))) (let ((reply$20 ($Kind.Parser.name reply.pst$14))) (let ((self21 reply$20)) (case (get self21 0) ('Parser.Reply.error (let ((f21 (get self21 1))) (let ((self22 f15)) (case (get self22 0) ('Maybe.none ($Parser.Reply.error f21)) ('Maybe.some (let ((f22 (get self22 1))) ($Parser.Reply.error ($Parser.Error.combine f22 f21)))))))) ('Parser.Reply.value (let ((f21 (get self21 1))) (let ((f22 (get self21 2))) (let ((self23 f21)) (case (get self23 0) ('Parser.State.new (let ((f23 (get self23 1))) (let ((f24 (get self23 2))) (let ((f25 (get self23 3))) (let ((f26 (get self23 4))) (let ((f27 (get self23 5))) (let ((reply.pst$28 ($Parser.State.new ($Parser.Error.maybe_combine f15 f23) f24 f25 f26 f27))) (let ((self29 reply.pst$28)) (case (get self29 0) ('Parser.State.new (let ((f29 (get self29 1))) (let ((f30 (get self29 2))) (let ((f31 (get self29 3))) (let ((f32 (get self29 4))) (let ((f33 (get self29 5))) (let ((reply$34 (($Parser.many (lambda (pst$34) (let ((self35 pst$34)) (case (get self35 0) ('Parser.State.new (let ((f35 (get self35 1))) (let ((f36 (get self35 2))) (let ((f37 (get self35 3))) (let ((f38 (get self35 4))) (let ((f39 (get self35 5))) (let ((reply$40 ($Kind.Parser.text "-" pst$34))) (let ((self41 reply$40)) (case (get self41 0) ('Parser.Reply.error (let ((f41 (get self41 1))) (let ((self42 f35)) (case (get self42 0) ('Maybe.none ($Parser.Reply.error f41)) ('Maybe.some (let ((f42 (get self42 1))) ($Parser.Reply.error ($Parser.Error.combine f42 f41)))))))) ('Parser.Reply.value (let ((f41 (get self41 1))) (let ((f42 (get self41 2))) (let ((self43 f41)) (case (get self43 0) ('Parser.State.new (let ((f43 (get self43 1))) (let ((f44 (get self43 2))) (let ((f45 (get self43 3))) (let ((f46 (get self43 4))) (let ((f47 (get self43 5))) (let ((reply.pst$48 ($Parser.State.new ($Parser.Error.maybe_combine f35 f43) f44 f45 f46 f47))) (let ((self49 reply.pst$48)) (case (get self49 0) ('Parser.State.new (let ((f49 (get self49 1))) (let ((f50 (get self49 2))) (let ((f51 (get self49 3))) (let ((f52 (get self49 4))) (let ((f53 (get self49 5))) (let ((reply$54 ($Parser.nat reply.pst$48))) (let ((self55 reply$54)) (case (get self55 0) ('Parser.Reply.error (let ((f55 (get self55 1))) (let ((self56 f49)) (case (get self56 0) ('Maybe.none ($Parser.Reply.error f55)) ('Maybe.some (let ((f56 (get self56 1))) ($Parser.Reply.error ($Parser.Error.combine f56 f55)))))))) ('Parser.Reply.value (let ((f55 (get self55 1))) (let ((f56 (get self55 2))) (let ((self57 f55)) (case (get self57 0) ('Parser.State.new (let ((f57 (get self57 1))) (let ((f58 (get self57 2))) (let ((f59 (get self57 3))) (let ((f60 (get self57 4))) (let ((f61 (get self57 5))) (let ((reply.pst$62 ($Parser.State.new ($Parser.Error.maybe_combine f49 f57) f58 f59 f60 f61))) (let ((bits$63 ($Bits.reverse ($Bits.tail ($Bits.reverse ($Nat.to_bits f56)))))) ($Parser.Reply.value reply.pst$62 bits$63)))))))))))))))))))))))))))))))))))))))))))))))))) reply.pst$28))) (let ((self35 reply$34)) (case (get self35 0) ('Parser.Reply.error (let ((f35 (get self35 1))) (let ((self36 f29)) (case (get self36 0) ('Maybe.none ($Parser.Reply.error f35)) ('Maybe.some (let ((f36 (get self36 1))) ($Parser.Reply.error ($Parser.Error.combine f36 f35)))))))) ('Parser.Reply.value (let ((f35 (get self35 1))) (let ((f36 (get self35 2))) (let ((self37 f35)) (case (get self37 0) ('Parser.State.new (let ((f37 (get self37 1))) (let ((f38 (get self37 2))) (let ((f39 (get self37 3))) (let ((f40 (get self37 4))) (let ((f41 (get self37 5))) (let ((reply.pst$42 ($Parser.State.new ($Parser.Error.maybe_combine f29 f37) f38 f39 f40 f41))) (let ((self43 reply.pst$42)) (case (get self43 0) ('Parser.State.new (let ((f43 (get self43 1))) (let ((f44 (get self43 2))) (let ((f45 (get self43 3))) (let ((f46 (get self43 4))) (let ((f47 (get self43 5))) (let ((reply$48 (let ((self48 reply.pst$42)) (case (get self48 0) ('Parser.State.new (let ((f48 (get self48 1))) (let ((f49 (get self48 2))) (let ((f50 (get self48 3))) (let ((f51 (get self48 4))) (let ((f52 (get self48 5))) (let ((reply$53 ($Parser.maybe (Parser.text "-") reply.pst$42))) (let ((self54 reply$53)) (case (get self54 0) ('Parser.Reply.error (let ((f54 (get self54 1))) (let ((self55 f48)) (case (get self55 0) ('Maybe.none ($Parser.Reply.error f54)) ('Maybe.some (let ((f55 (get self55 1))) ($Parser.Reply.error ($Parser.Error.combine f55 f54)))))))) ('Parser.Reply.value (let ((f54 (get self54 1))) (let ((f55 (get self54 2))) (let ((self56 f54)) (case (get self56 0) ('Parser.State.new (let ((f56 (get self56 1))) (let ((f57 (get self56 2))) (let ((f58 (get self56 3))) (let ((f59 (get self56 4))) (let ((f60 (get self56 5))) (let ((reply.pst$61 ($Parser.State.new ($Parser.Error.maybe_combine f48 f56) f57 f58 f59 f60))) ($Parser.Reply.value reply.pst$61 ($Maybe.is_some f55))))))))))))))))))))))))))) (let ((self49 reply$48)) (case (get self49 0) ('Parser.Reply.error (let ((f49 (get self49 1))) (let ((self50 f43)) (case (get self50 0) ('Maybe.none ($Parser.Reply.error f49)) ('Maybe.some (let ((f50 (get self50 1))) ($Parser.Reply.error ($Parser.Error.combine f50 f49)))))))) ('Parser.Reply.value (let ((f49 (get self49 1))) (let ((f50 (get self49 2))) (let ((self51 f49)) (case (get self51 0) ('Parser.State.new (let ((f51 (get self51 1))) (let ((f52 (get self51 2))) (let ((f53 (get self51 3))) (let ((f54 (get self51 4))) (let ((f55 (get self51 5))) (let ((reply.pst$56 ($Parser.State.new ($Parser.Error.maybe_combine f43 f51) f52 f53 f54 f55))) ($Parser.Reply.value reply.pst$56 ($Kind.Term.gol f22 f36 f50)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.hole ((Kind.Parser.block "hole") (lambda (pst$0) (let ((self1 pst$0)) (case (get self1 0) ('Parser.State.new (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((reply$6 ($Kind.Parser.text "_" pst$0))) (let ((self7 reply$6)) (case (get self7 0) ('Parser.Reply.error (let ((f7 (get self7 1))) (let ((self8 f1)) (case (get self8 0) ('Maybe.none ($Parser.Reply.error f7)) ('Maybe.some (let ((f8 (get self8 1))) ($Parser.Reply.error ($Parser.Error.combine f8 f7)))))))) ('Parser.Reply.value (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((self9 f7)) (case (get self9 0) ('Parser.State.new (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) (let ((reply.pst$14 ($Parser.State.new ($Parser.Error.maybe_combine f1 f9) f10 f11 f12 f13))) ($Parser.Reply.value reply.pst$14 ($Kind.Term.hol Bits.e))))))))))))))))))))))))))))
(define ($Kind.Parser.float.sign pst$0) (let ((self0 pst$0)) (case (get self0 0) ('Parser.State.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((self5 f4)) (case (<= (kstring-length self5) 0) (#t ($Parser.Reply.fail f1 f2 f3 "Expected '+' or '-'.")) (#f (let ((f5 (char->integer (kstring-head self5)))) (let ((f6 (kstring-tail self5))) (let ((self7 ($Bool.or ($U16.eql f5 43) ($U16.eql f5 45)))) (case self7 (#t ($Parser.Reply.value pst$0 f5)) (#f ($Parser.Reply.fail f1 f2 f3 "Expected '+' ou '-'."))))))))))))))))))
(define Kind.Parser.float.sign (lambda (pst$0) ($Kind.Parser.float.sign pst$0)))
(define ($List.any cond$1 list$2) (let ((self0 list$2)) (case (get self0 0) ('List.nil Bool.false) ('List.cons (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((self2 (cond$1 f0))) (case self2 (#t Bool.true) (#f ($List.any cond$1 f1))))))))))
(define List.any (lambda (cond$1) (lambda (list$2) ($List.any cond$1 list$2))))
(define ($Kind.Parser.float.str_digit pst$0) (let ((self0 pst$0)) (case (get self0 0) ('Parser.State.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((self5 f4)) (case (<= (kstring-length self5) 0) (#t ($Parser.Reply.fail f1 f2 f3 "Not a digit.")) (#f (let ((f5 (char->integer (kstring-head self5)))) (let ((f6 (kstring-tail self5))) (let ((digits$8 ($List.cons 48 ($List.cons 49 ($List.cons 50 ($List.cons 51 ($List.cons 52 ($List.cons 52 ($List.cons 53 ($List.cons 54 ($List.cons 55 ($List.cons 56 ($List.cons 57 List.nil))))))))))))) (let ((pst$9 ($Parser.State.new f0 f1 f2 ($Nat.succ f3) f6))) (let ((self9 ($List.any (U16.eql f5) digits$8))) (case self9 (#t ($Parser.Reply.value pst$9 f5)) (#f ($Parser.Reply.fail f1 f2 f3 "Not a digit."))))))))))))))))))))
(define Kind.Parser.float.str_digit (lambda (pst$0) ($Kind.Parser.float.str_digit pst$0)))
(define ($String.from_list xs$0) (let ((self0 xs$0)) (case (get self0 0) ('List.nil String.nil) ('List.cons (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($String.cons f0 ($String.from_list f1))))))))
(define String.from_list (lambda (xs$0) ($String.from_list xs$0)))
(define Kind.Parser.float.64 ((Kind.Parser.block "float") (lambda (pst$0) (let ((self1 pst$0)) (case (get self1 0) ('Parser.State.new (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((reply$6 ($Parser.maybe Kind.Parser.float.sign pst$0))) (let ((self7 reply$6)) (case (get self7 0) ('Parser.Reply.error (let ((f7 (get self7 1))) (let ((self8 f1)) (case (get self8 0) ('Maybe.none ($Parser.Reply.error f7)) ('Maybe.some (let ((f8 (get self8 1))) ($Parser.Reply.error ($Parser.Error.combine f8 f7)))))))) ('Parser.Reply.value (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((self9 f7)) (case (get self9 0) ('Parser.State.new (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) (let ((reply.pst$14 ($Parser.State.new ($Parser.Error.maybe_combine f1 f9) f10 f11 f12 f13))) (let ((sign$15 ($Maybe.default f8 43))) (let ((self16 reply.pst$14)) (case (get self16 0) ('Parser.State.new (let ((f16 (get self16 1))) (let ((f17 (get self16 2))) (let ((f18 (get self16 3))) (let ((f19 (get self16 4))) (let ((f20 (get self16 5))) (let ((reply$21 ($Parser.many1 Kind.Parser.float.str_digit reply.pst$14))) (let ((self22 reply$21)) (case (get self22 0) ('Parser.Reply.error (let ((f22 (get self22 1))) (let ((self23 f16)) (case (get self23 0) ('Maybe.none ($Parser.Reply.error f22)) ('Maybe.some (let ((f23 (get self23 1))) ($Parser.Reply.error ($Parser.Error.combine f23 f22)))))))) ('Parser.Reply.value (let ((f22 (get self22 1))) (let ((f23 (get self22 2))) (let ((self24 f22)) (case (get self24 0) ('Parser.State.new (let ((f24 (get self24 1))) (let ((f25 (get self24 2))) (let ((f26 (get self24 3))) (let ((f27 (get self24 4))) (let ((f28 (get self24 5))) (let ((reply.pst$29 ($Parser.State.new ($Parser.Error.maybe_combine f16 f24) f25 f26 f27 f28))) (let ((self30 reply.pst$29)) (case (get self30 0) ('Parser.State.new (let ((f30 (get self30 1))) (let ((f31 (get self30 2))) (let ((f32 (get self30 3))) (let ((f33 (get self30 4))) (let ((f34 (get self30 5))) (let ((reply$35 ($Parser.text "." reply.pst$29))) (let ((self36 reply$35)) (case (get self36 0) ('Parser.Reply.error (let ((f36 (get self36 1))) (let ((self37 f30)) (case (get self37 0) ('Maybe.none ($Parser.Reply.error f36)) ('Maybe.some (let ((f37 (get self37 1))) ($Parser.Reply.error ($Parser.Error.combine f37 f36)))))))) ('Parser.Reply.value (let ((f36 (get self36 1))) (let ((f37 (get self36 2))) (let ((self38 f36)) (case (get self38 0) ('Parser.State.new (let ((f38 (get self38 1))) (let ((f39 (get self38 2))) (let ((f40 (get self38 3))) (let ((f41 (get self38 4))) (let ((f42 (get self38 5))) (let ((reply.pst$43 ($Parser.State.new ($Parser.Error.maybe_combine f30 f38) f39 f40 f41 f42))) (let ((self44 reply.pst$43)) (case (get self44 0) ('Parser.State.new (let ((f44 (get self44 1))) (let ((f45 (get self44 2))) (let ((f46 (get self44 3))) (let ((f47 (get self44 4))) (let ((f48 (get self44 5))) (let ((reply$49 ($Parser.many1 Kind.Parser.float.str_digit reply.pst$43))) (let ((self50 reply$49)) (case (get self50 0) ('Parser.Reply.error (let ((f50 (get self50 1))) (let ((self51 f44)) (case (get self51 0) ('Maybe.none ($Parser.Reply.error f50)) ('Maybe.some (let ((f51 (get self51 1))) ($Parser.Reply.error ($Parser.Error.combine f51 f50)))))))) ('Parser.Reply.value (let ((f50 (get self50 1))) (let ((f51 (get self50 2))) (let ((self52 f50)) (case (get self52 0) ('Parser.State.new (let ((f52 (get self52 1))) (let ((f53 (get self52 2))) (let ((f54 (get self52 3))) (let ((f55 (get self52 4))) (let ((f56 (get self52 5))) (let ((reply.pst$57 ($Parser.State.new ($Parser.Error.maybe_combine f44 f52) f53 f54 f55 f56))) (let ((self58 reply.pst$57)) (case (get self58 0) ('Parser.State.new (let ((f58 (get self58 1))) (let ((f59 (get self58 2))) (let ((f60 (get self58 3))) (let ((f61 (get self58 4))) (let ((f62 (get self58 5))) (let ((reply$63 ($Parser.text "#64" reply.pst$57))) (let ((self64 reply$63)) (case (get self64 0) ('Parser.Reply.error (let ((f64 (get self64 1))) (let ((self65 f58)) (case (get self65 0) ('Maybe.none ($Parser.Reply.error f64)) ('Maybe.some (let ((f65 (get self65 1))) ($Parser.Reply.error ($Parser.Error.combine f65 f64)))))))) ('Parser.Reply.value (let ((f64 (get self64 1))) (let ((f65 (get self64 2))) (let ((self66 f64)) (case (get self66 0) ('Parser.State.new (let ((f66 (get self66 1))) (let ((f67 (get self66 2))) (let ((f68 (get self66 3))) (let ((f69 (get self66 4))) (let ((f70 (get self66 5))) (let ((reply.pst$71 ($Parser.State.new ($Parser.Error.maybe_combine f58 f66) f67 f68 f69 f70))) (let ((float_str$72 ($Kind.Term.str ($String.concat ($String.cons sign$15 ($String.from_list f23)) ($String.concat "." ($String.from_list f51)))))) (let ((conv$73 ($Kind.Term.ref "F64.parse"))) (let ((term$74 ($Kind.Term.app conv$73 float_str$72))) ($Parser.Reply.value reply.pst$71 term$74)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.float.32 ((Kind.Parser.block "float") (lambda (pst$0) (let ((self1 pst$0)) (case (get self1 0) ('Parser.State.new (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((reply$6 ($Parser.maybe Kind.Parser.float.sign pst$0))) (let ((self7 reply$6)) (case (get self7 0) ('Parser.Reply.error (let ((f7 (get self7 1))) (let ((self8 f1)) (case (get self8 0) ('Maybe.none ($Parser.Reply.error f7)) ('Maybe.some (let ((f8 (get self8 1))) ($Parser.Reply.error ($Parser.Error.combine f8 f7)))))))) ('Parser.Reply.value (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((self9 f7)) (case (get self9 0) ('Parser.State.new (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) (let ((reply.pst$14 ($Parser.State.new ($Parser.Error.maybe_combine f1 f9) f10 f11 f12 f13))) (let ((sign$15 ($Maybe.default f8 43))) (let ((self16 reply.pst$14)) (case (get self16 0) ('Parser.State.new (let ((f16 (get self16 1))) (let ((f17 (get self16 2))) (let ((f18 (get self16 3))) (let ((f19 (get self16 4))) (let ((f20 (get self16 5))) (let ((reply$21 ($Parser.many1 Kind.Parser.float.str_digit reply.pst$14))) (let ((self22 reply$21)) (case (get self22 0) ('Parser.Reply.error (let ((f22 (get self22 1))) (let ((self23 f16)) (case (get self23 0) ('Maybe.none ($Parser.Reply.error f22)) ('Maybe.some (let ((f23 (get self23 1))) ($Parser.Reply.error ($Parser.Error.combine f23 f22)))))))) ('Parser.Reply.value (let ((f22 (get self22 1))) (let ((f23 (get self22 2))) (let ((self24 f22)) (case (get self24 0) ('Parser.State.new (let ((f24 (get self24 1))) (let ((f25 (get self24 2))) (let ((f26 (get self24 3))) (let ((f27 (get self24 4))) (let ((f28 (get self24 5))) (let ((reply.pst$29 ($Parser.State.new ($Parser.Error.maybe_combine f16 f24) f25 f26 f27 f28))) (let ((self30 reply.pst$29)) (case (get self30 0) ('Parser.State.new (let ((f30 (get self30 1))) (let ((f31 (get self30 2))) (let ((f32 (get self30 3))) (let ((f33 (get self30 4))) (let ((f34 (get self30 5))) (let ((reply$35 ($Parser.text "." reply.pst$29))) (let ((self36 reply$35)) (case (get self36 0) ('Parser.Reply.error (let ((f36 (get self36 1))) (let ((self37 f30)) (case (get self37 0) ('Maybe.none ($Parser.Reply.error f36)) ('Maybe.some (let ((f37 (get self37 1))) ($Parser.Reply.error ($Parser.Error.combine f37 f36)))))))) ('Parser.Reply.value (let ((f36 (get self36 1))) (let ((f37 (get self36 2))) (let ((self38 f36)) (case (get self38 0) ('Parser.State.new (let ((f38 (get self38 1))) (let ((f39 (get self38 2))) (let ((f40 (get self38 3))) (let ((f41 (get self38 4))) (let ((f42 (get self38 5))) (let ((reply.pst$43 ($Parser.State.new ($Parser.Error.maybe_combine f30 f38) f39 f40 f41 f42))) (let ((self44 reply.pst$43)) (case (get self44 0) ('Parser.State.new (let ((f44 (get self44 1))) (let ((f45 (get self44 2))) (let ((f46 (get self44 3))) (let ((f47 (get self44 4))) (let ((f48 (get self44 5))) (let ((reply$49 ($Parser.many1 Kind.Parser.float.str_digit reply.pst$43))) (let ((self50 reply$49)) (case (get self50 0) ('Parser.Reply.error (let ((f50 (get self50 1))) (let ((self51 f44)) (case (get self51 0) ('Maybe.none ($Parser.Reply.error f50)) ('Maybe.some (let ((f51 (get self51 1))) ($Parser.Reply.error ($Parser.Error.combine f51 f50)))))))) ('Parser.Reply.value (let ((f50 (get self50 1))) (let ((f51 (get self50 2))) (let ((self52 f50)) (case (get self52 0) ('Parser.State.new (let ((f52 (get self52 1))) (let ((f53 (get self52 2))) (let ((f54 (get self52 3))) (let ((f55 (get self52 4))) (let ((f56 (get self52 5))) (let ((reply.pst$57 ($Parser.State.new ($Parser.Error.maybe_combine f44 f52) f53 f54 f55 f56))) (let ((self58 reply.pst$57)) (case (get self58 0) ('Parser.State.new (let ((f58 (get self58 1))) (let ((f59 (get self58 2))) (let ((f60 (get self58 3))) (let ((f61 (get self58 4))) (let ((f62 (get self58 5))) (let ((reply$63 ($Parser.text "#32" reply.pst$57))) (let ((self64 reply$63)) (case (get self64 0) ('Parser.Reply.error (let ((f64 (get self64 1))) (let ((self65 f58)) (case (get self65 0) ('Maybe.none ($Parser.Reply.error f64)) ('Maybe.some (let ((f65 (get self65 1))) ($Parser.Reply.error ($Parser.Error.combine f65 f64)))))))) ('Parser.Reply.value (let ((f64 (get self64 1))) (let ((f65 (get self64 2))) (let ((self66 f64)) (case (get self66 0) ('Parser.State.new (let ((f66 (get self66 1))) (let ((f67 (get self66 2))) (let ((f68 (get self66 3))) (let ((f69 (get self66 4))) (let ((f70 (get self66 5))) (let ((reply.pst$71 ($Parser.State.new ($Parser.Error.maybe_combine f58 f66) f67 f68 f69 f70))) (let ((float_str$72 ($Kind.Term.str ($String.concat ($String.cons sign$15 ($String.from_list f23)) ($String.concat "." ($String.from_list f51)))))) (let ((conv$73 ($Kind.Term.ref "F32.parse"))) (let ((term$74 ($Kind.Term.app conv$73 float_str$72))) ($Parser.Reply.value reply.pst$71 term$74)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(define ($Either.left value$2) (vector 'Either.left value$2))
(define Either.left (lambda (value$2) ($Either.left value$2)))
(define ($Either.right value$2) (vector 'Either.right value$2))
(define Either.right (lambda (value$2) ($Either.right value$2)))
(define ($Nat.sub_rem n$0 m$1) (let ((self0 m$1)) (case (= self0 0) (#t ($Either.left n$0)) (#f (let ((f0 (- self0 1))) (let ((self1 n$0)) (case (= self1 0) (#t ($Either.right ($Nat.succ f0))) (#f (let ((f1 (- self1 1))) ($Nat.sub_rem f1 f0))))))))))
(define Nat.sub_rem (lambda (n$0) (lambda (m$1) ($Nat.sub_rem n$0 m$1))))
(define ($Nat.div_mod.go n$0 m$1 d$2) (let ((self0 ($Nat.sub_rem n$0 m$1))) (case (get self0 0) ('Either.left (let ((f0 (get self0 1))) ($Nat.div_mod.go f0 m$1 ($Nat.succ d$2)))) ('Either.right (let ((f0 (get self0 1))) ($Pair.new d$2 n$0))))))
(define Nat.div_mod.go (lambda (n$0) (lambda (m$1) (lambda (d$2) ($Nat.div_mod.go n$0 m$1 d$2)))))
(define ($Nat.div_mod n$0 m$1) ($Nat.div_mod.go n$0 m$1 Nat.zero))
(define Nat.div_mod (lambda (n$0) (lambda (m$1) ($Nat.div_mod n$0 m$1))))
(define ($Nat.to_base.go base$0 nat$1 res$2) (let ((self0 ($Nat.div_mod nat$1 base$0))) (case (get self0 0) ('Pair.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((self2 f0)) (case (= self2 0) (#t ($List.cons f1 res$2)) (#f (let ((f2 (- self2 1))) ($Nat.to_base.go base$0 f0 ($List.cons f1 res$2))))))))))))
(define Nat.to_base.go (lambda (base$0) (lambda (nat$1) (lambda (res$2) ($Nat.to_base.go base$0 nat$1 res$2)))))
(define ($Nat.to_base base$0 nat$1) ($Nat.to_base.go base$0 nat$1 List.nil))
(define Nat.to_base (lambda (base$0) (lambda (nat$1) ($Nat.to_base base$0 nat$1))))
(define ($Nat.mod.go n$0 m$1 r$2) (let ((self0 m$1)) (case (= self0 0) (#t ($Nat.mod.go n$0 r$2 m$1)) (#f (let ((f0 (- self0 1))) (let ((self1 n$0)) (case (= self1 0) (#t r$2) (#f (let ((f1 (- self1 1))) ($Nat.mod.go f1 f0 ($Nat.succ r$2)))))))))))
(define Nat.mod.go (lambda (n$0) (lambda (m$1) (lambda (r$2) ($Nat.mod.go n$0 m$1 r$2)))))
(define ($Nat.mod n$0 m$1) (mod n$0 m$1))
(define Nat.mod (lambda (n$0) (lambda (m$1) ($Nat.mod n$0 m$1))))
(define ($Nat.lte n$0 m$1) (<= n$0 m$1))
(define Nat.lte (lambda (n$0) (lambda (m$1) ($Nat.lte n$0 m$1))))
(define ($List.at index$1 list$2) (let ((self0 list$2)) (case (get self0 0) ('List.nil Maybe.none) ('List.cons (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((self2 index$1)) (case (= self2 0) (#t ($Maybe.some f0)) (#f (let ((f2 (- self2 1))) ($List.at f2 f1)))))))))))
(define List.at (lambda (index$1) (lambda (list$2) ($List.at index$1 list$2))))
(define ($Nat.show_digit base$0 n$1) (let ((m$2 ($Nat.mod n$1 base$0))) (let ((base64$3 ($List.cons 48 ($List.cons 49 ($List.cons 50 ($List.cons 51 ($List.cons 52 ($List.cons 53 ($List.cons 54 ($List.cons 55 ($List.cons 56 ($List.cons 57 ($List.cons 97 ($List.cons 98 ($List.cons 99 ($List.cons 100 ($List.cons 101 ($List.cons 102 ($List.cons 103 ($List.cons 104 ($List.cons 105 ($List.cons 106 ($List.cons 107 ($List.cons 108 ($List.cons 109 ($List.cons 110 ($List.cons 111 ($List.cons 112 ($List.cons 113 ($List.cons 114 ($List.cons 115 ($List.cons 116 ($List.cons 117 ($List.cons 118 ($List.cons 119 ($List.cons 120 ($List.cons 121 ($List.cons 122 ($List.cons 65 ($List.cons 66 ($List.cons 67 ($List.cons 68 ($List.cons 69 ($List.cons 70 ($List.cons 71 ($List.cons 72 ($List.cons 73 ($List.cons 74 ($List.cons 75 ($List.cons 76 ($List.cons 77 ($List.cons 78 ($List.cons 79 ($List.cons 80 ($List.cons 81 ($List.cons 82 ($List.cons 83 ($List.cons 84 ($List.cons 85 ($List.cons 86 ($List.cons 87 ($List.cons 88 ($List.cons 89 ($List.cons 90 ($List.cons 43 ($List.cons 47 List.nil)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) (let ((self2 ($Bool.and ($Nat.gtn base$0 0) ($Nat.lte base$0 64)))) (case self2 (#t (let ((self2 ($List.at m$2 base64$3))) (case (get self2 0) ('Maybe.none 35) ('Maybe.some (let ((f2 (get self2 1))) f2))))) (#f 35))))))
(define Nat.show_digit (lambda (base$0) (lambda (n$1) ($Nat.show_digit base$0 n$1))))
(define ($Nat.to_string_base base$0 nat$1) ($List.fold ($Nat.to_base base$0 nat$1) String.nil (lambda (n$2) (lambda (str$3) ($String.cons ($Nat.show_digit base$0 n$2) str$3)))))
(define Nat.to_string_base (lambda (base$0) (lambda (nat$1) ($Nat.to_string_base base$0 nat$1))))
(define ($Nat.show n$0) (number->string n$0))
(define Nat.show (lambda (n$0) ($Nat.show n$0)))
(define ($Kind.Parser.int_pos pst$0) (let ((self0 pst$0)) (case (get self0 0) ('Parser.State.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((reply$6 ($Parser.text "+" pst$0))) (let ((self6 reply$6)) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))) (let ((self7 f0)) (case (get self7 0) ('Maybe.none ($Parser.Reply.error f6)) ('Maybe.some (let ((f7 (get self7 1))) ($Parser.Reply.error ($Parser.Error.combine f7 f6)))))))) ('Parser.Reply.value (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((self8 f6)) (case (get self8 0) ('Parser.State.new (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) (let ((f11 (get self8 4))) (let ((f12 (get self8 5))) (let ((reply.pst$14 ($Parser.State.new ($Parser.Error.maybe_combine f0 f8) f9 f10 f11 f12))) (let ((self14 reply.pst$14)) (case (get self14 0) ('Parser.State.new (let ((f14 (get self14 1))) (let ((f15 (get self14 2))) (let ((f16 (get self14 3))) (let ((f17 (get self14 4))) (let ((f18 (get self14 5))) (let ((reply$20 ($Parser.many1 Parser.digit reply.pst$14))) (let ((self20 reply$20)) (case (get self20 0) ('Parser.Reply.error (let ((f20 (get self20 1))) (let ((self21 f14)) (case (get self21 0) ('Maybe.none ($Parser.Reply.error f20)) ('Maybe.some (let ((f21 (get self21 1))) ($Parser.Reply.error ($Parser.Error.combine f21 f20)))))))) ('Parser.Reply.value (let ((f20 (get self20 1))) (let ((f21 (get self20 2))) (let ((self22 f20)) (case (get self22 0) ('Parser.State.new (let ((f22 (get self22 1))) (let ((f23 (get self22 2))) (let ((f24 (get self22 3))) (let ((f25 (get self22 4))) (let ((f26 (get self22 5))) (let ((reply.pst$28 ($Parser.State.new ($Parser.Error.maybe_combine f14 f22) f23 f24 f25 f26))) ($Parser.Reply.value reply.pst$28 ($Pair.new Bool.true ($Nat.from_base 10 f21))))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.int_pos (lambda (pst$0) ($Kind.Parser.int_pos pst$0)))
(define ($Kind.Parser.int_neg pst$0) (let ((self0 pst$0)) (case (get self0 0) ('Parser.State.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((reply$6 ($Parser.text "-" pst$0))) (let ((self6 reply$6)) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))) (let ((self7 f0)) (case (get self7 0) ('Maybe.none ($Parser.Reply.error f6)) ('Maybe.some (let ((f7 (get self7 1))) ($Parser.Reply.error ($Parser.Error.combine f7 f6)))))))) ('Parser.Reply.value (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((self8 f6)) (case (get self8 0) ('Parser.State.new (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) (let ((f11 (get self8 4))) (let ((f12 (get self8 5))) (let ((reply.pst$14 ($Parser.State.new ($Parser.Error.maybe_combine f0 f8) f9 f10 f11 f12))) (let ((self14 reply.pst$14)) (case (get self14 0) ('Parser.State.new (let ((f14 (get self14 1))) (let ((f15 (get self14 2))) (let ((f16 (get self14 3))) (let ((f17 (get self14 4))) (let ((f18 (get self14 5))) (let ((reply$20 ($Parser.many1 Parser.digit reply.pst$14))) (let ((self20 reply$20)) (case (get self20 0) ('Parser.Reply.error (let ((f20 (get self20 1))) (let ((self21 f14)) (case (get self21 0) ('Maybe.none ($Parser.Reply.error f20)) ('Maybe.some (let ((f21 (get self21 1))) ($Parser.Reply.error ($Parser.Error.combine f21 f20)))))))) ('Parser.Reply.value (let ((f20 (get self20 1))) (let ((f21 (get self20 2))) (let ((self22 f20)) (case (get self22 0) ('Parser.State.new (let ((f22 (get self22 1))) (let ((f23 (get self22 2))) (let ((f24 (get self22 3))) (let ((f25 (get self22 4))) (let ((f26 (get self22 5))) (let ((reply.pst$28 ($Parser.State.new ($Parser.Error.maybe_combine f14 f22) f23 f24 f25 f26))) ($Parser.Reply.value reply.pst$28 ($Pair.new Bool.false ($Nat.from_base 10 f21))))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.int_neg (lambda (pst$0) ($Kind.Parser.int_neg pst$0)))
(define ($Kind.Parser.machine_integer.signed size$0) ((Kind.Parser.block "int") (let ((size_str$1 ($Nat.show size$0))) (lambda (pst$2) (let ((self2 pst$2)) (case (get self2 0) ('Parser.State.new (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) (let ((f5 (get self2 4))) (let ((f6 (get self2 5))) (let ((reply$8 (Kind.Parser.spaces pst$2))) (let ((self8 reply$8)) (case (get self8 0) ('Parser.Reply.error (let ((f8 (get self8 1))) (let ((self9 f2)) (case (get self9 0) ('Maybe.none ($Parser.Reply.error f8)) ('Maybe.some (let ((f9 (get self9 1))) ($Parser.Reply.error ($Parser.Error.combine f9 f8)))))))) ('Parser.Reply.value (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((self10 f8)) (case (get self10 0) ('Parser.State.new (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) (let ((f13 (get self10 4))) (let ((f14 (get self10 5))) (let ((reply.pst$16 ($Parser.State.new ($Parser.Error.maybe_combine f2 f10) f11 f12 f13 f14))) (let ((self16 reply.pst$16)) (case (get self16 0) ('Parser.State.new (let ((f16 (get self16 1))) (let ((f17 (get self16 2))) (let ((f18 (get self16 3))) (let ((f19 (get self16 4))) (let ((f20 (get self16 5))) (let ((reply$22 ($Parser.choice ($List.cons Kind.Parser.int_pos ($List.cons Kind.Parser.int_neg List.nil)) reply.pst$16))) (let ((self22 reply$22)) (case (get self22 0) ('Parser.Reply.error (let ((f22 (get self22 1))) (let ((self23 f16)) (case (get self23 0) ('Maybe.none ($Parser.Reply.error f22)) ('Maybe.some (let ((f23 (get self23 1))) ($Parser.Reply.error ($Parser.Error.combine f23 f22)))))))) ('Parser.Reply.value (let ((f22 (get self22 1))) (let ((f23 (get self22 2))) (let ((self24 f22)) (case (get self24 0) ('Parser.State.new (let ((f24 (get self24 1))) (let ((f25 (get self24 2))) (let ((f26 (get self24 3))) (let ((f27 (get self24 4))) (let ((f28 (get self24 5))) (let ((reply.pst$30 ($Parser.State.new ($Parser.Error.maybe_combine f16 f24) f25 f26 f27 f28))) (let ((self30 reply.pst$30)) (case (get self30 0) ('Parser.State.new (let ((f30 (get self30 1))) (let ((f31 (get self30 2))) (let ((f32 (get self30 3))) (let ((f33 (get self30 4))) (let ((f34 (get self30 5))) (let ((reply$36 ($Parser.text ($String.concat "#" size_str$1) reply.pst$30))) (let ((self36 reply$36)) (case (get self36 0) ('Parser.Reply.error (let ((f36 (get self36 1))) (let ((self37 f30)) (case (get self37 0) ('Maybe.none ($Parser.Reply.error f36)) ('Maybe.some (let ((f37 (get self37 1))) ($Parser.Reply.error ($Parser.Error.combine f37 f36)))))))) ('Parser.Reply.value (let ((f36 (get self36 1))) (let ((f37 (get self36 2))) (let ((self38 f36)) (case (get self38 0) ('Parser.State.new (let ((f38 (get self38 1))) (let ((f39 (get self38 2))) (let ((f40 (get self38 3))) (let ((f41 (get self38 4))) (let ((f42 (get self38 5))) (let ((reply.pst$44 ($Parser.State.new ($Parser.Error.maybe_combine f30 f38) f39 f40 f41 f42))) ($Parser.Reply.value reply.pst$44 (let ((self44 f23)) (case (get self44 0) ('Pair.new (let ((f44 (get self44 1))) (let ((f45 (get self44 2))) (let ((term$47 ($Kind.Term.ref ($String.concat "I" ($String.concat size_str$1 ".from_nat"))))) (let ((term$48 ($Kind.Term.app term$47 ($Kind.Term.nat f45)))) (let ((term$49 (let ((self48 f44)) (case self48 (#t term$48) (#f ($Kind.Term.app ($Kind.Term.ref ($String.concat "I" ($String.concat size_str$1 ".neg"))) term$48)))))) term$49))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.machine_integer.signed (lambda (size$0) ($Kind.Parser.machine_integer.signed size$0)))
(define ($Parser.hex_digit pst$0) (let ((self0 pst$0)) (case (get self0 0) ('Parser.State.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((self5 f4)) (case (<= (kstring-length self5) 0) (#t ($Parser.Reply.fail f1 f2 f3 "Not a digit.")) (#f (let ((f5 (char->integer (kstring-head self5)))) (let ((f6 (kstring-tail self5))) (let ((pst$8 ($Parser.State.new f0 f1 f2 ($Nat.succ f3) f6))) (let ((self8 ($U16.eql f5 48))) (case self8 (#t ($Parser.Reply.value pst$8 0)) (#f (let ((self8 ($U16.eql f5 49))) (case self8 (#t ($Parser.Reply.value pst$8 1)) (#f (let ((self8 ($U16.eql f5 50))) (case self8 (#t ($Parser.Reply.value pst$8 2)) (#f (let ((self8 ($U16.eql f5 51))) (case self8 (#t ($Parser.Reply.value pst$8 3)) (#f (let ((self8 ($U16.eql f5 52))) (case self8 (#t ($Parser.Reply.value pst$8 4)) (#f (let ((self8 ($U16.eql f5 53))) (case self8 (#t ($Parser.Reply.value pst$8 5)) (#f (let ((self8 ($U16.eql f5 54))) (case self8 (#t ($Parser.Reply.value pst$8 6)) (#f (let ((self8 ($U16.eql f5 55))) (case self8 (#t ($Parser.Reply.value pst$8 7)) (#f (let ((self8 ($U16.eql f5 56))) (case self8 (#t ($Parser.Reply.value pst$8 8)) (#f (let ((self8 ($U16.eql f5 57))) (case self8 (#t ($Parser.Reply.value pst$8 9)) (#f (let ((self8 ($U16.eql f5 97))) (case self8 (#t ($Parser.Reply.value pst$8 10)) (#f (let ((self8 ($U16.eql f5 98))) (case self8 (#t ($Parser.Reply.value pst$8 11)) (#f (let ((self8 ($U16.eql f5 99))) (case self8 (#t ($Parser.Reply.value pst$8 12)) (#f (let ((self8 ($U16.eql f5 100))) (case self8 (#t ($Parser.Reply.value pst$8 13)) (#f (let ((self8 ($U16.eql f5 101))) (case self8 (#t ($Parser.Reply.value pst$8 14)) (#f (let ((self8 ($U16.eql f5 102))) (case self8 (#t ($Parser.Reply.value pst$8 15)) (#f (let ((self8 ($U16.eql f5 65))) (case self8 (#t ($Parser.Reply.value pst$8 10)) (#f (let ((self8 ($U16.eql f5 66))) (case self8 (#t ($Parser.Reply.value pst$8 11)) (#f (let ((self8 ($U16.eql f5 67))) (case self8 (#t ($Parser.Reply.value pst$8 12)) (#f (let ((self8 ($U16.eql f5 68))) (case self8 (#t ($Parser.Reply.value pst$8 13)) (#f (let ((self8 ($U16.eql f5 69))) (case self8 (#t ($Parser.Reply.value pst$8 14)) (#f (let ((self8 ($U16.eql f5 70))) (case self8 (#t ($Parser.Reply.value pst$8 15)) (#f ($Parser.Reply.fail f1 f2 f3 "Not a digit."))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(define Parser.hex_digit (lambda (pst$0) ($Parser.hex_digit pst$0)))
(define ($Parser.hex_nat pst$0) (let ((self0 pst$0)) (case (get self0 0) ('Parser.State.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((reply$6 ($Parser.text "0x" pst$0))) (let ((self6 reply$6)) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))) (let ((self7 f0)) (case (get self7 0) ('Maybe.none ($Parser.Reply.error f6)) ('Maybe.some (let ((f7 (get self7 1))) ($Parser.Reply.error ($Parser.Error.combine f7 f6)))))))) ('Parser.Reply.value (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((self8 f6)) (case (get self8 0) ('Parser.State.new (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) (let ((f11 (get self8 4))) (let ((f12 (get self8 5))) (let ((reply.pst$14 ($Parser.State.new ($Parser.Error.maybe_combine f0 f8) f9 f10 f11 f12))) (let ((self14 reply.pst$14)) (case (get self14 0) ('Parser.State.new (let ((f14 (get self14 1))) (let ((f15 (get self14 2))) (let ((f16 (get self14 3))) (let ((f17 (get self14 4))) (let ((f18 (get self14 5))) (let ((reply$20 ($Parser.many1 Parser.hex_digit reply.pst$14))) (let ((self20 reply$20)) (case (get self20 0) ('Parser.Reply.error (let ((f20 (get self20 1))) (let ((self21 f14)) (case (get self21 0) ('Maybe.none ($Parser.Reply.error f20)) ('Maybe.some (let ((f21 (get self21 1))) ($Parser.Reply.error ($Parser.Error.combine f21 f20)))))))) ('Parser.Reply.value (let ((f20 (get self20 1))) (let ((f21 (get self20 2))) (let ((self22 f20)) (case (get self22 0) ('Parser.State.new (let ((f22 (get self22 1))) (let ((f23 (get self22 2))) (let ((f24 (get self22 3))) (let ((f25 (get self22 4))) (let ((f26 (get self22 5))) (let ((reply.pst$28 ($Parser.State.new ($Parser.Error.maybe_combine f14 f22) f23 f24 f25 f26))) ($Parser.Reply.value reply.pst$28 ($Nat.from_base 16 f21)))))))))))))))))))))))))))))))))))))))))))))))))
(define Parser.hex_nat (lambda (pst$0) ($Parser.hex_nat pst$0)))
(define Kind.Parser.nat ((Kind.Parser.block "nat") (lambda (pst$0) (let ((self1 pst$0)) (case (get self1 0) ('Parser.State.new (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((reply$6 (Kind.Parser.spaces pst$0))) (let ((self7 reply$6)) (case (get self7 0) ('Parser.Reply.error (let ((f7 (get self7 1))) (let ((self8 f1)) (case (get self8 0) ('Maybe.none ($Parser.Reply.error f7)) ('Maybe.some (let ((f8 (get self8 1))) ($Parser.Reply.error ($Parser.Error.combine f8 f7)))))))) ('Parser.Reply.value (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((self9 f7)) (case (get self9 0) ('Parser.State.new (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) (let ((reply.pst$14 ($Parser.State.new ($Parser.Error.maybe_combine f1 f9) f10 f11 f12 f13))) (let ((self15 reply.pst$14)) (case (get self15 0) ('Parser.State.new (let ((f15 (get self15 1))) (let ((f16 (get self15 2))) (let ((f17 (get self15 3))) (let ((f18 (get self15 4))) (let ((f19 (get self15 5))) (let ((reply$20 ($Parser.choice ($List.cons Parser.hex_nat ($List.cons Parser.nat List.nil)) reply.pst$14))) (let ((self21 reply$20)) (case (get self21 0) ('Parser.Reply.error (let ((f21 (get self21 1))) (let ((self22 f15)) (case (get self22 0) ('Maybe.none ($Parser.Reply.error f21)) ('Maybe.some (let ((f22 (get self22 1))) ($Parser.Reply.error ($Parser.Error.combine f22 f21)))))))) ('Parser.Reply.value (let ((f21 (get self21 1))) (let ((f22 (get self21 2))) (let ((self23 f21)) (case (get self23 0) ('Parser.State.new (let ((f23 (get self23 1))) (let ((f24 (get self23 2))) (let ((f25 (get self23 3))) (let ((f26 (get self23 4))) (let ((f27 (get self23 5))) (let ((reply.pst$28 ($Parser.State.new ($Parser.Error.maybe_combine f15 f23) f24 f25 f26 f27))) ($Parser.Reply.value reply.pst$28 ($Kind.Term.nat f22)))))))))))))))))))))))))))))))))))))))))))))))))))
(define ($Kind.Parser.machine_integer.unsigned size$0) ((Kind.Parser.block "int") (let ((size_str$1 ($Nat.show size$0))) (lambda (pst$2) (let ((self2 pst$2)) (case (get self2 0) ('Parser.State.new (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) (let ((f5 (get self2 4))) (let ((f6 (get self2 5))) (let ((reply$8 (Kind.Parser.spaces pst$2))) (let ((self8 reply$8)) (case (get self8 0) ('Parser.Reply.error (let ((f8 (get self8 1))) (let ((self9 f2)) (case (get self9 0) ('Maybe.none ($Parser.Reply.error f8)) ('Maybe.some (let ((f9 (get self9 1))) ($Parser.Reply.error ($Parser.Error.combine f9 f8)))))))) ('Parser.Reply.value (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((self10 f8)) (case (get self10 0) ('Parser.State.new (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) (let ((f13 (get self10 4))) (let ((f14 (get self10 5))) (let ((reply.pst$16 ($Parser.State.new ($Parser.Error.maybe_combine f2 f10) f11 f12 f13 f14))) (let ((self16 reply.pst$16)) (case (get self16 0) ('Parser.State.new (let ((f16 (get self16 1))) (let ((f17 (get self16 2))) (let ((f18 (get self16 3))) (let ((f19 (get self16 4))) (let ((f20 (get self16 5))) (let ((reply$22 (Kind.Parser.nat reply.pst$16))) (let ((self22 reply$22)) (case (get self22 0) ('Parser.Reply.error (let ((f22 (get self22 1))) (let ((self23 f16)) (case (get self23 0) ('Maybe.none ($Parser.Reply.error f22)) ('Maybe.some (let ((f23 (get self23 1))) ($Parser.Reply.error ($Parser.Error.combine f23 f22)))))))) ('Parser.Reply.value (let ((f22 (get self22 1))) (let ((f23 (get self22 2))) (let ((self24 f22)) (case (get self24 0) ('Parser.State.new (let ((f24 (get self24 1))) (let ((f25 (get self24 2))) (let ((f26 (get self24 3))) (let ((f27 (get self24 4))) (let ((f28 (get self24 5))) (let ((reply.pst$30 ($Parser.State.new ($Parser.Error.maybe_combine f16 f24) f25 f26 f27 f28))) (let ((self30 reply.pst$30)) (case (get self30 0) ('Parser.State.new (let ((f30 (get self30 1))) (let ((f31 (get self30 2))) (let ((f32 (get self30 3))) (let ((f33 (get self30 4))) (let ((f34 (get self30 5))) (let ((reply$36 ($Parser.text ($String.concat "#" ($Nat.show size$0)) reply.pst$30))) (let ((self36 reply$36)) (case (get self36 0) ('Parser.Reply.error (let ((f36 (get self36 1))) (let ((self37 f30)) (case (get self37 0) ('Maybe.none ($Parser.Reply.error f36)) ('Maybe.some (let ((f37 (get self37 1))) ($Parser.Reply.error ($Parser.Error.combine f37 f36)))))))) ('Parser.Reply.value (let ((f36 (get self36 1))) (let ((f37 (get self36 2))) (let ((self38 f36)) (case (get self38 0) ('Parser.State.new (let ((f38 (get self38 1))) (let ((f39 (get self38 2))) (let ((f40 (get self38 3))) (let ((f41 (get self38 4))) (let ((f42 (get self38 5))) (let ((reply.pst$44 ($Parser.State.new ($Parser.Error.maybe_combine f30 f38) f39 f40 f41 f42))) (let ((term$45 ($Kind.Term.ref ($String.concat "Nat.to_u" ($Nat.show size$0))))) (let ((term$46 ($Kind.Term.app term$45 f23))) ($Parser.Reply.value reply.pst$44 term$46))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.machine_integer.unsigned (lambda (size$0) ($Kind.Parser.machine_integer.unsigned size$0)))
(define Kind.Parser.u64 ((Kind.Parser.block "u64") (lambda (pst$0) (let ((self1 pst$0)) (case (get self1 0) ('Parser.State.new (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((reply$6 (Kind.Parser.spaces pst$0))) (let ((self7 reply$6)) (case (get self7 0) ('Parser.Reply.error (let ((f7 (get self7 1))) (let ((self8 f1)) (case (get self8 0) ('Maybe.none ($Parser.Reply.error f7)) ('Maybe.some (let ((f8 (get self8 1))) ($Parser.Reply.error ($Parser.Error.combine f8 f7)))))))) ('Parser.Reply.value (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((self9 f7)) (case (get self9 0) ('Parser.State.new (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) (let ((reply.pst$14 ($Parser.State.new ($Parser.Error.maybe_combine f1 f9) f10 f11 f12 f13))) (let ((self15 reply.pst$14)) (case (get self15 0) ('Parser.State.new (let ((f15 (get self15 1))) (let ((f16 (get self15 2))) (let ((f17 (get self15 3))) (let ((f18 (get self15 4))) (let ((f19 (get self15 5))) (let ((reply$20 ($Parser.nat reply.pst$14))) (let ((self21 reply$20)) (case (get self21 0) ('Parser.Reply.error (let ((f21 (get self21 1))) (let ((self22 f15)) (case (get self22 0) ('Maybe.none ($Parser.Reply.error f21)) ('Maybe.some (let ((f22 (get self22 1))) ($Parser.Reply.error ($Parser.Error.combine f22 f21)))))))) ('Parser.Reply.value (let ((f21 (get self21 1))) (let ((f22 (get self21 2))) (let ((self23 f21)) (case (get self23 0) ('Parser.State.new (let ((f23 (get self23 1))) (let ((f24 (get self23 2))) (let ((f25 (get self23 3))) (let ((f26 (get self23 4))) (let ((f27 (get self23 5))) (let ((reply.pst$28 ($Parser.State.new ($Parser.Error.maybe_combine f15 f23) f24 f25 f26 f27))) (let ((self29 reply.pst$28)) (case (get self29 0) ('Parser.State.new (let ((f29 (get self29 1))) (let ((f30 (get self29 2))) (let ((f31 (get self29 3))) (let ((f32 (get self29 4))) (let ((f33 (get self29 5))) (let ((reply$34 ($Parser.text "l" reply.pst$28))) (let ((self35 reply$34)) (case (get self35 0) ('Parser.Reply.error (let ((f35 (get self35 1))) (let ((self36 f29)) (case (get self36 0) ('Maybe.none ($Parser.Reply.error f35)) ('Maybe.some (let ((f36 (get self36 1))) ($Parser.Reply.error ($Parser.Error.combine f36 f35)))))))) ('Parser.Reply.value (let ((f35 (get self35 1))) (let ((f36 (get self35 2))) (let ((self37 f35)) (case (get self37 0) ('Parser.State.new (let ((f37 (get self37 1))) (let ((f38 (get self37 2))) (let ((f39 (get self37 3))) (let ((f40 (get self37 4))) (let ((f41 (get self37 5))) (let ((reply.pst$42 ($Parser.State.new ($Parser.Error.maybe_combine f29 f37) f38 f39 f40 f41))) (let ((term$43 ($Kind.Term.ref "U64.from_nat"))) (let ((term$44 ($Kind.Term.app term$43 ($Kind.Term.nat f22)))) ($Parser.Reply.value reply.pst$42 term$44)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.u32 ((Kind.Parser.block "u32") (lambda (pst$0) (let ((self1 pst$0)) (case (get self1 0) ('Parser.State.new (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((reply$6 (Kind.Parser.spaces pst$0))) (let ((self7 reply$6)) (case (get self7 0) ('Parser.Reply.error (let ((f7 (get self7 1))) (let ((self8 f1)) (case (get self8 0) ('Maybe.none ($Parser.Reply.error f7)) ('Maybe.some (let ((f8 (get self8 1))) ($Parser.Reply.error ($Parser.Error.combine f8 f7)))))))) ('Parser.Reply.value (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((self9 f7)) (case (get self9 0) ('Parser.State.new (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) (let ((reply.pst$14 ($Parser.State.new ($Parser.Error.maybe_combine f1 f9) f10 f11 f12 f13))) (let ((self15 reply.pst$14)) (case (get self15 0) ('Parser.State.new (let ((f15 (get self15 1))) (let ((f16 (get self15 2))) (let ((f17 (get self15 3))) (let ((f18 (get self15 4))) (let ((f19 (get self15 5))) (let ((reply$20 ($Parser.nat reply.pst$14))) (let ((self21 reply$20)) (case (get self21 0) ('Parser.Reply.error (let ((f21 (get self21 1))) (let ((self22 f15)) (case (get self22 0) ('Maybe.none ($Parser.Reply.error f21)) ('Maybe.some (let ((f22 (get self22 1))) ($Parser.Reply.error ($Parser.Error.combine f22 f21)))))))) ('Parser.Reply.value (let ((f21 (get self21 1))) (let ((f22 (get self21 2))) (let ((self23 f21)) (case (get self23 0) ('Parser.State.new (let ((f23 (get self23 1))) (let ((f24 (get self23 2))) (let ((f25 (get self23 3))) (let ((f26 (get self23 4))) (let ((f27 (get self23 5))) (let ((reply.pst$28 ($Parser.State.new ($Parser.Error.maybe_combine f15 f23) f24 f25 f26 f27))) (let ((self29 reply.pst$28)) (case (get self29 0) ('Parser.State.new (let ((f29 (get self29 1))) (let ((f30 (get self29 2))) (let ((f31 (get self29 3))) (let ((f32 (get self29 4))) (let ((f33 (get self29 5))) (let ((reply$34 ($Parser.text "u" reply.pst$28))) (let ((self35 reply$34)) (case (get self35 0) ('Parser.Reply.error (let ((f35 (get self35 1))) (let ((self36 f29)) (case (get self36 0) ('Maybe.none ($Parser.Reply.error f35)) ('Maybe.some (let ((f36 (get self36 1))) ($Parser.Reply.error ($Parser.Error.combine f36 f35)))))))) ('Parser.Reply.value (let ((f35 (get self35 1))) (let ((f36 (get self35 2))) (let ((self37 f35)) (case (get self37 0) ('Parser.State.new (let ((f37 (get self37 1))) (let ((f38 (get self37 2))) (let ((f39 (get self37 3))) (let ((f40 (get self37 4))) (let ((f41 (get self37 5))) (let ((reply.pst$42 ($Parser.State.new ($Parser.Error.maybe_combine f29 f37) f38 f39 f40 f41))) (let ((term$43 ($Kind.Term.ref "U32.from_nat"))) (let ((term$44 ($Kind.Term.app term$43 ($Kind.Term.nat f22)))) ($Parser.Reply.value reply.pst$42 term$44)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.u16 ((Kind.Parser.block "u16") (lambda (pst$0) (let ((self1 pst$0)) (case (get self1 0) ('Parser.State.new (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((reply$6 (Kind.Parser.spaces pst$0))) (let ((self7 reply$6)) (case (get self7 0) ('Parser.Reply.error (let ((f7 (get self7 1))) (let ((self8 f1)) (case (get self8 0) ('Maybe.none ($Parser.Reply.error f7)) ('Maybe.some (let ((f8 (get self8 1))) ($Parser.Reply.error ($Parser.Error.combine f8 f7)))))))) ('Parser.Reply.value (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((self9 f7)) (case (get self9 0) ('Parser.State.new (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) (let ((reply.pst$14 ($Parser.State.new ($Parser.Error.maybe_combine f1 f9) f10 f11 f12 f13))) (let ((self15 reply.pst$14)) (case (get self15 0) ('Parser.State.new (let ((f15 (get self15 1))) (let ((f16 (get self15 2))) (let ((f17 (get self15 3))) (let ((f18 (get self15 4))) (let ((f19 (get self15 5))) (let ((reply$20 ($Parser.nat reply.pst$14))) (let ((self21 reply$20)) (case (get self21 0) ('Parser.Reply.error (let ((f21 (get self21 1))) (let ((self22 f15)) (case (get self22 0) ('Maybe.none ($Parser.Reply.error f21)) ('Maybe.some (let ((f22 (get self22 1))) ($Parser.Reply.error ($Parser.Error.combine f22 f21)))))))) ('Parser.Reply.value (let ((f21 (get self21 1))) (let ((f22 (get self21 2))) (let ((self23 f21)) (case (get self23 0) ('Parser.State.new (let ((f23 (get self23 1))) (let ((f24 (get self23 2))) (let ((f25 (get self23 3))) (let ((f26 (get self23 4))) (let ((f27 (get self23 5))) (let ((reply.pst$28 ($Parser.State.new ($Parser.Error.maybe_combine f15 f23) f24 f25 f26 f27))) (let ((self29 reply.pst$28)) (case (get self29 0) ('Parser.State.new (let ((f29 (get self29 1))) (let ((f30 (get self29 2))) (let ((f31 (get self29 3))) (let ((f32 (get self29 4))) (let ((f33 (get self29 5))) (let ((reply$34 ($Parser.text "s" reply.pst$28))) (let ((self35 reply$34)) (case (get self35 0) ('Parser.Reply.error (let ((f35 (get self35 1))) (let ((self36 f29)) (case (get self36 0) ('Maybe.none ($Parser.Reply.error f35)) ('Maybe.some (let ((f36 (get self36 1))) ($Parser.Reply.error ($Parser.Error.combine f36 f35)))))))) ('Parser.Reply.value (let ((f35 (get self35 1))) (let ((f36 (get self35 2))) (let ((self37 f35)) (case (get self37 0) ('Parser.State.new (let ((f37 (get self37 1))) (let ((f38 (get self37 2))) (let ((f39 (get self37 3))) (let ((f40 (get self37 4))) (let ((f41 (get self37 5))) (let ((reply.pst$42 ($Parser.State.new ($Parser.Error.maybe_combine f29 f37) f38 f39 f40 f41))) (let ((term$43 ($Kind.Term.ref "U16.from_nat"))) (let ((term$44 ($Kind.Term.app term$43 ($Kind.Term.nat f22)))) ($Parser.Reply.value reply.pst$42 term$44)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.u8 ((Kind.Parser.block "u8") (lambda (pst$0) (let ((self1 pst$0)) (case (get self1 0) ('Parser.State.new (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((reply$6 (Kind.Parser.spaces pst$0))) (let ((self7 reply$6)) (case (get self7 0) ('Parser.Reply.error (let ((f7 (get self7 1))) (let ((self8 f1)) (case (get self8 0) ('Maybe.none ($Parser.Reply.error f7)) ('Maybe.some (let ((f8 (get self8 1))) ($Parser.Reply.error ($Parser.Error.combine f8 f7)))))))) ('Parser.Reply.value (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((self9 f7)) (case (get self9 0) ('Parser.State.new (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) (let ((reply.pst$14 ($Parser.State.new ($Parser.Error.maybe_combine f1 f9) f10 f11 f12 f13))) (let ((self15 reply.pst$14)) (case (get self15 0) ('Parser.State.new (let ((f15 (get self15 1))) (let ((f16 (get self15 2))) (let ((f17 (get self15 3))) (let ((f18 (get self15 4))) (let ((f19 (get self15 5))) (let ((reply$20 ($Parser.nat reply.pst$14))) (let ((self21 reply$20)) (case (get self21 0) ('Parser.Reply.error (let ((f21 (get self21 1))) (let ((self22 f15)) (case (get self22 0) ('Maybe.none ($Parser.Reply.error f21)) ('Maybe.some (let ((f22 (get self22 1))) ($Parser.Reply.error ($Parser.Error.combine f22 f21)))))))) ('Parser.Reply.value (let ((f21 (get self21 1))) (let ((f22 (get self21 2))) (let ((self23 f21)) (case (get self23 0) ('Parser.State.new (let ((f23 (get self23 1))) (let ((f24 (get self23 2))) (let ((f25 (get self23 3))) (let ((f26 (get self23 4))) (let ((f27 (get self23 5))) (let ((reply.pst$28 ($Parser.State.new ($Parser.Error.maybe_combine f15 f23) f24 f25 f26 f27))) (let ((self29 reply.pst$28)) (case (get self29 0) ('Parser.State.new (let ((f29 (get self29 1))) (let ((f30 (get self29 2))) (let ((f31 (get self29 3))) (let ((f32 (get self29 4))) (let ((f33 (get self29 5))) (let ((reply$34 ($Parser.text "b" reply.pst$28))) (let ((self35 reply$34)) (case (get self35 0) ('Parser.Reply.error (let ((f35 (get self35 1))) (let ((self36 f29)) (case (get self36 0) ('Maybe.none ($Parser.Reply.error f35)) ('Maybe.some (let ((f36 (get self36 1))) ($Parser.Reply.error ($Parser.Error.combine f36 f35)))))))) ('Parser.Reply.value (let ((f35 (get self35 1))) (let ((f36 (get self35 2))) (let ((self37 f35)) (case (get self37 0) ('Parser.State.new (let ((f37 (get self37 1))) (let ((f38 (get self37 2))) (let ((f39 (get self37 3))) (let ((f40 (get self37 4))) (let ((f41 (get self37 5))) (let ((reply.pst$42 ($Parser.State.new ($Parser.Error.maybe_combine f29 f37) f38 f39 f40 f41))) (let ((term$43 ($Kind.Term.ref "U8.from_nat"))) (let ((term$44 ($Kind.Term.app term$43 ($Kind.Term.nat f22)))) ($Parser.Reply.value reply.pst$42 term$44)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(define ($Parser.Number.new sign$0 numb$1 frac$2) (vector 'Parser.Number.new sign$0 numb$1 frac$2))
(define Parser.Number.new (lambda (sign$0) (lambda (numb$1) (lambda (frac$2) ($Parser.Number.new sign$0 numb$1 frac$2)))))
(define ($Parser.num pst$0) (let ((self0 pst$0)) (case (get self0 0) ('Parser.State.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((reply$6 ($Parser.choice ($List.cons (lambda (pst$6) (let ((self6 pst$6)) (case (get self6 0) ('Parser.State.new (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((f8 (get self6 3))) (let ((f9 (get self6 4))) (let ((f10 (get self6 5))) (let ((reply$12 ($Parser.text "+" pst$6))) (let ((self12 reply$12)) (case (get self12 0) ('Parser.Reply.error (let ((f12 (get self12 1))) (let ((self13 f6)) (case (get self13 0) ('Maybe.none ($Parser.Reply.error f12)) ('Maybe.some (let ((f13 (get self13 1))) ($Parser.Reply.error ($Parser.Error.combine f13 f12)))))))) ('Parser.Reply.value (let ((f12 (get self12 1))) (let ((f13 (get self12 2))) (let ((self14 f12)) (case (get self14 0) ('Parser.State.new (let ((f14 (get self14 1))) (let ((f15 (get self14 2))) (let ((f16 (get self14 3))) (let ((f17 (get self14 4))) (let ((f18 (get self14 5))) (let ((reply.pst$20 ($Parser.State.new ($Parser.Error.maybe_combine f6 f14) f15 f16 f17 f18))) ($Parser.Reply.value reply.pst$20 ($Maybe.some Bool.true)))))))))))))))))))))))))) ($List.cons (lambda (pst$6) (let ((self6 pst$6)) (case (get self6 0) ('Parser.State.new (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((f8 (get self6 3))) (let ((f9 (get self6 4))) (let ((f10 (get self6 5))) (let ((reply$12 ($Parser.text "-" pst$6))) (let ((self12 reply$12)) (case (get self12 0) ('Parser.Reply.error (let ((f12 (get self12 1))) (let ((self13 f6)) (case (get self13 0) ('Maybe.none ($Parser.Reply.error f12)) ('Maybe.some (let ((f13 (get self13 1))) ($Parser.Reply.error ($Parser.Error.combine f13 f12)))))))) ('Parser.Reply.value (let ((f12 (get self12 1))) (let ((f13 (get self12 2))) (let ((self14 f12)) (case (get self14 0) ('Parser.State.new (let ((f14 (get self14 1))) (let ((f15 (get self14 2))) (let ((f16 (get self14 3))) (let ((f17 (get self14 4))) (let ((f18 (get self14 5))) (let ((reply.pst$20 ($Parser.State.new ($Parser.Error.maybe_combine f6 f14) f15 f16 f17 f18))) ($Parser.Reply.value reply.pst$20 ($Maybe.some Bool.false)))))))))))))))))))))))))) ($List.cons (lambda (pst$6) ($Parser.Reply.value pst$6 Maybe.none)) List.nil))) pst$0))) (let ((self6 reply$6)) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))) (let ((self7 f0)) (case (get self7 0) ('Maybe.none ($Parser.Reply.error f6)) ('Maybe.some (let ((f7 (get self7 1))) ($Parser.Reply.error ($Parser.Error.combine f7 f6)))))))) ('Parser.Reply.value (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((self8 f6)) (case (get self8 0) ('Parser.State.new (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) (let ((f11 (get self8 4))) (let ((f12 (get self8 5))) (let ((reply.pst$14 ($Parser.State.new ($Parser.Error.maybe_combine f0 f8) f9 f10 f11 f12))) (let ((self14 reply.pst$14)) (case (get self14 0) ('Parser.State.new (let ((f14 (get self14 1))) (let ((f15 (get self14 2))) (let ((f16 (get self14 3))) (let ((f17 (get self14 4))) (let ((f18 (get self14 5))) (let ((reply$20 ($Parser.choice ($List.cons Parser.hex_nat ($List.cons Parser.nat List.nil)) reply.pst$14))) (let ((self20 reply$20)) (case (get self20 0) ('Parser.Reply.error (let ((f20 (get self20 1))) (let ((self21 f14)) (case (get self21 0) ('Maybe.none ($Parser.Reply.error f20)) ('Maybe.some (let ((f21 (get self21 1))) ($Parser.Reply.error ($Parser.Error.combine f21 f20)))))))) ('Parser.Reply.value (let ((f20 (get self20 1))) (let ((f21 (get self20 2))) (let ((self22 f20)) (case (get self22 0) ('Parser.State.new (let ((f22 (get self22 1))) (let ((f23 (get self22 2))) (let ((f24 (get self22 3))) (let ((f25 (get self22 4))) (let ((f26 (get self22 5))) (let ((reply.pst$28 ($Parser.State.new ($Parser.Error.maybe_combine f14 f22) f23 f24 f25 f26))) (let ((self28 reply.pst$28)) (case (get self28 0) ('Parser.State.new (let ((f28 (get self28 1))) (let ((f29 (get self28 2))) (let ((f30 (get self28 3))) (let ((f31 (get self28 4))) (let ((f32 (get self28 5))) (let ((reply$34 (let ((self33 reply.pst$28)) (case (get self33 0) ('Parser.State.new (let ((f33 (get self33 1))) (let ((f34 (get self33 2))) (let ((f35 (get self33 3))) (let ((f36 (get self33 4))) (let ((f37 (get self33 5))) (let ((reply$39 ($Parser.maybe (Parser.text ".") reply.pst$28))) (let ((self39 reply$39)) (case (get self39 0) ('Parser.Reply.error (let ((f39 (get self39 1))) (let ((self40 f33)) (case (get self40 0) ('Maybe.none ($Parser.Reply.error f39)) ('Maybe.some (let ((f40 (get self40 1))) ($Parser.Reply.error ($Parser.Error.combine f40 f39)))))))) ('Parser.Reply.value (let ((f39 (get self39 1))) (let ((f40 (get self39 2))) (let ((self41 f39)) (case (get self41 0) ('Parser.State.new (let ((f41 (get self41 1))) (let ((f42 (get self41 2))) (let ((f43 (get self41 3))) (let ((f44 (get self41 4))) (let ((f45 (get self41 5))) (let ((reply.pst$47 ($Parser.State.new ($Parser.Error.maybe_combine f33 f41) f42 f43 f44 f45))) (let ((self47 reply.pst$47)) (case (get self47 0) ('Parser.State.new (let ((f47 (get self47 1))) (let ((f48 (get self47 2))) (let ((f49 (get self47 3))) (let ((f50 (get self47 4))) (let ((f51 (get self47 5))) (let ((reply$53 ($Parser.maybe Parser.nat reply.pst$47))) (let ((self53 reply$53)) (case (get self53 0) ('Parser.Reply.error (let ((f53 (get self53 1))) (let ((self54 f47)) (case (get self54 0) ('Maybe.none ($Parser.Reply.error f53)) ('Maybe.some (let ((f54 (get self54 1))) ($Parser.Reply.error ($Parser.Error.combine f54 f53)))))))) ('Parser.Reply.value (let ((f53 (get self53 1))) (let ((f54 (get self53 2))) (let ((self55 f53)) (case (get self55 0) ('Parser.State.new (let ((f55 (get self55 1))) (let ((f56 (get self55 2))) (let ((f57 (get self55 3))) (let ((f58 (get self55 4))) (let ((f59 (get self55 5))) (let ((reply.pst$61 ($Parser.State.new ($Parser.Error.maybe_combine f47 f55) f56 f57 f58 f59))) ($Parser.Reply.value reply.pst$61 f54))))))))))))))))))))))))))))))))))))))))))))))))) (let ((self34 reply$34)) (case (get self34 0) ('Parser.Reply.error (let ((f34 (get self34 1))) (let ((self35 f28)) (case (get self35 0) ('Maybe.none ($Parser.Reply.error f34)) ('Maybe.some (let ((f35 (get self35 1))) ($Parser.Reply.error ($Parser.Error.combine f35 f34)))))))) ('Parser.Reply.value (let ((f34 (get self34 1))) (let ((f35 (get self34 2))) (let ((self36 f34)) (case (get self36 0) ('Parser.State.new (let ((f36 (get self36 1))) (let ((f37 (get self36 2))) (let ((f38 (get self36 3))) (let ((f39 (get self36 4))) (let ((f40 (get self36 5))) (let ((reply.pst$42 ($Parser.State.new ($Parser.Error.maybe_combine f28 f36) f37 f38 f39 f40))) ($Parser.Reply.value reply.pst$42 ($Parser.Number.new f7 f21 f35))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(define Parser.num (lambda (pst$0) ($Parser.num pst$0)))
(define ($Kind.Term.num sign$0 numb$1 frac$2) (vector 'Kind.Term.num sign$0 numb$1 frac$2))
(define Kind.Term.num (lambda (sign$0) (lambda (numb$1) (lambda (frac$2) ($Kind.Term.num sign$0 numb$1 frac$2)))))
(define ($Kind.Parser.num pst$0) (let ((self0 pst$0)) (case (get self0 0) ('Parser.State.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((reply$6 ($Parser.num pst$0))) (let ((self6 reply$6)) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))) (let ((self7 f0)) (case (get self7 0) ('Maybe.none ($Parser.Reply.error f6)) ('Maybe.some (let ((f7 (get self7 1))) ($Parser.Reply.error ($Parser.Error.combine f7 f6)))))))) ('Parser.Reply.value (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((self8 f6)) (case (get self8 0) ('Parser.State.new (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) (let ((f11 (get self8 4))) (let ((f12 (get self8 5))) (let ((reply.pst$14 ($Parser.State.new ($Parser.Error.maybe_combine f0 f8) f9 f10 f11 f12))) ((let ((self14 f7)) (case (get self14 0) ('Parser.Number.new (let ((f14 (get self14 1))) (let ((f15 (get self14 2))) (let ((f16 (get self14 3))) (let ((self17 f14)) (case (get self17 0) ('Maybe.none (let ((self17 f16)) (case (get self17 0) ('Maybe.none (lambda (pst$18) ($Parser.Reply.value pst$18 ($Kind.Term.nat f15)))) ('Maybe.some (let ((f17 (get self17 1))) (lambda (pst$19) ($Parser.Reply.value pst$19 ($Kind.Term.num f14 f15 f16)))))))) ('Maybe.some (let ((f17 (get self17 1))) (lambda (pst$19) ($Parser.Reply.value pst$19 ($Kind.Term.num f14 f15 f16))))))))))))) reply.pst$14)))))))))))))))))))))))))
(define Kind.Parser.num (lambda (pst$0) ($Kind.Parser.num pst$0)))
(define Kind.Parser.reference ((Kind.Parser.block "reference") (lambda (pst$0) (let ((self1 pst$0)) (case (get self1 0) ('Parser.State.new (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((reply$6 ($Kind.Parser.name1 pst$0))) (let ((self7 reply$6)) (case (get self7 0) ('Parser.Reply.error (let ((f7 (get self7 1))) (let ((self8 f1)) (case (get self8 0) ('Maybe.none ($Parser.Reply.error f7)) ('Maybe.some (let ((f8 (get self8 1))) ($Parser.Reply.error ($Parser.Error.combine f8 f7)))))))) ('Parser.Reply.value (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((self9 f7)) (case (get self9 0) ('Parser.State.new (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) (let ((reply.pst$14 ($Parser.State.new ($Parser.Error.maybe_combine f1 f9) f10 f11 f12 f13))) ((let ((self15 ($String.eql f8 "Type"))) (case self15 (#t (lambda (pst$15) ($Parser.Reply.value pst$15 Kind.Term.typ))) (#f (let ((self15 ($String.eql f8 "true"))) (case self15 (#t (lambda (pst$15) ($Parser.Reply.value pst$15 ($Kind.Term.ref "Bool.true")))) (#f (let ((self15 ($String.eql f8 "false"))) (case self15 (#t (lambda (pst$15) ($Parser.Reply.value pst$15 ($Kind.Term.ref "Bool.false")))) (#f (let ((self15 ($String.eql f8 "unit"))) (case self15 (#t (lambda (pst$15) ($Parser.Reply.value pst$15 ($Kind.Term.ref "Unit.new")))) (#f (let ((self15 ($String.eql f8 "none"))) (case self15 (#t (let ((term$15 ($Kind.Term.ref "Maybe.none"))) (let ((term$16 ($Kind.Term.app term$15 ($Kind.Term.hol Bits.e)))) (lambda (pst$17) ($Parser.Reply.value pst$17 term$16))))) (#f (let ((self15 ($String.eql f8 "refl"))) (case self15 (#t (let ((term$15 ($Kind.Term.ref "Equal.refl"))) (let ((term$16 ($Kind.Term.app term$15 ($Kind.Term.hol Bits.e)))) (let ((term$17 ($Kind.Term.app term$16 ($Kind.Term.hol Bits.e)))) (lambda (pst$18) ($Parser.Reply.value pst$18 term$17)))))) (#f (lambda (pst$15) ($Parser.Reply.value pst$15 ($Kind.Term.ref f8))))))))))))))))))))) reply.pst$14)))))))))))))))))))))))))))
(define ($Kind.Parser.items_now ini$1 parser$2 end$3) (((Parser.wrap1 ($Kind.Parser.text_now ini$1)) (lambda (pst$4) (let ((self1 pst$4)) (case (get self1 0) ('Parser.State.new (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((reply$10 (Kind.Parser.spaces pst$4))) (let ((self7 reply$10)) (case (get self7 0) ('Parser.Reply.error (let ((f7 (get self7 1))) (let ((self8 f1)) (case (get self8 0) ('Maybe.none ($Parser.Reply.error f7)) ('Maybe.some (let ((f8 (get self8 1))) ($Parser.Reply.error ($Parser.Error.combine f8 f7)))))))) ('Parser.Reply.value (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((self9 f7)) (case (get self9 0) ('Parser.State.new (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) (let ((reply.pst$18 ($Parser.State.new ($Parser.Error.maybe_combine f1 f9) f10 f11 f12 f13))) (let ((self15 reply.pst$18)) (case (get self15 0) ('Parser.State.new (let ((f15 (get self15 1))) (let ((f16 (get self15 2))) (let ((f17 (get self15 3))) (let ((f18 (get self15 4))) (let ((f19 (get self15 5))) (let ((reply$24 (parser$2 reply.pst$18))) (let ((self21 reply$24)) (case (get self21 0) ('Parser.Reply.error (let ((f21 (get self21 1))) (let ((self22 f15)) (case (get self22 0) ('Maybe.none ($Parser.Reply.error f21)) ('Maybe.some (let ((f22 (get self22 1))) ($Parser.Reply.error ($Parser.Error.combine f22 f21)))))))) ('Parser.Reply.value (let ((f21 (get self21 1))) (let ((f22 (get self21 2))) (let ((self23 f21)) (case (get self23 0) ('Parser.State.new (let ((f23 (get self23 1))) (let ((f24 (get self23 2))) (let ((f25 (get self23 3))) (let ((f26 (get self23 4))) (let ((f27 (get self23 5))) (let ((reply.pst$32 ($Parser.State.new ($Parser.Error.maybe_combine f15 f23) f24 f25 f26 f27))) (let ((self29 reply.pst$32)) (case (get self29 0) ('Parser.State.new (let ((f29 (get self29 1))) (let ((f30 (get self29 2))) (let ((f31 (get self29 3))) (let ((f32 (get self29 4))) (let ((f33 (get self29 5))) (let ((reply$38 ($Parser.maybe (Kind.Parser.text ",") reply.pst$32))) (let ((self35 reply$38)) (case (get self35 0) ('Parser.Reply.error (let ((f35 (get self35 1))) (let ((self36 f29)) (case (get self36 0) ('Maybe.none ($Parser.Reply.error f35)) ('Maybe.some (let ((f36 (get self36 1))) ($Parser.Reply.error ($Parser.Error.combine f36 f35)))))))) ('Parser.Reply.value (let ((f35 (get self35 1))) (let ((f36 (get self35 2))) (let ((self37 f35)) (case (get self37 0) ('Parser.State.new (let ((f37 (get self37 1))) (let ((f38 (get self37 2))) (let ((f39 (get self37 3))) (let ((f40 (get self37 4))) (let ((f41 (get self37 5))) (let ((reply.pst$46 ($Parser.State.new ($Parser.Error.maybe_combine f29 f37) f38 f39 f40 f41))) ($Parser.Reply.value reply.pst$46 f22)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) (Kind.Parser.text end$3)))
(define Kind.Parser.items_now (lambda (ini$1) (lambda (parser$2) (lambda (end$3) ($Kind.Parser.items_now ini$1 parser$2 end$3)))))
(define ($List.for xs$1 b$3 f$4) (let ((self0 xs$1)) (case (get self0 0) ('List.nil b$3) ('List.cons (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($List.for f1 ((f$4 f0) b$3) f$4)))))))
(define List.for (lambda (xs$1) (lambda (b$3) (lambda (f$4) ($List.for xs$1 b$3 f$4)))))
(define ($Kind.Parser.application func$0 pst$1) (let ((self0 pst$1)) (case (get self0 0) ('Parser.State.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((reply$7 (($Kind.Parser.items_now "(" Kind.Parser.term ")") pst$1))) (let ((self6 reply$7)) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))) (let ((self7 f0)) (case (get self7 0) ('Maybe.none ($Parser.Reply.error f6)) ('Maybe.some (let ((f7 (get self7 1))) ($Parser.Reply.error ($Parser.Error.combine f7 f6)))))))) ('Parser.Reply.value (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((self8 f6)) (case (get self8 0) ('Parser.State.new (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) (let ((f11 (get self8 4))) (let ((f12 (get self8 5))) (let ((reply.pst$15 ($Parser.State.new ($Parser.Error.maybe_combine f0 f8) f9 f10 f11 f12))) (let ((expr$16 ($List.for f7 func$0 (lambda (x$16) (lambda (f$17) ($Kind.Term.app f$17 x$16)))))) ($Parser.Reply.value reply.pst$15 expr$16))))))))))))))))))))))))))
(define Kind.Parser.application (lambda (func$0) (lambda (pst$1) ($Kind.Parser.application func$0 pst$1))))
(define ($Kind.Parser.application.erased func$0 pst$1) (let ((self0 pst$1)) (case (get self0 0) ('Parser.State.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((reply$7 (($Kind.Parser.items_now "<" Kind.Parser.term ">") pst$1))) (let ((self6 reply$7)) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))) (let ((self7 f0)) (case (get self7 0) ('Maybe.none ($Parser.Reply.error f6)) ('Maybe.some (let ((f7 (get self7 1))) ($Parser.Reply.error ($Parser.Error.combine f7 f6)))))))) ('Parser.Reply.value (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((self8 f6)) (case (get self8 0) ('Parser.State.new (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) (let ((f11 (get self8 4))) (let ((f12 (get self8 5))) (let ((reply.pst$15 ($Parser.State.new ($Parser.Error.maybe_combine f0 f8) f9 f10 f11 f12))) (let ((expr$16 ($List.for f7 func$0 (lambda (x$16) (lambda (f$17) ($Kind.Term.app f$17 x$16)))))) ($Parser.Reply.value reply.pst$15 expr$16))))))))))))))))))))))))))
(define Kind.Parser.application.erased (lambda (func$0) (lambda (pst$1) ($Kind.Parser.application.erased func$0 pst$1))))
(define ($Kind.Parser.list_set list$0 pst$1) (let ((self0 pst$1)) (case (get self0 0) ('Parser.State.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((reply$7 (($Kind.Parser.text_now "[") pst$1))) (let ((self6 reply$7)) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))) (let ((self7 f0)) (case (get self7 0) ('Maybe.none ($Parser.Reply.error f6)) ('Maybe.some (let ((f7 (get self7 1))) ($Parser.Reply.error ($Parser.Error.combine f7 f6)))))))) ('Parser.Reply.value (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((self8 f6)) (case (get self8 0) ('Parser.State.new (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) (let ((f11 (get self8 4))) (let ((f12 (get self8 5))) (let ((reply.pst$15 ($Parser.State.new ($Parser.Error.maybe_combine f0 f8) f9 f10 f11 f12))) (let ((self14 reply.pst$15)) (case (get self14 0) ('Parser.State.new (let ((f14 (get self14 1))) (let ((f15 (get self14 2))) (let ((f16 (get self14 3))) (let ((f17 (get self14 4))) (let ((f18 (get self14 5))) (let ((reply$21 (Kind.Parser.term reply.pst$15))) (let ((self20 reply$21)) (case (get self20 0) ('Parser.Reply.error (let ((f20 (get self20 1))) (let ((self21 f14)) (case (get self21 0) ('Maybe.none ($Parser.Reply.error f20)) ('Maybe.some (let ((f21 (get self21 1))) ($Parser.Reply.error ($Parser.Error.combine f21 f20)))))))) ('Parser.Reply.value (let ((f20 (get self20 1))) (let ((f21 (get self20 2))) (let ((self22 f20)) (case (get self22 0) ('Parser.State.new (let ((f22 (get self22 1))) (let ((f23 (get self22 2))) (let ((f24 (get self22 3))) (let ((f25 (get self22 4))) (let ((f26 (get self22 5))) (let ((reply.pst$29 ($Parser.State.new ($Parser.Error.maybe_combine f14 f22) f23 f24 f25 f26))) (let ((self28 reply.pst$29)) (case (get self28 0) ('Parser.State.new (let ((f28 (get self28 1))) (let ((f29 (get self28 2))) (let ((f30 (get self28 3))) (let ((f31 (get self28 4))) (let ((f32 (get self28 5))) (let ((reply$35 ($Kind.Parser.text "]" reply.pst$29))) (let ((self34 reply$35)) (case (get self34 0) ('Parser.Reply.error (let ((f34 (get self34 1))) (let ((self35 f28)) (case (get self35 0) ('Maybe.none ($Parser.Reply.error f34)) ('Maybe.some (let ((f35 (get self35 1))) ($Parser.Reply.error ($Parser.Error.combine f35 f34)))))))) ('Parser.Reply.value (let ((f34 (get self34 1))) (let ((f35 (get self34 2))) (let ((self36 f34)) (case (get self36 0) ('Parser.State.new (let ((f36 (get self36 1))) (let ((f37 (get self36 2))) (let ((f38 (get self36 3))) (let ((f39 (get self36 4))) (let ((f40 (get self36 5))) (let ((reply.pst$43 ($Parser.State.new ($Parser.Error.maybe_combine f28 f36) f37 f38 f39 f40))) (let ((self42 reply.pst$43)) (case (get self42 0) ('Parser.State.new (let ((f42 (get self42 1))) (let ((f43 (get self42 2))) (let ((f44 (get self42 3))) (let ((f45 (get self42 4))) (let ((f46 (get self42 5))) (let ((reply$49 ($Kind.Parser.text "<-" reply.pst$43))) (let ((self48 reply$49)) (case (get self48 0) ('Parser.Reply.error (let ((f48 (get self48 1))) (let ((self49 f42)) (case (get self49 0) ('Maybe.none ($Parser.Reply.error f48)) ('Maybe.some (let ((f49 (get self49 1))) ($Parser.Reply.error ($Parser.Error.combine f49 f48)))))))) ('Parser.Reply.value (let ((f48 (get self48 1))) (let ((f49 (get self48 2))) (let ((self50 f48)) (case (get self50 0) ('Parser.State.new (let ((f50 (get self50 1))) (let ((f51 (get self50 2))) (let ((f52 (get self50 3))) (let ((f53 (get self50 4))) (let ((f54 (get self50 5))) (let ((reply.pst$57 ($Parser.State.new ($Parser.Error.maybe_combine f42 f50) f51 f52 f53 f54))) (let ((self56 reply.pst$57)) (case (get self56 0) ('Parser.State.new (let ((f56 (get self56 1))) (let ((f57 (get self56 2))) (let ((f58 (get self56 3))) (let ((f59 (get self56 4))) (let ((f60 (get self56 5))) (let ((reply$63 (Kind.Parser.term reply.pst$57))) (let ((self62 reply$63)) (case (get self62 0) ('Parser.Reply.error (let ((f62 (get self62 1))) (let ((self63 f56)) (case (get self63 0) ('Maybe.none ($Parser.Reply.error f62)) ('Maybe.some (let ((f63 (get self63 1))) ($Parser.Reply.error ($Parser.Error.combine f63 f62)))))))) ('Parser.Reply.value (let ((f62 (get self62 1))) (let ((f63 (get self62 2))) (let ((self64 f62)) (case (get self64 0) ('Parser.State.new (let ((f64 (get self64 1))) (let ((f65 (get self64 2))) (let ((f66 (get self64 3))) (let ((f67 (get self64 4))) (let ((f68 (get self64 5))) (let ((reply.pst$71 ($Parser.State.new ($Parser.Error.maybe_combine f56 f64) f65 f66 f67 f68))) (let ((term$72 ($Kind.Term.ref "List.set"))) (let ((term$73 ($Kind.Term.app term$72 ($Kind.Term.hol Bits.e)))) (let ((term$74 ($Kind.Term.app term$73 f21))) (let ((term$75 ($Kind.Term.app term$74 f63))) (let ((term$76 ($Kind.Term.app term$75 list$0))) ($Parser.Reply.value reply.pst$71 term$76))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.list_set (lambda (list$0) (lambda (pst$1) ($Kind.Parser.list_set list$0 pst$1))))
(define ($Kind.Parser.list_get list$0 pst$1) (let ((self0 pst$1)) (case (get self0 0) ('Parser.State.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((reply$7 (($Kind.Parser.text_now "[") pst$1))) (let ((self6 reply$7)) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))) (let ((self7 f0)) (case (get self7 0) ('Maybe.none ($Parser.Reply.error f6)) ('Maybe.some (let ((f7 (get self7 1))) ($Parser.Reply.error ($Parser.Error.combine f7 f6)))))))) ('Parser.Reply.value (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((self8 f6)) (case (get self8 0) ('Parser.State.new (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) (let ((f11 (get self8 4))) (let ((f12 (get self8 5))) (let ((reply.pst$15 ($Parser.State.new ($Parser.Error.maybe_combine f0 f8) f9 f10 f11 f12))) (let ((self14 reply.pst$15)) (case (get self14 0) ('Parser.State.new (let ((f14 (get self14 1))) (let ((f15 (get self14 2))) (let ((f16 (get self14 3))) (let ((f17 (get self14 4))) (let ((f18 (get self14 5))) (let ((reply$21 (Kind.Parser.term reply.pst$15))) (let ((self20 reply$21)) (case (get self20 0) ('Parser.Reply.error (let ((f20 (get self20 1))) (let ((self21 f14)) (case (get self21 0) ('Maybe.none ($Parser.Reply.error f20)) ('Maybe.some (let ((f21 (get self21 1))) ($Parser.Reply.error ($Parser.Error.combine f21 f20)))))))) ('Parser.Reply.value (let ((f20 (get self20 1))) (let ((f21 (get self20 2))) (let ((self22 f20)) (case (get self22 0) ('Parser.State.new (let ((f22 (get self22 1))) (let ((f23 (get self22 2))) (let ((f24 (get self22 3))) (let ((f25 (get self22 4))) (let ((f26 (get self22 5))) (let ((reply.pst$29 ($Parser.State.new ($Parser.Error.maybe_combine f14 f22) f23 f24 f25 f26))) (let ((self28 reply.pst$29)) (case (get self28 0) ('Parser.State.new (let ((f28 (get self28 1))) (let ((f29 (get self28 2))) (let ((f30 (get self28 3))) (let ((f31 (get self28 4))) (let ((f32 (get self28 5))) (let ((reply$35 ($Kind.Parser.text "]" reply.pst$29))) (let ((self34 reply$35)) (case (get self34 0) ('Parser.Reply.error (let ((f34 (get self34 1))) (let ((self35 f28)) (case (get self35 0) ('Maybe.none ($Parser.Reply.error f34)) ('Maybe.some (let ((f35 (get self35 1))) ($Parser.Reply.error ($Parser.Error.combine f35 f34)))))))) ('Parser.Reply.value (let ((f34 (get self34 1))) (let ((f35 (get self34 2))) (let ((self36 f34)) (case (get self36 0) ('Parser.State.new (let ((f36 (get self36 1))) (let ((f37 (get self36 2))) (let ((f38 (get self36 3))) (let ((f39 (get self36 4))) (let ((f40 (get self36 5))) (let ((reply.pst$43 ($Parser.State.new ($Parser.Error.maybe_combine f28 f36) f37 f38 f39 f40))) (let ((term$44 ($Kind.Term.ref "List.get"))) (let ((term$45 ($Kind.Term.app term$44 ($Kind.Term.hol Bits.e)))) (let ((term$46 ($Kind.Term.app term$45 f21))) (let ((term$47 ($Kind.Term.app term$46 list$0))) ($Parser.Reply.value reply.pst$43 term$47)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.list_get (lambda (list$0) (lambda (pst$1) ($Kind.Parser.list_get list$0 pst$1))))
(define ($Kind.Parser.map_set map$0 pst$1) (let ((self0 pst$1)) (case (get self0 0) ('Parser.State.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((reply$7 (($Kind.Parser.text_now "{") pst$1))) (let ((self6 reply$7)) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))) (let ((self7 f0)) (case (get self7 0) ('Maybe.none ($Parser.Reply.error f6)) ('Maybe.some (let ((f7 (get self7 1))) ($Parser.Reply.error ($Parser.Error.combine f7 f6)))))))) ('Parser.Reply.value (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((self8 f6)) (case (get self8 0) ('Parser.State.new (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) (let ((f11 (get self8 4))) (let ((f12 (get self8 5))) (let ((reply.pst$15 ($Parser.State.new ($Parser.Error.maybe_combine f0 f8) f9 f10 f11 f12))) (let ((self14 reply.pst$15)) (case (get self14 0) ('Parser.State.new (let ((f14 (get self14 1))) (let ((f15 (get self14 2))) (let ((f16 (get self14 3))) (let ((f17 (get self14 4))) (let ((f18 (get self14 5))) (let ((reply$21 (Kind.Parser.term reply.pst$15))) (let ((self20 reply$21)) (case (get self20 0) ('Parser.Reply.error (let ((f20 (get self20 1))) (let ((self21 f14)) (case (get self21 0) ('Maybe.none ($Parser.Reply.error f20)) ('Maybe.some (let ((f21 (get self21 1))) ($Parser.Reply.error ($Parser.Error.combine f21 f20)))))))) ('Parser.Reply.value (let ((f20 (get self20 1))) (let ((f21 (get self20 2))) (let ((self22 f20)) (case (get self22 0) ('Parser.State.new (let ((f22 (get self22 1))) (let ((f23 (get self22 2))) (let ((f24 (get self22 3))) (let ((f25 (get self22 4))) (let ((f26 (get self22 5))) (let ((reply.pst$29 ($Parser.State.new ($Parser.Error.maybe_combine f14 f22) f23 f24 f25 f26))) (let ((self28 reply.pst$29)) (case (get self28 0) ('Parser.State.new (let ((f28 (get self28 1))) (let ((f29 (get self28 2))) (let ((f30 (get self28 3))) (let ((f31 (get self28 4))) (let ((f32 (get self28 5))) (let ((reply$35 ($Kind.Parser.text "}" reply.pst$29))) (let ((self34 reply$35)) (case (get self34 0) ('Parser.Reply.error (let ((f34 (get self34 1))) (let ((self35 f28)) (case (get self35 0) ('Maybe.none ($Parser.Reply.error f34)) ('Maybe.some (let ((f35 (get self35 1))) ($Parser.Reply.error ($Parser.Error.combine f35 f34)))))))) ('Parser.Reply.value (let ((f34 (get self34 1))) (let ((f35 (get self34 2))) (let ((self36 f34)) (case (get self36 0) ('Parser.State.new (let ((f36 (get self36 1))) (let ((f37 (get self36 2))) (let ((f38 (get self36 3))) (let ((f39 (get self36 4))) (let ((f40 (get self36 5))) (let ((reply.pst$43 ($Parser.State.new ($Parser.Error.maybe_combine f28 f36) f37 f38 f39 f40))) (let ((self42 reply.pst$43)) (case (get self42 0) ('Parser.State.new (let ((f42 (get self42 1))) (let ((f43 (get self42 2))) (let ((f44 (get self42 3))) (let ((f45 (get self42 4))) (let ((f46 (get self42 5))) (let ((reply$49 ($Kind.Parser.text "<-" reply.pst$43))) (let ((self48 reply$49)) (case (get self48 0) ('Parser.Reply.error (let ((f48 (get self48 1))) (let ((self49 f42)) (case (get self49 0) ('Maybe.none ($Parser.Reply.error f48)) ('Maybe.some (let ((f49 (get self49 1))) ($Parser.Reply.error ($Parser.Error.combine f49 f48)))))))) ('Parser.Reply.value (let ((f48 (get self48 1))) (let ((f49 (get self48 2))) (let ((self50 f48)) (case (get self50 0) ('Parser.State.new (let ((f50 (get self50 1))) (let ((f51 (get self50 2))) (let ((f52 (get self50 3))) (let ((f53 (get self50 4))) (let ((f54 (get self50 5))) (let ((reply.pst$57 ($Parser.State.new ($Parser.Error.maybe_combine f42 f50) f51 f52 f53 f54))) (let ((self56 reply.pst$57)) (case (get self56 0) ('Parser.State.new (let ((f56 (get self56 1))) (let ((f57 (get self56 2))) (let ((f58 (get self56 3))) (let ((f59 (get self56 4))) (let ((f60 (get self56 5))) (let ((reply$63 (Kind.Parser.term reply.pst$57))) (let ((self62 reply$63)) (case (get self62 0) ('Parser.Reply.error (let ((f62 (get self62 1))) (let ((self63 f56)) (case (get self63 0) ('Maybe.none ($Parser.Reply.error f62)) ('Maybe.some (let ((f63 (get self63 1))) ($Parser.Reply.error ($Parser.Error.combine f63 f62)))))))) ('Parser.Reply.value (let ((f62 (get self62 1))) (let ((f63 (get self62 2))) (let ((self64 f62)) (case (get self64 0) ('Parser.State.new (let ((f64 (get self64 1))) (let ((f65 (get self64 2))) (let ((f66 (get self64 3))) (let ((f67 (get self64 4))) (let ((f68 (get self64 5))) (let ((reply.pst$71 ($Parser.State.new ($Parser.Error.maybe_combine f56 f64) f65 f66 f67 f68))) (let ((term$72 ($Kind.Term.ref "Map.set"))) (let ((term$73 ($Kind.Term.app term$72 ($Kind.Term.hol Bits.e)))) (let ((term$74 ($Kind.Term.app term$73 f21))) (let ((term$75 ($Kind.Term.app term$74 f63))) (let ((term$76 ($Kind.Term.app term$75 map$0))) ($Parser.Reply.value reply.pst$71 term$76))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.map_set (lambda (map$0) (lambda (pst$1) ($Kind.Parser.map_set map$0 pst$1))))
(define ($Kind.Parser.map_get map$0 pst$1) (let ((self0 pst$1)) (case (get self0 0) ('Parser.State.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((reply$7 (($Kind.Parser.text_now "{") pst$1))) (let ((self6 reply$7)) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))) (let ((self7 f0)) (case (get self7 0) ('Maybe.none ($Parser.Reply.error f6)) ('Maybe.some (let ((f7 (get self7 1))) ($Parser.Reply.error ($Parser.Error.combine f7 f6)))))))) ('Parser.Reply.value (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((self8 f6)) (case (get self8 0) ('Parser.State.new (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) (let ((f11 (get self8 4))) (let ((f12 (get self8 5))) (let ((reply.pst$15 ($Parser.State.new ($Parser.Error.maybe_combine f0 f8) f9 f10 f11 f12))) (let ((self14 reply.pst$15)) (case (get self14 0) ('Parser.State.new (let ((f14 (get self14 1))) (let ((f15 (get self14 2))) (let ((f16 (get self14 3))) (let ((f17 (get self14 4))) (let ((f18 (get self14 5))) (let ((reply$21 (Kind.Parser.term reply.pst$15))) (let ((self20 reply$21)) (case (get self20 0) ('Parser.Reply.error (let ((f20 (get self20 1))) (let ((self21 f14)) (case (get self21 0) ('Maybe.none ($Parser.Reply.error f20)) ('Maybe.some (let ((f21 (get self21 1))) ($Parser.Reply.error ($Parser.Error.combine f21 f20)))))))) ('Parser.Reply.value (let ((f20 (get self20 1))) (let ((f21 (get self20 2))) (let ((self22 f20)) (case (get self22 0) ('Parser.State.new (let ((f22 (get self22 1))) (let ((f23 (get self22 2))) (let ((f24 (get self22 3))) (let ((f25 (get self22 4))) (let ((f26 (get self22 5))) (let ((reply.pst$29 ($Parser.State.new ($Parser.Error.maybe_combine f14 f22) f23 f24 f25 f26))) (let ((self28 reply.pst$29)) (case (get self28 0) ('Parser.State.new (let ((f28 (get self28 1))) (let ((f29 (get self28 2))) (let ((f30 (get self28 3))) (let ((f31 (get self28 4))) (let ((f32 (get self28 5))) (let ((reply$35 ($Kind.Parser.text "}" reply.pst$29))) (let ((self34 reply$35)) (case (get self34 0) ('Parser.Reply.error (let ((f34 (get self34 1))) (let ((self35 f28)) (case (get self35 0) ('Maybe.none ($Parser.Reply.error f34)) ('Maybe.some (let ((f35 (get self35 1))) ($Parser.Reply.error ($Parser.Error.combine f35 f34)))))))) ('Parser.Reply.value (let ((f34 (get self34 1))) (let ((f35 (get self34 2))) (let ((self36 f34)) (case (get self36 0) ('Parser.State.new (let ((f36 (get self36 1))) (let ((f37 (get self36 2))) (let ((f38 (get self36 3))) (let ((f39 (get self36 4))) (let ((f40 (get self36 5))) (let ((reply.pst$43 ($Parser.State.new ($Parser.Error.maybe_combine f28 f36) f37 f38 f39 f40))) (let ((term$44 ($Kind.Term.ref "Map.get"))) (let ((term$45 ($Kind.Term.app term$44 ($Kind.Term.hol Bits.e)))) (let ((term$46 ($Kind.Term.app term$45 f21))) (let ((term$47 ($Kind.Term.app term$46 map$0))) ($Parser.Reply.value reply.pst$43 term$47)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.map_get (lambda (map$0) (lambda (pst$1) ($Kind.Parser.map_get map$0 pst$1))))
(define ($Kind.Term.set expr$0 fkey$1 fval$2) (vector 'Kind.Term.set expr$0 fkey$1 fval$2))
(define Kind.Term.set (lambda (expr$0) (lambda (fkey$1) (lambda (fval$2) ($Kind.Term.set expr$0 fkey$1 fval$2)))))
(define ($Kind.Parser.field_set term$0 pst$1) (let ((self0 pst$1)) (case (get self0 0) ('Parser.State.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((reply$7 ($Kind.Parser.text "@" pst$1))) (let ((self6 reply$7)) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))) (let ((self7 f0)) (case (get self7 0) ('Maybe.none ($Parser.Reply.error f6)) ('Maybe.some (let ((f7 (get self7 1))) ($Parser.Reply.error ($Parser.Error.combine f7 f6)))))))) ('Parser.Reply.value (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((self8 f6)) (case (get self8 0) ('Parser.State.new (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) (let ((f11 (get self8 4))) (let ((f12 (get self8 5))) (let ((reply.pst$15 ($Parser.State.new ($Parser.Error.maybe_combine f0 f8) f9 f10 f11 f12))) (let ((self14 reply.pst$15)) (case (get self14 0) ('Parser.State.new (let ((f14 (get self14 1))) (let ((f15 (get self14 2))) (let ((f16 (get self14 3))) (let ((f17 (get self14 4))) (let ((f18 (get self14 5))) (let ((reply$21 ($Kind.Parser.name1 reply.pst$15))) (let ((self20 reply$21)) (case (get self20 0) ('Parser.Reply.error (let ((f20 (get self20 1))) (let ((self21 f14)) (case (get self21 0) ('Maybe.none ($Parser.Reply.error f20)) ('Maybe.some (let ((f21 (get self21 1))) ($Parser.Reply.error ($Parser.Error.combine f21 f20)))))))) ('Parser.Reply.value (let ((f20 (get self20 1))) (let ((f21 (get self20 2))) (let ((self22 f20)) (case (get self22 0) ('Parser.State.new (let ((f22 (get self22 1))) (let ((f23 (get self22 2))) (let ((f24 (get self22 3))) (let ((f25 (get self22 4))) (let ((f26 (get self22 5))) (let ((reply.pst$29 ($Parser.State.new ($Parser.Error.maybe_combine f14 f22) f23 f24 f25 f26))) (let ((self28 reply.pst$29)) (case (get self28 0) ('Parser.State.new (let ((f28 (get self28 1))) (let ((f29 (get self28 2))) (let ((f30 (get self28 3))) (let ((f31 (get self28 4))) (let ((f32 (get self28 5))) (let ((reply$35 ($Kind.Parser.text "<-" reply.pst$29))) (let ((self34 reply$35)) (case (get self34 0) ('Parser.Reply.error (let ((f34 (get self34 1))) (let ((self35 f28)) (case (get self35 0) ('Maybe.none ($Parser.Reply.error f34)) ('Maybe.some (let ((f35 (get self35 1))) ($Parser.Reply.error ($Parser.Error.combine f35 f34)))))))) ('Parser.Reply.value (let ((f34 (get self34 1))) (let ((f35 (get self34 2))) (let ((self36 f34)) (case (get self36 0) ('Parser.State.new (let ((f36 (get self36 1))) (let ((f37 (get self36 2))) (let ((f38 (get self36 3))) (let ((f39 (get self36 4))) (let ((f40 (get self36 5))) (let ((reply.pst$43 ($Parser.State.new ($Parser.Error.maybe_combine f28 f36) f37 f38 f39 f40))) (let ((self42 reply.pst$43)) (case (get self42 0) ('Parser.State.new (let ((f42 (get self42 1))) (let ((f43 (get self42 2))) (let ((f44 (get self42 3))) (let ((f45 (get self42 4))) (let ((f46 (get self42 5))) (let ((reply$49 (Kind.Parser.term reply.pst$43))) (let ((self48 reply$49)) (case (get self48 0) ('Parser.Reply.error (let ((f48 (get self48 1))) (let ((self49 f42)) (case (get self49 0) ('Maybe.none ($Parser.Reply.error f48)) ('Maybe.some (let ((f49 (get self49 1))) ($Parser.Reply.error ($Parser.Error.combine f49 f48)))))))) ('Parser.Reply.value (let ((f48 (get self48 1))) (let ((f49 (get self48 2))) (let ((self50 f48)) (case (get self50 0) ('Parser.State.new (let ((f50 (get self50 1))) (let ((f51 (get self50 2))) (let ((f52 (get self50 3))) (let ((f53 (get self50 4))) (let ((f54 (get self50 5))) (let ((reply.pst$57 ($Parser.State.new ($Parser.Error.maybe_combine f42 f50) f51 f52 f53 f54))) ($Parser.Reply.value reply.pst$57 ($Kind.Term.set term$0 f21 f49)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.field_set (lambda (term$0) (lambda (pst$1) ($Kind.Parser.field_set term$0 pst$1))))
(define ($Kind.Term.get expr$0 fkey$1) (vector 'Kind.Term.get expr$0 fkey$1))
(define Kind.Term.get (lambda (expr$0) (lambda (fkey$1) ($Kind.Term.get expr$0 fkey$1))))
(define ($Kind.Parser.field_get term$0 pst$1) (let ((self0 pst$1)) (case (get self0 0) ('Parser.State.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((reply$7 ($Kind.Parser.text "@" pst$1))) (let ((self6 reply$7)) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))) (let ((self7 f0)) (case (get self7 0) ('Maybe.none ($Parser.Reply.error f6)) ('Maybe.some (let ((f7 (get self7 1))) ($Parser.Reply.error ($Parser.Error.combine f7 f6)))))))) ('Parser.Reply.value (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((self8 f6)) (case (get self8 0) ('Parser.State.new (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) (let ((f11 (get self8 4))) (let ((f12 (get self8 5))) (let ((reply.pst$15 ($Parser.State.new ($Parser.Error.maybe_combine f0 f8) f9 f10 f11 f12))) (let ((self14 reply.pst$15)) (case (get self14 0) ('Parser.State.new (let ((f14 (get self14 1))) (let ((f15 (get self14 2))) (let ((f16 (get self14 3))) (let ((f17 (get self14 4))) (let ((f18 (get self14 5))) (let ((reply$21 ($Kind.Parser.name1 reply.pst$15))) (let ((self20 reply$21)) (case (get self20 0) ('Parser.Reply.error (let ((f20 (get self20 1))) (let ((self21 f14)) (case (get self21 0) ('Maybe.none ($Parser.Reply.error f20)) ('Maybe.some (let ((f21 (get self21 1))) ($Parser.Reply.error ($Parser.Error.combine f21 f20)))))))) ('Parser.Reply.value (let ((f20 (get self20 1))) (let ((f21 (get self20 2))) (let ((self22 f20)) (case (get self22 0) ('Parser.State.new (let ((f22 (get self22 1))) (let ((f23 (get self22 2))) (let ((f24 (get self22 3))) (let ((f25 (get self22 4))) (let ((f26 (get self22 5))) (let ((reply.pst$29 ($Parser.State.new ($Parser.Error.maybe_combine f14 f22) f23 f24 f25 f26))) ($Parser.Reply.value reply.pst$29 ($Kind.Term.get term$0 f21)))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.field_get (lambda (term$0) (lambda (pst$1) ($Kind.Parser.field_get term$0 pst$1))))
(define ($Kind.Parser.arrow xtyp$0 pst$1) (let ((self0 pst$1)) (case (get self0 0) ('Parser.State.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((reply$7 ($Kind.Parser.text "->" pst$1))) (let ((self6 reply$7)) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))) (let ((self7 f0)) (case (get self7 0) ('Maybe.none ($Parser.Reply.error f6)) ('Maybe.some (let ((f7 (get self7 1))) ($Parser.Reply.error ($Parser.Error.combine f7 f6)))))))) ('Parser.Reply.value (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((self8 f6)) (case (get self8 0) ('Parser.State.new (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) (let ((f11 (get self8 4))) (let ((f12 (get self8 5))) (let ((reply.pst$15 ($Parser.State.new ($Parser.Error.maybe_combine f0 f8) f9 f10 f11 f12))) (let ((self14 reply.pst$15)) (case (get self14 0) ('Parser.State.new (let ((f14 (get self14 1))) (let ((f15 (get self14 2))) (let ((f16 (get self14 3))) (let ((f17 (get self14 4))) (let ((f18 (get self14 5))) (let ((reply$21 (Kind.Parser.term reply.pst$15))) (let ((self20 reply$21)) (case (get self20 0) ('Parser.Reply.error (let ((f20 (get self20 1))) (let ((self21 f14)) (case (get self21 0) ('Maybe.none ($Parser.Reply.error f20)) ('Maybe.some (let ((f21 (get self21 1))) ($Parser.Reply.error ($Parser.Error.combine f21 f20)))))))) ('Parser.Reply.value (let ((f20 (get self20 1))) (let ((f21 (get self20 2))) (let ((self22 f20)) (case (get self22 0) ('Parser.State.new (let ((f22 (get self22 1))) (let ((f23 (get self22 2))) (let ((f24 (get self22 3))) (let ((f25 (get self22 4))) (let ((f26 (get self22 5))) (let ((reply.pst$29 ($Parser.State.new ($Parser.Error.maybe_combine f14 f22) f23 f24 f25 f26))) ($Parser.Reply.value reply.pst$29 ($Kind.Term.all Bool.false "" "" xtyp$0 (lambda (s$30) (lambda (x$31) f21)))))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.arrow (lambda (xtyp$0) (lambda (pst$1) ($Kind.Parser.arrow xtyp$0 pst$1))))
(define ($Kind.Parser.concat lst0$0 pst$1) (let ((self0 pst$1)) (case (get self0 0) ('Parser.State.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((reply$7 ($Kind.Parser.text "++" pst$1))) (let ((self6 reply$7)) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))) (let ((self7 f0)) (case (get self7 0) ('Maybe.none ($Parser.Reply.error f6)) ('Maybe.some (let ((f7 (get self7 1))) ($Parser.Reply.error ($Parser.Error.combine f7 f6)))))))) ('Parser.Reply.value (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((self8 f6)) (case (get self8 0) ('Parser.State.new (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) (let ((f11 (get self8 4))) (let ((f12 (get self8 5))) (let ((reply.pst$15 ($Parser.State.new ($Parser.Error.maybe_combine f0 f8) f9 f10 f11 f12))) (let ((self14 reply.pst$15)) (case (get self14 0) ('Parser.State.new (let ((f14 (get self14 1))) (let ((f15 (get self14 2))) (let ((f16 (get self14 3))) (let ((f17 (get self14 4))) (let ((f18 (get self14 5))) (let ((reply$21 ($Parser.text " " reply.pst$15))) (let ((self20 reply$21)) (case (get self20 0) ('Parser.Reply.error (let ((f20 (get self20 1))) (let ((self21 f14)) (case (get self21 0) ('Maybe.none ($Parser.Reply.error f20)) ('Maybe.some (let ((f21 (get self21 1))) ($Parser.Reply.error ($Parser.Error.combine f21 f20)))))))) ('Parser.Reply.value (let ((f20 (get self20 1))) (let ((f21 (get self20 2))) (let ((self22 f20)) (case (get self22 0) ('Parser.State.new (let ((f22 (get self22 1))) (let ((f23 (get self22 2))) (let ((f24 (get self22 3))) (let ((f25 (get self22 4))) (let ((f26 (get self22 5))) (let ((reply.pst$29 ($Parser.State.new ($Parser.Error.maybe_combine f14 f22) f23 f24 f25 f26))) (let ((self28 reply.pst$29)) (case (get self28 0) ('Parser.State.new (let ((f28 (get self28 1))) (let ((f29 (get self28 2))) (let ((f30 (get self28 3))) (let ((f31 (get self28 4))) (let ((f32 (get self28 5))) (let ((reply$35 (Kind.Parser.term reply.pst$29))) (let ((self34 reply$35)) (case (get self34 0) ('Parser.Reply.error (let ((f34 (get self34 1))) (let ((self35 f28)) (case (get self35 0) ('Maybe.none ($Parser.Reply.error f34)) ('Maybe.some (let ((f35 (get self35 1))) ($Parser.Reply.error ($Parser.Error.combine f35 f34)))))))) ('Parser.Reply.value (let ((f34 (get self34 1))) (let ((f35 (get self34 2))) (let ((self36 f34)) (case (get self36 0) ('Parser.State.new (let ((f36 (get self36 1))) (let ((f37 (get self36 2))) (let ((f38 (get self36 3))) (let ((f39 (get self36 4))) (let ((f40 (get self36 5))) (let ((reply.pst$43 ($Parser.State.new ($Parser.Error.maybe_combine f28 f36) f37 f38 f39 f40))) (let ((term$44 ($Kind.Term.ref "List.concat"))) (let ((term$45 ($Kind.Term.app term$44 ($Kind.Term.hol Bits.e)))) (let ((term$46 ($Kind.Term.app term$45 lst0$0))) (let ((term$47 ($Kind.Term.app term$46 f35))) ($Parser.Reply.value reply.pst$43 term$47)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.concat (lambda (lst0$0) (lambda (pst$1) ($Kind.Parser.concat lst0$0 pst$1))))
(define ($Kind.Parser.equality val0$0 pst$1) (let ((self0 pst$1)) (case (get self0 0) ('Parser.State.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((reply$7 ($Kind.Parser.text "==" pst$1))) (let ((self6 reply$7)) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))) (let ((self7 f0)) (case (get self7 0) ('Maybe.none ($Parser.Reply.error f6)) ('Maybe.some (let ((f7 (get self7 1))) ($Parser.Reply.error ($Parser.Error.combine f7 f6)))))))) ('Parser.Reply.value (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((self8 f6)) (case (get self8 0) ('Parser.State.new (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) (let ((f11 (get self8 4))) (let ((f12 (get self8 5))) (let ((reply.pst$15 ($Parser.State.new ($Parser.Error.maybe_combine f0 f8) f9 f10 f11 f12))) (let ((self14 reply.pst$15)) (case (get self14 0) ('Parser.State.new (let ((f14 (get self14 1))) (let ((f15 (get self14 2))) (let ((f16 (get self14 3))) (let ((f17 (get self14 4))) (let ((f18 (get self14 5))) (let ((reply$21 (Kind.Parser.term reply.pst$15))) (let ((self20 reply$21)) (case (get self20 0) ('Parser.Reply.error (let ((f20 (get self20 1))) (let ((self21 f14)) (case (get self21 0) ('Maybe.none ($Parser.Reply.error f20)) ('Maybe.some (let ((f21 (get self21 1))) ($Parser.Reply.error ($Parser.Error.combine f21 f20)))))))) ('Parser.Reply.value (let ((f20 (get self20 1))) (let ((f21 (get self20 2))) (let ((self22 f20)) (case (get self22 0) ('Parser.State.new (let ((f22 (get self22 1))) (let ((f23 (get self22 2))) (let ((f24 (get self22 3))) (let ((f25 (get self22 4))) (let ((f26 (get self22 5))) (let ((reply.pst$29 ($Parser.State.new ($Parser.Error.maybe_combine f14 f22) f23 f24 f25 f26))) (let ((term$30 ($Kind.Term.ref "Equal"))) (let ((term$31 ($Kind.Term.app term$30 ($Kind.Term.hol Bits.e)))) (let ((term$32 ($Kind.Term.app term$31 val0$0))) (let ((term$33 ($Kind.Term.app term$32 f21))) ($Parser.Reply.value reply.pst$29 term$33))))))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.equality (lambda (val0$0) (lambda (pst$1) ($Kind.Parser.equality val0$0 pst$1))))
(define ($Kind.Term.ope name$0 arg0$1 arg1$2) (vector 'Kind.Term.ope name$0 arg0$1 arg1$2))
(define Kind.Term.ope (lambda (name$0) (lambda (arg0$1) (lambda (arg1$2) ($Kind.Term.ope name$0 arg0$1 arg1$2)))))
(define ($Kind.Parser.op sym$0 ref$1 val0$2 pst$3) (let ((self0 pst$3)) (case (get self0 0) ('Parser.State.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((reply$9 ($Kind.Parser.text sym$0 pst$3))) (let ((self6 reply$9)) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))) (let ((self7 f0)) (case (get self7 0) ('Maybe.none ($Parser.Reply.error f6)) ('Maybe.some (let ((f7 (get self7 1))) ($Parser.Reply.error ($Parser.Error.combine f7 f6)))))))) ('Parser.Reply.value (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((self8 f6)) (case (get self8 0) ('Parser.State.new (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) (let ((f11 (get self8 4))) (let ((f12 (get self8 5))) (let ((reply.pst$17 ($Parser.State.new ($Parser.Error.maybe_combine f0 f8) f9 f10 f11 f12))) (let ((self14 reply.pst$17)) (case (get self14 0) ('Parser.State.new (let ((f14 (get self14 1))) (let ((f15 (get self14 2))) (let ((f16 (get self14 3))) (let ((f17 (get self14 4))) (let ((f18 (get self14 5))) (let ((reply$23 (Kind.Parser.term reply.pst$17))) (let ((self20 reply$23)) (case (get self20 0) ('Parser.Reply.error (let ((f20 (get self20 1))) (let ((self21 f14)) (case (get self21 0) ('Maybe.none ($Parser.Reply.error f20)) ('Maybe.some (let ((f21 (get self21 1))) ($Parser.Reply.error ($Parser.Error.combine f21 f20)))))))) ('Parser.Reply.value (let ((f20 (get self20 1))) (let ((f21 (get self20 2))) (let ((self22 f20)) (case (get self22 0) ('Parser.State.new (let ((f22 (get self22 1))) (let ((f23 (get self22 2))) (let ((f24 (get self22 3))) (let ((f25 (get self22 4))) (let ((f26 (get self22 5))) (let ((reply.pst$31 ($Parser.State.new ($Parser.Error.maybe_combine f14 f22) f23 f24 f25 f26))) ($Parser.Reply.value reply.pst$31 ($Kind.Term.ope sym$0 val0$2 f21)))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.op (lambda (sym$0) (lambda (ref$1) (lambda (val0$2) (lambda (pst$3) ($Kind.Parser.op sym$0 ref$1 val0$2 pst$3))))))
(define Kind.Parser.add ((Kind.Parser.op "+") "Nat.add"))
(define Kind.Parser.sub ((Kind.Parser.op "-") "Nat.sub"))
(define Kind.Parser.mul ((Kind.Parser.op "*") "Nat.mul"))
(define Kind.Parser.div ((Kind.Parser.op "/") "Nat.div"))
(define Kind.Parser.mod ((Kind.Parser.op "%") "Nat.mod"))
(define Kind.Parser.ltn ((Kind.Parser.op "<?") "Nat.ltn"))
(define Kind.Parser.lte ((Kind.Parser.op "<=?") "Nat.lte"))
(define Kind.Parser.eql ((Kind.Parser.op "=?") "Nat.eql"))
(define Kind.Parser.gte ((Kind.Parser.op ">=?") "Nat.gte"))
(define Kind.Parser.gtn ((Kind.Parser.op ">?") "Nat.gtn"))
(define Kind.Parser.and ((Kind.Parser.op "&&") "Bool.and"))
(define Kind.Parser.or ((Kind.Parser.op "||") "Bool.or"))
(define ($Kind.Parser.composition val0$0 pst$1) (let ((self0 pst$1)) (case (get self0 0) ('Parser.State.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((reply$7 ($Kind.Parser.text "." pst$1))) (let ((self6 reply$7)) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))) (let ((self7 f0)) (case (get self7 0) ('Maybe.none ($Parser.Reply.error f6)) ('Maybe.some (let ((f7 (get self7 1))) ($Parser.Reply.error ($Parser.Error.combine f7 f6)))))))) ('Parser.Reply.value (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((self8 f6)) (case (get self8 0) ('Parser.State.new (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) (let ((f11 (get self8 4))) (let ((f12 (get self8 5))) (let ((reply.pst$15 ($Parser.State.new ($Parser.Error.maybe_combine f0 f8) f9 f10 f11 f12))) (let ((self14 reply.pst$15)) (case (get self14 0) ('Parser.State.new (let ((f14 (get self14 1))) (let ((f15 (get self14 2))) (let ((f16 (get self14 3))) (let ((f17 (get self14 4))) (let ((f18 (get self14 5))) (let ((reply$21 (Kind.Parser.term reply.pst$15))) (let ((self20 reply$21)) (case (get self20 0) ('Parser.Reply.error (let ((f20 (get self20 1))) (let ((self21 f14)) (case (get self21 0) ('Maybe.none ($Parser.Reply.error f20)) ('Maybe.some (let ((f21 (get self21 1))) ($Parser.Reply.error ($Parser.Error.combine f21 f20)))))))) ('Parser.Reply.value (let ((f20 (get self20 1))) (let ((f21 (get self20 2))) (let ((self22 f20)) (case (get self22 0) ('Parser.State.new (let ((f22 (get self22 1))) (let ((f23 (get self22 2))) (let ((f24 (get self22 3))) (let ((f25 (get self22 4))) (let ((f26 (get self22 5))) (let ((reply.pst$29 ($Parser.State.new ($Parser.Error.maybe_combine f14 f22) f23 f24 f25 f26))) (let ((term$30 ($Kind.Term.ref "Function.comp"))) (let ((term$31 ($Kind.Term.app term$30 ($Kind.Term.hol Bits.e)))) (let ((term$32 ($Kind.Term.app term$31 ($Kind.Term.hol Bits.e)))) (let ((term$33 ($Kind.Term.app term$32 ($Kind.Term.hol Bits.e)))) (let ((term$34 ($Kind.Term.app term$33 val0$0))) (let ((term$35 ($Kind.Term.app term$34 f21))) ($Parser.Reply.value reply.pst$29 term$35))))))))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.composition (lambda (val0$0) (lambda (pst$1) ($Kind.Parser.composition val0$0 pst$1))))
(define ($Kind.Parser.default val0$0 pst$1) (let ((self0 pst$1)) (case (get self0 0) ('Parser.State.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((reply$7 ($Kind.Parser.text "<>" pst$1))) (let ((self6 reply$7)) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))) (let ((self7 f0)) (case (get self7 0) ('Maybe.none ($Parser.Reply.error f6)) ('Maybe.some (let ((f7 (get self7 1))) ($Parser.Reply.error ($Parser.Error.combine f7 f6)))))))) ('Parser.Reply.value (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((self8 f6)) (case (get self8 0) ('Parser.State.new (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) (let ((f11 (get self8 4))) (let ((f12 (get self8 5))) (let ((reply.pst$15 ($Parser.State.new ($Parser.Error.maybe_combine f0 f8) f9 f10 f11 f12))) (let ((self14 reply.pst$15)) (case (get self14 0) ('Parser.State.new (let ((f14 (get self14 1))) (let ((f15 (get self14 2))) (let ((f16 (get self14 3))) (let ((f17 (get self14 4))) (let ((f18 (get self14 5))) (let ((reply$21 (Kind.Parser.term reply.pst$15))) (let ((self20 reply$21)) (case (get self20 0) ('Parser.Reply.error (let ((f20 (get self20 1))) (let ((self21 f14)) (case (get self21 0) ('Maybe.none ($Parser.Reply.error f20)) ('Maybe.some (let ((f21 (get self21 1))) ($Parser.Reply.error ($Parser.Error.combine f21 f20)))))))) ('Parser.Reply.value (let ((f20 (get self20 1))) (let ((f21 (get self20 2))) (let ((self22 f20)) (case (get self22 0) ('Parser.State.new (let ((f22 (get self22 1))) (let ((f23 (get self22 2))) (let ((f24 (get self22 3))) (let ((f25 (get self22 4))) (let ((f26 (get self22 5))) (let ((reply.pst$29 ($Parser.State.new ($Parser.Error.maybe_combine f14 f22) f23 f24 f25 f26))) (let ((term$30 ($Kind.Term.ref "Maybe.default"))) (let ((term$31 ($Kind.Term.app term$30 ($Kind.Term.hol Bits.e)))) (let ((term$32 ($Kind.Term.app term$31 val0$0))) (let ((term$33 ($Kind.Term.app term$32 f21))) ($Parser.Reply.value reply.pst$29 term$33))))))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.default (lambda (val0$0) (lambda (pst$1) ($Kind.Parser.default val0$0 pst$1))))
(define ($Kind.Parser.cons head$0 pst$1) (let ((self0 pst$1)) (case (get self0 0) ('Parser.State.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((reply$7 ($Kind.Parser.text "&" pst$1))) (let ((self6 reply$7)) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))) (let ((self7 f0)) (case (get self7 0) ('Maybe.none ($Parser.Reply.error f6)) ('Maybe.some (let ((f7 (get self7 1))) ($Parser.Reply.error ($Parser.Error.combine f7 f6)))))))) ('Parser.Reply.value (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((self8 f6)) (case (get self8 0) ('Parser.State.new (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) (let ((f11 (get self8 4))) (let ((f12 (get self8 5))) (let ((reply.pst$15 ($Parser.State.new ($Parser.Error.maybe_combine f0 f8) f9 f10 f11 f12))) (let ((self14 reply.pst$15)) (case (get self14 0) ('Parser.State.new (let ((f14 (get self14 1))) (let ((f15 (get self14 2))) (let ((f16 (get self14 3))) (let ((f17 (get self14 4))) (let ((f18 (get self14 5))) (let ((reply$21 (Kind.Parser.term reply.pst$15))) (let ((self20 reply$21)) (case (get self20 0) ('Parser.Reply.error (let ((f20 (get self20 1))) (let ((self21 f14)) (case (get self21 0) ('Maybe.none ($Parser.Reply.error f20)) ('Maybe.some (let ((f21 (get self21 1))) ($Parser.Reply.error ($Parser.Error.combine f21 f20)))))))) ('Parser.Reply.value (let ((f20 (get self20 1))) (let ((f21 (get self20 2))) (let ((self22 f20)) (case (get self22 0) ('Parser.State.new (let ((f22 (get self22 1))) (let ((f23 (get self22 2))) (let ((f24 (get self22 3))) (let ((f25 (get self22 4))) (let ((f26 (get self22 5))) (let ((reply.pst$29 ($Parser.State.new ($Parser.Error.maybe_combine f14 f22) f23 f24 f25 f26))) (let ((term$30 ($Kind.Term.ref "List.cons"))) (let ((term$31 ($Kind.Term.app term$30 ($Kind.Term.hol Bits.e)))) (let ((term$32 ($Kind.Term.app term$31 head$0))) (let ((term$33 ($Kind.Term.app term$32 f21))) ($Parser.Reply.value reply.pst$29 term$33))))))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.cons (lambda (head$0) (lambda (pst$1) ($Kind.Parser.cons head$0 pst$1))))
(define ($Kind.Parser.string_concat str0$0 pst$1) (let ((self0 pst$1)) (case (get self0 0) ('Parser.State.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((reply$7 ($Kind.Parser.text "|" pst$1))) (let ((self6 reply$7)) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))) (let ((self7 f0)) (case (get self7 0) ('Maybe.none ($Parser.Reply.error f6)) ('Maybe.some (let ((f7 (get self7 1))) ($Parser.Reply.error ($Parser.Error.combine f7 f6)))))))) ('Parser.Reply.value (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((self8 f6)) (case (get self8 0) ('Parser.State.new (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) (let ((f11 (get self8 4))) (let ((f12 (get self8 5))) (let ((reply.pst$15 ($Parser.State.new ($Parser.Error.maybe_combine f0 f8) f9 f10 f11 f12))) (let ((self14 reply.pst$15)) (case (get self14 0) ('Parser.State.new (let ((f14 (get self14 1))) (let ((f15 (get self14 2))) (let ((f16 (get self14 3))) (let ((f17 (get self14 4))) (let ((f18 (get self14 5))) (let ((reply$21 (Kind.Parser.term reply.pst$15))) (let ((self20 reply$21)) (case (get self20 0) ('Parser.Reply.error (let ((f20 (get self20 1))) (let ((self21 f14)) (case (get self21 0) ('Maybe.none ($Parser.Reply.error f20)) ('Maybe.some (let ((f21 (get self21 1))) ($Parser.Reply.error ($Parser.Error.combine f21 f20)))))))) ('Parser.Reply.value (let ((f20 (get self20 1))) (let ((f21 (get self20 2))) (let ((self22 f20)) (case (get self22 0) ('Parser.State.new (let ((f22 (get self22 1))) (let ((f23 (get self22 2))) (let ((f24 (get self22 3))) (let ((f25 (get self22 4))) (let ((f26 (get self22 5))) (let ((reply.pst$29 ($Parser.State.new ($Parser.Error.maybe_combine f14 f22) f23 f24 f25 f26))) (let ((term$30 ($Kind.Term.ref "String.concat"))) (let ((term$31 ($Kind.Term.app term$30 str0$0))) (let ((term$32 ($Kind.Term.app term$31 f21))) ($Parser.Reply.value reply.pst$29 term$32)))))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.string_concat (lambda (str0$0) (lambda (pst$1) ($Kind.Parser.string_concat str0$0 pst$1))))
(define ($Kind.Parser.sigma val0$0) ((Kind.Parser.block "sigma") (lambda (pst$1) (let ((self1 pst$1)) (case (get self1 0) ('Parser.State.new (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((reply$7 ($Kind.Parser.text "~" pst$1))) (let ((self7 reply$7)) (case (get self7 0) ('Parser.Reply.error (let ((f7 (get self7 1))) (let ((self8 f1)) (case (get self8 0) ('Maybe.none ($Parser.Reply.error f7)) ('Maybe.some (let ((f8 (get self8 1))) ($Parser.Reply.error ($Parser.Error.combine f8 f7)))))))) ('Parser.Reply.value (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((self9 f7)) (case (get self9 0) ('Parser.State.new (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) (let ((reply.pst$15 ($Parser.State.new ($Parser.Error.maybe_combine f1 f9) f10 f11 f12 f13))) (let ((self15 reply.pst$15)) (case (get self15 0) ('Parser.State.new (let ((f15 (get self15 1))) (let ((f16 (get self15 2))) (let ((f17 (get self15 3))) (let ((f18 (get self15 4))) (let ((f19 (get self15 5))) (let ((reply$21 (Kind.Parser.term reply.pst$15))) (let ((self21 reply$21)) (case (get self21 0) ('Parser.Reply.error (let ((f21 (get self21 1))) (let ((self22 f15)) (case (get self22 0) ('Maybe.none ($Parser.Reply.error f21)) ('Maybe.some (let ((f22 (get self22 1))) ($Parser.Reply.error ($Parser.Error.combine f22 f21)))))))) ('Parser.Reply.value (let ((f21 (get self21 1))) (let ((f22 (get self21 2))) (let ((self23 f21)) (case (get self23 0) ('Parser.State.new (let ((f23 (get self23 1))) (let ((f24 (get self23 2))) (let ((f25 (get self23 3))) (let ((f26 (get self23 4))) (let ((f27 (get self23 5))) (let ((reply.pst$29 ($Parser.State.new ($Parser.Error.maybe_combine f15 f23) f24 f25 f26 f27))) (let ((term$30 ($Kind.Term.ref "Sigma.new"))) (let ((term$31 ($Kind.Term.app term$30 ($Kind.Term.hol Bits.e)))) (let ((term$32 ($Kind.Term.app term$31 ($Kind.Term.hol Bits.e)))) (let ((term$33 ($Kind.Term.app term$32 val0$0))) (let ((term$34 ($Kind.Term.app term$33 f22))) ($Parser.Reply.value reply.pst$29 term$34)))))))))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.sigma (lambda (val0$0) ($Kind.Parser.sigma val0$0)))
(define ($Kind.Parser.inequality val0$0 pst$1) (let ((self0 pst$1)) (case (get self0 0) ('Parser.State.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((reply$7 ($Kind.Parser.text "!=" pst$1))) (let ((self6 reply$7)) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))) (let ((self7 f0)) (case (get self7 0) ('Maybe.none ($Parser.Reply.error f6)) ('Maybe.some (let ((f7 (get self7 1))) ($Parser.Reply.error ($Parser.Error.combine f7 f6)))))))) ('Parser.Reply.value (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((self8 f6)) (case (get self8 0) ('Parser.State.new (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) (let ((f11 (get self8 4))) (let ((f12 (get self8 5))) (let ((reply.pst$15 ($Parser.State.new ($Parser.Error.maybe_combine f0 f8) f9 f10 f11 f12))) (let ((self14 reply.pst$15)) (case (get self14 0) ('Parser.State.new (let ((f14 (get self14 1))) (let ((f15 (get self14 2))) (let ((f16 (get self14 3))) (let ((f17 (get self14 4))) (let ((f18 (get self14 5))) (let ((reply$21 (Kind.Parser.term reply.pst$15))) (let ((self20 reply$21)) (case (get self20 0) ('Parser.Reply.error (let ((f20 (get self20 1))) (let ((self21 f14)) (case (get self21 0) ('Maybe.none ($Parser.Reply.error f20)) ('Maybe.some (let ((f21 (get self21 1))) ($Parser.Reply.error ($Parser.Error.combine f21 f20)))))))) ('Parser.Reply.value (let ((f20 (get self20 1))) (let ((f21 (get self20 2))) (let ((self22 f20)) (case (get self22 0) ('Parser.State.new (let ((f22 (get self22 1))) (let ((f23 (get self22 2))) (let ((f24 (get self22 3))) (let ((f25 (get self22 4))) (let ((f26 (get self22 5))) (let ((reply.pst$29 ($Parser.State.new ($Parser.Error.maybe_combine f14 f22) f23 f24 f25 f26))) (let ((term$30 ($Kind.Term.ref "Equal"))) (let ((term$31 ($Kind.Term.app term$30 ($Kind.Term.hol Bits.e)))) (let ((term$32 ($Kind.Term.app term$31 val0$0))) (let ((term$33 ($Kind.Term.app term$32 f21))) (let ((term$34 ($Kind.Term.app ($Kind.Term.ref "Not") term$33))) ($Parser.Reply.value reply.pst$29 term$34)))))))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.inequality (lambda (val0$0) (lambda (pst$1) ($Kind.Parser.inequality val0$0 pst$1))))
(define ($Kind.Parser.rewrite subt$0 pst$1) (let ((self0 pst$1)) (case (get self0 0) ('Parser.State.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((reply$7 ($Kind.Parser.text "::" pst$1))) (let ((self6 reply$7)) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))) (let ((self7 f0)) (case (get self7 0) ('Maybe.none ($Parser.Reply.error f6)) ('Maybe.some (let ((f7 (get self7 1))) ($Parser.Reply.error ($Parser.Error.combine f7 f6)))))))) ('Parser.Reply.value (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((self8 f6)) (case (get self8 0) ('Parser.State.new (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) (let ((f11 (get self8 4))) (let ((f12 (get self8 5))) (let ((reply.pst$15 ($Parser.State.new ($Parser.Error.maybe_combine f0 f8) f9 f10 f11 f12))) (let ((self14 reply.pst$15)) (case (get self14 0) ('Parser.State.new (let ((f14 (get self14 1))) (let ((f15 (get self14 2))) (let ((f16 (get self14 3))) (let ((f17 (get self14 4))) (let ((f18 (get self14 5))) (let ((reply$21 ($Kind.Parser.text "rewrite" reply.pst$15))) (let ((self20 reply$21)) (case (get self20 0) ('Parser.Reply.error (let ((f20 (get self20 1))) (let ((self21 f14)) (case (get self21 0) ('Maybe.none ($Parser.Reply.error f20)) ('Maybe.some (let ((f21 (get self21 1))) ($Parser.Reply.error ($Parser.Error.combine f21 f20)))))))) ('Parser.Reply.value (let ((f20 (get self20 1))) (let ((f21 (get self20 2))) (let ((self22 f20)) (case (get self22 0) ('Parser.State.new (let ((f22 (get self22 1))) (let ((f23 (get self22 2))) (let ((f24 (get self22 3))) (let ((f25 (get self22 4))) (let ((f26 (get self22 5))) (let ((reply.pst$29 ($Parser.State.new ($Parser.Error.maybe_combine f14 f22) f23 f24 f25 f26))) (let ((self28 reply.pst$29)) (case (get self28 0) ('Parser.State.new (let ((f28 (get self28 1))) (let ((f29 (get self28 2))) (let ((f30 (get self28 3))) (let ((f31 (get self28 4))) (let ((f32 (get self28 5))) (let ((reply$35 ($Kind.Parser.name1 reply.pst$29))) (let ((self34 reply$35)) (case (get self34 0) ('Parser.Reply.error (let ((f34 (get self34 1))) (let ((self35 f28)) (case (get self35 0) ('Maybe.none ($Parser.Reply.error f34)) ('Maybe.some (let ((f35 (get self35 1))) ($Parser.Reply.error ($Parser.Error.combine f35 f34)))))))) ('Parser.Reply.value (let ((f34 (get self34 1))) (let ((f35 (get self34 2))) (let ((self36 f34)) (case (get self36 0) ('Parser.State.new (let ((f36 (get self36 1))) (let ((f37 (get self36 2))) (let ((f38 (get self36 3))) (let ((f39 (get self36 4))) (let ((f40 (get self36 5))) (let ((reply.pst$43 ($Parser.State.new ($Parser.Error.maybe_combine f28 f36) f37 f38 f39 f40))) (let ((self42 reply.pst$43)) (case (get self42 0) ('Parser.State.new (let ((f42 (get self42 1))) (let ((f43 (get self42 2))) (let ((f44 (get self42 3))) (let ((f45 (get self42 4))) (let ((f46 (get self42 5))) (let ((reply$49 ($Kind.Parser.text "in" reply.pst$43))) (let ((self48 reply$49)) (case (get self48 0) ('Parser.Reply.error (let ((f48 (get self48 1))) (let ((self49 f42)) (case (get self49 0) ('Maybe.none ($Parser.Reply.error f48)) ('Maybe.some (let ((f49 (get self49 1))) ($Parser.Reply.error ($Parser.Error.combine f49 f48)))))))) ('Parser.Reply.value (let ((f48 (get self48 1))) (let ((f49 (get self48 2))) (let ((self50 f48)) (case (get self50 0) ('Parser.State.new (let ((f50 (get self50 1))) (let ((f51 (get self50 2))) (let ((f52 (get self50 3))) (let ((f53 (get self50 4))) (let ((f54 (get self50 5))) (let ((reply.pst$57 ($Parser.State.new ($Parser.Error.maybe_combine f42 f50) f51 f52 f53 f54))) (let ((self56 reply.pst$57)) (case (get self56 0) ('Parser.State.new (let ((f56 (get self56 1))) (let ((f57 (get self56 2))) (let ((f58 (get self56 3))) (let ((f59 (get self56 4))) (let ((f60 (get self56 5))) (let ((reply$63 (Kind.Parser.term reply.pst$57))) (let ((self62 reply$63)) (case (get self62 0) ('Parser.Reply.error (let ((f62 (get self62 1))) (let ((self63 f56)) (case (get self63 0) ('Maybe.none ($Parser.Reply.error f62)) ('Maybe.some (let ((f63 (get self63 1))) ($Parser.Reply.error ($Parser.Error.combine f63 f62)))))))) ('Parser.Reply.value (let ((f62 (get self62 1))) (let ((f63 (get self62 2))) (let ((self64 f62)) (case (get self64 0) ('Parser.State.new (let ((f64 (get self64 1))) (let ((f65 (get self64 2))) (let ((f66 (get self64 3))) (let ((f67 (get self64 4))) (let ((f68 (get self64 5))) (let ((reply.pst$71 ($Parser.State.new ($Parser.Error.maybe_combine f56 f64) f65 f66 f67 f68))) (let ((self70 reply.pst$71)) (case (get self70 0) ('Parser.State.new (let ((f70 (get self70 1))) (let ((f71 (get self70 2))) (let ((f72 (get self70 3))) (let ((f73 (get self70 4))) (let ((f74 (get self70 5))) (let ((reply$77 ($Kind.Parser.text "with" reply.pst$71))) (let ((self76 reply$77)) (case (get self76 0) ('Parser.Reply.error (let ((f76 (get self76 1))) (let ((self77 f70)) (case (get self77 0) ('Maybe.none ($Parser.Reply.error f76)) ('Maybe.some (let ((f77 (get self77 1))) ($Parser.Reply.error ($Parser.Error.combine f77 f76)))))))) ('Parser.Reply.value (let ((f76 (get self76 1))) (let ((f77 (get self76 2))) (let ((self78 f76)) (case (get self78 0) ('Parser.State.new (let ((f78 (get self78 1))) (let ((f79 (get self78 2))) (let ((f80 (get self78 3))) (let ((f81 (get self78 4))) (let ((f82 (get self78 5))) (let ((reply.pst$85 ($Parser.State.new ($Parser.Error.maybe_combine f70 f78) f79 f80 f81 f82))) (let ((self84 reply.pst$85)) (case (get self84 0) ('Parser.State.new (let ((f84 (get self84 1))) (let ((f85 (get self84 2))) (let ((f86 (get self84 3))) (let ((f87 (get self84 4))) (let ((f88 (get self84 5))) (let ((reply$91 (Kind.Parser.term reply.pst$85))) (let ((self90 reply$91)) (case (get self90 0) ('Parser.Reply.error (let ((f90 (get self90 1))) (let ((self91 f84)) (case (get self91 0) ('Maybe.none ($Parser.Reply.error f90)) ('Maybe.some (let ((f91 (get self91 1))) ($Parser.Reply.error ($Parser.Error.combine f91 f90)))))))) ('Parser.Reply.value (let ((f90 (get self90 1))) (let ((f91 (get self90 2))) (let ((self92 f90)) (case (get self92 0) ('Parser.State.new (let ((f92 (get self92 1))) (let ((f93 (get self92 2))) (let ((f94 (get self92 3))) (let ((f95 (get self92 4))) (let ((f96 (get self92 5))) (let ((reply.pst$99 ($Parser.State.new ($Parser.Error.maybe_combine f84 f92) f93 f94 f95 f96))) (let ((term$100 ($Kind.Term.ref "Equal.rewrite"))) (let ((term$101 ($Kind.Term.app term$100 ($Kind.Term.hol Bits.e)))) (let ((term$102 ($Kind.Term.app term$101 ($Kind.Term.hol Bits.e)))) (let ((term$103 ($Kind.Term.app term$102 ($Kind.Term.hol Bits.e)))) (let ((term$104 ($Kind.Term.app term$103 f91))) (let ((term$105 ($Kind.Term.app term$104 ($Kind.Term.lam f35 (lambda (x$105) f63))))) (let ((term$106 ($Kind.Term.app term$105 subt$0))) ($Parser.Reply.value reply.pst$99 term$106))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.rewrite (lambda (subt$0) (lambda (pst$1) ($Kind.Parser.rewrite subt$0 pst$1))))
(define ($Kind.Parser.annotation term$0 pst$1) (let ((self0 pst$1)) (case (get self0 0) ('Parser.State.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((reply$7 ($Kind.Parser.text "::" pst$1))) (let ((self6 reply$7)) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))) (let ((self7 f0)) (case (get self7 0) ('Maybe.none ($Parser.Reply.error f6)) ('Maybe.some (let ((f7 (get self7 1))) ($Parser.Reply.error ($Parser.Error.combine f7 f6)))))))) ('Parser.Reply.value (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((self8 f6)) (case (get self8 0) ('Parser.State.new (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) (let ((f11 (get self8 4))) (let ((f12 (get self8 5))) (let ((reply.pst$15 ($Parser.State.new ($Parser.Error.maybe_combine f0 f8) f9 f10 f11 f12))) (let ((self14 reply.pst$15)) (case (get self14 0) ('Parser.State.new (let ((f14 (get self14 1))) (let ((f15 (get self14 2))) (let ((f16 (get self14 3))) (let ((f17 (get self14 4))) (let ((f18 (get self14 5))) (let ((reply$21 (Kind.Parser.term reply.pst$15))) (let ((self20 reply$21)) (case (get self20 0) ('Parser.Reply.error (let ((f20 (get self20 1))) (let ((self21 f14)) (case (get self21 0) ('Maybe.none ($Parser.Reply.error f20)) ('Maybe.some (let ((f21 (get self21 1))) ($Parser.Reply.error ($Parser.Error.combine f21 f20)))))))) ('Parser.Reply.value (let ((f20 (get self20 1))) (let ((f21 (get self20 2))) (let ((self22 f20)) (case (get self22 0) ('Parser.State.new (let ((f22 (get self22 1))) (let ((f23 (get self22 2))) (let ((f24 (get self22 3))) (let ((f25 (get self22 4))) (let ((f26 (get self22 5))) (let ((reply.pst$29 ($Parser.State.new ($Parser.Error.maybe_combine f14 f22) f23 f24 f25 f26))) ($Parser.Reply.value reply.pst$29 ($Kind.Term.ann Bool.false term$0 f21)))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.annotation (lambda (term$0) (lambda (pst$1) ($Kind.Parser.annotation term$0 pst$1))))
(define ($Kind.Parser.application.hole term$0 pst$1) (let ((self0 pst$1)) (case (get self0 0) ('Parser.State.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((reply$7 (($Kind.Parser.text_now "!") pst$1))) (let ((self6 reply$7)) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))) (let ((self7 f0)) (case (get self7 0) ('Maybe.none ($Parser.Reply.error f6)) ('Maybe.some (let ((f7 (get self7 1))) ($Parser.Reply.error ($Parser.Error.combine f7 f6)))))))) ('Parser.Reply.value (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((self8 f6)) (case (get self8 0) ('Parser.State.new (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) (let ((f11 (get self8 4))) (let ((f12 (get self8 5))) (let ((reply.pst$15 ($Parser.State.new ($Parser.Error.maybe_combine f0 f8) f9 f10 f11 f12))) ($Parser.Reply.value reply.pst$15 ($Kind.Term.app term$0 ($Kind.Term.hol Bits.e)))))))))))))))))))))))))))
(define Kind.Parser.application.hole (lambda (term$0) (lambda (pst$1) ($Kind.Parser.application.hole term$0 pst$1))))
(define ($Kind.Parser.term.suffix term$0 pst$1) (let ((self0 pst$1)) (case (get self0 0) ('Parser.State.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((suffix_parser$7 (Parser.choice ($List.cons (Kind.Parser.application term$0) ($List.cons (Kind.Parser.application.erased term$0) ($List.cons (Kind.Parser.list_set term$0) ($List.cons (Kind.Parser.list_get term$0) ($List.cons (Kind.Parser.map_set term$0) ($List.cons (Kind.Parser.map_get term$0) ($List.cons (Kind.Parser.field_set term$0) ($List.cons (Kind.Parser.field_get term$0) ($List.cons (Kind.Parser.arrow term$0) ($List.cons (Kind.Parser.concat term$0) ($List.cons (Kind.Parser.equality term$0) ($List.cons (Kind.Parser.add term$0) ($List.cons (Kind.Parser.sub term$0) ($List.cons (Kind.Parser.mul term$0) ($List.cons (Kind.Parser.div term$0) ($List.cons (Kind.Parser.mod term$0) ($List.cons (Kind.Parser.ltn term$0) ($List.cons (Kind.Parser.lte term$0) ($List.cons (Kind.Parser.eql term$0) ($List.cons (Kind.Parser.gte term$0) ($List.cons (Kind.Parser.gtn term$0) ($List.cons (Kind.Parser.and term$0) ($List.cons (Kind.Parser.or term$0) ($List.cons (Kind.Parser.composition term$0) ($List.cons (Kind.Parser.default term$0) ($List.cons (Kind.Parser.cons term$0) ($List.cons (Kind.Parser.string_concat term$0) ($List.cons ($Kind.Parser.sigma term$0) ($List.cons (Kind.Parser.inequality term$0) ($List.cons (Kind.Parser.rewrite term$0) ($List.cons (Kind.Parser.annotation term$0) ($List.cons (Kind.Parser.application.hole term$0) List.nil))))))))))))))))))))))))))))))))))) (let ((self6 (suffix_parser$7 pst$1))) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))) (let ((self7 f6)) (case (get self7 0) ('Parser.Error.new (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((f9 (get self7 3))) (let ((f10 (get self7 4))) (let ((err$13 ($Parser.Error.maybe_combine f0 ($Maybe.some f6)))) (let ((pst$14 ($Parser.State.new err$13 f1 f2 f3 f4))) ($Parser.Reply.value pst$14 term$0)))))))))))) ('Parser.Reply.value (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) ($Kind.Parser.term.suffix f7 f6))))))))))))))))
(define Kind.Parser.term.suffix (lambda (term$0) (lambda (pst$1) ($Kind.Parser.term.suffix term$0 pst$1))))
(define Kind.Parser.term ((Kind.Parser.block "term") (lambda (pst$0) (let ((self1 pst$0)) (case (get self1 0) ('Parser.State.new (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((reply$6 ($Parser.choice ($List.cons Kind.Parser.dom ($List.cons Kind.Parser.forall ($List.cons Kind.Parser.lambda ($List.cons Kind.Parser.lambda.erased ($List.cons Kind.Parser.parenthesis ($List.cons ($Kind.Parser.letforrange.u32 (lambda (x$6) Kind.Parser.term)) ($List.cons ($Kind.Parser.letforrange.u32.with (lambda (x$6) Kind.Parser.term)) ($List.cons ($Kind.Parser.letforrange.i32 (lambda (x$6) Kind.Parser.term)) ($List.cons ($Kind.Parser.letforrange.i32.with (lambda (x$6) Kind.Parser.term)) ($List.cons ($Kind.Parser.letforrange.nat (lambda (x$6) Kind.Parser.term)) ($List.cons ($Kind.Parser.letforrange.nat.with (lambda (x$6) Kind.Parser.term)) ($List.cons ($Kind.Parser.letforin (lambda (x$6) Kind.Parser.term)) ($List.cons ($Kind.Parser.letforin.with (lambda (x$6) Kind.Parser.term)) ($List.cons ($Kind.Parser.letforinmap (lambda (x$6) Kind.Parser.term)) ($List.cons ($Kind.Parser.letforinmap.with (lambda (x$6) Kind.Parser.term)) ($List.cons ($Kind.Parser.letwhile (lambda (x$6) Kind.Parser.term)) ($List.cons ($Kind.Parser.letwhile.with (lambda (x$6) Kind.Parser.term)) ($List.cons ($Kind.Parser.let.abort (lambda (x$6) Kind.Parser.term)) ($List.cons ($Kind.Parser.let (lambda (x$6) Kind.Parser.term)) ($List.cons ($Kind.Parser.let.omit (lambda (x$6) Kind.Parser.term)) ($List.cons ($Kind.Parser.getwhile (lambda (x$6) Kind.Parser.term)) ($List.cons (Kind.Parser.getwhile.with (lambda (x$6) Kind.Parser.term)) ($List.cons ($Kind.Parser.get (lambda (x$6) Kind.Parser.term)) ($List.cons ($Kind.Parser.get.omit (lambda (x$6) Kind.Parser.term)) ($List.cons ($Kind.Parser.def (lambda (x$6) Kind.Parser.term)) ($List.cons ($Kind.Parser.use.abort (lambda (x$6) Kind.Parser.term)) ($List.cons ($Kind.Parser.use (lambda (x$6) Kind.Parser.term)) ($List.cons Kind.Parser.goal_rewrite ($List.cons Kind.Parser.if ($List.cons Kind.Parser.char ($List.cons ($Kind.Parser.string 34) ($List.cons ($Kind.Parser.string 96) ($List.cons Kind.Parser.new ($List.cons Kind.Parser.sigma.type ($List.cons Kind.Parser.some ($List.cons Kind.Parser.not ($List.cons Kind.Parser.left ($List.cons Kind.Parser.right ($List.cons Kind.Parser.apply ($List.cons Kind.Parser.chain ($List.cons Kind.Parser.mirror ($List.cons Kind.Parser.comprehension ($List.cons Kind.Parser.comprehension_range ($List.cons Kind.Parser.list ($List.cons Kind.Parser.map ($List.cons ($Kind.Parser.log (lambda (x$6) Kind.Parser.term)) ($List.cons Kind.Parser.do ($List.cons Kind.Parser.case ($List.cons ($Kind.Parser.open (lambda (x$6) Kind.Parser.term)) ($List.cons Kind.Parser.without ($List.cons Kind.Parser.switch ($List.cons Kind.Parser.goal ($List.cons Kind.Parser.hole ($List.cons Kind.Parser.float.64 ($List.cons Kind.Parser.float.32 ($List.cons ($Kind.Parser.machine_integer.signed 256) ($List.cons ($Kind.Parser.machine_integer.signed 128) ($List.cons ($Kind.Parser.machine_integer.signed 64) ($List.cons ($Kind.Parser.machine_integer.signed 32) ($List.cons ($Kind.Parser.machine_integer.signed 16) ($List.cons ($Kind.Parser.machine_integer.signed 8) ($List.cons ($Kind.Parser.machine_integer.unsigned 256) ($List.cons ($Kind.Parser.machine_integer.unsigned 128) ($List.cons ($Kind.Parser.machine_integer.unsigned 64) ($List.cons ($Kind.Parser.machine_integer.unsigned 32) ($List.cons ($Kind.Parser.machine_integer.unsigned 16) ($List.cons ($Kind.Parser.machine_integer.unsigned 8) ($List.cons Kind.Parser.u64 ($List.cons Kind.Parser.u32 ($List.cons Kind.Parser.u16 ($List.cons Kind.Parser.u8 ($List.cons Kind.Parser.num ($List.cons Kind.Parser.reference ($List.cons (lambda (pst$6) (let ((self7 pst$6)) (case (get self7 0) ('Parser.State.new (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((f9 (get self7 3))) (let ((f10 (get self7 4))) (let ((f11 (get self7 5))) (let ((reply$12 (Kind.Parser.spaces pst$6))) (let ((self13 reply$12)) (case (get self13 0) ('Parser.Reply.error (let ((f13 (get self13 1))) (let ((self14 f7)) (case (get self14 0) ('Maybe.none ($Parser.Reply.error f13)) ('Maybe.some (let ((f14 (get self14 1))) ($Parser.Reply.error ($Parser.Error.combine f14 f13)))))))) ('Parser.Reply.value (let ((f13 (get self13 1))) (let ((f14 (get self13 2))) (let ((self15 f13)) (case (get self15 0) ('Parser.State.new (let ((f15 (get self15 1))) (let ((f16 (get self15 2))) (let ((f17 (get self15 3))) (let ((f18 (get self15 4))) (let ((f19 (get self15 5))) (let ((reply.pst$20 ($Parser.State.new ($Parser.Error.maybe_combine f7 f15) f16 f17 f18 f19))) ($Parser.fail "Expected a term." reply.pst$20))))))))))))))))))))))))) List.nil)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) pst$0))) (let ((self7 reply$6)) (case (get self7 0) ('Parser.Reply.error (let ((f7 (get self7 1))) (let ((self8 f1)) (case (get self8 0) ('Maybe.none ($Parser.Reply.error f7)) ('Maybe.some (let ((f8 (get self8 1))) ($Parser.Reply.error ($Parser.Error.combine f8 f7)))))))) ('Parser.Reply.value (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((self9 f7)) (case (get self9 0) ('Parser.State.new (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) (let ((reply.pst$14 ($Parser.State.new ($Parser.Error.maybe_combine f1 f9) f10 f11 f12 f13))) (let ((self15 reply.pst$14)) (case (get self15 0) ('Parser.State.new (let ((f15 (get self15 1))) (let ((f16 (get self15 2))) (let ((f17 (get self15 3))) (let ((f18 (get self15 4))) (let ((f19 (get self15 5))) (let ((reply$20 ($Kind.Parser.term.suffix f8 reply.pst$14))) (let ((self21 reply$20)) (case (get self21 0) ('Parser.Reply.error (let ((f21 (get self21 1))) (let ((self22 f15)) (case (get self22 0) ('Maybe.none ($Parser.Reply.error f21)) ('Maybe.some (let ((f22 (get self22 1))) ($Parser.Reply.error ($Parser.Error.combine f22 f21)))))))) ('Parser.Reply.value (let ((f21 (get self21 1))) (let ((f22 (get self21 2))) (let ((self23 f21)) (case (get self23 0) ('Parser.State.new (let ((f23 (get self23 1))) (let ((f24 (get self23 2))) (let ((f25 (get self23 3))) (let ((f26 (get self23 4))) (let ((f27 (get self23 5))) (let ((reply.pst$28 ($Parser.State.new ($Parser.Error.maybe_combine f15 f23) f24 f25 f26 f27))) ($Parser.Reply.value reply.pst$28 f22))))))))))))))))))))))))))))))))))))))))))))))))))
(define ($Kind.Parser.name_term sep$0 pst$1) (let ((self0 pst$1)) (case (get self0 0) ('Parser.State.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((reply$7 ($Kind.Parser.name pst$1))) (let ((self6 reply$7)) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))) (let ((self7 f0)) (case (get self7 0) ('Maybe.none ($Parser.Reply.error f6)) ('Maybe.some (let ((f7 (get self7 1))) ($Parser.Reply.error ($Parser.Error.combine f7 f6)))))))) ('Parser.Reply.value (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((self8 f6)) (case (get self8 0) ('Parser.State.new (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) (let ((f11 (get self8 4))) (let ((f12 (get self8 5))) (let ((reply.pst$15 ($Parser.State.new ($Parser.Error.maybe_combine f0 f8) f9 f10 f11 f12))) (let ((self14 reply.pst$15)) (case (get self14 0) ('Parser.State.new (let ((f14 (get self14 1))) (let ((f15 (get self14 2))) (let ((f16 (get self14 3))) (let ((f17 (get self14 4))) (let ((f18 (get self14 5))) (let ((reply$21 ($Kind.Parser.text sep$0 reply.pst$15))) (let ((self20 reply$21)) (case (get self20 0) ('Parser.Reply.error (let ((f20 (get self20 1))) (let ((self21 f14)) (case (get self21 0) ('Maybe.none ($Parser.Reply.error f20)) ('Maybe.some (let ((f21 (get self21 1))) ($Parser.Reply.error ($Parser.Error.combine f21 f20)))))))) ('Parser.Reply.value (let ((f20 (get self20 1))) (let ((f21 (get self20 2))) (let ((self22 f20)) (case (get self22 0) ('Parser.State.new (let ((f22 (get self22 1))) (let ((f23 (get self22 2))) (let ((f24 (get self22 3))) (let ((f25 (get self22 4))) (let ((f26 (get self22 5))) (let ((reply.pst$29 ($Parser.State.new ($Parser.Error.maybe_combine f14 f22) f23 f24 f25 f26))) (let ((self28 reply.pst$29)) (case (get self28 0) ('Parser.State.new (let ((f28 (get self28 1))) (let ((f29 (get self28 2))) (let ((f30 (get self28 3))) (let ((f31 (get self28 4))) (let ((f32 (get self28 5))) (let ((reply$35 (Kind.Parser.term reply.pst$29))) (let ((self34 reply$35)) (case (get self34 0) ('Parser.Reply.error (let ((f34 (get self34 1))) (let ((self35 f28)) (case (get self35 0) ('Maybe.none ($Parser.Reply.error f34)) ('Maybe.some (let ((f35 (get self35 1))) ($Parser.Reply.error ($Parser.Error.combine f35 f34)))))))) ('Parser.Reply.value (let ((f34 (get self34 1))) (let ((f35 (get self34 2))) (let ((self36 f34)) (case (get self36 0) ('Parser.State.new (let ((f36 (get self36 1))) (let ((f37 (get self36 2))) (let ((f38 (get self36 3))) (let ((f39 (get self36 4))) (let ((f40 (get self36 5))) (let ((reply.pst$43 ($Parser.State.new ($Parser.Error.maybe_combine f28 f36) f37 f38 f39 f40))) ($Parser.Reply.value reply.pst$43 ($Pair.new f7 f35))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.name_term (lambda (sep$0) (lambda (pst$1) ($Kind.Parser.name_term sep$0 pst$1))))
(define ($Kind.Binder.new eras$0 name$1 term$2) (vector 'Kind.Binder.new eras$0 name$1 term$2))
(define Kind.Binder.new (lambda (eras$0) (lambda (name$1) (lambda (term$2) ($Kind.Binder.new eras$0 name$1 term$2)))))
(define ($Kind.Parser.binder.homo sep$0 eras$1) (let ((open$2 (let ((self0 eras$1)) (case self0 (#t "<") (#f "("))))) (let ((clos$3 (let ((self1 eras$1)) (case self1 (#t ">") (#f ")"))))) (lambda (pst$4) (let ((self3 pst$4)) (case (get self3 0) ('Parser.State.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) (let ((f7 (get self3 5))) (let ((reply$10 (($Kind.Parser.items1 open$2 (Kind.Parser.name_term sep$0) clos$3) pst$4))) (let ((self9 reply$10)) (case (get self9 0) ('Parser.Reply.error (let ((f9 (get self9 1))) (let ((self10 f3)) (case (get self10 0) ('Maybe.none ($Parser.Reply.error f9)) ('Maybe.some (let ((f10 (get self10 1))) ($Parser.Reply.error ($Parser.Error.combine f10 f9)))))))) ('Parser.Reply.value (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((self11 f9)) (case (get self11 0) ('Parser.State.new (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) (let ((f13 (get self11 3))) (let ((f14 (get self11 4))) (let ((f15 (get self11 5))) (let ((reply.pst$18 ($Parser.State.new ($Parser.Error.maybe_combine f3 f11) f12 f13 f14 f15))) ($Parser.Reply.value reply.pst$18 ($List.mapped f10 (lambda (pair$19) (let ((self18 pair$19)) (case (get self18 0) ('Pair.new (let ((f18 (get self18 1))) (let ((f19 (get self18 2))) ($Kind.Binder.new eras$1 f18 f19))))))))))))))))))))))))))))))))))))
(define Kind.Parser.binder.homo (lambda (sep$0) (lambda (eras$1) ($Kind.Parser.binder.homo sep$0 eras$1))))
(define ($List.concat as$1 bs$2) (let ((self0 as$1)) (case (get self0 0) ('List.nil bs$2) ('List.cons (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($List.cons f0 ($List.concat f1 bs$2))))))))
(define List.concat (lambda (as$1) (lambda (bs$2) ($List.concat as$1 bs$2))))
(define ($List.flatten xs$1) (let ((self0 xs$1)) (case (get self0 0) ('List.nil List.nil) ('List.cons (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($List.concat f0 ($List.flatten f1))))))))
(define List.flatten (lambda (xs$1) ($List.flatten xs$1)))
(define ($Kind.Parser.binder sep$0 pst$1) (let ((self0 pst$1)) (case (get self0 0) ('Parser.State.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((reply$7 ($Parser.many1 (Parser.choice ($List.cons ($Kind.Parser.binder.homo sep$0 Bool.true) ($List.cons ($Kind.Parser.binder.homo sep$0 Bool.false) List.nil))) pst$1))) (let ((self6 reply$7)) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))) (let ((self7 f0)) (case (get self7 0) ('Maybe.none ($Parser.Reply.error f6)) ('Maybe.some (let ((f7 (get self7 1))) ($Parser.Reply.error ($Parser.Error.combine f7 f6)))))))) ('Parser.Reply.value (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((self8 f6)) (case (get self8 0) ('Parser.State.new (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) (let ((f11 (get self8 4))) (let ((f12 (get self8 5))) (let ((reply.pst$15 ($Parser.State.new ($Parser.Error.maybe_combine f0 f8) f9 f10 f11 f12))) ($Parser.Reply.value reply.pst$15 ($List.flatten f7))))))))))))))))))))))))))
(define Kind.Parser.binder (lambda (sep$0) (lambda (pst$1) ($Kind.Parser.binder sep$0 pst$1))))
(define ($List.length xs$1) (let ((self0 xs$1)) (case (get self0 0) ('List.nil 0) ('List.cons (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($Nat.succ ($List.length f1))))))))
(define List.length (lambda (xs$1) ($List.length xs$1)))
(define ($Kind.Parser.forall.make binds$0 body$1) (let ((self0 binds$0)) (case (get self0 0) ('List.nil body$1) ('List.cons (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((self2 f0)) (case (get self2 0) ('Kind.Binder.new (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) ($Kind.Term.all f2 "" f3 f4 (lambda (s$7) (lambda (x$8) ($Kind.Parser.forall.make f1 body$1))))))))))))))))
(define Kind.Parser.forall.make (lambda (binds$0) (lambda (body$1) ($Kind.Parser.forall.make binds$0 body$1))))
(define ($List.at_last index$1 list$2) ($List.at index$1 ($List.reverse list$2)))
(define List.at_last (lambda (index$1) (lambda (list$2) ($List.at_last index$1 list$2))))
(define ($Kind.Term.var name$0 indx$1) (vector 'Kind.Term.var name$0 indx$1))
(define Kind.Term.var (lambda (name$0) (lambda (indx$1) ($Kind.Term.var name$0 indx$1))))
(define ($Kind.Context.get_name_skips name$0) (let ((self0 name$0)) (case (<= (kstring-length self0) 0) (#t ($Pair.new "" 0)) (#f (let ((f0 (char->integer (kstring-head self0)))) (let ((f1 (kstring-tail self0))) (let ((name_skips$3 ($Kind.Context.get_name_skips f1))) (let ((self3 name_skips$3)) (case (get self3 0) ('Pair.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((self5 ($U16.eql f0 94))) (case self5 (#t ($Pair.new f3 ($Nat.succ f4))) (#f ($Pair.new ($String.cons f0 f3) f4))))))))))))))))
(define Kind.Context.get_name_skips (lambda (name$0) ($Kind.Context.get_name_skips name$0)))
(define ($Kind.Name.eql a$0 b$1) ($String.eql a$0 b$1))
(define Kind.Name.eql (lambda (a$0) (lambda (b$1) ($Kind.Name.eql a$0 b$1))))
(define ($Kind.Context.find.go name$0 skip$1 ctx$2) (let ((self0 ctx$2)) (case (get self0 0) ('List.nil Maybe.none) ('List.cons (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((self2 f0)) (case (get self2 0) ('Pair.new (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((self4 ($Kind.Name.eql name$0 f2))) (case self4 (#t (let ((self4 skip$1)) (case (= self4 0) (#t ($Maybe.some f3)) (#f (let ((f4 (- self4 1))) ($Kind.Context.find.go name$0 f4 f1)))))) (#f ($Kind.Context.find.go name$0 skip$1 f1)))))))))))))))
(define Kind.Context.find.go (lambda (name$0) (lambda (skip$1) (lambda (ctx$2) ($Kind.Context.find.go name$0 skip$1 ctx$2)))))
(define ($Kind.Context.find name$0 ctx$1) (let ((self0 ($Kind.Context.get_name_skips name$0))) (case (get self0 0) ('Pair.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($Kind.Context.find.go f0 f1 ctx$1)))))))
(define Kind.Context.find (lambda (name$0) (lambda (ctx$1) ($Kind.Context.find name$0 ctx$1))))
(define ($Kind.Path.Builder.o path$0 x$1) (path$0 ($Bits.o x$1)))
(define Kind.Path.Builder.o (lambda (path$0) (lambda (x$1) ($Kind.Path.Builder.o path$0 x$1))))
(define ($Kind.Path.Builder.i path$0 x$1) (path$0 ($Bits.i x$1)))
(define Kind.Path.Builder.i (lambda (path$0) (lambda (x$1) ($Kind.Path.Builder.i path$0 x$1))))
(define ($Kind.Path.Builder.to_bits path$0) (path$0 Bits.e))
(define Kind.Path.Builder.to_bits (lambda (path$0) ($Kind.Path.Builder.to_bits path$0)))
(define ($List.imapped as$1 f$3) (let ((self0 as$1)) (case (get self0 0) ('List.nil List.nil) ('List.cons (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($List.cons ((f$3 0) f0) ($List.imapped f1 (lambda (n$6) (f$3 ($Nat.succ n$6)))))))))))
(define List.imapped (lambda (as$1) (lambda (f$3) ($List.imapped as$1 f$3))))
(define ($Kind.Path.Builder.nat n$0 b$1) (let ((self0 n$0)) (case (= self0 0) (#t (Kind.Path.Builder.o b$1)) (#f (let ((f0 (- self0 1))) (Kind.Path.Builder.i ($Kind.Path.Builder.nat f0 b$1)))))))
(define Kind.Path.Builder.nat (lambda (n$0) (lambda (b$1) ($Kind.Path.Builder.nat n$0 b$1))))
(define ($Kind.Term.bind vars$0 path$1 term$2) (let ((self0 term$2)) (case (get self0 0) ('Kind.Term.var (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((self2 ($List.at_last f1 vars$0))) (case (get self2 0) ('Maybe.none ($Kind.Term.var f0 f1)) ('Maybe.some (let ((f2 (get self2 1))) ($Pair.snd f2)))))))) ('Kind.Term.ref (let ((f0 (get self0 1))) (let ((self1 ($Kind.Context.find f0 vars$0))) (case (get self1 0) ('Maybe.none ($Kind.Term.ref f0)) ('Maybe.some (let ((f1 (get self1 1))) f1)))))) ('Kind.Term.typ Kind.Term.typ) ('Kind.Term.all (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((vlen$8 ($List.length vars$0))) ($Kind.Term.all f0 f1 f2 ($Kind.Term.bind vars$0 (Kind.Path.Builder.o path$1) f3) (lambda (s$9) (lambda (x$10) ($Kind.Term.bind ($List.cons ($Pair.new f2 x$10) ($List.cons ($Pair.new f1 s$9) vars$0)) (Kind.Path.Builder.i path$1) ((f4 ($Kind.Term.var f1 vlen$8)) ($Kind.Term.var f2 ($Nat.succ vlen$8)))))))))))))) ('Kind.Term.lam (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((vlen$5 ($List.length vars$0))) ($Kind.Term.lam f0 (lambda (x$6) ($Kind.Term.bind ($List.cons ($Pair.new f0 x$6) vars$0) (Kind.Path.Builder.o path$1) (f1 ($Kind.Term.var f0 vlen$5))))))))) ('Kind.Term.app (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($Kind.Term.app ($Kind.Term.bind vars$0 (Kind.Path.Builder.o path$1) f0) ($Kind.Term.bind vars$0 (Kind.Path.Builder.i path$1) f1))))) ('Kind.Term.let (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((vlen$6 ($List.length vars$0))) ($Kind.Term.let f0 ($Kind.Term.bind vars$0 (Kind.Path.Builder.o path$1) f1) (lambda (x$7) ($Kind.Term.bind ($List.cons ($Pair.new f0 x$7) vars$0) (Kind.Path.Builder.i path$1) (f2 ($Kind.Term.var f0 vlen$6)))))))))) ('Kind.Term.def (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((vlen$6 ($List.length vars$0))) ($Kind.Term.def f0 ($Kind.Term.bind vars$0 (Kind.Path.Builder.o path$1) f1) (lambda (x$7) ($Kind.Term.bind ($List.cons ($Pair.new f0 x$7) vars$0) (Kind.Path.Builder.i path$1) (f2 ($Kind.Term.var f0 vlen$6)))))))))) ('Kind.Term.ann (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) ($Kind.Term.ann f0 ($Kind.Term.bind vars$0 (Kind.Path.Builder.o path$1) f1) ($Kind.Term.bind vars$0 (Kind.Path.Builder.i path$1) f2)))))) ('Kind.Term.gol (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) ($Kind.Term.gol f0 f1 f2))))) ('Kind.Term.hol (let ((f0 (get self0 1))) ($Kind.Term.hol ($Kind.Path.Builder.to_bits path$1)))) ('Kind.Term.nat (let ((f0 (get self0 1))) ($Kind.Term.nat f0))) ('Kind.Term.chr (let ((f0 (get self0 1))) ($Kind.Term.chr f0))) ('Kind.Term.str (let ((f0 (get self0 1))) ($Kind.Term.str f0))) ('Kind.Term.num (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) ($Kind.Term.num f0 f1 f2))))) ('Kind.Term.cse (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((f5 (get self0 6))) (let ((expr$9 ($Kind.Term.bind vars$0 (Kind.Path.Builder.o path$1) f1))) (let ((name$10 f2)) (let ((wyth$11 ($List.mapped f3 (lambda (with_var$11) (let ((self9 with_var$11)) (case (get self9 0) ('Kind.Ann.new (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((with_var_term$15 ($Kind.Term.bind vars$0 path$1 f10))) (let ((with_var_type$16 (let ((self13 f11)) (case (get self13 0) ('Maybe.none Maybe.none) ('Maybe.some (let ((f13 (get self13 1))) ($Maybe.some ($Kind.Term.bind vars$0 path$1 f13)))))))) ($Kind.Ann.new f9 with_var_term$15 with_var_type$16))))))))))))) (let ((cses$12 f4)) (let ((moti$13 f5)) ($Kind.Term.cse ($Kind.Path.Builder.to_bits path$1) expr$9 name$10 wyth$11 cses$12 moti$13))))))))))))) ('Kind.Term.new (let ((f0 (get self0 1))) (let ((args$4 ($List.imapped f0 (lambda (idx$4) (lambda (arg$5) ($Kind.Term.bind vars$0 ($Kind.Path.Builder.nat idx$4 path$1) arg$5)))))) ($Kind.Term.new args$4)))) ('Kind.Term.get (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((expr$5 ($Kind.Term.bind vars$0 (Kind.Path.Builder.o path$1) f0))) ($Kind.Term.get expr$5 f1))))) ('Kind.Term.set (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((expr$6 ($Kind.Term.bind vars$0 (Kind.Path.Builder.o path$1) f0))) (let ((fval$7 ($Kind.Term.bind vars$0 (Kind.Path.Builder.i path$1) f2))) ($Kind.Term.set expr$6 f1 fval$7))))))) ('Kind.Term.ope (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((arg0$6 ($Kind.Term.bind vars$0 (Kind.Path.Builder.o path$1) f1))) (let ((arg1$7 ($Kind.Term.bind vars$0 (Kind.Path.Builder.i path$1) f2))) ($Kind.Term.ope f0 arg0$6 arg1$7))))))) ('Kind.Term.ori (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($Kind.Term.ori f0 ($Kind.Term.bind vars$0 path$1 f1))))))))
(define Kind.Term.bind (lambda (vars$0) (lambda (path$1) (lambda (term$2) ($Kind.Term.bind vars$0 path$1 term$2)))))
(define ($Trampoline.call t$1) (let ((self0 t$1)) (case (get self0 0) ('Trampoline.done (let ((f0 (get self0 1))) f0)) ('Trampoline.wrap (let ((f0 (get self0 1))) ($Trampoline.call (f0 Unit.new)))))))
(define Trampoline.call (lambda (t$1) ($Trampoline.call t$1)))
(define ($Trampoline.wrap value$1) (vector 'Trampoline.wrap value$1))
(define Trampoline.wrap (lambda (value$1) ($Trampoline.wrap value$1)))
(define ($BitsMap.set_if_empty.cps.go bits$1 val$2 map$3 cont$4) (let ((self0 bits$1)) (case (if (eq? self0 #b1) 2 (bitwise-and self0 #b1)) (2 (let ((self0 map$3)) (case (get self0 0) ('BitsMap.new (cont$4 ($BitsMap.tie ($Maybe.some val$2) BitsMap.new BitsMap.new))) ('BitsMap.tie (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (cont$4 ($BitsMap.tie (let ((self3 f0)) (case (get self3 0) ('Maybe.none ($Maybe.some val$2)) ('Maybe.some (let ((f3 (get self3 1))) ($Maybe.some f3))))) f1 f2))))))))) (0 (let ((f0 (bitwise-arithmetic-shift-right self0 #b1))) (let ((self1 map$3)) (case (get self1 0) ('BitsMap.new ($BitsMap.set_if_empty.cps.go f0 val$2 BitsMap.new (lambda (lft$6) ($Trampoline.wrap (lambda ($7) (cont$4 ($BitsMap.tie Maybe.none lft$6 BitsMap.new))))))) ('BitsMap.tie (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) ($BitsMap.set_if_empty.cps.go f0 val$2 f2 (lambda (lft$9) ($Trampoline.wrap (lambda ($10) (cont$4 ($BitsMap.tie f1 lft$9 f3)))))))))))))) (1 (let ((f0 (bitwise-arithmetic-shift-right self0 #b1))) (let ((self1 map$3)) (case (get self1 0) ('BitsMap.new ($BitsMap.set_if_empty.cps.go f0 val$2 BitsMap.new (lambda (rgt$6) ($Trampoline.wrap (lambda ($7) (cont$4 ($BitsMap.tie Maybe.none BitsMap.new rgt$6))))))) ('BitsMap.tie (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) ($BitsMap.set_if_empty.cps.go f0 val$2 f3 (lambda (rgt$9) ($Trampoline.wrap (lambda ($10) (cont$4 ($BitsMap.tie f1 f2 rgt$9)))))))))))))))))
(define BitsMap.set_if_empty.cps.go (lambda (bits$1) (lambda (val$2) (lambda (map$3) (lambda (cont$4) ($BitsMap.set_if_empty.cps.go bits$1 val$2 map$3 cont$4))))))
(define ($Trampoline.done value$1) (vector 'Trampoline.done value$1))
(define Trampoline.done (lambda (value$1) ($Trampoline.done value$1)))
(define ($BitsMap.set_if_empty.cps bits$1 val$2 map$3) ($Trampoline.call ($BitsMap.set_if_empty.cps.go bits$1 val$2 map$3 Trampoline.done)))
(define BitsMap.set_if_empty.cps (lambda (bits$1) (lambda (val$2) (lambda (map$3) ($BitsMap.set_if_empty.cps bits$1 val$2 map$3)))))
(define ($BitsMap.set_if_empty bits$1 val$2 map$3) ($BitsMap.set_if_empty.cps bits$1 val$2 map$3))
(define BitsMap.set_if_empty (lambda (bits$1) (lambda (val$2) (lambda (map$3) ($BitsMap.set_if_empty bits$1 val$2 map$3)))))
(define ($Kind.Map.set_if_empty name$1 val$2 map$3) ($BitsMap.set_if_empty ($Kind.Name.to_bits name$1) val$2 map$3))
(define Kind.Map.set_if_empty (lambda (name$1) (lambda (val$2) (lambda (map$3) ($Kind.Map.set_if_empty name$1 val$2 map$3)))))
(define Kind.Status.init (vector 'Kind.Status.init))
(define ($Kind.Map.def file$0 code$1 orig$2 name$3 term$4 type$5 isct$6 arit$7 done$8 defs$9) (let ((defn$10 ((((((((Kind.Def.new file$0) code$1) orig$2) name$3) term$4) type$5) isct$6) arit$7))) (let ((self1 done$8)) (case self1 (#t ($Kind.Map.set name$3 (defn$10 ($Kind.Status.done Bool.false)) defs$9)) (#f ($Kind.Map.set_if_empty name$3 (defn$10 Kind.Status.init) defs$9))))))
(define Kind.Map.def (lambda (file$0) (lambda (code$1) (lambda (orig$2) (lambda (name$3) (lambda (term$4) (lambda (type$5) (lambda (isct$6) (lambda (arit$7) (lambda (done$8) (lambda (defs$9) ($Kind.Map.def file$0 code$1 orig$2 name$3 term$4 type$5 isct$6 arit$7 done$8 defs$9))))))))))))
(define ($Kind.Parser.file.def file$0 code$1 defs$2 pst$3) (let ((self0 pst$3)) (case (get self0 0) ('Parser.State.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((reply$9 (Kind.Parser.spaces pst$3))) (let ((self6 reply$9)) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))) (let ((self7 f0)) (case (get self7 0) ('Maybe.none ($Parser.Reply.error f6)) ('Maybe.some (let ((f7 (get self7 1))) ($Parser.Reply.error ($Parser.Error.combine f7 f6)))))))) ('Parser.Reply.value (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((self8 f6)) (case (get self8 0) ('Parser.State.new (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) (let ((f11 (get self8 4))) (let ((f12 (get self8 5))) (let ((reply.pst$17 ($Parser.State.new ($Parser.Error.maybe_combine f0 f8) f9 f10 f11 f12))) (let ((self14 reply.pst$17)) (case (get self14 0) ('Parser.State.new (let ((f14 (get self14 1))) (let ((f15 (get self14 2))) (let ((f16 (get self14 3))) (let ((f17 (get self14 4))) (let ((f18 (get self14 5))) (let ((reply$23 ($Parser.get_idx reply.pst$17))) (let ((self20 reply$23)) (case (get self20 0) ('Parser.Reply.error (let ((f20 (get self20 1))) (let ((self21 f14)) (case (get self21 0) ('Maybe.none ($Parser.Reply.error f20)) ('Maybe.some (let ((f21 (get self21 1))) ($Parser.Reply.error ($Parser.Error.combine f21 f20)))))))) ('Parser.Reply.value (let ((f20 (get self20 1))) (let ((f21 (get self20 2))) (let ((self22 f20)) (case (get self22 0) ('Parser.State.new (let ((f22 (get self22 1))) (let ((f23 (get self22 2))) (let ((f24 (get self22 3))) (let ((f25 (get self22 4))) (let ((f26 (get self22 5))) (let ((reply.pst$31 ($Parser.State.new ($Parser.Error.maybe_combine f14 f22) f23 f24 f25 f26))) (let ((self28 reply.pst$31)) (case (get self28 0) ('Parser.State.new (let ((f28 (get self28 1))) (let ((f29 (get self28 2))) (let ((f30 (get self28 3))) (let ((f31 (get self28 4))) (let ((f32 (get self28 5))) (let ((reply$37 ($Kind.Parser.name1 reply.pst$31))) (let ((self34 reply$37)) (case (get self34 0) ('Parser.Reply.error (let ((f34 (get self34 1))) (let ((self35 f28)) (case (get self35 0) ('Maybe.none ($Parser.Reply.error f34)) ('Maybe.some (let ((f35 (get self35 1))) ($Parser.Reply.error ($Parser.Error.combine f35 f34)))))))) ('Parser.Reply.value (let ((f34 (get self34 1))) (let ((f35 (get self34 2))) (let ((self36 f34)) (case (get self36 0) ('Parser.State.new (let ((f36 (get self36 1))) (let ((f37 (get self36 2))) (let ((f38 (get self36 3))) (let ((f39 (get self36 4))) (let ((f40 (get self36 5))) (let ((reply.pst$45 ($Parser.State.new ($Parser.Error.maybe_combine f28 f36) f37 f38 f39 f40))) (let ((self42 reply.pst$45)) (case (get self42 0) ('Parser.State.new (let ((f42 (get self42 1))) (let ((f43 (get self42 2))) (let ((f44 (get self42 3))) (let ((f45 (get self42 4))) (let ((f46 (get self42 5))) (let ((reply$51 (($Parser.many (Kind.Parser.binder ":")) reply.pst$45))) (let ((self48 reply$51)) (case (get self48 0) ('Parser.Reply.error (let ((f48 (get self48 1))) (let ((self49 f42)) (case (get self49 0) ('Maybe.none ($Parser.Reply.error f48)) ('Maybe.some (let ((f49 (get self49 1))) ($Parser.Reply.error ($Parser.Error.combine f49 f48)))))))) ('Parser.Reply.value (let ((f48 (get self48 1))) (let ((f49 (get self48 2))) (let ((self50 f48)) (case (get self50 0) ('Parser.State.new (let ((f50 (get self50 1))) (let ((f51 (get self50 2))) (let ((f52 (get self50 3))) (let ((f53 (get self50 4))) (let ((f54 (get self50 5))) (let ((reply.pst$59 ($Parser.State.new ($Parser.Error.maybe_combine f42 f50) f51 f52 f53 f54))) (let ((args$60 ($List.flatten f49))) (let ((self57 reply.pst$59)) (case (get self57 0) ('Parser.State.new (let ((f57 (get self57 1))) (let ((f58 (get self57 2))) (let ((f59 (get self57 3))) (let ((f60 (get self57 4))) (let ((f61 (get self57 5))) (let ((reply$66 ($Kind.Parser.text ":" reply.pst$59))) (let ((self63 reply$66)) (case (get self63 0) ('Parser.Reply.error (let ((f63 (get self63 1))) (let ((self64 f57)) (case (get self64 0) ('Maybe.none ($Parser.Reply.error f63)) ('Maybe.some (let ((f64 (get self64 1))) ($Parser.Reply.error ($Parser.Error.combine f64 f63)))))))) ('Parser.Reply.value (let ((f63 (get self63 1))) (let ((f64 (get self63 2))) (let ((self65 f63)) (case (get self65 0) ('Parser.State.new (let ((f65 (get self65 1))) (let ((f66 (get self65 2))) (let ((f67 (get self65 3))) (let ((f68 (get self65 4))) (let ((f69 (get self65 5))) (let ((reply.pst$74 ($Parser.State.new ($Parser.Error.maybe_combine f57 f65) f66 f67 f68 f69))) (let ((self71 reply.pst$74)) (case (get self71 0) ('Parser.State.new (let ((f71 (get self71 1))) (let ((f72 (get self71 2))) (let ((f73 (get self71 3))) (let ((f74 (get self71 4))) (let ((f75 (get self71 5))) (let ((reply$80 (Kind.Parser.term reply.pst$74))) (let ((self77 reply$80)) (case (get self77 0) ('Parser.Reply.error (let ((f77 (get self77 1))) (let ((self78 f71)) (case (get self78 0) ('Maybe.none ($Parser.Reply.error f77)) ('Maybe.some (let ((f78 (get self78 1))) ($Parser.Reply.error ($Parser.Error.combine f78 f77)))))))) ('Parser.Reply.value (let ((f77 (get self77 1))) (let ((f78 (get self77 2))) (let ((self79 f77)) (case (get self79 0) ('Parser.State.new (let ((f79 (get self79 1))) (let ((f80 (get self79 2))) (let ((f81 (get self79 3))) (let ((f82 (get self79 4))) (let ((f83 (get self79 5))) (let ((reply.pst$88 ($Parser.State.new ($Parser.Error.maybe_combine f71 f79) f80 f81 f82 f83))) (let ((self85 reply.pst$88)) (case (get self85 0) ('Parser.State.new (let ((f85 (get self85 1))) (let ((f86 (get self85 2))) (let ((f87 (get self85 3))) (let ((f88 (get self85 4))) (let ((f89 (get self85 5))) (let ((reply$94 (Kind.Parser.term reply.pst$88))) (let ((self91 reply$94)) (case (get self91 0) ('Parser.Reply.error (let ((f91 (get self91 1))) (let ((self92 f85)) (case (get self92 0) ('Maybe.none ($Parser.Reply.error f91)) ('Maybe.some (let ((f92 (get self92 1))) ($Parser.Reply.error ($Parser.Error.combine f92 f91)))))))) ('Parser.Reply.value (let ((f91 (get self91 1))) (let ((f92 (get self91 2))) (let ((self93 f91)) (case (get self93 0) ('Parser.State.new (let ((f93 (get self93 1))) (let ((f94 (get self93 2))) (let ((f95 (get self93 3))) (let ((f96 (get self93 4))) (let ((f97 (get self93 5))) (let ((reply.pst$102 ($Parser.State.new ($Parser.Error.maybe_combine f85 f93) f94 f95 f96 f97))) (let ((self99 reply.pst$102)) (case (get self99 0) ('Parser.State.new (let ((f99 (get self99 1))) (let ((f100 (get self99 2))) (let ((f101 (get self99 3))) (let ((f102 (get self99 4))) (let ((f103 (get self99 5))) (let ((reply$108 ($Parser.get_idx reply.pst$102))) (let ((self105 reply$108)) (case (get self105 0) ('Parser.Reply.error (let ((f105 (get self105 1))) (let ((self106 f99)) (case (get self106 0) ('Maybe.none ($Parser.Reply.error f105)) ('Maybe.some (let ((f106 (get self106 1))) ($Parser.Reply.error ($Parser.Error.combine f106 f105)))))))) ('Parser.Reply.value (let ((f105 (get self105 1))) (let ((f106 (get self105 2))) (let ((self107 f105)) (case (get self107 0) ('Parser.State.new (let ((f107 (get self107 1))) (let ((f108 (get self107 2))) (let ((f109 (get self107 3))) (let ((f110 (get self107 4))) (let ((f111 (get self107 5))) (let ((reply.pst$116 ($Parser.State.new ($Parser.Error.maybe_combine f99 f107) f108 f109 f110 f111))) (let ((orig$117 ($Pair.new f21 f106))) (let ((arit$118 ($List.length args$60))) (let ((type$119 ($Kind.Parser.forall.make args$60 f78))) (let ((term$120 ($Kind.Parser.lambda.make ($List.mapped args$60 (lambda (x$120) (let ((self117 x$120)) (case (get self117 0) ('Kind.Binder.new (let ((f117 (get self117 1))) (let ((f118 (get self117 2))) (let ((f119 (get self117 3))) f118)))))))) f92))) (let ((type$121 ($Kind.Term.bind List.nil (lambda (x$121) ($Bits.i x$121)) type$119))) (let ((term$122 ($Kind.Term.bind List.nil (lambda (x$122) ($Bits.o x$122)) term$120))) (let ((defs$123 ($Kind.Map.def file$0 code$1 orig$117 f35 term$122 type$121 Bool.false arit$118 Bool.false defs$2))) ($Parser.Reply.value reply.pst$116 defs$123))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.file.def (lambda (file$0) (lambda (code$1) (lambda (defs$2) (lambda (pst$3) ($Kind.Parser.file.def file$0 code$1 defs$2 pst$3))))))
(define ($Kind.Parser.ADT.Constructor.new name$0 args$1 inds$2) (vector 'Kind.Parser.ADT.Constructor.new name$0 args$1 inds$2))
(define Kind.Parser.ADT.Constructor.new (lambda (name$0) (lambda (args$1) (lambda (inds$2) ($Kind.Parser.ADT.Constructor.new name$0 args$1 inds$2)))))
(define ($Kind.Parser.ADT.ctor namespace$0 pst$1) (let ((self0 pst$1)) (case (get self0 0) ('Parser.State.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((reply$7 ($Kind.Parser.name1 pst$1))) (let ((self6 reply$7)) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))) (let ((self7 f0)) (case (get self7 0) ('Maybe.none ($Parser.Reply.error f6)) ('Maybe.some (let ((f7 (get self7 1))) ($Parser.Reply.error ($Parser.Error.combine f7 f6)))))))) ('Parser.Reply.value (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((self8 f6)) (case (get self8 0) ('Parser.State.new (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) (let ((f11 (get self8 4))) (let ((f12 (get self8 5))) (let ((reply.pst$15 ($Parser.State.new ($Parser.Error.maybe_combine f0 f8) f9 f10 f11 f12))) (let ((self14 reply.pst$15)) (case (get self14 0) ('Parser.State.new (let ((f14 (get self14 1))) (let ((f15 (get self14 2))) (let ((f16 (get self14 3))) (let ((f17 (get self14 4))) (let ((f18 (get self14 5))) (let ((reply$21 ($Parser.maybe (Kind.Parser.binder ":") reply.pst$15))) (let ((self20 reply$21)) (case (get self20 0) ('Parser.Reply.error (let ((f20 (get self20 1))) (let ((self21 f14)) (case (get self21 0) ('Maybe.none ($Parser.Reply.error f20)) ('Maybe.some (let ((f21 (get self21 1))) ($Parser.Reply.error ($Parser.Error.combine f21 f20)))))))) ('Parser.Reply.value (let ((f20 (get self20 1))) (let ((f21 (get self20 2))) (let ((self22 f20)) (case (get self22 0) ('Parser.State.new (let ((f22 (get self22 1))) (let ((f23 (get self22 2))) (let ((f24 (get self22 3))) (let ((f25 (get self22 4))) (let ((f26 (get self22 5))) (let ((reply.pst$29 ($Parser.State.new ($Parser.Error.maybe_combine f14 f22) f23 f24 f25 f26))) (let ((self28 reply.pst$29)) (case (get self28 0) ('Parser.State.new (let ((f28 (get self28 1))) (let ((f29 (get self28 2))) (let ((f30 (get self28 3))) (let ((f31 (get self28 4))) (let ((f32 (get self28 5))) (let ((reply$35 ($Parser.maybe (lambda (pst$35) (let ((self34 pst$35)) (case (get self34 0) ('Parser.State.new (let ((f34 (get self34 1))) (let ((f35 (get self34 2))) (let ((f36 (get self34 3))) (let ((f37 (get self34 4))) (let ((f38 (get self34 5))) (let ((reply$41 ($Kind.Parser.text "~" pst$35))) (let ((self40 reply$41)) (case (get self40 0) ('Parser.Reply.error (let ((f40 (get self40 1))) (let ((self41 f34)) (case (get self41 0) ('Maybe.none ($Parser.Reply.error f40)) ('Maybe.some (let ((f41 (get self41 1))) ($Parser.Reply.error ($Parser.Error.combine f41 f40)))))))) ('Parser.Reply.value (let ((f40 (get self40 1))) (let ((f41 (get self40 2))) (let ((self42 f40)) (case (get self42 0) ('Parser.State.new (let ((f42 (get self42 1))) (let ((f43 (get self42 2))) (let ((f44 (get self42 3))) (let ((f45 (get self42 4))) (let ((f46 (get self42 5))) (let ((reply.pst$49 ($Parser.State.new ($Parser.Error.maybe_combine f34 f42) f43 f44 f45 f46))) ($Kind.Parser.binder "=" reply.pst$49))))))))))))))))))))))))) reply.pst$29))) (let ((self34 reply$35)) (case (get self34 0) ('Parser.Reply.error (let ((f34 (get self34 1))) (let ((self35 f28)) (case (get self35 0) ('Maybe.none ($Parser.Reply.error f34)) ('Maybe.some (let ((f35 (get self35 1))) ($Parser.Reply.error ($Parser.Error.combine f35 f34)))))))) ('Parser.Reply.value (let ((f34 (get self34 1))) (let ((f35 (get self34 2))) (let ((self36 f34)) (case (get self36 0) ('Parser.State.new (let ((f36 (get self36 1))) (let ((f37 (get self36 2))) (let ((f38 (get self36 3))) (let ((f39 (get self36 4))) (let ((f40 (get self36 5))) (let ((reply.pst$43 ($Parser.State.new ($Parser.Error.maybe_combine f28 f36) f37 f38 f39 f40))) (let ((args$44 ($Maybe.default f21 List.nil))) (let ((inds$45 ($Maybe.default f35 List.nil))) ($Parser.Reply.value reply.pst$43 ($Kind.Parser.ADT.Constructor.new f7 args$44 inds$45))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.ADT.ctor (lambda (namespace$0) (lambda (pst$1) ($Kind.Parser.ADT.ctor namespace$0 pst$1))))
(define ($Kind.Parser.ADT.Datatype.new name$0 pars$1 inds$2 ctrs$3 deri$4) (vector 'Kind.Parser.ADT.Datatype.new name$0 pars$1 inds$2 ctrs$3 deri$4))
(define Kind.Parser.ADT.Datatype.new (lambda (name$0) (lambda (pars$1) (lambda (inds$2) (lambda (ctrs$3) (lambda (deri$4) ($Kind.Parser.ADT.Datatype.new name$0 pars$1 inds$2 ctrs$3 deri$4)))))))
(define ($Kind.Parser.ADT.adt pst$0) (let ((self0 pst$0)) (case (get self0 0) ('Parser.State.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((reply$6 ($Kind.Parser.text "type " pst$0))) (let ((self6 reply$6)) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))) (let ((self7 f0)) (case (get self7 0) ('Maybe.none ($Parser.Reply.error f6)) ('Maybe.some (let ((f7 (get self7 1))) ($Parser.Reply.error ($Parser.Error.combine f7 f6)))))))) ('Parser.Reply.value (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((self8 f6)) (case (get self8 0) ('Parser.State.new (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) (let ((f11 (get self8 4))) (let ((f12 (get self8 5))) (let ((reply.pst$14 ($Parser.State.new ($Parser.Error.maybe_combine f0 f8) f9 f10 f11 f12))) (let ((self14 reply.pst$14)) (case (get self14 0) ('Parser.State.new (let ((f14 (get self14 1))) (let ((f15 (get self14 2))) (let ((f16 (get self14 3))) (let ((f17 (get self14 4))) (let ((f18 (get self14 5))) (let ((reply$20 ($Kind.Parser.name1 reply.pst$14))) (let ((self20 reply$20)) (case (get self20 0) ('Parser.Reply.error (let ((f20 (get self20 1))) (let ((self21 f14)) (case (get self21 0) ('Maybe.none ($Parser.Reply.error f20)) ('Maybe.some (let ((f21 (get self21 1))) ($Parser.Reply.error ($Parser.Error.combine f21 f20)))))))) ('Parser.Reply.value (let ((f20 (get self20 1))) (let ((f21 (get self20 2))) (let ((self22 f20)) (case (get self22 0) ('Parser.State.new (let ((f22 (get self22 1))) (let ((f23 (get self22 2))) (let ((f24 (get self22 3))) (let ((f25 (get self22 4))) (let ((f26 (get self22 5))) (let ((reply.pst$28 ($Parser.State.new ($Parser.Error.maybe_combine f14 f22) f23 f24 f25 f26))) (let ((self28 reply.pst$28)) (case (get self28 0) ('Parser.State.new (let ((f28 (get self28 1))) (let ((f29 (get self28 2))) (let ((f30 (get self28 3))) (let ((f31 (get self28 4))) (let ((f32 (get self28 5))) (let ((reply$34 ($Parser.maybe (Kind.Parser.binder ":") reply.pst$28))) (let ((self34 reply$34)) (case (get self34 0) ('Parser.Reply.error (let ((f34 (get self34 1))) (let ((self35 f28)) (case (get self35 0) ('Maybe.none ($Parser.Reply.error f34)) ('Maybe.some (let ((f35 (get self35 1))) ($Parser.Reply.error ($Parser.Error.combine f35 f34)))))))) ('Parser.Reply.value (let ((f34 (get self34 1))) (let ((f35 (get self34 2))) (let ((self36 f34)) (case (get self36 0) ('Parser.State.new (let ((f36 (get self36 1))) (let ((f37 (get self36 2))) (let ((f38 (get self36 3))) (let ((f39 (get self36 4))) (let ((f40 (get self36 5))) (let ((reply.pst$42 ($Parser.State.new ($Parser.Error.maybe_combine f28 f36) f37 f38 f39 f40))) (let ((self42 reply.pst$42)) (case (get self42 0) ('Parser.State.new (let ((f42 (get self42 1))) (let ((f43 (get self42 2))) (let ((f44 (get self42 3))) (let ((f45 (get self42 4))) (let ((f46 (get self42 5))) (let ((reply$48 ($Parser.maybe (lambda (pst$48) (let ((self48 pst$48)) (case (get self48 0) ('Parser.State.new (let ((f48 (get self48 1))) (let ((f49 (get self48 2))) (let ((f50 (get self48 3))) (let ((f51 (get self48 4))) (let ((f52 (get self48 5))) (let ((reply$54 ($Kind.Parser.text "~" pst$48))) (let ((self54 reply$54)) (case (get self54 0) ('Parser.Reply.error (let ((f54 (get self54 1))) (let ((self55 f48)) (case (get self55 0) ('Maybe.none ($Parser.Reply.error f54)) ('Maybe.some (let ((f55 (get self55 1))) ($Parser.Reply.error ($Parser.Error.combine f55 f54)))))))) ('Parser.Reply.value (let ((f54 (get self54 1))) (let ((f55 (get self54 2))) (let ((self56 f54)) (case (get self56 0) ('Parser.State.new (let ((f56 (get self56 1))) (let ((f57 (get self56 2))) (let ((f58 (get self56 3))) (let ((f59 (get self56 4))) (let ((f60 (get self56 5))) (let ((reply.pst$62 ($Parser.State.new ($Parser.Error.maybe_combine f48 f56) f57 f58 f59 f60))) ($Kind.Parser.binder ":" reply.pst$62))))))))))))))))))))))))) reply.pst$42))) (let ((self48 reply$48)) (case (get self48 0) ('Parser.Reply.error (let ((f48 (get self48 1))) (let ((self49 f42)) (case (get self49 0) ('Maybe.none ($Parser.Reply.error f48)) ('Maybe.some (let ((f49 (get self49 1))) ($Parser.Reply.error ($Parser.Error.combine f49 f48)))))))) ('Parser.Reply.value (let ((f48 (get self48 1))) (let ((f49 (get self48 2))) (let ((self50 f48)) (case (get self50 0) ('Parser.State.new (let ((f50 (get self50 1))) (let ((f51 (get self50 2))) (let ((f52 (get self50 3))) (let ((f53 (get self50 4))) (let ((f54 (get self50 5))) (let ((reply.pst$56 ($Parser.State.new ($Parser.Error.maybe_combine f42 f50) f51 f52 f53 f54))) (let ((pars$57 ($Maybe.default f35 List.nil))) (let ((inds$58 ($Maybe.default f49 List.nil))) (let ((self58 reply.pst$56)) (case (get self58 0) ('Parser.State.new (let ((f58 (get self58 1))) (let ((f59 (get self58 2))) (let ((f60 (get self58 3))) (let ((f61 (get self58 4))) (let ((f62 (get self58 5))) (let ((reply$64 (($Kind.Parser.items "{" (Kind.Parser.ADT.ctor f21) "}") reply.pst$56))) (let ((self64 reply$64)) (case (get self64 0) ('Parser.Reply.error (let ((f64 (get self64 1))) (let ((self65 f58)) (case (get self65 0) ('Maybe.none ($Parser.Reply.error f64)) ('Maybe.some (let ((f65 (get self65 1))) ($Parser.Reply.error ($Parser.Error.combine f65 f64)))))))) ('Parser.Reply.value (let ((f64 (get self64 1))) (let ((f65 (get self64 2))) (let ((self66 f64)) (case (get self66 0) ('Parser.State.new (let ((f66 (get self66 1))) (let ((f67 (get self66 2))) (let ((f68 (get self66 3))) (let ((f69 (get self66 4))) (let ((f70 (get self66 5))) (let ((reply.pst$72 ($Parser.State.new ($Parser.Error.maybe_combine f58 f66) f67 f68 f69 f70))) (let ((self72 reply.pst$72)) (case (get self72 0) ('Parser.State.new (let ((f72 (get self72 1))) (let ((f73 (get self72 2))) (let ((f74 (get self72 3))) (let ((f75 (get self72 4))) (let ((f76 (get self72 5))) (let ((reply$78 ($Parser.maybe (lambda (pst$78) (let ((self78 pst$78)) (case (get self78 0) ('Parser.State.new (let ((f78 (get self78 1))) (let ((f79 (get self78 2))) (let ((f80 (get self78 3))) (let ((f81 (get self78 4))) (let ((f82 (get self78 5))) (let ((reply$84 ($Kind.Parser.text "deriving" pst$78))) (let ((self84 reply$84)) (case (get self84 0) ('Parser.Reply.error (let ((f84 (get self84 1))) (let ((self85 f78)) (case (get self85 0) ('Maybe.none ($Parser.Reply.error f84)) ('Maybe.some (let ((f85 (get self85 1))) ($Parser.Reply.error ($Parser.Error.combine f85 f84)))))))) ('Parser.Reply.value (let ((f84 (get self84 1))) (let ((f85 (get self84 2))) (let ((self86 f84)) (case (get self86 0) ('Parser.State.new (let ((f86 (get self86 1))) (let ((f87 (get self86 2))) (let ((f88 (get self86 3))) (let ((f89 (get self86 4))) (let ((f90 (get self86 5))) (let ((reply.pst$92 ($Parser.State.new ($Parser.Error.maybe_combine f78 f86) f87 f88 f89 f90))) (($Kind.Parser.items "(" Kind.Parser.name1 ")") reply.pst$92))))))))))))))))))))))))) reply.pst$72))) (let ((self78 reply$78)) (case (get self78 0) ('Parser.Reply.error (let ((f78 (get self78 1))) (let ((self79 f72)) (case (get self79 0) ('Maybe.none ($Parser.Reply.error f78)) ('Maybe.some (let ((f79 (get self79 1))) ($Parser.Reply.error ($Parser.Error.combine f79 f78)))))))) ('Parser.Reply.value (let ((f78 (get self78 1))) (let ((f79 (get self78 2))) (let ((self80 f78)) (case (get self80 0) ('Parser.State.new (let ((f80 (get self80 1))) (let ((f81 (get self80 2))) (let ((f82 (get self80 3))) (let ((f83 (get self80 4))) (let ((f84 (get self80 5))) (let ((reply.pst$86 ($Parser.State.new ($Parser.Error.maybe_combine f72 f80) f81 f82 f83 f84))) (let ((deri$87 (let ((self86 f79)) (case (get self86 0) ('Maybe.none List.nil) ('Maybe.some (let ((f86 (get self86 1))) f86)))))) ($Parser.Reply.value reply.pst$86 ($Kind.Parser.ADT.Datatype.new f21 pars$57 inds$58 f65 deri$87))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.ADT.adt (lambda (pst$0) ($Kind.Parser.ADT.adt pst$0)))
(define ($Kind.Parser.ADT.Datatype.build_term.motive.go type$0 name$1 inds$2) (let ((self0 inds$2)) (case (get self0 0) ('List.nil (let ((self0 type$0)) (case (get self0 0) ('Kind.Parser.ADT.Datatype.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((slf$8 ($Kind.Term.ref name$1))) (let ((slf$9 ($List.for f1 slf$8 (lambda (v$9) (lambda (slf$10) ($Kind.Term.app slf$10 ($Kind.Term.ref (let ((self8 v$9)) (case (get self8 0) ('Kind.Binder.new (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) f9))))))))))))) (let ((slf$10 ($List.for f2 slf$9 (lambda (v$10) (lambda (slf$11) ($Kind.Term.app slf$11 ($Kind.Term.ref (let ((self9 v$10)) (case (get self9 0) ('Kind.Binder.new (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) f10))))))))))))) ($Kind.Term.all Bool.false "" "" slf$10 (lambda (s$11) (lambda (x$12) Kind.Term.typ))))))))))))))) ('List.cons (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((self2 f0)) (case (get self2 0) ('Kind.Binder.new (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) ($Kind.Term.all f2 "" f3 f4 (lambda (s$8) (lambda (x$9) ($Kind.Parser.ADT.Datatype.build_term.motive.go type$0 name$1 f1))))))))))))))))
(define Kind.Parser.ADT.Datatype.build_term.motive.go (lambda (type$0) (lambda (name$1) (lambda (inds$2) ($Kind.Parser.ADT.Datatype.build_term.motive.go type$0 name$1 inds$2)))))
(define ($Kind.Parser.ADT.Datatype.build_term.motive type$0) (let ((self0 type$0)) (case (get self0 0) ('Kind.Parser.ADT.Datatype.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) ($Kind.Parser.ADT.Datatype.build_term.motive.go type$0 f0 f2))))))))))
(define Kind.Parser.ADT.Datatype.build_term.motive (lambda (type$0) ($Kind.Parser.ADT.Datatype.build_term.motive type$0)))
(define ($String.flatten.go xs$0 res$1) (let ((self0 xs$0)) (case (get self0 0) ('List.nil res$1) ('List.cons (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($String.flatten.go f1 ($String.concat res$1 f0))))))))
(define String.flatten.go (lambda (xs$0) (lambda (res$1) ($String.flatten.go xs$0 res$1))))
(define ($String.flatten xs$0) ($String.flatten.go xs$0 ""))
(define String.flatten (lambda (xs$0) ($String.flatten xs$0)))
(define ($Kind.Parser.ADT.Datatype.build_term.constructor.go type$0 ctor$1 args$2) (let ((self0 args$2)) (case (get self0 0) ('List.nil (let ((self0 type$0)) (case (get self0 0) ('Kind.Parser.ADT.Datatype.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((self5 ctor$1)) (case (get self5 0) ('Kind.Parser.ADT.Constructor.new (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) (let ((ret$11 ($Kind.Term.ref ($Kind.Name.read "P")))) (let ((ret$12 ($List.for f7 ret$11 (lambda (v$12) (lambda (ret$13) ($Kind.Term.app ret$13 (let ((self11 v$12)) (case (get self11 0) ('Kind.Binder.new (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) (let ((f13 (get self11 3))) f13)))))))))))) (let ((ctr$13 ($String.flatten ($List.cons f0 ($List.cons ($Kind.Name.read ".") ($List.cons f5 List.nil)))))) (let ((slf$14 ($Kind.Term.ref ctr$13))) (let ((slf$15 ($List.for f1 slf$14 (lambda (v$15) (lambda (slf$16) ($Kind.Term.app slf$16 ($Kind.Term.ref (let ((self14 v$15)) (case (get self14 0) ('Kind.Binder.new (let ((f14 (get self14 1))) (let ((f15 (get self14 2))) (let ((f16 (get self14 3))) f15))))))))))))) (let ((slf$16 ($List.for f6 slf$15 (lambda (v$16) (lambda (slf$17) ($Kind.Term.app slf$17 ($Kind.Term.ref (let ((self15 v$16)) (case (get self15 0) ('Kind.Binder.new (let ((f15 (get self15 1))) (let ((f16 (get self15 2))) (let ((f17 (get self15 3))) f16))))))))))))) ($Kind.Term.app ret$12 slf$16)))))))))))))))))))))) ('List.cons (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((self2 f0)) (case (get self2 0) ('Kind.Binder.new (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) (let ((eras$8 f2)) (let ((name$9 f3)) (let ((xtyp$10 f4)) (let ((body$11 ($Kind.Parser.ADT.Datatype.build_term.constructor.go type$0 ctor$1 f1))) ($Kind.Term.all eras$8 "" name$9 xtyp$10 (lambda (s$12) (lambda (x$13) body$11)))))))))))))))))))
(define Kind.Parser.ADT.Datatype.build_term.constructor.go (lambda (type$0) (lambda (ctor$1) (lambda (args$2) ($Kind.Parser.ADT.Datatype.build_term.constructor.go type$0 ctor$1 args$2)))))
(define ($Kind.Parser.ADT.Datatype.build_term.constructor type$0 ctor$1) (let ((self0 ctor$1)) (case (get self0 0) ('Kind.Parser.ADT.Constructor.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) ($Kind.Parser.ADT.Datatype.build_term.constructor.go type$0 ctor$1 f1))))))))
(define Kind.Parser.ADT.Datatype.build_term.constructor (lambda (type$0) (lambda (ctor$1) ($Kind.Parser.ADT.Datatype.build_term.constructor type$0 ctor$1))))
(define ($Kind.Parser.ADT.Datatype.build_term.constructors.go type$0 name$1 ctrs$2) (let ((self0 ctrs$2)) (case (get self0 0) ('List.nil (let ((self0 type$0)) (case (get self0 0) ('Kind.Parser.ADT.Datatype.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((ret$8 ($Kind.Term.ref ($Kind.Name.read "P")))) (let ((ret$9 ($List.for f2 ret$8 (lambda (v$9) (lambda (ret$10) ($Kind.Term.app ret$10 ($Kind.Term.ref (let ((self8 v$9)) (case (get self8 0) ('Kind.Binder.new (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) f9))))))))))))) ($Kind.Term.app ret$9 ($Kind.Term.ref ($String.concat name$1 ".Self")))))))))))))) ('List.cons (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((self2 f0)) (case (get self2 0) ('Kind.Parser.ADT.Constructor.new (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) ($Kind.Term.all Bool.false "" f2 ($Kind.Parser.ADT.Datatype.build_term.constructor type$0 f0) (lambda (s$8) (lambda (x$9) ($Kind.Parser.ADT.Datatype.build_term.constructors.go type$0 name$1 f1))))))))))))))))
(define Kind.Parser.ADT.Datatype.build_term.constructors.go (lambda (type$0) (lambda (name$1) (lambda (ctrs$2) ($Kind.Parser.ADT.Datatype.build_term.constructors.go type$0 name$1 ctrs$2)))))
(define ($Kind.Parser.ADT.Datatype.build_term.constructors type$0) (let ((self0 type$0)) (case (get self0 0) ('Kind.Parser.ADT.Datatype.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) ($Kind.Parser.ADT.Datatype.build_term.constructors.go type$0 f0 f3))))))))))
(define Kind.Parser.ADT.Datatype.build_term.constructors (lambda (type$0) ($Kind.Parser.ADT.Datatype.build_term.constructors type$0)))
(define ($Kind.Parser.ADT.Datatype.build_term.go type$0 name$1 pars$2 inds$3) (let ((self0 pars$2)) (case (get self0 0) ('List.nil (let ((self0 inds$3)) (case (get self0 0) ('List.nil ($Kind.Term.all Bool.true ($String.concat name$1 ".Self") ($Kind.Name.read "P") ($Kind.Parser.ADT.Datatype.build_term.motive type$0) (lambda (s$4) (lambda (x$5) ($Kind.Parser.ADT.Datatype.build_term.constructors type$0))))) ('List.cons (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((self2 f0)) (case (get self2 0) ('Kind.Binder.new (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) ($Kind.Term.lam f3 (lambda (x$9) ($Kind.Parser.ADT.Datatype.build_term.go type$0 name$1 pars$2 f1))))))))))))))) ('List.cons (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((self2 f0)) (case (get self2 0) ('Kind.Binder.new (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) ($Kind.Term.lam f3 (lambda (x$9) ($Kind.Parser.ADT.Datatype.build_term.go type$0 name$1 f1 inds$3)))))))))))))))
(define Kind.Parser.ADT.Datatype.build_term.go (lambda (type$0) (lambda (name$1) (lambda (pars$2) (lambda (inds$3) ($Kind.Parser.ADT.Datatype.build_term.go type$0 name$1 pars$2 inds$3))))))
(define ($Kind.Parser.ADT.Datatype.build_term type$0) (let ((self0 type$0)) (case (get self0 0) ('Kind.Parser.ADT.Datatype.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) ($Kind.Parser.ADT.Datatype.build_term.go type$0 f0 f1 f2))))))))))
(define Kind.Parser.ADT.Datatype.build_term (lambda (type$0) ($Kind.Parser.ADT.Datatype.build_term type$0)))
(define ($Kind.Parser.ADT.Datatype.build_type.go type$0 name$1 pars$2 inds$3) (let ((self0 pars$2)) (case (get self0 0) ('List.nil (let ((self0 inds$3)) (case (get self0 0) ('List.nil Kind.Term.typ) ('List.cons (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((self2 f0)) (case (get self2 0) ('Kind.Binder.new (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) ($Kind.Term.all Bool.false "" f3 f4 (lambda (s$9) (lambda (x$10) ($Kind.Parser.ADT.Datatype.build_type.go type$0 name$1 pars$2 f1)))))))))))))))) ('List.cons (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((self2 f0)) (case (get self2 0) ('Kind.Binder.new (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) ($Kind.Term.all Bool.false "" f3 f4 (lambda (s$9) (lambda (x$10) ($Kind.Parser.ADT.Datatype.build_type.go type$0 name$1 f1 inds$3))))))))))))))))
(define Kind.Parser.ADT.Datatype.build_type.go (lambda (type$0) (lambda (name$1) (lambda (pars$2) (lambda (inds$3) ($Kind.Parser.ADT.Datatype.build_type.go type$0 name$1 pars$2 inds$3))))))
(define ($Kind.Parser.ADT.Datatype.build_type type$0) (let ((self0 type$0)) (case (get self0 0) ('Kind.Parser.ADT.Datatype.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) ($Kind.Parser.ADT.Datatype.build_type.go type$0 f0 f1 f2))))))))))
(define Kind.Parser.ADT.Datatype.build_type (lambda (type$0) ($Kind.Parser.ADT.Datatype.build_type type$0)))
(define ($Kind.Parser.ADT.Constructor.build_term.opt.go type$0 ctor$1 ctrs$2) (let ((self0 ctrs$2)) (case (get self0 0) ('List.nil (let ((self0 ctor$1)) (case (get self0 0) ('Kind.Parser.ADT.Constructor.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((ret$6 ($Kind.Term.ref f0))) (let ((ret$7 ($List.for f1 ret$6 (lambda (arg$7) (lambda (ret$8) ($Kind.Term.app ret$8 ($Kind.Term.ref (let ((self6 arg$7)) (case (get self6 0) ('Kind.Binder.new (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((f8 (get self6 3))) f7))))))))))))) ret$7))))))))) ('List.cons (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((self2 f0)) (case (get self2 0) ('Kind.Parser.ADT.Constructor.new (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) ($Kind.Term.lam f2 (lambda (x$8) ($Kind.Parser.ADT.Constructor.build_term.opt.go type$0 ctor$1 f1)))))))))))))))
(define Kind.Parser.ADT.Constructor.build_term.opt.go (lambda (type$0) (lambda (ctor$1) (lambda (ctrs$2) ($Kind.Parser.ADT.Constructor.build_term.opt.go type$0 ctor$1 ctrs$2)))))
(define ($Kind.Parser.ADT.Constructor.build_term.opt type$0 ctor$1) (let ((self0 type$0)) (case (get self0 0) ('Kind.Parser.ADT.Datatype.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) ($Kind.Parser.ADT.Constructor.build_term.opt.go type$0 ctor$1 f3))))))))))
(define Kind.Parser.ADT.Constructor.build_term.opt (lambda (type$0) (lambda (ctor$1) ($Kind.Parser.ADT.Constructor.build_term.opt type$0 ctor$1))))
(define ($Kind.Parser.ADT.Constructor.build_term.go type$0 ctor$1 name$2 pars$3 args$4) (let ((self0 pars$3)) (case (get self0 0) ('List.nil (let ((self0 args$4)) (case (get self0 0) ('List.nil ($Kind.Term.lam ($Kind.Name.read "P") (lambda (x$5) ($Kind.Parser.ADT.Constructor.build_term.opt type$0 ctor$1)))) ('List.cons (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((self2 f0)) (case (get self2 0) ('Kind.Binder.new (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) ($Kind.Term.lam f3 (lambda (x$10) ($Kind.Parser.ADT.Constructor.build_term.go type$0 ctor$1 name$2 pars$3 f1))))))))))))))) ('List.cons (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((self2 f0)) (case (get self2 0) ('Kind.Binder.new (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) ($Kind.Term.lam f3 (lambda (x$10) ($Kind.Parser.ADT.Constructor.build_term.go type$0 ctor$1 name$2 f1 args$4)))))))))))))))
(define Kind.Parser.ADT.Constructor.build_term.go (lambda (type$0) (lambda (ctor$1) (lambda (name$2) (lambda (pars$3) (lambda (args$4) ($Kind.Parser.ADT.Constructor.build_term.go type$0 ctor$1 name$2 pars$3 args$4)))))))
(define ($Kind.Parser.ADT.Constructor.build_term type$0 ctor$1) (let ((self0 type$0)) (case (get self0 0) ('Kind.Parser.ADT.Datatype.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((self5 ctor$1)) (case (get self5 0) ('Kind.Parser.ADT.Constructor.new (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) ($Kind.Parser.ADT.Constructor.build_term.go type$0 ctor$1 f0 f1 f6))))))))))))))))
(define Kind.Parser.ADT.Constructor.build_term (lambda (type$0) (lambda (ctor$1) ($Kind.Parser.ADT.Constructor.build_term type$0 ctor$1))))
(define ($Kind.Parser.ADT.Constructor.build_type.go type$0 ctor$1 name$2 pars$3 args$4) (let ((self0 pars$3)) (case (get self0 0) ('List.nil (let ((self0 args$4)) (case (get self0 0) ('List.nil (let ((self0 type$0)) (case (get self0 0) ('Kind.Parser.ADT.Datatype.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((self5 ctor$1)) (case (get self5 0) ('Kind.Parser.ADT.Constructor.new (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) (let ((type$13 ($Kind.Term.ref name$2))) (let ((type$14 ($List.for f1 type$13 (lambda (v$14) (lambda (type$15) ($Kind.Term.app type$15 ($Kind.Term.ref (let ((self11 v$14)) (case (get self11 0) ('Kind.Binder.new (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) (let ((f13 (get self11 3))) f12))))))))))))) (let ((type$15 ($List.for f7 type$14 (lambda (v$15) (lambda (type$16) ($Kind.Term.app type$16 (let ((self12 v$15)) (case (get self12 0) ('Kind.Binder.new (let ((f12 (get self12 1))) (let ((f13 (get self12 2))) (let ((f14 (get self12 3))) f14)))))))))))) type$15)))))))))))))))))) ('List.cons (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((self2 f0)) (case (get self2 0) ('Kind.Binder.new (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) ($Kind.Term.all f2 "" f3 f4 (lambda (s$10) (lambda (x$11) ($Kind.Parser.ADT.Constructor.build_type.go type$0 ctor$1 name$2 pars$3 f1)))))))))))))))) ('List.cons (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((self2 f0)) (case (get self2 0) ('Kind.Binder.new (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) ($Kind.Term.all f2 "" f3 f4 (lambda (s$10) (lambda (x$11) ($Kind.Parser.ADT.Constructor.build_type.go type$0 ctor$1 name$2 f1 args$4))))))))))))))))
(define Kind.Parser.ADT.Constructor.build_type.go (lambda (type$0) (lambda (ctor$1) (lambda (name$2) (lambda (pars$3) (lambda (args$4) ($Kind.Parser.ADT.Constructor.build_type.go type$0 ctor$1 name$2 pars$3 args$4)))))))
(define ($Kind.Parser.ADT.Constructor.build_type type$0 ctor$1) (let ((self0 type$0)) (case (get self0 0) ('Kind.Parser.ADT.Datatype.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((self5 ctor$1)) (case (get self5 0) ('Kind.Parser.ADT.Constructor.new (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) ($Kind.Parser.ADT.Constructor.build_type.go type$0 ctor$1 f0 f1 f6))))))))))))))))
(define Kind.Parser.ADT.Constructor.build_type (lambda (type$0) (lambda (ctor$1) ($Kind.Parser.ADT.Constructor.build_type type$0 ctor$1))))
(define ($List.is_empty list$1) (let ((self0 list$1)) (case (get self0 0) ('List.nil Bool.true) ('List.cons (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) Bool.false))))))
(define List.is_empty (lambda (list$1) ($List.is_empty list$1)))
(define ($Kind.Term.get_args.go term$0 args$1) (let ((self0 term$0)) (case (get self0 0) ('Kind.Term.var (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($Pair.new term$0 args$1)))) ('Kind.Term.ref (let ((f0 (get self0 1))) ($Pair.new term$0 args$1))) ('Kind.Term.typ ($Pair.new term$0 args$1)) ('Kind.Term.all (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) ($Pair.new term$0 args$1))))))) ('Kind.Term.lam (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($Pair.new term$0 args$1)))) ('Kind.Term.app (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($Kind.Term.get_args.go f0 ($List.cons f1 args$1))))) ('Kind.Term.let (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) ($Pair.new term$0 args$1))))) ('Kind.Term.def (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) ($Pair.new term$0 args$1))))) ('Kind.Term.ann (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) ($Pair.new term$0 args$1))))) ('Kind.Term.gol (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) ($Pair.new term$0 args$1))))) ('Kind.Term.hol (let ((f0 (get self0 1))) ($Pair.new term$0 args$1))) ('Kind.Term.nat (let ((f0 (get self0 1))) ($Pair.new term$0 args$1))) ('Kind.Term.chr (let ((f0 (get self0 1))) ($Pair.new term$0 args$1))) ('Kind.Term.str (let ((f0 (get self0 1))) ($Pair.new term$0 args$1))) ('Kind.Term.num (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) ($Pair.new term$0 args$1))))) ('Kind.Term.cse (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((f5 (get self0 6))) ($Pair.new term$0 args$1)))))))) ('Kind.Term.new (let ((f0 (get self0 1))) ($Pair.new term$0 args$1))) ('Kind.Term.get (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($Pair.new term$0 args$1)))) ('Kind.Term.set (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) ($Pair.new term$0 args$1))))) ('Kind.Term.ope (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) ($Pair.new term$0 args$1))))) ('Kind.Term.ori (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($Kind.Term.get_args.go f1 args$1)))))))
(define Kind.Term.get_args.go (lambda (term$0) (lambda (args$1) ($Kind.Term.get_args.go term$0 args$1))))
(define ($Kind.Term.get_args term$0) ($Kind.Term.get_args.go term$0 List.nil))
(define Kind.Term.get_args (lambda (term$0) ($Kind.Term.get_args term$0)))
(define ($Kind.Parser.ADT.Derive.stringifier.term.cont call$0 rest$1) (let ((self0 ($Kind.Term.get_args call$0))) (case (get self0 0) ('Pair.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((term$4 ($Kind.Term.ref ($String.concat ($Kind.Term.extract_name f0) ".stringifier")))) (let ((term$5 ($List.for f1 term$4 (lambda (par$5) (lambda (term$6) ($Kind.Term.app term$6 ($Kind.Term.hol Bits.e))))))) (let ((term$6 ($List.for f1 term$5 (lambda (par$6) (lambda (term$7) ($Kind.Term.app term$7 ($Kind.Parser.ADT.Derive.stringifier.term.cont par$6 Maybe.none))))))) (let ((self5 rest$1)) (case (get self5 0) ('Maybe.none term$6) ('Maybe.some (let ((f5 (get self5 1))) (let ((self6 f5)) (case (get self6 0) ('Pair.new (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((term$10 ($Kind.Term.app term$6 ($Kind.Term.ref f6)))) (let ((term$11 ($Kind.Term.app term$10 f7))) term$11))))))))))))))))))))
(define Kind.Parser.ADT.Derive.stringifier.term.cont (lambda (call$0) (lambda (rest$1) ($Kind.Parser.ADT.Derive.stringifier.term.cont call$0 rest$1))))
(define ($Kind.Parser.ADT.Derive.stringifier.term.args args$0 fst$1) (let ((self0 args$0)) (case (get self0 0) ('List.nil (let ((term$2 ($Kind.Term.ref "str"))) (let ((term$3 (let ((self1 fst$1)) (case self1 (#t term$2) (#f ($Kind.Term.app ($Kind.Term.app ($Kind.Term.ref "Stringifier.text") ($Kind.Term.str ")")) term$2)))))) term$3))) ('List.cons (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((self2 f0)) (case (get self2 0) ('Kind.Binder.new (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) (let ((self5 ($Kind.Term.get_args f4))) (case (get self5 0) ('Pair.new (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((rest$9 ($Kind.Parser.ADT.Derive.stringifier.term.args f1 Bool.false))) (let ((term$10 ($Kind.Parser.ADT.Derive.stringifier.term.cont f4 ($Maybe.some ($Pair.new ($String.concat "x." f3) rest$9))))) (let ((term$11 ($Kind.Term.app ($Kind.Term.app ($Kind.Term.ref "Stringifier.text") ($Kind.Term.str (let ((self9 fst$1)) (case self9 (#t "(") (#f ","))))) term$10))) term$11))))))))))))))))))))
(define Kind.Parser.ADT.Derive.stringifier.term.args (lambda (args$0) (lambda (fst$1) ($Kind.Parser.ADT.Derive.stringifier.term.args args$0 fst$1))))
(define ($Kind.Parser.ADT.Derive.stringifier.ctr adt_name$0 ctr$1) (let ((self0 ctr$1)) (case (get self0 0) ('Kind.Parser.ADT.Constructor.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((term$5 ($Kind.Term.ref "Stringifier.text"))) (let ((term$6 ($Kind.Term.app term$5 ($Kind.Term.str ($String.concat adt_name$0 ($String.concat "." f0)))))) (let ((term$7 ($Kind.Term.app term$6 ($Kind.Parser.ADT.Derive.stringifier.term.args f1 Bool.true)))) ($Pair.new f0 term$7)))))))))))
(define Kind.Parser.ADT.Derive.stringifier.ctr (lambda (adt_name$0) (lambda (ctr$1) ($Kind.Parser.ADT.Derive.stringifier.ctr adt_name$0 ctr$1))))
(define ($Kind.Parser.ADT.Derive.stringifier.term.ctrs adt_name$0 ctrs$1) (let ((self0 ctrs$1)) (case (get self0 0) ('List.nil List.nil) ('List.cons (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($List.cons ($Kind.Parser.ADT.Derive.stringifier.ctr adt_name$0 f0) ($Kind.Parser.ADT.Derive.stringifier.term.ctrs adt_name$0 f1))))))))
(define Kind.Parser.ADT.Derive.stringifier.term.ctrs (lambda (adt_name$0) (lambda (ctrs$1) ($Kind.Parser.ADT.Derive.stringifier.term.ctrs adt_name$0 ctrs$1))))
(define ($Kind.Parser.ADT.Derive.stringifier.term adt$0) (let ((self0 adt$0)) (case (get self0 0) ('Kind.Parser.ADT.Datatype.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((self5 ($Bool.and ($List.is_empty f1) ($List.is_empty f2)))) (case self5 (#t (let ((term$6 ($Kind.Term.lam "x" (lambda (x$6) ($Kind.Term.lam "str" (lambda (str$7) (let ((ctrs$8 ($Kind.Parser.ADT.Derive.stringifier.term.ctrs f0 f3))) (let ((cses$9 Kind.Map.new)) (let ((cses$10 ($List.for ctrs$8 cses$9 (lambda (ctr$10) (lambda (cses$11) (let ((self11 ctr$10)) (case (get self11 0) ('Pair.new (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) ($Kind.Map.set f11 f12 cses$11))))))))))) ($Kind.Term.cse Bits.e x$6 "x" List.nil cses$10 Maybe.none)))))))))) ($Maybe.some term$6))) (#f Maybe.none))))))))))))
(define Kind.Parser.ADT.Derive.stringifier.term (lambda (adt$0) ($Kind.Parser.ADT.Derive.stringifier.term adt$0)))
(define ($Kind.Parser.ADT.Derive.stringifier.type adt$0) (let ((self0 adt$0)) (case (get self0 0) ('Kind.Parser.ADT.Datatype.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((self5 ($Bool.and ($List.is_empty f1) ($List.is_empty f2)))) (case self5 (#t ($Maybe.some ($Kind.Term.app ($Kind.Term.ref "Stringifier") ($Kind.Term.ref f0)))) (#f Maybe.none))))))))))))
(define Kind.Parser.ADT.Derive.stringifier.type (lambda (adt$0) ($Kind.Parser.ADT.Derive.stringifier.type adt$0)))
(define ($Kind.Parser.ADT.Derived.new name$0 arit$1 term$2 type$3) (vector 'Kind.Parser.ADT.Derived.new name$0 arit$1 term$2 type$3))
(define Kind.Parser.ADT.Derived.new (lambda (name$0) (lambda (arit$1) (lambda (term$2) (lambda (type$3) ($Kind.Parser.ADT.Derived.new name$0 arit$1 term$2 type$3))))))
(define ($Kind.Parser.ADT.Derive.parser.term.cont call$0) (let ((self0 ($Kind.Term.get_args call$0))) (case (get self0 0) ('Pair.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((term$3 ($Kind.Term.ref ($String.concat ($Kind.Term.extract_name f0) ".parser")))) (let ((term$4 ($List.for f1 term$3 (lambda (par$4) (lambda (term$5) ($Kind.Term.app term$5 ($Kind.Term.hol Bits.e))))))) (let ((term$5 ($List.for f1 term$4 (lambda (par$5) (lambda (term$6) ($Kind.Term.app term$6 ($Kind.Parser.ADT.Derive.parser.term.cont par$5))))))) term$5)))))))))
(define Kind.Parser.ADT.Derive.parser.term.cont (lambda (call$0) ($Kind.Parser.ADT.Derive.parser.term.cont call$0)))
(define ($Kind.Parser.ADT.Derive.parser.term.args adt$0 cnam$1 args$2 vars$3 fst$4) (let ((self0 args$2)) (case (get self0 0) ('List.nil (let ((body$5 ($Kind.Term.ref "Parser.pure"))) (let ((body$6 ($Kind.Term.app body$5 ($Kind.Term.hol Bits.e)))) (let ((func$7 ($Kind.Term.ref cnam$1))) (let ((func$8 ($List.fold vars$3 func$7 (lambda (var$8) (lambda (func$9) ($Kind.Term.app func$9 var$8)))))) (let ((body$9 ($Kind.Term.app body$6 func$8))) (let ((self5 fst$4)) (case self5 (#t body$9) (#f (let ((term$10 ($Kind.Term.ref "Parser.bind"))) (let ((term$11 ($Kind.Term.app term$10 ($Kind.Term.hol Bits.e)))) (let ((term$12 ($Kind.Term.app term$11 ($Kind.Term.hol Bits.e)))) (let ((term$13 ($Kind.Term.app term$12 ($Kind.Term.app ($Kind.Term.ref "Parser.text") ($Kind.Term.str ")"))))) (let ((term$14 ($Kind.Term.app term$13 ($Kind.Term.lam "" (lambda (x$14) body$9))))) term$14)))))))))))))) ('List.cons (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((self2 f0)) (case (get self2 0) ('Kind.Binder.new (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) (let ((term$10 ($Kind.Term.ref "Parser.bind"))) (let ((term$11 ($Kind.Term.app term$10 ($Kind.Term.hol Bits.e)))) (let ((term$12 ($Kind.Term.app term$11 ($Kind.Term.hol Bits.e)))) (let ((cont$13 ($Kind.Term.ref "Parser.prefix"))) (let ((cont$14 ($Kind.Term.app cont$13 ($Kind.Term.hol Bits.e)))) (let ((cont$15 ($Kind.Term.app cont$14 ($Kind.Term.str (let ((self10 fst$4)) (case self10 (#t "(") (#f ","))))))) (let ((cont$16 ($Kind.Term.app cont$15 ($Kind.Parser.ADT.Derive.parser.term.cont f4)))) (let ((term$17 ($Kind.Term.app term$12 cont$16))) (let ((term$18 ($Kind.Term.app term$17 ($Kind.Term.lam f3 (lambda (x$18) ($Kind.Parser.ADT.Derive.parser.term.args adt$0 cnam$1 f1 ($List.cons x$18 vars$3) Bool.false)))))) term$18)))))))))))))))))))))
(define Kind.Parser.ADT.Derive.parser.term.args (lambda (adt$0) (lambda (cnam$1) (lambda (args$2) (lambda (vars$3) (lambda (fst$4) ($Kind.Parser.ADT.Derive.parser.term.args adt$0 cnam$1 args$2 vars$3 fst$4)))))))
(define ($Kind.Parser.ADT.Derive.parser.term.cses adt$0 cses$1) (let ((self0 adt$0)) (case (get self0 0) ('Kind.Parser.ADT.Datatype.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((self5 cses$1)) (case (get self5 0) ('List.nil (let ((fail$7 ($Kind.Term.ref "Parser.fail"))) (let ((fail$8 ($Kind.Term.app fail$7 ($Kind.Term.hol Bits.e)))) (let ((fail$9 ($Kind.Term.app fail$8 ($Kind.Term.str "")))) (let ((term$10 ($Kind.Term.ref "List.cons"))) (let ((term$11 ($Kind.Term.app term$10 ($Kind.Term.hol Bits.e)))) (let ((term$12 ($Kind.Term.app term$11 fail$9))) (let ((term$13 ($Kind.Term.app term$12 ($Kind.Term.app ($Kind.Term.ref "List.nil") ($Kind.Term.hol Bits.e))))) term$13)))))))) ('List.cons (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((self7 f5)) (case (get self7 0) ('Kind.Parser.ADT.Constructor.new (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((f9 (get self7 3))) (let ((cnam$12 ($String.concat f0 ($String.concat "." f7)))) (let ((term$13 ($Kind.Term.ref "Parser.bind"))) (let ((term$14 ($Kind.Term.app term$13 ($Kind.Term.hol Bits.e)))) (let ((term$15 ($Kind.Term.app term$14 ($Kind.Term.hol Bits.e)))) (let ((term$16 ($Kind.Term.app term$15 ($Kind.Term.app ($Kind.Term.ref "Parser.text") ($Kind.Term.str cnam$12))))) (let ((term$17 ($Kind.Term.app term$16 ($Kind.Term.lam "" (lambda (x$17) ($Kind.Parser.ADT.Derive.parser.term.args adt$0 cnam$12 f8 List.nil Bool.true)))))) (let ((list$18 ($Kind.Term.ref "List.cons"))) (let ((list$19 ($Kind.Term.app list$18 ($Kind.Term.hol Bits.e)))) (let ((list$20 ($Kind.Term.app list$19 term$17))) (let ((list$21 ($Kind.Term.app list$20 ($Kind.Parser.ADT.Derive.parser.term.cses adt$0 f6)))) list$21))))))))))))))))))))))))))))))
(define Kind.Parser.ADT.Derive.parser.term.cses (lambda (adt$0) (lambda (cses$1) ($Kind.Parser.ADT.Derive.parser.term.cses adt$0 cses$1))))
(define ($Kind.Parser.ADT.Derive.parser.term adt$0) (let ((self0 adt$0)) (case (get self0 0) ('Kind.Parser.ADT.Datatype.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((self5 ($Bool.and ($List.is_empty f1) ($List.is_empty f2)))) (case self5 (#t (let ((term$6 ($Kind.Term.ref "Parser.choice"))) (let ((term$7 ($Kind.Term.app term$6 ($Kind.Term.hol Bits.e)))) (let ((term$8 ($Kind.Term.app term$7 ($Kind.Parser.ADT.Derive.parser.term.cses adt$0 f3)))) ($Maybe.some term$8))))) (#f Maybe.none))))))))))))
(define Kind.Parser.ADT.Derive.parser.term (lambda (adt$0) ($Kind.Parser.ADT.Derive.parser.term adt$0)))
(define ($Kind.Parser.ADT.Derive.parser.type adt$0) (let ((self0 adt$0)) (case (get self0 0) ('Kind.Parser.ADT.Datatype.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((self5 ($Bool.and ($List.is_empty f1) ($List.is_empty f2)))) (case self5 (#t ($Maybe.some ($Kind.Term.app ($Kind.Term.ref "Parser") ($Kind.Term.ref f0)))) (#f Maybe.none))))))))))))
(define Kind.Parser.ADT.Derive.parser.type (lambda (adt$0) ($Kind.Parser.ADT.Derive.parser.type adt$0)))
(define ($Kind.Parser.ADT.Derive.serializer.term.cont call$0 rest$1) (let ((self0 ($Kind.Term.get_args call$0))) (case (get self0 0) ('Pair.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((term$4 ($Kind.Term.ref ($String.concat ($Kind.Term.extract_name f0) ".serializer")))) (let ((term$5 ($List.for f1 term$4 (lambda (par$5) (lambda (term$6) ($Kind.Term.app term$6 ($Kind.Term.hol Bits.e))))))) (let ((term$6 ($List.for f1 term$5 (lambda (par$6) (lambda (term$7) ($Kind.Term.app term$7 ($Kind.Parser.ADT.Derive.serializer.term.cont par$6 Maybe.none))))))) (let ((self5 rest$1)) (case (get self5 0) ('Maybe.none term$6) ('Maybe.some (let ((f5 (get self5 1))) (let ((self6 f5)) (case (get self6 0) ('Pair.new (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((term$10 ($Kind.Term.app term$6 ($Kind.Term.ref f6)))) (let ((term$11 ($Kind.Term.app term$10 f7))) term$11))))))))))))))))))))
(define Kind.Parser.ADT.Derive.serializer.term.cont (lambda (call$0) (lambda (rest$1) ($Kind.Parser.ADT.Derive.serializer.term.cont call$0 rest$1))))
(define ($Kind.Parser.ADT.Derive.serializer.term.args args$0) (let ((self0 args$0)) (case (get self0 0) ('List.nil ($Kind.Term.ref "bs")) ('List.cons (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((self2 f0)) (case (get self2 0) ('Kind.Binder.new (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) (let ((self5 ($Kind.Term.get_args f4))) (case (get self5 0) ('Pair.new (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((rest$8 ($Kind.Parser.ADT.Derive.serializer.term.args f1))) (let ((term$9 ($Kind.Parser.ADT.Derive.serializer.term.cont f4 ($Maybe.some ($Pair.new ($String.concat "x." f3) rest$8))))) term$9)))))))))))))))))))
(define Kind.Parser.ADT.Derive.serializer.term.args (lambda (args$0) ($Kind.Parser.ADT.Derive.serializer.term.args args$0)))
(define ($Kind.Parser.ADT.Derive.serializer.ctr.bits bs$0 rest$1) (let ((self0 bs$0)) (case (if (eq? self0 #b1) 2 (bitwise-and self0 #b1)) (2 rest$1) (0 (let ((f0 (bitwise-arithmetic-shift-right self0 #b1))) ($Kind.Term.app ($Kind.Term.ref "Bits.o") ($Kind.Parser.ADT.Derive.serializer.ctr.bits f0 rest$1)))) (1 (let ((f0 (bitwise-arithmetic-shift-right self0 #b1))) ($Kind.Term.app ($Kind.Term.ref "Bits.i") ($Kind.Parser.ADT.Derive.serializer.ctr.bits f0 rest$1)))))))
(define Kind.Parser.ADT.Derive.serializer.ctr.bits (lambda (bs$0) (lambda (rest$1) ($Kind.Parser.ADT.Derive.serializer.ctr.bits bs$0 rest$1))))
(define ($Kind.Parser.ADT.Derive.serializer.ctr adt_name$0 ctr$1 header$2) (let ((self0 ctr$1)) (case (get self0 0) ('Kind.Parser.ADT.Constructor.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((term$6 ($Kind.Parser.ADT.Derive.serializer.term.args f1))) (let ((term$7 ($Kind.Parser.ADT.Derive.serializer.ctr.bits header$2 term$6))) ($Pair.new f0 term$7))))))))))
(define Kind.Parser.ADT.Derive.serializer.ctr (lambda (adt_name$0) (lambda (ctr$1) (lambda (header$2) ($Kind.Parser.ADT.Derive.serializer.ctr adt_name$0 ctr$1 header$2)))))
(define ($Kind.Parser.ADT.Derive.serializer.term.ctrs adt_name$0 ctrs$1 header$2) (let ((self0 ctrs$1)) (case (get self0 0) ('List.nil List.nil) ('List.cons (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($List.cons ($Kind.Parser.ADT.Derive.serializer.ctr adt_name$0 f0 header$2) ($Kind.Parser.ADT.Derive.serializer.term.ctrs adt_name$0 f1 ($Bits.inc header$2)))))))))
(define Kind.Parser.ADT.Derive.serializer.term.ctrs (lambda (adt_name$0) (lambda (ctrs$1) (lambda (header$2) ($Kind.Parser.ADT.Derive.serializer.term.ctrs adt_name$0 ctrs$1 header$2)))))
(define ($Bits.zeros n$0) (let ((self0 n$0)) (case (= self0 0) (#t Bits.e) (#f (let ((f0 (- self0 1))) ($Bits.o ($Bits.zeros f0)))))))
(define Bits.zeros (lambda (n$0) ($Bits.zeros n$0)))
(define ($Nat.div n$0 m$1) (div n$0 m$1))
(define Nat.div (lambda (n$0) (lambda (m$1) ($Nat.div n$0 m$1))))
(define ($Nat.bitlen n$0) (let ((self0 n$0)) (case (= self0 0) (#t 0) (#f (let ((f0 (- self0 1))) ($Nat.succ ($Nat.bitlen ($Nat.div n$0 2))))))))
(define Nat.bitlen (lambda (n$0) ($Nat.bitlen n$0)))
(define ($Kind.Parser.ADT.Derive.serializer.term adt$0) (let ((self0 adt$0)) (case (get self0 0) ('Kind.Parser.ADT.Datatype.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((self5 ($Bool.and ($List.is_empty f1) ($List.is_empty f2)))) (case self5 (#t (let ((term$6 ($Kind.Term.lam "x" (lambda (x$6) ($Kind.Term.lam "bs" (lambda (bs$7) (let ((ctrs$8 ($Kind.Parser.ADT.Derive.serializer.term.ctrs f0 f3 ($Bits.zeros ($Nat.bitlen ($Nat.pred ($List.length f3))))))) (let ((cses$9 Kind.Map.new)) (let ((cses$10 ($List.for ctrs$8 cses$9 (lambda (ctr$10) (lambda (cses$11) (let ((self11 ctr$10)) (case (get self11 0) ('Pair.new (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) ($Kind.Map.set f11 f12 cses$11))))))))))) ($Kind.Term.cse Bits.e x$6 "x" List.nil cses$10 Maybe.none)))))))))) ($Maybe.some term$6))) (#f Maybe.none))))))))))))
(define Kind.Parser.ADT.Derive.serializer.term (lambda (adt$0) ($Kind.Parser.ADT.Derive.serializer.term adt$0)))
(define ($Kind.Parser.ADT.Derive.serializer.type adt$0) (let ((self0 adt$0)) (case (get self0 0) ('Kind.Parser.ADT.Datatype.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((self5 ($Bool.and ($List.is_empty f1) ($List.is_empty f2)))) (case self5 (#t ($Maybe.some ($Kind.Term.app ($Kind.Term.ref "Serializer") ($Kind.Term.ref f0)))) (#f Maybe.none))))))))))))
(define Kind.Parser.ADT.Derive.serializer.type (lambda (adt$0) ($Kind.Parser.ADT.Derive.serializer.type adt$0)))
(define ($Kind.Parser.ADT.Derive.serializer.term.bits bits$0) (let ((self0 bits$0)) (case (if (eq? self0 #b1) 2 (bitwise-and self0 #b1)) (2 ($Kind.Term.ref "Bits.e")) (0 (let ((f0 (bitwise-arithmetic-shift-right self0 #b1))) ($Kind.Term.app ($Kind.Term.ref "Bits.o") ($Kind.Parser.ADT.Derive.serializer.term.bits f0)))) (1 (let ((f0 (bitwise-arithmetic-shift-right self0 #b1))) ($Kind.Term.app ($Kind.Term.ref "Bits.i") ($Kind.Parser.ADT.Derive.serializer.term.bits f0)))))))
(define Kind.Parser.ADT.Derive.serializer.term.bits (lambda (bits$0) ($Kind.Parser.ADT.Derive.serializer.term.bits bits$0)))
(define ($Kind.Parser.ADT.Derive.deserializer.term.cont call$0) (let ((self0 ($Kind.Term.get_args call$0))) (case (get self0 0) ('Pair.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((term$3 ($Kind.Term.ref ($String.concat ($Kind.Term.extract_name f0) ".deserializer")))) (let ((term$4 ($List.for f1 term$3 (lambda (par$4) (lambda (term$5) ($Kind.Term.app term$5 ($Kind.Term.hol Bits.e))))))) (let ((term$5 ($List.for f1 term$4 (lambda (par$5) (lambda (term$6) ($Kind.Term.app term$6 ($Kind.Parser.ADT.Derive.deserializer.term.cont par$5))))))) term$5)))))))))
(define Kind.Parser.ADT.Derive.deserializer.term.cont (lambda (call$0) ($Kind.Parser.ADT.Derive.deserializer.term.cont call$0)))
(define ($Kind.Parser.ADT.Derive.deserializer.term.args adt$0 cnam$1 args$2 vars$3 fst$4) (let ((self0 args$2)) (case (get self0 0) ('List.nil (let ((body$5 ($Kind.Term.ref "Deserializer.pure"))) (let ((body$6 ($Kind.Term.app body$5 ($Kind.Term.hol Bits.e)))) (let ((func$7 ($Kind.Term.ref cnam$1))) (let ((func$8 ($List.fold vars$3 func$7 (lambda (var$8) (lambda (func$9) ($Kind.Term.app func$9 var$8)))))) (let ((body$9 ($Kind.Term.app body$6 func$8))) body$9)))))) ('List.cons (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((self2 f0)) (case (get self2 0) ('Kind.Binder.new (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) (let ((term$10 ($Kind.Term.ref "Deserializer.bind"))) (let ((term$11 ($Kind.Term.app term$10 ($Kind.Term.hol Bits.e)))) (let ((term$12 ($Kind.Term.app term$11 ($Kind.Term.hol Bits.e)))) (let ((term$13 ($Kind.Term.app term$12 ($Kind.Parser.ADT.Derive.deserializer.term.cont f4)))) (let ((term$14 ($Kind.Term.app term$13 ($Kind.Term.lam f3 (lambda (x$14) ($Kind.Parser.ADT.Derive.deserializer.term.args adt$0 cnam$1 f1 ($List.cons x$14 vars$3) Bool.false)))))) term$14)))))))))))))))))
(define Kind.Parser.ADT.Derive.deserializer.term.args (lambda (adt$0) (lambda (cnam$1) (lambda (args$2) (lambda (vars$3) (lambda (fst$4) ($Kind.Parser.ADT.Derive.deserializer.term.args adt$0 cnam$1 args$2 vars$3 fst$4)))))))
(define ($Kind.Parser.ADT.Derive.deserializer.term.cses adt$0 cses$1 header$2) (let ((self0 adt$0)) (case (get self0 0) ('Kind.Parser.ADT.Datatype.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((self5 cses$1)) (case (get self5 0) ('List.nil ($Kind.Term.app ($Kind.Term.ref "List.nil") ($Kind.Term.hol Bits.e))) ('List.cons (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((self7 f5)) (case (get self7 0) ('Kind.Parser.ADT.Constructor.new (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((f9 (get self7 3))) (let ((cnam$13 ($String.concat f0 ($String.concat "." f7)))) (let ((term$14 ($Kind.Term.ref "Deserializer.bind"))) (let ((term$15 ($Kind.Term.app term$14 ($Kind.Term.hol Bits.e)))) (let ((term$16 ($Kind.Term.app term$15 ($Kind.Term.hol Bits.e)))) (let ((term$17 ($Kind.Term.app term$16 ($Kind.Term.app ($Kind.Term.ref "Deserializer.bits") ($Kind.Parser.ADT.Derive.serializer.term.bits header$2))))) (let ((term$18 ($Kind.Term.app term$17 ($Kind.Term.lam "" (lambda (x$18) ($Kind.Parser.ADT.Derive.deserializer.term.args adt$0 cnam$13 f8 List.nil Bool.true)))))) (let ((list$19 ($Kind.Term.ref "List.cons"))) (let ((list$20 ($Kind.Term.app list$19 ($Kind.Term.hol Bits.e)))) (let ((list$21 ($Kind.Term.app list$20 term$18))) (let ((list$22 ($Kind.Term.app list$21 ($Kind.Parser.ADT.Derive.deserializer.term.cses adt$0 f6 ($Bits.inc header$2))))) list$22))))))))))))))))))))))))))))))
(define Kind.Parser.ADT.Derive.deserializer.term.cses (lambda (adt$0) (lambda (cses$1) (lambda (header$2) ($Kind.Parser.ADT.Derive.deserializer.term.cses adt$0 cses$1 header$2)))))
(define ($Kind.Parser.ADT.Derive.deserializer.term adt$0) (let ((self0 adt$0)) (case (get self0 0) ('Kind.Parser.ADT.Datatype.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((self5 ($Bool.and ($List.is_empty f1) ($List.is_empty f2)))) (case self5 (#t (let ((term$6 ($Kind.Term.ref "Deserializer.choice"))) (let ((term$7 ($Kind.Term.app term$6 ($Kind.Term.hol Bits.e)))) (let ((term$8 ($Kind.Term.app term$7 ($Kind.Parser.ADT.Derive.deserializer.term.cses adt$0 f3 ($Bits.zeros ($Nat.bitlen ($Nat.pred ($List.length f3)))))))) ($Maybe.some term$8))))) (#f Maybe.none))))))))))))
(define Kind.Parser.ADT.Derive.deserializer.term (lambda (adt$0) ($Kind.Parser.ADT.Derive.deserializer.term adt$0)))
(define ($Kind.Parser.ADT.Derive.deserializer.type adt$0) (let ((self0 adt$0)) (case (get self0 0) ('Kind.Parser.ADT.Datatype.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((self5 ($Bool.and ($List.is_empty f1) ($List.is_empty f2)))) (case self5 (#t ($Maybe.some ($Kind.Term.app ($Kind.Term.ref "Deserializer") ($Kind.Term.ref f0)))) (#f Maybe.none))))))))))))
(define Kind.Parser.ADT.Derive.deserializer.type (lambda (adt$0) ($Kind.Parser.ADT.Derive.deserializer.type adt$0)))
(define ($Kind.Parser.ADT.Derive.by_name deri$0 adt$1) (let ((self0 adt$1)) (case (get self0 0) ('Kind.Parser.ADT.Datatype.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((self5 ($String.eql deri$0 "stringifier"))) (case self5 (#t (let ((name$7 ($String.concat f0 ($String.concat "." deri$0)))) (((let ((self6 Maybe.monad)) (case (get self6 0) ('Monad.new (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) f6))))) ($Kind.Parser.ADT.Derive.stringifier.term adt$1)) (lambda (term$8) (((let ((self7 Maybe.monad)) (case (get self7 0) ('Monad.new (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) f7))))) ($Kind.Parser.ADT.Derive.stringifier.type adt$1)) (lambda (type$9) ((let ((self8 Maybe.monad)) (case (get self8 0) ('Monad.new (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) f9))))) ($Kind.Parser.ADT.Derived.new name$7 0 term$8 type$9)))))))) (#f (let ((self5 ($String.eql deri$0 "parser"))) (case self5 (#t (let ((name$7 ($String.concat f0 ($String.concat "." deri$0)))) (((let ((self6 Maybe.monad)) (case (get self6 0) ('Monad.new (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) f6))))) ($Kind.Parser.ADT.Derive.parser.term adt$1)) (lambda (term$8) (((let ((self7 Maybe.monad)) (case (get self7 0) ('Monad.new (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) f7))))) ($Kind.Parser.ADT.Derive.parser.type adt$1)) (lambda (type$9) ((let ((self8 Maybe.monad)) (case (get self8 0) ('Monad.new (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) f9))))) ($Kind.Parser.ADT.Derived.new name$7 0 term$8 type$9)))))))) (#f (let ((self5 ($String.eql deri$0 "serializer"))) (case self5 (#t (let ((name$7 ($String.concat f0 ($String.concat "." deri$0)))) (((let ((self6 Maybe.monad)) (case (get self6 0) ('Monad.new (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) f6))))) ($Kind.Parser.ADT.Derive.serializer.term adt$1)) (lambda (term$8) (((let ((self7 Maybe.monad)) (case (get self7 0) ('Monad.new (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) f7))))) ($Kind.Parser.ADT.Derive.serializer.type adt$1)) (lambda (type$9) ((let ((self8 Maybe.monad)) (case (get self8 0) ('Monad.new (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) f9))))) ($Kind.Parser.ADT.Derived.new name$7 0 term$8 type$9)))))))) (#f (let ((self5 ($String.eql deri$0 "deserializer"))) (case self5 (#t (let ((name$7 ($String.concat f0 ($String.concat "." deri$0)))) (((let ((self6 Maybe.monad)) (case (get self6 0) ('Monad.new (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) f6))))) ($Kind.Parser.ADT.Derive.deserializer.term adt$1)) (lambda (term$8) (((let ((self7 Maybe.monad)) (case (get self7 0) ('Monad.new (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) f7))))) ($Kind.Parser.ADT.Derive.deserializer.type adt$1)) (lambda (type$9) ((let ((self8 Maybe.monad)) (case (get self8 0) ('Monad.new (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) f9))))) ($Kind.Parser.ADT.Derived.new name$7 0 term$8 type$9)))))))) (#f Maybe.none)))))))))))))))))))))
(define Kind.Parser.ADT.Derive.by_name (lambda (deri$0) (lambda (adt$1) ($Kind.Parser.ADT.Derive.by_name deri$0 adt$1))))
(define ($Kind.Parser.file.adt file$0 code$1 defs$2 pst$3) (let ((self0 pst$3)) (case (get self0 0) ('Parser.State.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((reply$9 (Kind.Parser.spaces pst$3))) (let ((self6 reply$9)) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))) (let ((self7 f0)) (case (get self7 0) ('Maybe.none ($Parser.Reply.error f6)) ('Maybe.some (let ((f7 (get self7 1))) ($Parser.Reply.error ($Parser.Error.combine f7 f6)))))))) ('Parser.Reply.value (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((self8 f6)) (case (get self8 0) ('Parser.State.new (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) (let ((f11 (get self8 4))) (let ((f12 (get self8 5))) (let ((reply.pst$17 ($Parser.State.new ($Parser.Error.maybe_combine f0 f8) f9 f10 f11 f12))) (let ((self14 reply.pst$17)) (case (get self14 0) ('Parser.State.new (let ((f14 (get self14 1))) (let ((f15 (get self14 2))) (let ((f16 (get self14 3))) (let ((f17 (get self14 4))) (let ((f18 (get self14 5))) (let ((reply$23 ($Parser.get_idx reply.pst$17))) (let ((self20 reply$23)) (case (get self20 0) ('Parser.Reply.error (let ((f20 (get self20 1))) (let ((self21 f14)) (case (get self21 0) ('Maybe.none ($Parser.Reply.error f20)) ('Maybe.some (let ((f21 (get self21 1))) ($Parser.Reply.error ($Parser.Error.combine f21 f20)))))))) ('Parser.Reply.value (let ((f20 (get self20 1))) (let ((f21 (get self20 2))) (let ((self22 f20)) (case (get self22 0) ('Parser.State.new (let ((f22 (get self22 1))) (let ((f23 (get self22 2))) (let ((f24 (get self22 3))) (let ((f25 (get self22 4))) (let ((f26 (get self22 5))) (let ((reply.pst$31 ($Parser.State.new ($Parser.Error.maybe_combine f14 f22) f23 f24 f25 f26))) (let ((self28 reply.pst$31)) (case (get self28 0) ('Parser.State.new (let ((f28 (get self28 1))) (let ((f29 (get self28 2))) (let ((f30 (get self28 3))) (let ((f31 (get self28 4))) (let ((f32 (get self28 5))) (let ((reply$37 ($Kind.Parser.ADT.adt reply.pst$31))) (let ((self34 reply$37)) (case (get self34 0) ('Parser.Reply.error (let ((f34 (get self34 1))) (let ((self35 f28)) (case (get self35 0) ('Maybe.none ($Parser.Reply.error f34)) ('Maybe.some (let ((f35 (get self35 1))) ($Parser.Reply.error ($Parser.Error.combine f35 f34)))))))) ('Parser.Reply.value (let ((f34 (get self34 1))) (let ((f35 (get self34 2))) (let ((self36 f34)) (case (get self36 0) ('Parser.State.new (let ((f36 (get self36 1))) (let ((f37 (get self36 2))) (let ((f38 (get self36 3))) (let ((f39 (get self36 4))) (let ((f40 (get self36 5))) (let ((reply.pst$45 ($Parser.State.new ($Parser.Error.maybe_combine f28 f36) f37 f38 f39 f40))) (let ((self42 reply.pst$45)) (case (get self42 0) ('Parser.State.new (let ((f42 (get self42 1))) (let ((f43 (get self42 2))) (let ((f44 (get self42 3))) (let ((f45 (get self42 4))) (let ((f46 (get self42 5))) (let ((reply$51 ($Parser.get_idx reply.pst$45))) (let ((self48 reply$51)) (case (get self48 0) ('Parser.Reply.error (let ((f48 (get self48 1))) (let ((self49 f42)) (case (get self49 0) ('Maybe.none ($Parser.Reply.error f48)) ('Maybe.some (let ((f49 (get self49 1))) ($Parser.Reply.error ($Parser.Error.combine f49 f48)))))))) ('Parser.Reply.value (let ((f48 (get self48 1))) (let ((f49 (get self48 2))) (let ((self50 f48)) (case (get self50 0) ('Parser.State.new (let ((f50 (get self50 1))) (let ((f51 (get self50 2))) (let ((f52 (get self50 3))) (let ((f53 (get self50 4))) (let ((f54 (get self50 5))) (let ((reply.pst$59 ($Parser.State.new ($Parser.Error.maybe_combine f42 f50) f51 f52 f53 f54))) (let ((orig$60 ($Pair.new f21 f49))) ((let ((self57 f35)) (case (get self57 0) ('Kind.Parser.ADT.Datatype.new (let ((f57 (get self57 1))) (let ((f58 (get self57 2))) (let ((f59 (get self57 3))) (let ((f60 (get self57 4))) (let ((f61 (get self57 5))) (let ((term$66 ($Kind.Parser.ADT.Datatype.build_term f35))) (let ((term$67 ($Kind.Term.bind List.nil (lambda (x$67) ($Bits.i x$67)) term$66))) (let ((type$68 ($Kind.Parser.ADT.Datatype.build_type f35))) (let ((type$69 ($Kind.Term.bind List.nil (lambda (x$69) ($Bits.o x$69)) type$68))) (let ((arit$70 ($Nat.add ($List.length f58) ($List.length f59)))) (let ((defs$71 ($Kind.Map.def file$0 code$1 orig$60 f57 term$67 type$69 Bool.false arit$70 Bool.false defs$2))) (let ((defs$72 ($List.fold f60 defs$71 (lambda (ctr$72) (lambda (defs$73) (let ((typ_name$74 f57)) (let ((ctr_arit$75 ($Nat.add arit$70 ($List.length (let ((self71 ctr$72)) (case (get self71 0) ('Kind.Parser.ADT.Constructor.new (let ((f71 (get self71 1))) (let ((f72 (get self71 2))) (let ((f73 (get self71 3))) f72)))))))))) (let ((ctr_name$76 ($String.flatten ($List.cons typ_name$74 ($List.cons ($Kind.Name.read ".") ($List.cons (let ((self72 ctr$72)) (case (get self72 0) ('Kind.Parser.ADT.Constructor.new (let ((f72 (get self72 1))) (let ((f73 (get self72 2))) (let ((f74 (get self72 3))) f72)))))) List.nil)))))) (let ((ctr_term$77 ($Kind.Parser.ADT.Constructor.build_term f35 ctr$72))) (let ((ctr_term$78 ($Kind.Term.bind List.nil (lambda (x$78) ($Bits.i x$78)) ctr_term$77))) (let ((ctr_type$79 ($Kind.Parser.ADT.Constructor.build_type f35 ctr$72))) (let ((ctr_type$80 ($Kind.Term.bind List.nil (lambda (x$80) ($Bits.o x$80)) ctr_type$79))) ($Kind.Map.def file$0 code$1 orig$60 ctr_name$76 ctr_term$78 ctr_type$80 Bool.true ctr_arit$75 Bool.false defs$73))))))))))))) (let ((defs$73 ($List.fold f61 ($Either.right defs$72) (lambda (deri$73) (lambda (defs$74) (let ((self71 defs$74)) (case (get self71 0) ('Either.left (let ((f71 (get self71 1))) ($Either.left f71))) ('Either.right (let ((f71 (get self71 1))) (let ((self72 ($Kind.Parser.ADT.Derive.by_name deri$73 f35))) (case (get self72 0) ('Maybe.none ($Either.left ($String.concat "Can't derive '" ($String.concat deri$73 ($String.concat "' for '" ($String.concat f57 "' type.")))))) ('Maybe.some (let ((f72 (get self72 1))) (let ((self73 f72)) (case (get self73 0) ('Kind.Parser.ADT.Derived.new (let ((f73 (get self73 1))) (let ((f74 (get self73 2))) (let ((f75 (get self73 3))) (let ((f76 (get self73 4))) (let ((name$81 f73)) (let ((term$82 f75)) (let ((term$83 ($Kind.Term.bind List.nil (lambda (x$83) ($Bits.i x$83)) term$82))) (let ((type$84 f76)) (let ((type$85 ($Kind.Term.bind List.nil (lambda (x$85) ($Bits.o x$85)) type$84))) (let ((arit$86 f74)) ($Either.right ($Kind.Map.def file$0 code$1 orig$60 name$81 term$83 type$85 Bool.false arit$86 Bool.false f71)))))))))))))))))))))))))))) (let ((self70 defs$73)) (case (get self70 0) ('Either.left (let ((f70 (get self70 1))) (Parser.fail f70))) ('Either.right (let ((f70 (get self70 1))) (lambda (pst$75) ($Parser.Reply.value pst$75 f70)))))))))))))))))))))) reply.pst$59)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.file.adt (lambda (file$0) (lambda (code$1) (lambda (defs$2) (lambda (pst$3) ($Kind.Parser.file.adt file$0 code$1 defs$2 pst$3))))))
(define ($Kind.Parser.file.end file$0 code$1 defs$2 pst$3) (let ((self0 pst$3)) (case (get self0 0) ('Parser.State.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((reply$9 (Kind.Parser.spaces pst$3))) (let ((self6 reply$9)) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))) (let ((self7 f0)) (case (get self7 0) ('Maybe.none ($Parser.Reply.error f6)) ('Maybe.some (let ((f7 (get self7 1))) ($Parser.Reply.error ($Parser.Error.combine f7 f6)))))))) ('Parser.Reply.value (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((self8 f6)) (case (get self8 0) ('Parser.State.new (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) (let ((f11 (get self8 4))) (let ((f12 (get self8 5))) (let ((reply.pst$17 ($Parser.State.new ($Parser.Error.maybe_combine f0 f8) f9 f10 f11 f12))) (let ((self14 reply.pst$17)) (case (get self14 0) ('Parser.State.new (let ((f14 (get self14 1))) (let ((f15 (get self14 2))) (let ((f16 (get self14 3))) (let ((f17 (get self14 4))) (let ((f18 (get self14 5))) (let ((reply$23 ($Parser.eof reply.pst$17))) (let ((self20 reply$23)) (case (get self20 0) ('Parser.Reply.error (let ((f20 (get self20 1))) (let ((self21 f14)) (case (get self21 0) ('Maybe.none ($Parser.Reply.error f20)) ('Maybe.some (let ((f21 (get self21 1))) ($Parser.Reply.error ($Parser.Error.combine f21 f20)))))))) ('Parser.Reply.value (let ((f20 (get self20 1))) (let ((f21 (get self20 2))) (let ((self22 f20)) (case (get self22 0) ('Parser.State.new (let ((f22 (get self22 1))) (let ((f23 (get self22 2))) (let ((f24 (get self22 3))) (let ((f25 (get self22 4))) (let ((f26 (get self22 5))) (let ((reply.pst$31 ($Parser.State.new ($Parser.Error.maybe_combine f14 f22) f23 f24 f25 f26))) ($Parser.Reply.value reply.pst$31 defs$2))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.file.end (lambda (file$0) (lambda (code$1) (lambda (defs$2) (lambda (pst$3) ($Kind.Parser.file.end file$0 code$1 defs$2 pst$3))))))
(define ($Kind.Parser.file file$0 code$1 defs$2 pst$3) (let ((self0 pst$3)) (case (get self0 0) ('Parser.State.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((reply$9 ($Parser.is_eof pst$3))) (let ((self6 reply$9)) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))) (let ((self7 f0)) (case (get self7 0) ('Maybe.none ($Parser.Reply.error f6)) ('Maybe.some (let ((f7 (get self7 1))) ($Parser.Reply.error ($Parser.Error.combine f7 f6)))))))) ('Parser.Reply.value (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((self8 f6)) (case (get self8 0) ('Parser.State.new (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) (let ((f11 (get self8 4))) (let ((f12 (get self8 5))) (let ((reply.pst$17 ($Parser.State.new ($Parser.Error.maybe_combine f0 f8) f9 f10 f11 f12))) ((let ((self14 f7)) (case self14 (#t (lambda (pst$18) ($Parser.Reply.value pst$18 defs$2))) (#f (lambda (pst$18) (let ((self15 pst$18)) (case (get self15 0) ('Parser.State.new (let ((f15 (get self15 1))) (let ((f16 (get self15 2))) (let ((f17 (get self15 3))) (let ((f18 (get self15 4))) (let ((f19 (get self15 5))) (let ((reply$24 ($Parser.choice ($List.cons (((Kind.Parser.file.def file$0) code$1) defs$2) ($List.cons (((Kind.Parser.file.adt file$0) code$1) defs$2) ($List.cons (((Kind.Parser.file.end file$0) code$1) defs$2) ($List.cons (Parser.fail "Expected a top-level definition or a type declaration.") List.nil)))) pst$18))) (let ((self21 reply$24)) (case (get self21 0) ('Parser.Reply.error (let ((f21 (get self21 1))) (let ((self22 f15)) (case (get self22 0) ('Maybe.none ($Parser.Reply.error f21)) ('Maybe.some (let ((f22 (get self22 1))) ($Parser.Reply.error ($Parser.Error.combine f22 f21)))))))) ('Parser.Reply.value (let ((f21 (get self21 1))) (let ((f22 (get self21 2))) (let ((self23 f21)) (case (get self23 0) ('Parser.State.new (let ((f23 (get self23 1))) (let ((f24 (get self23 2))) (let ((f25 (get self23 3))) (let ((f26 (get self23 4))) (let ((f27 (get self23 5))) (let ((reply.pst$32 ($Parser.State.new ($Parser.Error.maybe_combine f15 f23) f24 f25 f26 f27))) (let ((self29 reply.pst$32)) (case (get self29 0) ('Parser.State.new (let ((f29 (get self29 1))) (let ((f30 (get self29 2))) (let ((f31 (get self29 3))) (let ((f32 (get self29 4))) (let ((f33 (get self29 5))) (let ((reply$38 ($Kind.Parser.file file$0 code$1 f22 reply.pst$32))) (let ((self35 reply$38)) (case (get self35 0) ('Parser.Reply.error (let ((f35 (get self35 1))) (let ((self36 f29)) (case (get self36 0) ('Maybe.none ($Parser.Reply.error f35)) ('Maybe.some (let ((f36 (get self36 1))) ($Parser.Reply.error ($Parser.Error.combine f36 f35)))))))) ('Parser.Reply.value (let ((f35 (get self35 1))) (let ((f36 (get self35 2))) (let ((self37 f35)) (case (get self37 0) ('Parser.State.new (let ((f37 (get self37 1))) (let ((f38 (get self37 2))) (let ((f39 (get self37 3))) (let ((f40 (get self37 4))) (let ((f41 (get self37 5))) (let ((reply.pst$46 ($Parser.State.new ($Parser.Error.maybe_combine f29 f37) f38 f39 f40 f41))) ($Parser.Reply.value reply.pst$46 f36))))))))))))))))))))))))))))))))))))))))))))))))))) reply.pst$17)))))))))))))))))))))))))
(define Kind.Parser.file (lambda (file$0) (lambda (code$1) (lambda (defs$2) (lambda (pst$3) ($Kind.Parser.file file$0 code$1 defs$2 pst$3))))))
(define ($String.join.go sep$0 list$1 fst$2) (let ((self0 list$1)) (case (get self0 0) ('List.nil "") ('List.cons (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($String.flatten ($List.cons (let ((self2 fst$2)) (case self2 (#t "") (#f sep$0))) ($List.cons f0 ($List.cons ($String.join.go sep$0 f1 Bool.false) List.nil))))))))))
(define String.join.go (lambda (sep$0) (lambda (list$1) (lambda (fst$2) ($String.join.go sep$0 list$1 fst$2)))))
(define ($String.join sep$0 list$1) ($String.join.go sep$0 list$1 Bool.true))
(define String.join (lambda (sep$0) (lambda (list$1) ($String.join sep$0 list$1))))
(define ($Kind.Code.highlight.end col$0 row$1 res$2) ($String.join "\xa;" res$2))
(define Kind.Code.highlight.end (lambda (col$0) (lambda (row$1) (lambda (res$2) ($Kind.Code.highlight.end col$0 row$1 res$2)))))
(define ($Maybe.extract m$1 a$3 f$4) (let ((self0 m$1)) (case (get self0 0) ('Maybe.none a$3) ('Maybe.some (let ((f0 (get self0 1))) (f$4 f0))))))
(define Maybe.extract (lambda (m$1) (lambda (a$3) (lambda (f$4) ($Maybe.extract m$1 a$3 f$4)))))
(define ($Nat.is_zero n$0) (let ((self0 n$0)) (case (= self0 0) (#t Bool.true) (#f (let ((f0 (- self0 1))) Bool.false)))))
(define Nat.is_zero (lambda (n$0) ($Nat.is_zero n$0)))
(define ($Nat.double n$0) (let ((self0 n$0)) (case (= self0 0) (#t Nat.zero) (#f (let ((f0 (- self0 1))) ($Nat.succ ($Nat.succ ($Nat.double f0))))))))
(define Nat.double (lambda (n$0) ($Nat.double n$0)))
(define ($String.pad_right size$0 chr$1 str$2) (let ((self0 size$0)) (case (= self0 0) (#t str$2) (#f (let ((f0 (- self0 1))) (let ((self1 str$2)) (case (<= (kstring-length self1) 0) (#t ($String.cons chr$1 ($String.pad_right f0 chr$1 ""))) (#f (let ((f1 (char->integer (kstring-head self1)))) (let ((f2 (kstring-tail self1))) ($String.cons f1 ($String.pad_right f0 chr$1 f2))))))))))))
(define String.pad_right (lambda (size$0) (lambda (chr$1) (lambda (str$2) ($String.pad_right size$0 chr$1 str$2)))))
(define ($String.pad_left size$0 chr$1 str$2) ($String.reverse ($String.pad_right size$0 chr$1 ($String.reverse str$2))))
(define String.pad_left (lambda (size$0) (lambda (chr$1) (lambda (str$2) ($String.pad_left size$0 chr$1 str$2)))))
(define ($Kind.Code.color col$0 str$1) ($String.cons ($Nat.to_u16 27) ($String.concat "[" ($String.concat col$0 ($String.concat "m" ($String.concat str$1 ($String.cons ($Nat.to_u16 27) "[0m")))))))
(define Kind.Code.color (lambda (col$0) (lambda (str$1) ($Kind.Code.color col$0 str$1))))
(define ($List.take n$1 xs$2) (let ((self0 xs$2)) (case (get self0 0) ('List.nil List.nil) ('List.cons (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((self2 n$1)) (case (= self2 0) (#t List.nil) (#f (let ((f2 (- self2 1))) ($List.cons f0 ($List.take f2 f1))))))))))))
(define List.take (lambda (n$1) (lambda (xs$2) ($List.take n$1 xs$2))))
(define ($Kind.Code.highlight.go code$0 ixi$1 ix0$2 ix1$3 col$4 row$5 lft$6 lin$7 res$8) (let ((spa$9 3)) (let ((self1 code$0)) (case (<= (kstring-length self1) 0) (#t ($Kind.Code.highlight.end col$4 row$5 ($List.reverse res$8))) (#f (let ((f1 (char->integer (kstring-head self1)))) (let ((f2 (kstring-tail self1))) (let ((self3 ($U16.eql f1 10))) (case self3 (#t (let ((stp$12 ($Maybe.extract lft$6 Bool.false Nat.is_zero))) (let ((self4 stp$12)) (case self4 (#t ($Kind.Code.highlight.end col$4 row$5 ($List.reverse res$8))) (#f (let ((siz$13 ($Nat.succ ($Nat.double spa$9)))) (let ((lft$14 (let ((self5 ix1$3)) (case (= self5 0) (#t (let ((self5 lft$6)) (case (get self5 0) ('Maybe.none ($Maybe.some spa$9)) ('Maybe.some (let ((f5 (get self5 1))) ($Maybe.some ($Nat.pred f5))))))) (#f (let ((f5 (- self5 1))) lft$6)))))) (let ((ixi$15 ($Nat.pred ixi$1))) (let ((ix0$16 ($Nat.pred ix0$2))) (let ((ix1$17 ($Nat.pred ix1$3))) (let ((col$18 0)) (let ((row$19 ($Nat.succ row$5))) (let ((res$20 ($List.cons ($String.reverse lin$7) res$8))) (let ((lin$21 ($String.reverse ($String.flatten ($List.cons ($String.pad_left 4 32 ($Nat.show row$19)) ($List.cons " | " List.nil)))))) ($Kind.Code.highlight.go f2 ixi$15 ix0$16 ix1$17 col$18 row$19 lft$14 lin$21 res$20))))))))))))))) (#f (let ((chr$12 ($String.cons f1 String.nil))) (let ((chr$13 (let ((self4 ($Bool.and ($Nat.is_zero ix0$2) ($Bool.not ($Nat.is_zero ix1$3))))) (case self4 (#t ($String.reverse ($Kind.Code.color "41" ($Kind.Code.color "37" chr$12)))) (#f (let ((self4 ($Bool.and ($Nat.is_zero ixi$1) ($Bool.not ($Nat.is_zero ix1$3))))) (case self4 (#t ($String.reverse ($Kind.Code.color "31" ($Kind.Code.color "4" chr$12)))) (#f chr$12)))))))) (let ((res$14 (let ((self5 ($Nat.eql ix0$2 1))) (case self5 (#t ($List.take spa$9 res$8)) (#f res$8))))) (let ((ixi$15 ($Nat.pred ixi$1))) (let ((ix0$16 ($Nat.pred ix0$2))) (let ((ix1$17 ($Nat.pred ix1$3))) (let ((col$18 ($Nat.succ col$4))) (let ((lin$19 ($String.flatten ($List.cons chr$13 ($List.cons lin$7 List.nil))))) ($Kind.Code.highlight.go f2 ixi$15 ix0$16 ix1$17 col$18 row$5 lft$6 lin$19 res$14)))))))))))))))))))
(define Kind.Code.highlight.go (lambda (code$0) (lambda (ixi$1) (lambda (ix0$2) (lambda (ix1$3) (lambda (col$4) (lambda (row$5) (lambda (lft$6) (lambda (lin$7) (lambda (res$8) ($Kind.Code.highlight.go code$0 ixi$1 ix0$2 ix1$3 col$4 row$5 lft$6 lin$7 res$8)))))))))))
(define ($Kind.Code.highlight code$0 init$1 idx0$2 idx1$3) ($Kind.Code.highlight.go ($String.concat code$0 " \xa;") init$1 idx0$2 idx1$3 0 1 Maybe.none ($String.reverse "   1 | ") List.nil))
(define Kind.Code.highlight (lambda (code$0) (lambda (init$1) (lambda (idx0$2) (lambda (idx1$3) ($Kind.Code.highlight code$0 init$1 idx0$2 idx1$3))))))
(define ($Kind.Defs.read file$0 code$1 defs$2) (let ((self0 ($Kind.Parser.file file$0 code$1 defs$2 ($Parser.State.new Maybe.none "" 0 0 code$1)))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))) (let ((self1 f0)) (case (get self1 0) ('Parser.Error.new (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((err$8 ($String.concat f4 (let ((self5 f1)) (case (<= (kstring-length self5) 0) (#t "") (#f (let ((f5 (char->integer (kstring-head self5)))) (let ((f6 (kstring-tail self5))) ($String.concat " Inside " ($String.concat f1 ":")))))))))) (let ((hig$9 ($Kind.Code.highlight code$1 f2 f3 ($Nat.succ f3)))) (let ((str$10 ($String.flatten ($List.cons err$8 ($List.cons "\xa;" ($List.cons hig$9 List.nil)))))) ($Either.left str$10))))))))))))) ('Parser.Reply.value (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($Either.right f1)))))))
(define Kind.Defs.read (lambda (file$0) (lambda (code$1) (lambda (defs$2) ($Kind.Defs.read file$0 code$1 defs$2)))))
(define ($Kind.Synth.load.go name$0 files$1 defs$2) (let ((self0 files$1)) (case (get self0 0) ('List.nil ((let ((self0 IO.monad)) (case (get self0 0) ('Monad.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) f1))))) Maybe.none)) ('List.cons (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (((let ((self2 IO.monad)) (case (get self2 0) ('Monad.new (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) f2))))) ($Kind.Synth.get_kind_code f0)) (lambda (code$5) (let ((read$6 ($Kind.Defs.read f0 code$5 defs$2))) (let ((self4 read$6)) (case (get self4 0) ('Either.left (let ((f4 (get self4 1))) ($Kind.Synth.load.go name$0 f1 defs$2))) ('Either.right (let ((f4 (get self4 1))) (let ((defs$8 f4)) (let ((self6 ($Kind.Map.get name$0 defs$8))) (case (get self6 0) ('Maybe.none ($Kind.Synth.load.go name$0 f1 defs$8)) ('Maybe.some (let ((f6 (get self6 1))) ((let ((self7 IO.monad)) (case (get self7 0) ('Monad.new (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) f8))))) ($Maybe.some defs$8))))))))))))))))))))
(define Kind.Synth.load.go (lambda (name$0) (lambda (files$1) (lambda (defs$2) ($Kind.Synth.load.go name$0 files$1 defs$2)))))
(define ($Kind.Synth.files_of.make names$0 last$1) (let ((self0 names$0)) (case (get self0 0) ('List.nil List.nil) ('List.cons (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((head$4 ($String.concat last$1 ($String.concat f0 ".kind")))) (let ((tail$5 ($Kind.Synth.files_of.make f1 ($String.concat last$1 ($String.concat f0 "/"))))) ($List.cons head$4 tail$5)))))))))
(define Kind.Synth.files_of.make (lambda (names$0) (lambda (last$1) ($Kind.Synth.files_of.make names$0 last$1))))
(define ($String.length.go xs$0 n$1) (let ((self0 xs$0)) (case (<= (kstring-length self0) 0) (#t n$1) (#f (let ((f0 (char->integer (kstring-head self0)))) (let ((f1 (kstring-tail self0))) ($String.length.go f1 ($Nat.succ n$1))))))))
(define String.length.go (lambda (xs$0) (lambda (n$1) ($String.length.go xs$0 n$1))))
(define ($String.length xs$0) ($String.length.go xs$0 0))
(define String.length (lambda (xs$0) ($String.length xs$0)))
(define ($String.split.go xs$0 match$1 last$2) (let ((self0 xs$0)) (case (<= (kstring-length self0) 0) (#t ($List.cons last$2 List.nil)) (#f (let ((f0 (char->integer (kstring-head self0)))) (let ((f1 (kstring-tail self0))) (let ((self2 ($String.starts_with xs$0 match$1))) (case self2 (#t (let ((rest$5 ($String.drop ($String.length match$1) xs$0))) ($List.cons last$2 ($String.split.go rest$5 match$1 "")))) (#f (let ((next$5 ($String.cons f0 String.nil))) ($String.split.go f1 match$1 ($String.concat last$2 next$5))))))))))))
(define String.split.go (lambda (xs$0) (lambda (match$1) (lambda (last$2) ($String.split.go xs$0 match$1 last$2)))))
(define ($String.split xs$0 match$1) ($String.split.go xs$0 match$1 ""))
(define String.split (lambda (xs$0) (lambda (match$1) ($String.split xs$0 match$1))))
(define ($Kind.Synth.files_of name$0) ($List.reverse ($Kind.Synth.files_of.make ($String.split name$0 ".") "")))
(define Kind.Synth.files_of (lambda (name$0) ($Kind.Synth.files_of name$0)))
(define ($Kind.Synth.load name$0 defs$1) (((let ((self0 IO.monad)) (case (get self0 0) ('Monad.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) f0))))) ($Kind.Synth.load.cached ($List.cons name$0 List.nil) defs$1)) (lambda (cached_defs$2) (let ((self1 cached_defs$2)) (case (get self1 0) ('Maybe.none ($Kind.Synth.load.go name$0 ($Kind.Synth.files_of name$0) defs$1)) ('Maybe.some (let ((f1 (get self1 1))) ((let ((self2 IO.monad)) (case (get self2 0) ('Monad.new (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) f3))))) ($Maybe.some f1)))))))))
(define Kind.Synth.load (lambda (name$0) (lambda (defs$1) ($Kind.Synth.load name$0 defs$1))))
(define Kind.Status.wait (vector 'Kind.Status.wait))
(define ($Kind.Check.result value$1 errors$2) (vector 'Kind.Check.result value$1 errors$2))
(define Kind.Check.result (lambda (value$1) (lambda (errors$2) ($Kind.Check.result value$1 errors$2))))
(define ($Kind.Error.undefined_reference origin$0 name$1) (vector 'Kind.Error.undefined_reference origin$0 name$1))
(define Kind.Error.undefined_reference (lambda (origin$0) (lambda (name$1) ($Kind.Error.undefined_reference origin$0 name$1))))
(define ($Kind.Error.waiting name$0) (vector 'Kind.Error.waiting name$0))
(define Kind.Error.waiting (lambda (name$0) ($Kind.Error.waiting name$0)))
(define ($Kind.Error.indirect name$0) (vector 'Kind.Error.indirect name$0))
(define Kind.Error.indirect (lambda (name$0) ($Kind.Error.indirect name$0)))
(define ($Maybe.mapped m$1 f$3) (let ((self0 m$1)) (case (get self0 0) ('Maybe.none Maybe.none) ('Maybe.some (let ((f0 (get self0 1))) ($Maybe.some (f$3 f0)))))))
(define Maybe.mapped (lambda (m$1) (lambda (f$3) ($Maybe.mapped m$1 f$3))))
(define ($Kind.Path.Maybe.Builder.o path$0) ($Maybe.mapped path$0 Kind.Path.Builder.o))
(define Kind.Path.Maybe.Builder.o (lambda (path$0) ($Kind.Path.Maybe.Builder.o path$0)))
(define ($Kind.Path.Maybe.Builder.i path$0) ($Maybe.mapped path$0 Kind.Path.Builder.i))
(define Kind.Path.Maybe.Builder.i (lambda (path$0) ($Kind.Path.Maybe.Builder.i path$0)))
(define ($Kind.Error.patch path$0 term$1) (vector 'Kind.Error.patch path$0 term$1))
(define Kind.Error.patch (lambda (path$0) (lambda (term$1) ($Kind.Error.patch path$0 term$1))))
(define ($Kind.Path.Maybe.Builder.to_bits path$0) (let ((self0 path$0)) (case (get self0 0) ('Maybe.none Bits.e) ('Maybe.some (let ((f0 (get self0 1))) (f0 Bits.e))))))
(define Kind.Path.Maybe.Builder.to_bits (lambda (path$0) ($Kind.Path.Maybe.Builder.to_bits path$0)))
(define ($Kind.Term.check.patch term$0 type$1 path$2) ($Kind.Check.result type$1 ($List.cons ($Kind.Error.patch ($Kind.Path.Maybe.Builder.to_bits path$2) term$0) List.nil)))
(define Kind.Term.check.patch (lambda (term$0) (lambda (type$1) (lambda (path$2) ($Kind.Term.check.patch term$0 type$1 path$2)))))
(define ($Kind.Error.type_mismatch origin$0 expected$1 detected$2 context$3) (vector 'Kind.Error.type_mismatch origin$0 expected$1 detected$2 context$3))
(define Kind.Error.type_mismatch (lambda (origin$0) (lambda (expected$1) (lambda (detected$2) (lambda (context$3) ($Kind.Error.type_mismatch origin$0 expected$1 detected$2 context$3))))))
(define ($Kind.Error.show_goal name$0 dref$1 verb$2 goal$3 context$4) (vector 'Kind.Error.show_goal name$0 dref$1 verb$2 goal$3 context$4))
(define Kind.Error.show_goal (lambda (name$0) (lambda (dref$1) (lambda (verb$2) (lambda (goal$3) (lambda (context$4) ($Kind.Error.show_goal name$0 dref$1 verb$2 goal$3 context$4)))))))
(define ($Kind.Path.Builder.nil x$0) x$0)
(define Kind.Path.Builder.nil (lambda (x$0) ($Kind.Path.Builder.nil x$0)))
(define Kind.Path.Maybe.Builder.nil ($Maybe.some Kind.Path.Builder.nil))
(define ($Kind.Term.check.direct term$0 defs$1) (let ((self0 ($Kind.Term.check term$0 Maybe.none defs$1 List.nil Kind.Path.Maybe.Builder.nil Maybe.none))) (case (get self0 0) ('Kind.Check.result (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((self2 f0)) (case (get self2 0) ('Maybe.none ($Kind.Check.result Maybe.none f1)) ('Maybe.some (let ((f2 (get self2 1))) (let ((self3 ($Kind.Check.result ($Maybe.some term$0) List.nil))) (case (get self3 0) ('Kind.Check.result (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) ($Kind.Check.result f3 ($List.concat f1 f4)))))))))))))))))
(define Kind.Term.check.direct (lambda (term$0) (lambda (defs$1) ($Kind.Term.check.direct term$0 defs$1))))
(define ($Kind.Term.check.get_name_of_self_type.slice self$0) (let ((len$1 ($String.length self$0))) (let ((ini$2 ($String.slice 0 ($Nat.sub len$1 5) self$0))) (let ((end$3 ($String.slice ($Nat.sub len$1 5) len$1 self$0))) (let ((self3 ($String.eql end$3 ".Self"))) (case self3 (#t ($Maybe.some ini$2)) (#f Maybe.none)))))))
(define Kind.Term.check.get_name_of_self_type.slice (lambda (self$0) ($Kind.Term.check.get_name_of_self_type.slice self$0)))
(define ($Kind.Term.check.get_name_of_self_type type$0 defs$1) (let ((self0 ($Kind.Term.reduce type$0 Kind.Map.new))) (case (get self0 0) ('Kind.Term.var (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((self2 ($Kind.Term.reduce type$0 defs$1))) (case (get self2 0) ('Kind.Term.var (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) Maybe.none))) ('Kind.Term.ref (let ((f2 (get self2 1))) ($Maybe.some f2))) ('Kind.Term.typ Maybe.none) ('Kind.Term.all (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) (let ((f5 (get self2 4))) (let ((f6 (get self2 5))) ($Kind.Term.check.get_name_of_self_type.slice f3))))))) ('Kind.Term.lam (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) Maybe.none))) ('Kind.Term.app (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) Maybe.none))) ('Kind.Term.let (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) Maybe.none)))) ('Kind.Term.def (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) Maybe.none)))) ('Kind.Term.ann (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) Maybe.none)))) ('Kind.Term.gol (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) Maybe.none)))) ('Kind.Term.hol (let ((f2 (get self2 1))) Maybe.none)) ('Kind.Term.nat (let ((f2 (get self2 1))) Maybe.none)) ('Kind.Term.chr (let ((f2 (get self2 1))) Maybe.none)) ('Kind.Term.str (let ((f2 (get self2 1))) Maybe.none)) ('Kind.Term.num (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) Maybe.none)))) ('Kind.Term.cse (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) (let ((f5 (get self2 4))) (let ((f6 (get self2 5))) (let ((f7 (get self2 6))) Maybe.none))))))) ('Kind.Term.new (let ((f2 (get self2 1))) Maybe.none)) ('Kind.Term.get (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) Maybe.none))) ('Kind.Term.set (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) Maybe.none)))) ('Kind.Term.ope (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) Maybe.none)))) ('Kind.Term.ori (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) Maybe.none)))))))) ('Kind.Term.ref (let ((f0 (get self0 1))) ($Maybe.some f0))) ('Kind.Term.typ (let ((self0 ($Kind.Term.reduce type$0 defs$1))) (case (get self0 0) ('Kind.Term.var (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) Maybe.none))) ('Kind.Term.ref (let ((f0 (get self0 1))) ($Maybe.some f0))) ('Kind.Term.typ Maybe.none) ('Kind.Term.all (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) ($Kind.Term.check.get_name_of_self_type.slice f1))))))) ('Kind.Term.lam (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) Maybe.none))) ('Kind.Term.app (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) Maybe.none))) ('Kind.Term.let (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) Maybe.none)))) ('Kind.Term.def (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) Maybe.none)))) ('Kind.Term.ann (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) Maybe.none)))) ('Kind.Term.gol (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) Maybe.none)))) ('Kind.Term.hol (let ((f0 (get self0 1))) Maybe.none)) ('Kind.Term.nat (let ((f0 (get self0 1))) Maybe.none)) ('Kind.Term.chr (let ((f0 (get self0 1))) Maybe.none)) ('Kind.Term.str (let ((f0 (get self0 1))) Maybe.none)) ('Kind.Term.num (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) Maybe.none)))) ('Kind.Term.cse (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((f5 (get self0 6))) Maybe.none))))))) ('Kind.Term.new (let ((f0 (get self0 1))) Maybe.none)) ('Kind.Term.get (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) Maybe.none))) ('Kind.Term.set (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) Maybe.none)))) ('Kind.Term.ope (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) Maybe.none)))) ('Kind.Term.ori (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) Maybe.none)))))) ('Kind.Term.all (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((self5 ($Kind.Term.reduce type$0 defs$1))) (case (get self5 0) ('Kind.Term.var (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) Maybe.none))) ('Kind.Term.ref (let ((f5 (get self5 1))) ($Maybe.some f5))) ('Kind.Term.typ Maybe.none) ('Kind.Term.all (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) (let ((f8 (get self5 4))) (let ((f9 (get self5 5))) ($Kind.Term.check.get_name_of_self_type.slice f6))))))) ('Kind.Term.lam (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) Maybe.none))) ('Kind.Term.app (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) Maybe.none))) ('Kind.Term.let (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) Maybe.none)))) ('Kind.Term.def (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) Maybe.none)))) ('Kind.Term.ann (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) Maybe.none)))) ('Kind.Term.gol (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) Maybe.none)))) ('Kind.Term.hol (let ((f5 (get self5 1))) Maybe.none)) ('Kind.Term.nat (let ((f5 (get self5 1))) Maybe.none)) ('Kind.Term.chr (let ((f5 (get self5 1))) Maybe.none)) ('Kind.Term.str (let ((f5 (get self5 1))) Maybe.none)) ('Kind.Term.num (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) Maybe.none)))) ('Kind.Term.cse (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) (let ((f8 (get self5 4))) (let ((f9 (get self5 5))) (let ((f10 (get self5 6))) Maybe.none))))))) ('Kind.Term.new (let ((f5 (get self5 1))) Maybe.none)) ('Kind.Term.get (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) Maybe.none))) ('Kind.Term.set (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) Maybe.none)))) ('Kind.Term.ope (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) Maybe.none)))) ('Kind.Term.ori (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) Maybe.none))))))))))) ('Kind.Term.lam (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((self2 ($Kind.Term.reduce type$0 defs$1))) (case (get self2 0) ('Kind.Term.var (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) Maybe.none))) ('Kind.Term.ref (let ((f2 (get self2 1))) ($Maybe.some f2))) ('Kind.Term.typ Maybe.none) ('Kind.Term.all (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) (let ((f5 (get self2 4))) (let ((f6 (get self2 5))) ($Kind.Term.check.get_name_of_self_type.slice f3))))))) ('Kind.Term.lam (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) Maybe.none))) ('Kind.Term.app (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) Maybe.none))) ('Kind.Term.let (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) Maybe.none)))) ('Kind.Term.def (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) Maybe.none)))) ('Kind.Term.ann (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) Maybe.none)))) ('Kind.Term.gol (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) Maybe.none)))) ('Kind.Term.hol (let ((f2 (get self2 1))) Maybe.none)) ('Kind.Term.nat (let ((f2 (get self2 1))) Maybe.none)) ('Kind.Term.chr (let ((f2 (get self2 1))) Maybe.none)) ('Kind.Term.str (let ((f2 (get self2 1))) Maybe.none)) ('Kind.Term.num (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) Maybe.none)))) ('Kind.Term.cse (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) (let ((f5 (get self2 4))) (let ((f6 (get self2 5))) (let ((f7 (get self2 6))) Maybe.none))))))) ('Kind.Term.new (let ((f2 (get self2 1))) Maybe.none)) ('Kind.Term.get (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) Maybe.none))) ('Kind.Term.set (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) Maybe.none)))) ('Kind.Term.ope (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) Maybe.none)))) ('Kind.Term.ori (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) Maybe.none)))))))) ('Kind.Term.app (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((self2 ($Kind.Term.reduce type$0 defs$1))) (case (get self2 0) ('Kind.Term.var (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) Maybe.none))) ('Kind.Term.ref (let ((f2 (get self2 1))) ($Maybe.some f2))) ('Kind.Term.typ Maybe.none) ('Kind.Term.all (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) (let ((f5 (get self2 4))) (let ((f6 (get self2 5))) ($Kind.Term.check.get_name_of_self_type.slice f3))))))) ('Kind.Term.lam (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) Maybe.none))) ('Kind.Term.app (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) Maybe.none))) ('Kind.Term.let (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) Maybe.none)))) ('Kind.Term.def (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) Maybe.none)))) ('Kind.Term.ann (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) Maybe.none)))) ('Kind.Term.gol (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) Maybe.none)))) ('Kind.Term.hol (let ((f2 (get self2 1))) Maybe.none)) ('Kind.Term.nat (let ((f2 (get self2 1))) Maybe.none)) ('Kind.Term.chr (let ((f2 (get self2 1))) Maybe.none)) ('Kind.Term.str (let ((f2 (get self2 1))) Maybe.none)) ('Kind.Term.num (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) Maybe.none)))) ('Kind.Term.cse (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) (let ((f5 (get self2 4))) (let ((f6 (get self2 5))) (let ((f7 (get self2 6))) Maybe.none))))))) ('Kind.Term.new (let ((f2 (get self2 1))) Maybe.none)) ('Kind.Term.get (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) Maybe.none))) ('Kind.Term.set (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) Maybe.none)))) ('Kind.Term.ope (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) Maybe.none)))) ('Kind.Term.ori (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) Maybe.none)))))))) ('Kind.Term.let (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((self3 ($Kind.Term.reduce type$0 defs$1))) (case (get self3 0) ('Kind.Term.var (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) Maybe.none))) ('Kind.Term.ref (let ((f3 (get self3 1))) ($Maybe.some f3))) ('Kind.Term.typ Maybe.none) ('Kind.Term.all (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) (let ((f7 (get self3 5))) ($Kind.Term.check.get_name_of_self_type.slice f4))))))) ('Kind.Term.lam (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) Maybe.none))) ('Kind.Term.app (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) Maybe.none))) ('Kind.Term.let (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) Maybe.none)))) ('Kind.Term.def (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) Maybe.none)))) ('Kind.Term.ann (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) Maybe.none)))) ('Kind.Term.gol (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) Maybe.none)))) ('Kind.Term.hol (let ((f3 (get self3 1))) Maybe.none)) ('Kind.Term.nat (let ((f3 (get self3 1))) Maybe.none)) ('Kind.Term.chr (let ((f3 (get self3 1))) Maybe.none)) ('Kind.Term.str (let ((f3 (get self3 1))) Maybe.none)) ('Kind.Term.num (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) Maybe.none)))) ('Kind.Term.cse (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) (let ((f7 (get self3 5))) (let ((f8 (get self3 6))) Maybe.none))))))) ('Kind.Term.new (let ((f3 (get self3 1))) Maybe.none)) ('Kind.Term.get (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) Maybe.none))) ('Kind.Term.set (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) Maybe.none)))) ('Kind.Term.ope (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) Maybe.none)))) ('Kind.Term.ori (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) Maybe.none))))))))) ('Kind.Term.def (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((self3 ($Kind.Term.reduce type$0 defs$1))) (case (get self3 0) ('Kind.Term.var (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) Maybe.none))) ('Kind.Term.ref (let ((f3 (get self3 1))) ($Maybe.some f3))) ('Kind.Term.typ Maybe.none) ('Kind.Term.all (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) (let ((f7 (get self3 5))) ($Kind.Term.check.get_name_of_self_type.slice f4))))))) ('Kind.Term.lam (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) Maybe.none))) ('Kind.Term.app (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) Maybe.none))) ('Kind.Term.let (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) Maybe.none)))) ('Kind.Term.def (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) Maybe.none)))) ('Kind.Term.ann (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) Maybe.none)))) ('Kind.Term.gol (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) Maybe.none)))) ('Kind.Term.hol (let ((f3 (get self3 1))) Maybe.none)) ('Kind.Term.nat (let ((f3 (get self3 1))) Maybe.none)) ('Kind.Term.chr (let ((f3 (get self3 1))) Maybe.none)) ('Kind.Term.str (let ((f3 (get self3 1))) Maybe.none)) ('Kind.Term.num (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) Maybe.none)))) ('Kind.Term.cse (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) (let ((f7 (get self3 5))) (let ((f8 (get self3 6))) Maybe.none))))))) ('Kind.Term.new (let ((f3 (get self3 1))) Maybe.none)) ('Kind.Term.get (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) Maybe.none))) ('Kind.Term.set (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) Maybe.none)))) ('Kind.Term.ope (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) Maybe.none)))) ('Kind.Term.ori (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) Maybe.none))))))))) ('Kind.Term.ann (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((self3 ($Kind.Term.reduce type$0 defs$1))) (case (get self3 0) ('Kind.Term.var (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) Maybe.none))) ('Kind.Term.ref (let ((f3 (get self3 1))) ($Maybe.some f3))) ('Kind.Term.typ Maybe.none) ('Kind.Term.all (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) (let ((f7 (get self3 5))) ($Kind.Term.check.get_name_of_self_type.slice f4))))))) ('Kind.Term.lam (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) Maybe.none))) ('Kind.Term.app (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) Maybe.none))) ('Kind.Term.let (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) Maybe.none)))) ('Kind.Term.def (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) Maybe.none)))) ('Kind.Term.ann (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) Maybe.none)))) ('Kind.Term.gol (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) Maybe.none)))) ('Kind.Term.hol (let ((f3 (get self3 1))) Maybe.none)) ('Kind.Term.nat (let ((f3 (get self3 1))) Maybe.none)) ('Kind.Term.chr (let ((f3 (get self3 1))) Maybe.none)) ('Kind.Term.str (let ((f3 (get self3 1))) Maybe.none)) ('Kind.Term.num (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) Maybe.none)))) ('Kind.Term.cse (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) (let ((f7 (get self3 5))) (let ((f8 (get self3 6))) Maybe.none))))))) ('Kind.Term.new (let ((f3 (get self3 1))) Maybe.none)) ('Kind.Term.get (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) Maybe.none))) ('Kind.Term.set (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) Maybe.none)))) ('Kind.Term.ope (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) Maybe.none)))) ('Kind.Term.ori (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) Maybe.none))))))))) ('Kind.Term.gol (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((self3 ($Kind.Term.reduce type$0 defs$1))) (case (get self3 0) ('Kind.Term.var (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) Maybe.none))) ('Kind.Term.ref (let ((f3 (get self3 1))) ($Maybe.some f3))) ('Kind.Term.typ Maybe.none) ('Kind.Term.all (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) (let ((f7 (get self3 5))) ($Kind.Term.check.get_name_of_self_type.slice f4))))))) ('Kind.Term.lam (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) Maybe.none))) ('Kind.Term.app (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) Maybe.none))) ('Kind.Term.let (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) Maybe.none)))) ('Kind.Term.def (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) Maybe.none)))) ('Kind.Term.ann (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) Maybe.none)))) ('Kind.Term.gol (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) Maybe.none)))) ('Kind.Term.hol (let ((f3 (get self3 1))) Maybe.none)) ('Kind.Term.nat (let ((f3 (get self3 1))) Maybe.none)) ('Kind.Term.chr (let ((f3 (get self3 1))) Maybe.none)) ('Kind.Term.str (let ((f3 (get self3 1))) Maybe.none)) ('Kind.Term.num (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) Maybe.none)))) ('Kind.Term.cse (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) (let ((f7 (get self3 5))) (let ((f8 (get self3 6))) Maybe.none))))))) ('Kind.Term.new (let ((f3 (get self3 1))) Maybe.none)) ('Kind.Term.get (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) Maybe.none))) ('Kind.Term.set (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) Maybe.none)))) ('Kind.Term.ope (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) Maybe.none)))) ('Kind.Term.ori (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) Maybe.none))))))))) ('Kind.Term.hol (let ((f0 (get self0 1))) (let ((self1 ($Kind.Term.reduce type$0 defs$1))) (case (get self1 0) ('Kind.Term.var (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) Maybe.none))) ('Kind.Term.ref (let ((f1 (get self1 1))) ($Maybe.some f1))) ('Kind.Term.typ Maybe.none) ('Kind.Term.all (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) ($Kind.Term.check.get_name_of_self_type.slice f2))))))) ('Kind.Term.lam (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) Maybe.none))) ('Kind.Term.app (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) Maybe.none))) ('Kind.Term.let (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) Maybe.none)))) ('Kind.Term.def (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) Maybe.none)))) ('Kind.Term.ann (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) Maybe.none)))) ('Kind.Term.gol (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) Maybe.none)))) ('Kind.Term.hol (let ((f1 (get self1 1))) Maybe.none)) ('Kind.Term.nat (let ((f1 (get self1 1))) Maybe.none)) ('Kind.Term.chr (let ((f1 (get self1 1))) Maybe.none)) ('Kind.Term.str (let ((f1 (get self1 1))) Maybe.none)) ('Kind.Term.num (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) Maybe.none)))) ('Kind.Term.cse (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((f6 (get self1 6))) Maybe.none))))))) ('Kind.Term.new (let ((f1 (get self1 1))) Maybe.none)) ('Kind.Term.get (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) Maybe.none))) ('Kind.Term.set (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) Maybe.none)))) ('Kind.Term.ope (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) Maybe.none)))) ('Kind.Term.ori (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) Maybe.none))))))) ('Kind.Term.nat (let ((f0 (get self0 1))) (let ((self1 ($Kind.Term.reduce type$0 defs$1))) (case (get self1 0) ('Kind.Term.var (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) Maybe.none))) ('Kind.Term.ref (let ((f1 (get self1 1))) ($Maybe.some f1))) ('Kind.Term.typ Maybe.none) ('Kind.Term.all (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) ($Kind.Term.check.get_name_of_self_type.slice f2))))))) ('Kind.Term.lam (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) Maybe.none))) ('Kind.Term.app (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) Maybe.none))) ('Kind.Term.let (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) Maybe.none)))) ('Kind.Term.def (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) Maybe.none)))) ('Kind.Term.ann (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) Maybe.none)))) ('Kind.Term.gol (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) Maybe.none)))) ('Kind.Term.hol (let ((f1 (get self1 1))) Maybe.none)) ('Kind.Term.nat (let ((f1 (get self1 1))) Maybe.none)) ('Kind.Term.chr (let ((f1 (get self1 1))) Maybe.none)) ('Kind.Term.str (let ((f1 (get self1 1))) Maybe.none)) ('Kind.Term.num (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) Maybe.none)))) ('Kind.Term.cse (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((f6 (get self1 6))) Maybe.none))))))) ('Kind.Term.new (let ((f1 (get self1 1))) Maybe.none)) ('Kind.Term.get (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) Maybe.none))) ('Kind.Term.set (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) Maybe.none)))) ('Kind.Term.ope (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) Maybe.none)))) ('Kind.Term.ori (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) Maybe.none))))))) ('Kind.Term.chr (let ((f0 (get self0 1))) (let ((self1 ($Kind.Term.reduce type$0 defs$1))) (case (get self1 0) ('Kind.Term.var (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) Maybe.none))) ('Kind.Term.ref (let ((f1 (get self1 1))) ($Maybe.some f1))) ('Kind.Term.typ Maybe.none) ('Kind.Term.all (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) ($Kind.Term.check.get_name_of_self_type.slice f2))))))) ('Kind.Term.lam (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) Maybe.none))) ('Kind.Term.app (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) Maybe.none))) ('Kind.Term.let (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) Maybe.none)))) ('Kind.Term.def (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) Maybe.none)))) ('Kind.Term.ann (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) Maybe.none)))) ('Kind.Term.gol (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) Maybe.none)))) ('Kind.Term.hol (let ((f1 (get self1 1))) Maybe.none)) ('Kind.Term.nat (let ((f1 (get self1 1))) Maybe.none)) ('Kind.Term.chr (let ((f1 (get self1 1))) Maybe.none)) ('Kind.Term.str (let ((f1 (get self1 1))) Maybe.none)) ('Kind.Term.num (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) Maybe.none)))) ('Kind.Term.cse (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((f6 (get self1 6))) Maybe.none))))))) ('Kind.Term.new (let ((f1 (get self1 1))) Maybe.none)) ('Kind.Term.get (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) Maybe.none))) ('Kind.Term.set (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) Maybe.none)))) ('Kind.Term.ope (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) Maybe.none)))) ('Kind.Term.ori (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) Maybe.none))))))) ('Kind.Term.str (let ((f0 (get self0 1))) (let ((self1 ($Kind.Term.reduce type$0 defs$1))) (case (get self1 0) ('Kind.Term.var (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) Maybe.none))) ('Kind.Term.ref (let ((f1 (get self1 1))) ($Maybe.some f1))) ('Kind.Term.typ Maybe.none) ('Kind.Term.all (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) ($Kind.Term.check.get_name_of_self_type.slice f2))))))) ('Kind.Term.lam (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) Maybe.none))) ('Kind.Term.app (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) Maybe.none))) ('Kind.Term.let (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) Maybe.none)))) ('Kind.Term.def (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) Maybe.none)))) ('Kind.Term.ann (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) Maybe.none)))) ('Kind.Term.gol (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) Maybe.none)))) ('Kind.Term.hol (let ((f1 (get self1 1))) Maybe.none)) ('Kind.Term.nat (let ((f1 (get self1 1))) Maybe.none)) ('Kind.Term.chr (let ((f1 (get self1 1))) Maybe.none)) ('Kind.Term.str (let ((f1 (get self1 1))) Maybe.none)) ('Kind.Term.num (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) Maybe.none)))) ('Kind.Term.cse (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((f6 (get self1 6))) Maybe.none))))))) ('Kind.Term.new (let ((f1 (get self1 1))) Maybe.none)) ('Kind.Term.get (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) Maybe.none))) ('Kind.Term.set (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) Maybe.none)))) ('Kind.Term.ope (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) Maybe.none)))) ('Kind.Term.ori (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) Maybe.none))))))) ('Kind.Term.num (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((self3 ($Kind.Term.reduce type$0 defs$1))) (case (get self3 0) ('Kind.Term.var (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) Maybe.none))) ('Kind.Term.ref (let ((f3 (get self3 1))) ($Maybe.some f3))) ('Kind.Term.typ Maybe.none) ('Kind.Term.all (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) (let ((f7 (get self3 5))) ($Kind.Term.check.get_name_of_self_type.slice f4))))))) ('Kind.Term.lam (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) Maybe.none))) ('Kind.Term.app (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) Maybe.none))) ('Kind.Term.let (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) Maybe.none)))) ('Kind.Term.def (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) Maybe.none)))) ('Kind.Term.ann (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) Maybe.none)))) ('Kind.Term.gol (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) Maybe.none)))) ('Kind.Term.hol (let ((f3 (get self3 1))) Maybe.none)) ('Kind.Term.nat (let ((f3 (get self3 1))) Maybe.none)) ('Kind.Term.chr (let ((f3 (get self3 1))) Maybe.none)) ('Kind.Term.str (let ((f3 (get self3 1))) Maybe.none)) ('Kind.Term.num (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) Maybe.none)))) ('Kind.Term.cse (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) (let ((f7 (get self3 5))) (let ((f8 (get self3 6))) Maybe.none))))))) ('Kind.Term.new (let ((f3 (get self3 1))) Maybe.none)) ('Kind.Term.get (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) Maybe.none))) ('Kind.Term.set (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) Maybe.none)))) ('Kind.Term.ope (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) Maybe.none)))) ('Kind.Term.ori (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) Maybe.none))))))))) ('Kind.Term.cse (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((f5 (get self0 6))) (let ((self6 ($Kind.Term.reduce type$0 defs$1))) (case (get self6 0) ('Kind.Term.var (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) Maybe.none))) ('Kind.Term.ref (let ((f6 (get self6 1))) ($Maybe.some f6))) ('Kind.Term.typ Maybe.none) ('Kind.Term.all (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((f8 (get self6 3))) (let ((f9 (get self6 4))) (let ((f10 (get self6 5))) ($Kind.Term.check.get_name_of_self_type.slice f7))))))) ('Kind.Term.lam (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) Maybe.none))) ('Kind.Term.app (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) Maybe.none))) ('Kind.Term.let (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((f8 (get self6 3))) Maybe.none)))) ('Kind.Term.def (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((f8 (get self6 3))) Maybe.none)))) ('Kind.Term.ann (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((f8 (get self6 3))) Maybe.none)))) ('Kind.Term.gol (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((f8 (get self6 3))) Maybe.none)))) ('Kind.Term.hol (let ((f6 (get self6 1))) Maybe.none)) ('Kind.Term.nat (let ((f6 (get self6 1))) Maybe.none)) ('Kind.Term.chr (let ((f6 (get self6 1))) Maybe.none)) ('Kind.Term.str (let ((f6 (get self6 1))) Maybe.none)) ('Kind.Term.num (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((f8 (get self6 3))) Maybe.none)))) ('Kind.Term.cse (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((f8 (get self6 3))) (let ((f9 (get self6 4))) (let ((f10 (get self6 5))) (let ((f11 (get self6 6))) Maybe.none))))))) ('Kind.Term.new (let ((f6 (get self6 1))) Maybe.none)) ('Kind.Term.get (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) Maybe.none))) ('Kind.Term.set (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((f8 (get self6 3))) Maybe.none)))) ('Kind.Term.ope (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((f8 (get self6 3))) Maybe.none)))) ('Kind.Term.ori (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) Maybe.none)))))))))))) ('Kind.Term.new (let ((f0 (get self0 1))) (let ((self1 ($Kind.Term.reduce type$0 defs$1))) (case (get self1 0) ('Kind.Term.var (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) Maybe.none))) ('Kind.Term.ref (let ((f1 (get self1 1))) ($Maybe.some f1))) ('Kind.Term.typ Maybe.none) ('Kind.Term.all (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) ($Kind.Term.check.get_name_of_self_type.slice f2))))))) ('Kind.Term.lam (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) Maybe.none))) ('Kind.Term.app (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) Maybe.none))) ('Kind.Term.let (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) Maybe.none)))) ('Kind.Term.def (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) Maybe.none)))) ('Kind.Term.ann (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) Maybe.none)))) ('Kind.Term.gol (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) Maybe.none)))) ('Kind.Term.hol (let ((f1 (get self1 1))) Maybe.none)) ('Kind.Term.nat (let ((f1 (get self1 1))) Maybe.none)) ('Kind.Term.chr (let ((f1 (get self1 1))) Maybe.none)) ('Kind.Term.str (let ((f1 (get self1 1))) Maybe.none)) ('Kind.Term.num (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) Maybe.none)))) ('Kind.Term.cse (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((f6 (get self1 6))) Maybe.none))))))) ('Kind.Term.new (let ((f1 (get self1 1))) Maybe.none)) ('Kind.Term.get (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) Maybe.none))) ('Kind.Term.set (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) Maybe.none)))) ('Kind.Term.ope (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) Maybe.none)))) ('Kind.Term.ori (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) Maybe.none))))))) ('Kind.Term.get (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((self2 ($Kind.Term.reduce type$0 defs$1))) (case (get self2 0) ('Kind.Term.var (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) Maybe.none))) ('Kind.Term.ref (let ((f2 (get self2 1))) ($Maybe.some f2))) ('Kind.Term.typ Maybe.none) ('Kind.Term.all (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) (let ((f5 (get self2 4))) (let ((f6 (get self2 5))) ($Kind.Term.check.get_name_of_self_type.slice f3))))))) ('Kind.Term.lam (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) Maybe.none))) ('Kind.Term.app (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) Maybe.none))) ('Kind.Term.let (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) Maybe.none)))) ('Kind.Term.def (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) Maybe.none)))) ('Kind.Term.ann (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) Maybe.none)))) ('Kind.Term.gol (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) Maybe.none)))) ('Kind.Term.hol (let ((f2 (get self2 1))) Maybe.none)) ('Kind.Term.nat (let ((f2 (get self2 1))) Maybe.none)) ('Kind.Term.chr (let ((f2 (get self2 1))) Maybe.none)) ('Kind.Term.str (let ((f2 (get self2 1))) Maybe.none)) ('Kind.Term.num (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) Maybe.none)))) ('Kind.Term.cse (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) (let ((f5 (get self2 4))) (let ((f6 (get self2 5))) (let ((f7 (get self2 6))) Maybe.none))))))) ('Kind.Term.new (let ((f2 (get self2 1))) Maybe.none)) ('Kind.Term.get (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) Maybe.none))) ('Kind.Term.set (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) Maybe.none)))) ('Kind.Term.ope (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) Maybe.none)))) ('Kind.Term.ori (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) Maybe.none)))))))) ('Kind.Term.set (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((self3 ($Kind.Term.reduce type$0 defs$1))) (case (get self3 0) ('Kind.Term.var (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) Maybe.none))) ('Kind.Term.ref (let ((f3 (get self3 1))) ($Maybe.some f3))) ('Kind.Term.typ Maybe.none) ('Kind.Term.all (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) (let ((f7 (get self3 5))) ($Kind.Term.check.get_name_of_self_type.slice f4))))))) ('Kind.Term.lam (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) Maybe.none))) ('Kind.Term.app (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) Maybe.none))) ('Kind.Term.let (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) Maybe.none)))) ('Kind.Term.def (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) Maybe.none)))) ('Kind.Term.ann (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) Maybe.none)))) ('Kind.Term.gol (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) Maybe.none)))) ('Kind.Term.hol (let ((f3 (get self3 1))) Maybe.none)) ('Kind.Term.nat (let ((f3 (get self3 1))) Maybe.none)) ('Kind.Term.chr (let ((f3 (get self3 1))) Maybe.none)) ('Kind.Term.str (let ((f3 (get self3 1))) Maybe.none)) ('Kind.Term.num (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) Maybe.none)))) ('Kind.Term.cse (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) (let ((f7 (get self3 5))) (let ((f8 (get self3 6))) Maybe.none))))))) ('Kind.Term.new (let ((f3 (get self3 1))) Maybe.none)) ('Kind.Term.get (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) Maybe.none))) ('Kind.Term.set (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) Maybe.none)))) ('Kind.Term.ope (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) Maybe.none)))) ('Kind.Term.ori (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) Maybe.none))))))))) ('Kind.Term.ope (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((self3 ($Kind.Term.reduce type$0 defs$1))) (case (get self3 0) ('Kind.Term.var (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) Maybe.none))) ('Kind.Term.ref (let ((f3 (get self3 1))) ($Maybe.some f3))) ('Kind.Term.typ Maybe.none) ('Kind.Term.all (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) (let ((f7 (get self3 5))) ($Kind.Term.check.get_name_of_self_type.slice f4))))))) ('Kind.Term.lam (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) Maybe.none))) ('Kind.Term.app (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) Maybe.none))) ('Kind.Term.let (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) Maybe.none)))) ('Kind.Term.def (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) Maybe.none)))) ('Kind.Term.ann (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) Maybe.none)))) ('Kind.Term.gol (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) Maybe.none)))) ('Kind.Term.hol (let ((f3 (get self3 1))) Maybe.none)) ('Kind.Term.nat (let ((f3 (get self3 1))) Maybe.none)) ('Kind.Term.chr (let ((f3 (get self3 1))) Maybe.none)) ('Kind.Term.str (let ((f3 (get self3 1))) Maybe.none)) ('Kind.Term.num (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) Maybe.none)))) ('Kind.Term.cse (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) (let ((f7 (get self3 5))) (let ((f8 (get self3 6))) Maybe.none))))))) ('Kind.Term.new (let ((f3 (get self3 1))) Maybe.none)) ('Kind.Term.get (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) Maybe.none))) ('Kind.Term.set (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) Maybe.none)))) ('Kind.Term.ope (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) Maybe.none)))) ('Kind.Term.ori (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) Maybe.none))))))))) ('Kind.Term.ori (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((self2 ($Kind.Term.reduce type$0 defs$1))) (case (get self2 0) ('Kind.Term.var (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) Maybe.none))) ('Kind.Term.ref (let ((f2 (get self2 1))) ($Maybe.some f2))) ('Kind.Term.typ Maybe.none) ('Kind.Term.all (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) (let ((f5 (get self2 4))) (let ((f6 (get self2 5))) ($Kind.Term.check.get_name_of_self_type.slice f3))))))) ('Kind.Term.lam (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) Maybe.none))) ('Kind.Term.app (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) Maybe.none))) ('Kind.Term.let (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) Maybe.none)))) ('Kind.Term.def (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) Maybe.none)))) ('Kind.Term.ann (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) Maybe.none)))) ('Kind.Term.gol (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) Maybe.none)))) ('Kind.Term.hol (let ((f2 (get self2 1))) Maybe.none)) ('Kind.Term.nat (let ((f2 (get self2 1))) Maybe.none)) ('Kind.Term.chr (let ((f2 (get self2 1))) Maybe.none)) ('Kind.Term.str (let ((f2 (get self2 1))) Maybe.none)) ('Kind.Term.num (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) Maybe.none)))) ('Kind.Term.cse (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) (let ((f5 (get self2 4))) (let ((f6 (get self2 5))) (let ((f7 (get self2 6))) Maybe.none))))))) ('Kind.Term.new (let ((f2 (get self2 1))) Maybe.none)) ('Kind.Term.get (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) Maybe.none))) ('Kind.Term.set (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) Maybe.none)))) ('Kind.Term.ope (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) Maybe.none)))) ('Kind.Term.ori (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) Maybe.none)))))))))))
(define Kind.Term.check.get_name_of_self_type (lambda (type$0) (lambda (defs$1) ($Kind.Term.check.get_name_of_self_type type$0 defs$1))))
(define ($Kind.Term.check.expand.num.nat numb$0) ($Kind.Term.nat numb$0))
(define Kind.Term.check.expand.num.nat (lambda (numb$0) ($Kind.Term.check.expand.num.nat numb$0)))
(define ($Kind.Term.check.expand.num.int sign$0 numb$1) (let ((term$2 ($Kind.Term.nat numb$1))) (let ((term$3 ($Kind.Term.app ($Kind.Term.ref "Int.from_nat") term$2))) (let ((term$4 (let ((self2 sign$0)) (case (get self2 0) ('Maybe.none term$3) ('Maybe.some (let ((f2 (get self2 1))) (let ((self3 f2)) (case self3 (#t term$3) (#f ($Kind.Term.app ($Kind.Term.ref "Int.neg") term$3)))))))))) term$4))))
(define Kind.Term.check.expand.num.int (lambda (sign$0) (lambda (numb$1) ($Kind.Term.check.expand.num.int sign$0 numb$1))))
(define ($Kind.Term.check.expand.num.other name$0 sign$1 numb$2 frac$3) (let ((text$4 (let ((self0 sign$1)) (case (get self0 0) ('Maybe.none "") ('Maybe.some (let ((f0 (get self0 1))) (let ((self1 f0)) (case self1 (#t "+") (#f "-"))))))))) (let ((text$5 ($String.concat text$4 ($Nat.show numb$2)))) (let ((text$6 ($String.concat text$5 (let ((self2 frac$3)) (case (get self2 0) ('Maybe.none "") ('Maybe.some (let ((f2 (get self2 1))) ($String.concat "." ($Nat.show f2))))))))) ($Kind.Term.app ($Kind.Term.ref ($String.concat name$0 ".read")) ($Kind.Term.str text$6))))))
(define Kind.Term.check.expand.num.other (lambda (name$0) (lambda (sign$1) (lambda (numb$2) (lambda (frac$3) ($Kind.Term.check.expand.num.other name$0 sign$1 numb$2 frac$3))))))
(define ($Kind.Term.check.expand.num sign$0 numb$1 frac$2 type$3 defs$4) (let ((got$5 (let ((self0 type$3)) (case (get self0 0) ('Maybe.none Maybe.none) ('Maybe.some (let ((f0 (get self0 1))) (let ((self1 ($Kind.Term.check.get_name_of_self_type f0 defs$4))) (case (get self1 0) ('Maybe.none Maybe.none) ('Maybe.some (let ((f1 (get self1 1))) (let ((self2 ($String.eql f1 "Nat"))) (case self2 (#t ($Maybe.some ($Kind.Term.check.expand.num.nat numb$1))) (#f (let ((self2 ($String.eql f1 "Int"))) (case self2 (#t ($Maybe.some ($Kind.Term.check.expand.num.int sign$0 numb$1))) (#f ($Maybe.some ($Kind.Term.check.expand.num.other f1 sign$0 numb$1 frac$2)))))))))))))))))) (let ((self1 got$5)) (case (get self1 0) ('Maybe.none (let ((self1 frac$2)) (case (get self1 0) ('Maybe.none (let ((self1 sign$0)) (case (get self1 0) ('Maybe.none ($Kind.Term.check.expand.num.nat numb$1)) ('Maybe.some (let ((f1 (get self1 1))) ($Kind.Term.check.expand.num.int sign$0 numb$1)))))) ('Maybe.some (let ((f1 (get self1 1))) ($Kind.Term.check.expand.num.other "F64" sign$0 numb$1 frac$2)))))) ('Maybe.some (let ((f1 (get self1 1))) f1))))))
(define Kind.Term.check.expand.num (lambda (sign$0) (lambda (numb$1) (lambda (frac$2) (lambda (type$3) (lambda (defs$4) ($Kind.Term.check.expand.num sign$0 numb$1 frac$2 type$3 defs$4)))))))
(define ($Kind.Term.check.infer_types_of_with vars$0 defs$1 ctx$2 path$3 orig$4) (let ((self0 vars$0)) (case (get self0 0) ('List.nil ($Kind.Check.result ($Maybe.some List.nil) List.nil)) ('List.cons (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((self2 f0)) (case (get self2 0) ('Kind.Ann.new (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) (let ((self5 (let ((self5 f4)) (case (get self5 0) ('Maybe.none (let ((self5 ($Kind.Term.check f3 Maybe.none defs$1 ctx$2 path$3 orig$4))) (case (get self5 0) ('Kind.Check.result (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((self7 f5)) (case (get self7 0) ('Maybe.none ($Kind.Check.result Maybe.none f6)) ('Maybe.some (let ((f7 (get self7 1))) (let ((self8 ($Kind.Check.result ($Maybe.some ($Maybe.some f7)) List.nil))) (case (get self8 0) ('Kind.Check.result (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) ($Kind.Check.result f8 ($List.concat f6 f9))))))))))))))))) ('Maybe.some (let ((f5 (get self5 1))) ($Kind.Check.result ($Maybe.some ($Maybe.some f5)) List.nil))))))) (case (get self5 0) ('Kind.Check.result (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((self7 f5)) (case (get self7 0) ('Maybe.none ($Kind.Check.result Maybe.none f6)) ('Maybe.some (let ((f7 (get self7 1))) (let ((self8 (let ((self8 ($Kind.Term.check.infer_types_of_with f1 defs$1 ctx$2 path$3 orig$4))) (case (get self8 0) ('Kind.Check.result (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((self10 f8)) (case (get self10 0) ('Maybe.none ($Kind.Check.result Maybe.none f9)) ('Maybe.some (let ((f10 (get self10 1))) (let ((self11 ($Kind.Check.result ($Maybe.some ($List.cons ($Kind.Ann.new f2 f3 f7) f10)) List.nil))) (case (get self11 0) ('Kind.Check.result (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) ($Kind.Check.result f11 ($List.concat f9 f12)))))))))))))))))) (case (get self8 0) ('Kind.Check.result (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) ($Kind.Check.result f8 ($List.concat f6 f9))))))))))))))))))))))))))))
(define Kind.Term.check.infer_types_of_with (lambda (vars$0) (lambda (defs$1) (lambda (ctx$2) (lambda (path$3) (lambda (orig$4) ($Kind.Term.check.infer_types_of_with vars$0 defs$1 ctx$2 path$3 orig$4)))))))
(define ($Kind.Term.normalize term$0 defs$1) (let ((self0 ($Kind.Term.reduce term$0 defs$1))) (case (get self0 0) ('Kind.Term.var (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($Kind.Term.var f0 f1)))) ('Kind.Term.ref (let ((f0 (get self0 1))) ($Kind.Term.ref f0))) ('Kind.Term.typ Kind.Term.typ) ('Kind.Term.all (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) ($Kind.Term.all f0 f1 f2 ($Kind.Term.normalize f3 defs$1) (lambda (s$7) (lambda (x$8) ($Kind.Term.normalize ((f4 s$7) x$8) defs$1)))))))))) ('Kind.Term.lam (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($Kind.Term.lam f0 (lambda (x$4) ($Kind.Term.normalize (f1 x$4) defs$1)))))) ('Kind.Term.app (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($Kind.Term.app ($Kind.Term.normalize f0 defs$1) ($Kind.Term.normalize f1 defs$1))))) ('Kind.Term.let (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) ($Kind.Term.let f0 ($Kind.Term.normalize f1 defs$1) (lambda (x$5) ($Kind.Term.normalize (f2 x$5) defs$1))))))) ('Kind.Term.def (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) ($Kind.Term.def f0 ($Kind.Term.normalize f1 defs$1) (lambda (x$5) ($Kind.Term.normalize (f2 x$5) defs$1))))))) ('Kind.Term.ann (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) ($Kind.Term.ann f0 ($Kind.Term.normalize f1 defs$1) ($Kind.Term.normalize f2 defs$1)))))) ('Kind.Term.gol (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) ($Kind.Term.gol f0 f1 f2))))) ('Kind.Term.hol (let ((f0 (get self0 1))) ($Kind.Term.hol f0))) ('Kind.Term.nat (let ((f0 (get self0 1))) ($Kind.Term.nat f0))) ('Kind.Term.chr (let ((f0 (get self0 1))) ($Kind.Term.chr f0))) ('Kind.Term.str (let ((f0 (get self0 1))) ($Kind.Term.str f0))) ('Kind.Term.num (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) term$0)))) ('Kind.Term.cse (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((f5 (get self0 6))) term$0))))))) ('Kind.Term.new (let ((f0 (get self0 1))) term$0)) ('Kind.Term.get (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) term$0))) ('Kind.Term.set (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) term$0)))) ('Kind.Term.ope (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) term$0)))) ('Kind.Term.ori (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($Kind.Term.normalize f1 defs$1)))))))
(define Kind.Term.normalize (lambda (term$0) (lambda (defs$1) ($Kind.Term.normalize term$0 defs$1))))
(define ($Kind.Term.check.expand.cse.motive.go wyth$0 moti$1 name$2 expr$3 etyp$4 rtyp$5 defs$6 size$7) (let ((self0 wyth$0)) (case (get self0 0) ('List.nil (let ((self0 moti$1)) (case (get self0 0) ('Maybe.none (let ((self0 rtyp$5)) (case (get self0 0) ('Maybe.none ($Kind.Term.hol Bits.e)) ('Maybe.some (let ((f0 (get self0 1))) ($Kind.Term.normalize f0 Kind.Map.new)))))) ('Maybe.some (let ((f0 (get self0 1))) f0))))) ('List.cons (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((self2 f0)) (case (get self2 0) ('Kind.Ann.new (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) ($Kind.Term.all Bool.false "" f2 ($Maybe.default f4 ($Kind.Term.hol Bits.e)) (lambda (s$13) (lambda (x$14) ($Kind.Term.check.expand.cse.motive f1 moti$1 name$2 expr$3 etyp$4 rtyp$5 defs$6 ($Nat.succ ($Nat.succ size$7))))))))))))))))))
(define Kind.Term.check.expand.cse.motive.go (lambda (wyth$0) (lambda (moti$1) (lambda (name$2) (lambda (expr$3) (lambda (etyp$4) (lambda (rtyp$5) (lambda (defs$6) (lambda (size$7) ($Kind.Term.check.expand.cse.motive.go wyth$0 moti$1 name$2 expr$3 etyp$4 rtyp$5 defs$6 size$7))))))))))
(define ($List.tail xs$1) (let ((self0 xs$1)) (case (get self0 0) ('List.nil List.nil) ('List.cons (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) f1))))))
(define List.tail (lambda (xs$1) ($List.tail xs$1)))
(define ($Kind.Term.SmartMotive.vals.cont expr$0 term$1 args$2 defs$3) (let ((self0 ($Kind.Term.reduce term$1 defs$3))) (case (get self0 0) ('Kind.Term.var (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($List.cons expr$0 ($List.tail ($List.reverse args$2)))))) ('Kind.Term.ref (let ((f0 (get self0 1))) ($List.cons expr$0 ($List.tail ($List.reverse args$2))))) ('Kind.Term.typ ($List.cons expr$0 ($List.tail ($List.reverse args$2)))) ('Kind.Term.all (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) ($List.cons expr$0 ($List.tail ($List.reverse args$2))))))))) ('Kind.Term.lam (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($List.cons expr$0 ($List.tail ($List.reverse args$2)))))) ('Kind.Term.app (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($Kind.Term.SmartMotive.vals.cont expr$0 f0 ($List.cons f1 args$2) defs$3)))) ('Kind.Term.let (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) ($List.cons expr$0 ($List.tail ($List.reverse args$2))))))) ('Kind.Term.def (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) ($List.cons expr$0 ($List.tail ($List.reverse args$2))))))) ('Kind.Term.ann (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) ($List.cons expr$0 ($List.tail ($List.reverse args$2))))))) ('Kind.Term.gol (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) ($List.cons expr$0 ($List.tail ($List.reverse args$2))))))) ('Kind.Term.hol (let ((f0 (get self0 1))) ($List.cons expr$0 ($List.tail ($List.reverse args$2))))) ('Kind.Term.nat (let ((f0 (get self0 1))) ($List.cons expr$0 ($List.tail ($List.reverse args$2))))) ('Kind.Term.chr (let ((f0 (get self0 1))) ($List.cons expr$0 ($List.tail ($List.reverse args$2))))) ('Kind.Term.str (let ((f0 (get self0 1))) ($List.cons expr$0 ($List.tail ($List.reverse args$2))))) ('Kind.Term.num (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) ($List.cons expr$0 ($List.tail ($List.reverse args$2))))))) ('Kind.Term.cse (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((f5 (get self0 6))) ($List.cons expr$0 ($List.tail ($List.reverse args$2)))))))))) ('Kind.Term.new (let ((f0 (get self0 1))) ($List.cons expr$0 ($List.tail ($List.reverse args$2))))) ('Kind.Term.get (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($List.cons expr$0 ($List.tail ($List.reverse args$2)))))) ('Kind.Term.set (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) ($List.cons expr$0 ($List.tail ($List.reverse args$2))))))) ('Kind.Term.ope (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) ($List.cons expr$0 ($List.tail ($List.reverse args$2))))))) ('Kind.Term.ori (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($List.cons expr$0 ($List.tail ($List.reverse args$2)))))))))
(define Kind.Term.SmartMotive.vals.cont (lambda (expr$0) (lambda (term$1) (lambda (args$2) (lambda (defs$3) ($Kind.Term.SmartMotive.vals.cont expr$0 term$1 args$2 defs$3))))))
(define ($Kind.Term.SmartMotive.vals expr$0 type$1 defs$2) (let ((self0 ($Kind.Term.reduce type$1 defs$2))) (case (get self0 0) ('Kind.Term.var (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($Kind.Term.SmartMotive.vals.cont expr$0 type$1 List.nil defs$2)))) ('Kind.Term.ref (let ((f0 (get self0 1))) ($Kind.Term.SmartMotive.vals.cont expr$0 type$1 List.nil defs$2))) ('Kind.Term.typ ($Kind.Term.SmartMotive.vals.cont expr$0 type$1 List.nil defs$2)) ('Kind.Term.all (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) ($Kind.Term.SmartMotive.vals expr$0 ((f4 Kind.Term.typ) Kind.Term.typ) defs$2))))))) ('Kind.Term.lam (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($Kind.Term.SmartMotive.vals.cont expr$0 type$1 List.nil defs$2)))) ('Kind.Term.app (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($Kind.Term.SmartMotive.vals.cont expr$0 type$1 List.nil defs$2)))) ('Kind.Term.let (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) ($Kind.Term.SmartMotive.vals.cont expr$0 type$1 List.nil defs$2))))) ('Kind.Term.def (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) ($Kind.Term.SmartMotive.vals.cont expr$0 type$1 List.nil defs$2))))) ('Kind.Term.ann (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) ($Kind.Term.SmartMotive.vals.cont expr$0 type$1 List.nil defs$2))))) ('Kind.Term.gol (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) ($Kind.Term.SmartMotive.vals.cont expr$0 type$1 List.nil defs$2))))) ('Kind.Term.hol (let ((f0 (get self0 1))) ($Kind.Term.SmartMotive.vals.cont expr$0 type$1 List.nil defs$2))) ('Kind.Term.nat (let ((f0 (get self0 1))) ($Kind.Term.SmartMotive.vals.cont expr$0 type$1 List.nil defs$2))) ('Kind.Term.chr (let ((f0 (get self0 1))) ($Kind.Term.SmartMotive.vals.cont expr$0 type$1 List.nil defs$2))) ('Kind.Term.str (let ((f0 (get self0 1))) ($Kind.Term.SmartMotive.vals.cont expr$0 type$1 List.nil defs$2))) ('Kind.Term.num (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) ($Kind.Term.SmartMotive.vals.cont expr$0 type$1 List.nil defs$2))))) ('Kind.Term.cse (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((f5 (get self0 6))) ($Kind.Term.SmartMotive.vals.cont expr$0 type$1 List.nil defs$2)))))))) ('Kind.Term.new (let ((f0 (get self0 1))) ($Kind.Term.SmartMotive.vals.cont expr$0 type$1 List.nil defs$2))) ('Kind.Term.get (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($Kind.Term.SmartMotive.vals.cont expr$0 type$1 List.nil defs$2)))) ('Kind.Term.set (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) ($Kind.Term.SmartMotive.vals.cont expr$0 type$1 List.nil defs$2))))) ('Kind.Term.ope (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) ($Kind.Term.SmartMotive.vals.cont expr$0 type$1 List.nil defs$2))))) ('Kind.Term.ori (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($Kind.Term.SmartMotive.vals.cont expr$0 type$1 List.nil defs$2)))))))
(define Kind.Term.SmartMotive.vals (lambda (expr$0) (lambda (type$1) (lambda (defs$2) ($Kind.Term.SmartMotive.vals expr$0 type$1 defs$2)))))
(define ($Kind.Term.SmartMotive.nams.cont name$0 term$1 binds$2 defs$3) (let ((self0 ($Kind.Term.reduce term$1 defs$3))) (case (get self0 0) ('Kind.Term.var (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($List.cons name$0 ($List.tail binds$2))))) ('Kind.Term.ref (let ((f0 (get self0 1))) ($List.cons name$0 ($List.tail binds$2)))) ('Kind.Term.typ ($List.cons name$0 ($List.tail binds$2))) ('Kind.Term.all (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) ($Kind.Term.SmartMotive.nams.cont name$0 ((f4 ($Kind.Term.ref f1)) ($Kind.Term.ref f2)) ($List.cons ($String.flatten ($List.cons name$0 ($List.cons "." ($List.cons f2 List.nil)))) binds$2) defs$3))))))) ('Kind.Term.lam (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($List.cons name$0 ($List.tail binds$2))))) ('Kind.Term.app (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($List.cons name$0 ($List.tail binds$2))))) ('Kind.Term.let (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) ($List.cons name$0 ($List.tail binds$2)))))) ('Kind.Term.def (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) ($List.cons name$0 ($List.tail binds$2)))))) ('Kind.Term.ann (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) ($List.cons name$0 ($List.tail binds$2)))))) ('Kind.Term.gol (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) ($List.cons name$0 ($List.tail binds$2)))))) ('Kind.Term.hol (let ((f0 (get self0 1))) ($List.cons name$0 ($List.tail binds$2)))) ('Kind.Term.nat (let ((f0 (get self0 1))) ($List.cons name$0 ($List.tail binds$2)))) ('Kind.Term.chr (let ((f0 (get self0 1))) ($List.cons name$0 ($List.tail binds$2)))) ('Kind.Term.str (let ((f0 (get self0 1))) ($List.cons name$0 ($List.tail binds$2)))) ('Kind.Term.num (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) ($List.cons name$0 ($List.tail binds$2)))))) ('Kind.Term.cse (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((f5 (get self0 6))) ($List.cons name$0 ($List.tail binds$2))))))))) ('Kind.Term.new (let ((f0 (get self0 1))) ($List.cons name$0 ($List.tail binds$2)))) ('Kind.Term.get (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($List.cons name$0 ($List.tail binds$2))))) ('Kind.Term.set (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) ($List.cons name$0 ($List.tail binds$2)))))) ('Kind.Term.ope (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) ($List.cons name$0 ($List.tail binds$2)))))) ('Kind.Term.ori (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($List.cons name$0 ($List.tail binds$2))))))))
(define Kind.Term.SmartMotive.nams.cont (lambda (name$0) (lambda (term$1) (lambda (binds$2) (lambda (defs$3) ($Kind.Term.SmartMotive.nams.cont name$0 term$1 binds$2 defs$3))))))
(define ($Kind.Term.SmartMotive.nams name$0 type$1 defs$2) (let ((self0 ($Kind.Term.reduce type$1 defs$2))) (case (get self0 0) ('Kind.Term.var (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) List.nil))) ('Kind.Term.ref (let ((f0 (get self0 1))) List.nil)) ('Kind.Term.typ List.nil) ('Kind.Term.all (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) ($Kind.Term.SmartMotive.nams.cont name$0 f3 List.nil defs$2))))))) ('Kind.Term.lam (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) List.nil))) ('Kind.Term.app (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) List.nil))) ('Kind.Term.let (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) List.nil)))) ('Kind.Term.def (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) List.nil)))) ('Kind.Term.ann (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) List.nil)))) ('Kind.Term.gol (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) List.nil)))) ('Kind.Term.hol (let ((f0 (get self0 1))) List.nil)) ('Kind.Term.nat (let ((f0 (get self0 1))) List.nil)) ('Kind.Term.chr (let ((f0 (get self0 1))) List.nil)) ('Kind.Term.str (let ((f0 (get self0 1))) List.nil)) ('Kind.Term.num (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) List.nil)))) ('Kind.Term.cse (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((f5 (get self0 6))) List.nil))))))) ('Kind.Term.new (let ((f0 (get self0 1))) List.nil)) ('Kind.Term.get (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) List.nil))) ('Kind.Term.set (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) List.nil)))) ('Kind.Term.ope (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) List.nil)))) ('Kind.Term.ori (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) List.nil))))))
(define Kind.Term.SmartMotive.nams (lambda (name$0) (lambda (type$1) (lambda (defs$2) ($Kind.Term.SmartMotive.nams name$0 type$1 defs$2)))))
(define ($List.zip as$2 bs$3) (let ((self0 as$2)) (case (get self0 0) ('List.nil List.nil) ('List.cons (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((self2 bs$3)) (case (get self2 0) ('List.nil List.nil) ('List.cons (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) ($List.cons ($Pair.new f0 f2) ($List.zip f1 f3)))))))))))))
(define List.zip (lambda (as$2) (lambda (bs$3) ($List.zip as$2 bs$3))))
(define ($Nat.gte n$0 m$1) (>= n$0 m$1))
(define Nat.gte (lambda (n$0) (lambda (m$1) ($Nat.gte n$0 m$1))))
(define ($Bits.concat a$0 b$1) (let ((self0 a$0)) (case (if (eq? self0 #b1) 2 (bitwise-and self0 #b1)) (2 b$1) (0 (let ((f0 (bitwise-arithmetic-shift-right self0 #b1))) ($Bits.o ($Bits.concat f0 b$1)))) (1 (let ((f0 (bitwise-arithmetic-shift-right self0 #b1))) ($Bits.i ($Bits.concat f0 b$1)))))))
(define Bits.concat (lambda (a$0) (lambda (b$1) ($Bits.concat a$0 b$1))))
(define ($Kind.Term.serialize.go term$0 depth$1 init$2 diff$3 x$4) (let ((self0 term$0)) (case (get self0 0) ('Kind.Term.var (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((self2 ($Nat.gte f1 init$2))) (case self2 (#t (let ((name$7 (Bits.concat ($Nat.to_bits ($Nat.pred ($Nat.sub depth$1 f1)))))) ($Bits.o ($Bits.o ($Bits.i (name$7 x$4)))))) (#f (let ((name$7 (Bits.concat ($Nat.to_bits f1)))) ($Bits.o ($Bits.i ($Bits.o (name$7 x$4))))))))))) ('Kind.Term.ref (let ((f0 (get self0 1))) (let ((name$6 (Bits.concat ($Kind.Name.to_bits f0)))) ($Bits.o ($Bits.o ($Bits.o (name$6 x$4))))))) ('Kind.Term.typ ($Bits.o ($Bits.i ($Bits.i x$4)))) ('Kind.Term.all (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((eras$10 (let ((self5 f0)) (case self5 (#t Bits.i) (#f Bits.o))))) (let ((self$11 (Bits.concat ($Kind.Name.to_bits f1)))) (let ((xtyp$12 ((((Kind.Term.serialize.go f3) depth$1) init$2) diff$3))) (let ((body$13 ((((Kind.Term.serialize.go ((f4 ($Kind.Term.var f1 depth$1)) ($Kind.Term.var f2 ($Nat.succ depth$1)))) ($Nat.succ ($Nat.succ depth$1))) init$2) diff$3))) ($Bits.i ($Bits.o ($Bits.o (eras$10 (self$11 (xtyp$12 (body$13 x$4))))))))))))))))) ('Kind.Term.lam (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((body$7 ((((Kind.Term.serialize.go (f1 ($Kind.Term.var f0 depth$1))) ($Nat.succ depth$1)) init$2) diff$3))) ($Bits.i ($Bits.o ($Bits.i (body$7 x$4)))))))) ('Kind.Term.app (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((func$7 ((((Kind.Term.serialize.go f0) depth$1) init$2) diff$3))) (let ((argm$8 ((((Kind.Term.serialize.go f1) depth$1) init$2) diff$3))) ($Bits.i ($Bits.i ($Bits.o (func$7 (argm$8 x$4)))))))))) ('Kind.Term.let (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((expr$8 ((((Kind.Term.serialize.go f1) depth$1) init$2) diff$3))) (let ((body$9 ((((Kind.Term.serialize.go (f2 ($Kind.Term.var f0 depth$1))) ($Nat.succ depth$1)) init$2) diff$3))) ($Bits.i ($Bits.i ($Bits.i (expr$8 (body$9 x$4))))))))))) ('Kind.Term.def (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) ($Kind.Term.serialize.go (f2 f1) depth$1 init$2 diff$3 x$4))))) ('Kind.Term.ann (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) ($Kind.Term.serialize.go f1 depth$1 init$2 diff$3 x$4))))) ('Kind.Term.gol (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((name$8 (Bits.concat ($Kind.Name.to_bits f0)))) ($Bits.o ($Bits.o ($Bits.o (name$8 x$4))))))))) ('Kind.Term.hol (let ((f0 (get self0 1))) x$4)) ('Kind.Term.nat (let ((f0 (get self0 1))) ($Kind.Term.serialize.go ($Kind.Term.unroll_nat f0) depth$1 init$2 diff$3 x$4))) ('Kind.Term.chr (let ((f0 (get self0 1))) ($Kind.Term.serialize.go ($Kind.Term.unroll_chr f0) depth$1 init$2 diff$3 x$4))) ('Kind.Term.str (let ((f0 (get self0 1))) ($Kind.Term.serialize.go ($Kind.Term.unroll_str f0) depth$1 init$2 diff$3 x$4))) ('Kind.Term.num (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (diff$3 x$4))))) ('Kind.Term.cse (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((f5 (get self0 6))) (diff$3 x$4)))))))) ('Kind.Term.new (let ((f0 (get self0 1))) (diff$3 x$4))) ('Kind.Term.get (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (diff$3 x$4)))) ('Kind.Term.set (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (diff$3 x$4))))) ('Kind.Term.ope (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (diff$3 x$4))))) ('Kind.Term.ori (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($Kind.Term.serialize.go f1 depth$1 init$2 diff$3 x$4)))))))
(define Kind.Term.serialize.go (lambda (term$0) (lambda (depth$1) (lambda (init$2) (lambda (diff$3) (lambda (x$4) ($Kind.Term.serialize.go term$0 depth$1 init$2 diff$3 x$4)))))))
(define ($Kind.Term.serialize term$0 depth$1 side$2) (let ((diff$3 (let ((self0 side$2)) (case self0 (#t Bits.o) (#f Bits.i))))) ($Kind.Term.serialize.go term$0 depth$1 depth$1 diff$3 Bits.e)))
(define Kind.Term.serialize (lambda (term$0) (lambda (depth$1) (lambda (side$2) ($Kind.Term.serialize term$0 depth$1 side$2)))))
(define ($Bits.eql a$0 b$1) (let ((self0 a$0)) (case (if (eq? self0 #b1) 2 (bitwise-and self0 #b1)) (2 (let ((self0 b$1)) (case (if (eq? self0 #b1) 2 (bitwise-and self0 #b1)) (2 Bool.true) (0 (let ((f0 (bitwise-arithmetic-shift-right self0 #b1))) Bool.false)) (1 (let ((f0 (bitwise-arithmetic-shift-right self0 #b1))) Bool.false))))) (0 (let ((f0 (bitwise-arithmetic-shift-right self0 #b1))) (let ((self1 b$1)) (case (if (eq? self1 #b1) 2 (bitwise-and self1 #b1)) (2 Bool.false) (0 (let ((f1 (bitwise-arithmetic-shift-right self1 #b1))) ($Bits.eql f0 f1))) (1 (let ((f1 (bitwise-arithmetic-shift-right self1 #b1))) Bool.false)))))) (1 (let ((f0 (bitwise-arithmetic-shift-right self0 #b1))) (let ((self1 b$1)) (case (if (eq? self1 #b1) 2 (bitwise-and self1 #b1)) (2 Bool.false) (0 (let ((f1 (bitwise-arithmetic-shift-right self1 #b1))) Bool.false)) (1 (let ((f1 (bitwise-arithmetic-shift-right self1 #b1))) ($Bits.eql f0 f1))))))))))
(define Bits.eql (lambda (a$0) (lambda (b$1) ($Bits.eql a$0 b$1))))
(define ($Kind.Term.identical a$0 b$1 lv$2) (let ((ah$3 ($Kind.Term.serialize a$0 lv$2 Bool.false))) (let ((bh$4 ($Kind.Term.serialize b$1 lv$2 Bool.true))) ($Bits.eql ah$3 bh$4))))
(define Kind.Term.identical (lambda (a$0) (lambda (b$1) (lambda (lv$2) ($Kind.Term.identical a$0 b$1 lv$2)))))
(define ($Kind.Term.SmartMotive.replace term$0 from$1 to$2 lv$3) (let ((self0 ($Kind.Term.identical term$0 from$1 lv$3))) (case self0 (#t to$2) (#f (let ((self0 term$0)) (case (get self0 0) ('Kind.Term.var (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($Kind.Term.var f0 f1)))) ('Kind.Term.ref (let ((f0 (get self0 1))) ($Kind.Term.ref f0))) ('Kind.Term.typ Kind.Term.typ) ('Kind.Term.all (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((xtyp$9 ($Kind.Term.SmartMotive.replace f3 from$1 to$2 lv$3))) (let ((body$10 ((f4 ($Kind.Term.ref f1)) ($Kind.Term.ref f2)))) (let ((body$11 ($Kind.Term.SmartMotive.replace body$10 from$1 to$2 ($Nat.succ ($Nat.succ lv$3))))) ($Kind.Term.all f0 f1 f2 xtyp$9 (lambda (s$12) (lambda (x$13) body$11)))))))))))) ('Kind.Term.lam (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((body$6 (f1 ($Kind.Term.ref f0)))) (let ((body$7 ($Kind.Term.SmartMotive.replace body$6 from$1 to$2 ($Nat.succ lv$3)))) ($Kind.Term.lam f0 (lambda (x$8) body$7))))))) ('Kind.Term.app (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((func$6 ($Kind.Term.SmartMotive.replace f0 from$1 to$2 lv$3))) (let ((argm$7 ($Kind.Term.SmartMotive.replace f1 from$1 to$2 lv$3))) ($Kind.Term.app func$6 argm$7)))))) ('Kind.Term.let (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((expr$7 ($Kind.Term.SmartMotive.replace f1 from$1 to$2 lv$3))) (let ((body$8 (f2 ($Kind.Term.ref f0)))) (let ((body$9 ($Kind.Term.SmartMotive.replace body$8 from$1 to$2 ($Nat.succ lv$3)))) ($Kind.Term.let f0 expr$7 (lambda (x$10) body$9))))))))) ('Kind.Term.def (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((expr$7 ($Kind.Term.SmartMotive.replace f1 from$1 to$2 lv$3))) (let ((body$8 (f2 ($Kind.Term.ref f0)))) (let ((body$9 ($Kind.Term.SmartMotive.replace body$8 from$1 to$2 ($Nat.succ lv$3)))) ($Kind.Term.def f0 expr$7 (lambda (x$10) body$9))))))))) ('Kind.Term.ann (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((term$7 ($Kind.Term.SmartMotive.replace f1 from$1 to$2 lv$3))) (let ((type$8 ($Kind.Term.SmartMotive.replace f2 from$1 to$2 lv$3))) ($Kind.Term.ann f0 term$7 type$8))))))) ('Kind.Term.gol (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) term$0)))) ('Kind.Term.hol (let ((f0 (get self0 1))) term$0)) ('Kind.Term.nat (let ((f0 (get self0 1))) term$0)) ('Kind.Term.chr (let ((f0 (get self0 1))) term$0)) ('Kind.Term.str (let ((f0 (get self0 1))) term$0)) ('Kind.Term.num (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) term$0)))) ('Kind.Term.cse (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((f5 (get self0 6))) term$0))))))) ('Kind.Term.new (let ((f0 (get self0 1))) term$0)) ('Kind.Term.get (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((expr$6 ($Kind.Term.SmartMotive.replace f0 from$1 to$2 lv$3))) (let ((fkey$7 f1)) ($Kind.Term.get expr$6 fkey$7)))))) ('Kind.Term.set (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((expr$7 ($Kind.Term.SmartMotive.replace f0 from$1 to$2 lv$3))) (let ((fkey$8 f1)) (let ((fval$9 ($Kind.Term.SmartMotive.replace f2 from$1 to$2 lv$3))) ($Kind.Term.set expr$7 fkey$8 fval$9)))))))) ('Kind.Term.ope (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((arg0$7 ($Kind.Term.SmartMotive.replace f1 from$1 to$2 lv$3))) (let ((arg1$8 ($Kind.Term.SmartMotive.replace f2 from$1 to$2 lv$3))) ($Kind.Term.ope f0 arg0$7 arg1$8))))))) ('Kind.Term.ori (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($Kind.Term.SmartMotive.replace f1 from$1 to$2 lv$3))))))))))
(define Kind.Term.SmartMotive.replace (lambda (term$0) (lambda (from$1) (lambda (to$2) (lambda (lv$3) ($Kind.Term.SmartMotive.replace term$0 from$1 to$2 lv$3))))))
(define ($Kind.Term.SmartMotive.make name$0 expr$1 type$2 moti$3 size$4 defs$5) (let ((vals$6 ($Kind.Term.SmartMotive.vals expr$1 type$2 defs$5))) (let ((nams$7 ($Kind.Term.SmartMotive.nams name$0 type$2 defs$5))) (let ((subs$8 ($List.zip nams$7 vals$6))) ($List.fold subs$8 moti$3 (lambda (sub$9) (lambda (moti$10) (let ((self5 sub$9)) (case (get self5 0) ('Pair.new (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) ($Kind.Term.SmartMotive.replace moti$10 f6 ($Kind.Term.ref f5) size$4)))))))))))))
(define Kind.Term.SmartMotive.make (lambda (name$0) (lambda (expr$1) (lambda (type$2) (lambda (moti$3) (lambda (size$4) (lambda (defs$5) ($Kind.Term.SmartMotive.make name$0 expr$1 type$2 moti$3 size$4 defs$5))))))))
(define ($Kind.Term.check.expand.cse.motive wyth$0 moti$1 name$2 expr$3 etyp$4 rtyp$5 defs$6 size$7) (let ((done$8 ($Kind.Term.check.expand.cse.motive.go wyth$0 moti$1 name$2 expr$3 etyp$4 rtyp$5 defs$6 size$7))) (let ((self1 moti$1)) (case (get self1 0) ('Maybe.none ($Kind.Term.SmartMotive.make name$2 expr$3 etyp$4 done$8 size$7 defs$6)) ('Maybe.some (let ((f1 (get self1 1))) done$8))))))
(define Kind.Term.check.expand.cse.motive (lambda (wyth$0) (lambda (moti$1) (lambda (name$2) (lambda (expr$3) (lambda (etyp$4) (lambda (rtyp$5) (lambda (defs$6) (lambda (size$7) ($Kind.Term.check.expand.cse.motive wyth$0 moti$1 name$2 expr$3 etyp$4 rtyp$5 defs$6 size$7))))))))))
(define ($Kind.Term.check.expand.cse.argument name$0 wyth$1 type$2 body$3 defs$4) (let ((self0 ($Kind.Term.reduce type$2 defs$4))) (case (get self0 0) ('Kind.Term.var (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((self2 wyth$1)) (case (get self2 0) ('List.nil body$3) ('List.cons (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((self4 f2)) (case (get self4 0) ('Kind.Ann.new (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((f6 (get self4 3))) ($Kind.Term.lam f4 (lambda (x$12) ($Kind.Term.check.expand.cse.argument name$0 f3 type$2 body$3 defs$4))))))))))))))))) ('Kind.Term.ref (let ((f0 (get self0 1))) (let ((self1 wyth$1)) (case (get self1 0) ('List.nil body$3) ('List.cons (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((self3 f1)) (case (get self3 0) ('Kind.Ann.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Kind.Term.lam f3 (lambda (x$11) ($Kind.Term.check.expand.cse.argument name$0 f2 type$2 body$3 defs$4)))))))))))))))) ('Kind.Term.typ (let ((self0 wyth$1)) (case (get self0 0) ('List.nil body$3) ('List.cons (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((self2 f0)) (case (get self2 0) ('Kind.Ann.new (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) ($Kind.Term.lam f2 (lambda (x$10) ($Kind.Term.check.expand.cse.argument name$0 f1 type$2 body$3 defs$4))))))))))))))) ('Kind.Term.all (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) ($Kind.Term.lam (let ((self5 ($String.is_empty f2))) (case self5 (#t name$0) (#f ($String.flatten ($List.cons name$0 ($List.cons "." ($List.cons f2 List.nil))))))) (lambda (x$10) ($Kind.Term.check.expand.cse.argument name$0 wyth$1 ((f4 ($Kind.Term.var f1 0)) ($Kind.Term.var f2 0)) body$3 defs$4))))))))) ('Kind.Term.lam (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((self2 wyth$1)) (case (get self2 0) ('List.nil body$3) ('List.cons (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((self4 f2)) (case (get self4 0) ('Kind.Ann.new (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((f6 (get self4 3))) ($Kind.Term.lam f4 (lambda (x$12) ($Kind.Term.check.expand.cse.argument name$0 f3 type$2 body$3 defs$4))))))))))))))))) ('Kind.Term.app (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((self2 wyth$1)) (case (get self2 0) ('List.nil body$3) ('List.cons (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((self4 f2)) (case (get self4 0) ('Kind.Ann.new (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((f6 (get self4 3))) ($Kind.Term.lam f4 (lambda (x$12) ($Kind.Term.check.expand.cse.argument name$0 f3 type$2 body$3 defs$4))))))))))))))))) ('Kind.Term.let (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((self3 wyth$1)) (case (get self3 0) ('List.nil body$3) ('List.cons (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((self5 f3)) (case (get self5 0) ('Kind.Ann.new (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) ($Kind.Term.lam f5 (lambda (x$13) ($Kind.Term.check.expand.cse.argument name$0 f4 type$2 body$3 defs$4)))))))))))))))))) ('Kind.Term.def (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((self3 wyth$1)) (case (get self3 0) ('List.nil body$3) ('List.cons (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((self5 f3)) (case (get self5 0) ('Kind.Ann.new (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) ($Kind.Term.lam f5 (lambda (x$13) ($Kind.Term.check.expand.cse.argument name$0 f4 type$2 body$3 defs$4)))))))))))))))))) ('Kind.Term.ann (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((self3 wyth$1)) (case (get self3 0) ('List.nil body$3) ('List.cons (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((self5 f3)) (case (get self5 0) ('Kind.Ann.new (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) ($Kind.Term.lam f5 (lambda (x$13) ($Kind.Term.check.expand.cse.argument name$0 f4 type$2 body$3 defs$4)))))))))))))))))) ('Kind.Term.gol (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((self3 wyth$1)) (case (get self3 0) ('List.nil body$3) ('List.cons (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((self5 f3)) (case (get self5 0) ('Kind.Ann.new (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) ($Kind.Term.lam f5 (lambda (x$13) ($Kind.Term.check.expand.cse.argument name$0 f4 type$2 body$3 defs$4)))))))))))))))))) ('Kind.Term.hol (let ((f0 (get self0 1))) (let ((self1 wyth$1)) (case (get self1 0) ('List.nil body$3) ('List.cons (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((self3 f1)) (case (get self3 0) ('Kind.Ann.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Kind.Term.lam f3 (lambda (x$11) ($Kind.Term.check.expand.cse.argument name$0 f2 type$2 body$3 defs$4)))))))))))))))) ('Kind.Term.nat (let ((f0 (get self0 1))) (let ((self1 wyth$1)) (case (get self1 0) ('List.nil body$3) ('List.cons (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((self3 f1)) (case (get self3 0) ('Kind.Ann.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Kind.Term.lam f3 (lambda (x$11) ($Kind.Term.check.expand.cse.argument name$0 f2 type$2 body$3 defs$4)))))))))))))))) ('Kind.Term.chr (let ((f0 (get self0 1))) (let ((self1 wyth$1)) (case (get self1 0) ('List.nil body$3) ('List.cons (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((self3 f1)) (case (get self3 0) ('Kind.Ann.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Kind.Term.lam f3 (lambda (x$11) ($Kind.Term.check.expand.cse.argument name$0 f2 type$2 body$3 defs$4)))))))))))))))) ('Kind.Term.str (let ((f0 (get self0 1))) (let ((self1 wyth$1)) (case (get self1 0) ('List.nil body$3) ('List.cons (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((self3 f1)) (case (get self3 0) ('Kind.Ann.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Kind.Term.lam f3 (lambda (x$11) ($Kind.Term.check.expand.cse.argument name$0 f2 type$2 body$3 defs$4)))))))))))))))) ('Kind.Term.num (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((self3 wyth$1)) (case (get self3 0) ('List.nil body$3) ('List.cons (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((self5 f3)) (case (get self5 0) ('Kind.Ann.new (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) ($Kind.Term.lam f5 (lambda (x$13) ($Kind.Term.check.expand.cse.argument name$0 f4 type$2 body$3 defs$4)))))))))))))))))) ('Kind.Term.cse (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((f5 (get self0 6))) (let ((self6 wyth$1)) (case (get self6 0) ('List.nil body$3) ('List.cons (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((self8 f6)) (case (get self8 0) ('Kind.Ann.new (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) ($Kind.Term.lam f8 (lambda (x$16) ($Kind.Term.check.expand.cse.argument name$0 f7 type$2 body$3 defs$4))))))))))))))))))))) ('Kind.Term.new (let ((f0 (get self0 1))) (let ((self1 wyth$1)) (case (get self1 0) ('List.nil body$3) ('List.cons (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((self3 f1)) (case (get self3 0) ('Kind.Ann.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Kind.Term.lam f3 (lambda (x$11) ($Kind.Term.check.expand.cse.argument name$0 f2 type$2 body$3 defs$4)))))))))))))))) ('Kind.Term.get (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((self2 wyth$1)) (case (get self2 0) ('List.nil body$3) ('List.cons (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((self4 f2)) (case (get self4 0) ('Kind.Ann.new (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((f6 (get self4 3))) ($Kind.Term.lam f4 (lambda (x$12) ($Kind.Term.check.expand.cse.argument name$0 f3 type$2 body$3 defs$4))))))))))))))))) ('Kind.Term.set (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((self3 wyth$1)) (case (get self3 0) ('List.nil body$3) ('List.cons (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((self5 f3)) (case (get self5 0) ('Kind.Ann.new (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) ($Kind.Term.lam f5 (lambda (x$13) ($Kind.Term.check.expand.cse.argument name$0 f4 type$2 body$3 defs$4)))))))))))))))))) ('Kind.Term.ope (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((self3 wyth$1)) (case (get self3 0) ('List.nil body$3) ('List.cons (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((self5 f3)) (case (get self5 0) ('Kind.Ann.new (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) ($Kind.Term.lam f5 (lambda (x$13) ($Kind.Term.check.expand.cse.argument name$0 f4 type$2 body$3 defs$4)))))))))))))))))) ('Kind.Term.ori (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((self2 wyth$1)) (case (get self2 0) ('List.nil body$3) ('List.cons (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((self4 f2)) (case (get self4 0) ('Kind.Ann.new (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((f6 (get self4 3))) ($Kind.Term.lam f4 (lambda (x$12) ($Kind.Term.check.expand.cse.argument name$0 f3 type$2 body$3 defs$4))))))))))))))))))))
(define Kind.Term.check.expand.cse.argument (lambda (name$0) (lambda (wyth$1) (lambda (type$2) (lambda (body$3) (lambda (defs$4) ($Kind.Term.check.expand.cse.argument name$0 wyth$1 type$2 body$3 defs$4)))))))
(define ($Maybe.or a$1 b$2) (let ((self0 a$1)) (case (get self0 0) ('Maybe.none b$2) ('Maybe.some (let ((f0 (get self0 1))) ($Maybe.some f0))))))
(define Maybe.or (lambda (a$1) (lambda (b$2) ($Maybe.or a$1 b$2))))
(define ($Kind.Term.check.expand.cse.cases expr$0 name$1 wyth$2 cses$3 type$4 defs$5 ctxt$6) (let ((self0 ($Kind.Term.reduce type$4 defs$5))) (case (get self0 0) ('Kind.Term.var (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((expr$9 ($List.for wyth$2 expr$0 (lambda (defn$9) (lambda (expr$10) ($Kind.Term.app expr$10 (let ((self4 defn$9)) (case (get self4 0) ('Kind.Ann.new (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((f6 (get self4 3))) f5)))))))))))) expr$9)))) ('Kind.Term.ref (let ((f0 (get self0 1))) (let ((expr$8 ($List.for wyth$2 expr$0 (lambda (defn$8) (lambda (expr$9) ($Kind.Term.app expr$9 (let ((self3 defn$8)) (case (get self3 0) ('Kind.Ann.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) f4)))))))))))) expr$8))) ('Kind.Term.typ (let ((expr$7 ($List.for wyth$2 expr$0 (lambda (defn$7) (lambda (expr$8) ($Kind.Term.app expr$8 (let ((self2 defn$7)) (case (get self2 0) ('Kind.Ann.new (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) f3)))))))))))) expr$7)) ('Kind.Term.all (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((argm$12 ($Maybe.or ($Kind.Map.get f2 cses$3) ($Kind.Map.get "_" cses$3)))) (let ((argm$13 ($Maybe.default argm$12 ($Kind.Term.ref ($String.concat name$1 ($String.concat "_" ($String.concat f2 "_case"))))))) (let ((argm$14 ($Kind.Term.check.expand.cse.argument name$1 wyth$2 f3 argm$13 defs$5))) (let ((expr$15 ($Kind.Term.app expr$0 argm$14))) (let ((type$16 ((f4 ($Kind.Term.var f1 0)) ($Kind.Term.var f2 0)))) ($Kind.Term.check.expand.cse.cases expr$15 name$1 wyth$2 cses$3 type$16 defs$5 ctxt$6)))))))))))) ('Kind.Term.lam (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((expr$9 ($List.for wyth$2 expr$0 (lambda (defn$9) (lambda (expr$10) ($Kind.Term.app expr$10 (let ((self4 defn$9)) (case (get self4 0) ('Kind.Ann.new (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((f6 (get self4 3))) f5)))))))))))) expr$9)))) ('Kind.Term.app (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((expr$9 ($List.for wyth$2 expr$0 (lambda (defn$9) (lambda (expr$10) ($Kind.Term.app expr$10 (let ((self4 defn$9)) (case (get self4 0) ('Kind.Ann.new (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((f6 (get self4 3))) f5)))))))))))) expr$9)))) ('Kind.Term.let (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((expr$10 ($List.for wyth$2 expr$0 (lambda (defn$10) (lambda (expr$11) ($Kind.Term.app expr$11 (let ((self5 defn$10)) (case (get self5 0) ('Kind.Ann.new (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) f6)))))))))))) expr$10))))) ('Kind.Term.def (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((expr$10 ($List.for wyth$2 expr$0 (lambda (defn$10) (lambda (expr$11) ($Kind.Term.app expr$11 (let ((self5 defn$10)) (case (get self5 0) ('Kind.Ann.new (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) f6)))))))))))) expr$10))))) ('Kind.Term.ann (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((expr$10 ($List.for wyth$2 expr$0 (lambda (defn$10) (lambda (expr$11) ($Kind.Term.app expr$11 (let ((self5 defn$10)) (case (get self5 0) ('Kind.Ann.new (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) f6)))))))))))) expr$10))))) ('Kind.Term.gol (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((expr$10 ($List.for wyth$2 expr$0 (lambda (defn$10) (lambda (expr$11) ($Kind.Term.app expr$11 (let ((self5 defn$10)) (case (get self5 0) ('Kind.Ann.new (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) f6)))))))))))) expr$10))))) ('Kind.Term.hol (let ((f0 (get self0 1))) (let ((expr$8 ($List.for wyth$2 expr$0 (lambda (defn$8) (lambda (expr$9) ($Kind.Term.app expr$9 (let ((self3 defn$8)) (case (get self3 0) ('Kind.Ann.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) f4)))))))))))) expr$8))) ('Kind.Term.nat (let ((f0 (get self0 1))) (let ((expr$8 ($List.for wyth$2 expr$0 (lambda (defn$8) (lambda (expr$9) ($Kind.Term.app expr$9 (let ((self3 defn$8)) (case (get self3 0) ('Kind.Ann.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) f4)))))))))))) expr$8))) ('Kind.Term.chr (let ((f0 (get self0 1))) (let ((expr$8 ($List.for wyth$2 expr$0 (lambda (defn$8) (lambda (expr$9) ($Kind.Term.app expr$9 (let ((self3 defn$8)) (case (get self3 0) ('Kind.Ann.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) f4)))))))))))) expr$8))) ('Kind.Term.str (let ((f0 (get self0 1))) (let ((expr$8 ($List.for wyth$2 expr$0 (lambda (defn$8) (lambda (expr$9) ($Kind.Term.app expr$9 (let ((self3 defn$8)) (case (get self3 0) ('Kind.Ann.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) f4)))))))))))) expr$8))) ('Kind.Term.num (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((expr$10 ($List.for wyth$2 expr$0 (lambda (defn$10) (lambda (expr$11) ($Kind.Term.app expr$11 (let ((self5 defn$10)) (case (get self5 0) ('Kind.Ann.new (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) f6)))))))))))) expr$10))))) ('Kind.Term.cse (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((f5 (get self0 6))) (let ((expr$13 ($List.for wyth$2 expr$0 (lambda (defn$13) (lambda (expr$14) ($Kind.Term.app expr$14 (let ((self8 defn$13)) (case (get self8 0) ('Kind.Ann.new (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) f9)))))))))))) expr$13)))))))) ('Kind.Term.new (let ((f0 (get self0 1))) (let ((expr$8 ($List.for wyth$2 expr$0 (lambda (defn$8) (lambda (expr$9) ($Kind.Term.app expr$9 (let ((self3 defn$8)) (case (get self3 0) ('Kind.Ann.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) f4)))))))))))) expr$8))) ('Kind.Term.get (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((expr$9 ($List.for wyth$2 expr$0 (lambda (defn$9) (lambda (expr$10) ($Kind.Term.app expr$10 (let ((self4 defn$9)) (case (get self4 0) ('Kind.Ann.new (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((f6 (get self4 3))) f5)))))))))))) expr$9)))) ('Kind.Term.set (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((expr$10 ($List.for wyth$2 expr$0 (lambda (defn$10) (lambda (expr$11) ($Kind.Term.app expr$11 (let ((self5 defn$10)) (case (get self5 0) ('Kind.Ann.new (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) f6)))))))))))) expr$10))))) ('Kind.Term.ope (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((expr$10 ($List.for wyth$2 expr$0 (lambda (defn$10) (lambda (expr$11) ($Kind.Term.app expr$11 (let ((self5 defn$10)) (case (get self5 0) ('Kind.Ann.new (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) f6)))))))))))) expr$10))))) ('Kind.Term.ori (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((expr$9 ($List.for wyth$2 expr$0 (lambda (defn$9) (lambda (expr$10) ($Kind.Term.app expr$10 (let ((self4 defn$9)) (case (get self4 0) ('Kind.Ann.new (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((f6 (get self4 3))) f5)))))))))))) expr$9)))))))
(define Kind.Term.check.expand.cse.cases (lambda (expr$0) (lambda (name$1) (lambda (wyth$2) (lambda (cses$3) (lambda (type$4) (lambda (defs$5) (lambda (ctxt$6) ($Kind.Term.check.expand.cse.cases expr$0 name$1 wyth$2 cses$3 type$4 defs$5 ctxt$6)))))))))
(define ($Kind.Term.check.expand.cse expr$0 name$1 wyth$2 cses$3 moti$4 etyp$5 rtyp$6 defs$7 ctxt$8) (let ((self0 ($Kind.Term.reduce etyp$5 defs$7))) (case (get self0 0) ('Kind.Term.var (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) Maybe.none))) ('Kind.Term.ref (let ((f0 (get self0 1))) Maybe.none)) ('Kind.Term.typ Maybe.none) ('Kind.Term.all (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((moti$14 ($Kind.Term.check.expand.cse.motive wyth$2 moti$4 name$1 expr$0 etyp$5 rtyp$6 defs$7 ($List.length ctxt$8)))) (let ((argm$15 ($Kind.Term.check.expand.cse.argument name$1 List.nil f3 moti$14 defs$7))) (let ((expr$16 ($Kind.Term.app expr$0 argm$15))) (let ((type$17 ((f4 ($Kind.Term.var f1 0)) ($Kind.Term.var f2 0)))) ($Maybe.some ($Kind.Term.check.expand.cse.cases expr$16 name$1 wyth$2 cses$3 type$17 defs$7 ctxt$8)))))))))))) ('Kind.Term.lam (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) Maybe.none))) ('Kind.Term.app (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) Maybe.none))) ('Kind.Term.let (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) Maybe.none)))) ('Kind.Term.def (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) Maybe.none)))) ('Kind.Term.ann (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) Maybe.none)))) ('Kind.Term.gol (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) Maybe.none)))) ('Kind.Term.hol (let ((f0 (get self0 1))) Maybe.none)) ('Kind.Term.nat (let ((f0 (get self0 1))) Maybe.none)) ('Kind.Term.chr (let ((f0 (get self0 1))) Maybe.none)) ('Kind.Term.str (let ((f0 (get self0 1))) Maybe.none)) ('Kind.Term.num (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) Maybe.none)))) ('Kind.Term.cse (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((f5 (get self0 6))) Maybe.none))))))) ('Kind.Term.new (let ((f0 (get self0 1))) Maybe.none)) ('Kind.Term.get (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) Maybe.none))) ('Kind.Term.set (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) Maybe.none)))) ('Kind.Term.ope (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) Maybe.none)))) ('Kind.Term.ori (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) Maybe.none))))))
(define Kind.Term.check.expand.cse (lambda (expr$0) (lambda (name$1) (lambda (wyth$2) (lambda (cses$3) (lambda (moti$4) (lambda (etyp$5) (lambda (rtyp$6) (lambda (defs$7) (lambda (ctxt$8) ($Kind.Term.check.expand.cse expr$0 name$1 wyth$2 cses$3 moti$4 etyp$5 rtyp$6 defs$7 ctxt$8)))))))))))
(define ($Kind.Error.cant_infer origin$0 term$1 context$2) (vector 'Kind.Error.cant_infer origin$0 term$1 context$2))
(define Kind.Error.cant_infer (lambda (origin$0) (lambda (term$1) (lambda (context$2) ($Kind.Error.cant_infer origin$0 term$1 context$2)))))
(define ($Kind.Term.check.cant_infer term$0 type$1 ctx$2 orig$3) ($Kind.Check.result type$1 ($List.cons ($Kind.Error.cant_infer orig$3 term$0 ctx$2) List.nil)))
(define Kind.Term.check.cant_infer (lambda (term$0) (lambda (type$1) (lambda (ctx$2) (lambda (orig$3) ($Kind.Term.check.cant_infer term$0 type$1 ctx$2 orig$3))))))
(define ($Kind.Term.get_bnds term$0 depth$1) (let ((self0 term$0)) (case (get self0 0) ('Kind.Term.var (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($Pair.new List.nil term$0)))) ('Kind.Term.ref (let ((f0 (get self0 1))) ($Pair.new List.nil term$0))) ('Kind.Term.typ ($Pair.new List.nil term$0)) ('Kind.Term.all (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((b$7 ((f4 ($Kind.Term.var f1 depth$1)) ($Kind.Term.var f2 ($Nat.succ depth$1))))) (let ((self6 ($Kind.Term.get_bnds b$7 ($Nat.succ ($Nat.succ depth$1))))) (case (get self6 0) ('Pair.new (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) ($Pair.new ($List.cons ($Pair.new f2 f3) f6) f7))))))))))))) ('Kind.Term.lam (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($Pair.new List.nil term$0)))) ('Kind.Term.app (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($Pair.new List.nil term$0)))) ('Kind.Term.let (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) ($Pair.new List.nil term$0))))) ('Kind.Term.def (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) ($Pair.new List.nil term$0))))) ('Kind.Term.ann (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) ($Pair.new List.nil term$0))))) ('Kind.Term.gol (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) ($Pair.new List.nil term$0))))) ('Kind.Term.hol (let ((f0 (get self0 1))) ($Pair.new List.nil term$0))) ('Kind.Term.nat (let ((f0 (get self0 1))) ($Pair.new List.nil term$0))) ('Kind.Term.chr (let ((f0 (get self0 1))) ($Pair.new List.nil term$0))) ('Kind.Term.str (let ((f0 (get self0 1))) ($Pair.new List.nil term$0))) ('Kind.Term.num (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) ($Pair.new List.nil term$0))))) ('Kind.Term.cse (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((f5 (get self0 6))) ($Pair.new List.nil term$0)))))))) ('Kind.Term.new (let ((f0 (get self0 1))) ($Pair.new List.nil term$0))) ('Kind.Term.get (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($Pair.new List.nil term$0)))) ('Kind.Term.set (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) ($Pair.new List.nil term$0))))) ('Kind.Term.ope (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) ($Pair.new List.nil term$0))))) ('Kind.Term.ori (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($Pair.new List.nil term$0)))))))
(define Kind.Term.get_bnds (lambda (term$0) (lambda (depth$1) ($Kind.Term.get_bnds term$0 depth$1))))
(define ($List.last.go xs$1 last$2) (let ((self0 xs$1)) (case (get self0 0) ('List.nil last$2) ('List.cons (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($List.last.go f1 ($Maybe.some f0))))))))
(define List.last.go (lambda (xs$1) (lambda (last$2) ($List.last.go xs$1 last$2))))
(define ($List.last xs$1) ($List.last.go xs$1 Maybe.none))
(define List.last (lambda (xs$1) ($List.last xs$1)))
(define ($Kind.Term.check.expand.set.count_params xtyp$0) (let ((self0 ($Kind.Term.get_bnds xtyp$0 0))) (case (get self0 0) ('Pair.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((self2 ($Kind.Term.get_args ($Pair.snd ($Maybe.default ($List.last f0) ($Pair.new "" Kind.Term.typ)))))) (case (get self2 0) ('Pair.new (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((indexs$5 ($Nat.pred ($List.length f0)))) (let ((params$6 ($Nat.sub ($List.length f3) indexs$5))) params$6)))))))))))))
(define Kind.Term.check.expand.set.count_params (lambda (xtyp$0) ($Kind.Term.check.expand.set.count_params xtyp$0)))
(define ($Nat.for state$1 from$2 til$3 func$4) (let ((self0 ($Nat.eql from$2 til$3))) (case self0 (#t state$1) (#f ($Nat.for ((func$4 from$2) state$1) ($Nat.succ from$2) til$3 func$4)))))
(define Nat.for (lambda (state$1) (lambda (from$2) (lambda (til$3) (lambda (func$4) ($Nat.for state$1 from$2 til$3 func$4))))))
(define ($List.get index$1 list$2) (let ((self0 list$2)) (case (get self0 0) ('List.nil Maybe.none) ('List.cons (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((self2 index$1)) (case (= self2 0) (#t ($Maybe.some f0)) (#f (let ((f2 (- self2 1))) ($List.get f2 f1)))))))))))
(define List.get (lambda (index$1) (lambda (list$2) ($List.get index$1 list$2))))
(define ($Kind.Term.check.expand.new.pair args$0 type$1 defs$2) (let ((self0 ($Nat.eql ($List.length args$0) 2))) (case self0 (#t (let ((term$3 ($Kind.Term.ref "Pair.new"))) (let ((term$4 ($Kind.Term.app term$3 ($Kind.Term.hol Bits.e)))) (let ((term$5 ($Kind.Term.app term$4 ($Kind.Term.hol Bits.e)))) (let ((term$6 ($Kind.Term.app term$5 ($Maybe.default ($List.get 0 args$0) ($Kind.Term.ref "pair_fst"))))) (let ((term$7 ($Kind.Term.app term$6 ($Maybe.default ($List.get 1 args$0) ($Kind.Term.ref "pair_snd"))))) ($Maybe.some term$7))))))) (#f Maybe.none))))
(define Kind.Term.check.expand.new.pair (lambda (args$0) (lambda (type$1) (lambda (defs$2) ($Kind.Term.check.expand.new.pair args$0 type$1 defs$2)))))
(define ($Kind.Term.check.expand.new args$0 type$1 defs$2) (let ((got$3 (let ((self0 type$1)) (case (get self0 0) ('Maybe.none Maybe.none) ('Maybe.some (let ((f0 (get self0 1))) (let ((self1 ($Kind.Term.reduce f0 defs$2))) (case (get self1 0) ('Kind.Term.var (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) Maybe.none))) ('Kind.Term.ref (let ((f1 (get self1 1))) Maybe.none)) ('Kind.Term.typ Maybe.none) ('Kind.Term.all (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((self6 ($Kind.Term.reduce ((f5 Kind.Term.typ) Kind.Term.typ) defs$2))) (case (get self6 0) ('Kind.Term.var (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) Maybe.none))) ('Kind.Term.ref (let ((f6 (get self6 1))) Maybe.none)) ('Kind.Term.typ Maybe.none) ('Kind.Term.all (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((f8 (get self6 3))) (let ((f9 (get self6 4))) (let ((f10 (get self6 5))) (let ((tnam$14 ($Maybe.default ($Kind.Term.check.get_name_of_self_type.slice f2) ""))) (let ((term$15 ($Kind.Term.ref ($String.concat tnam$14 ($String.concat "." f8))))) (let ((pars$16 ($Kind.Term.check.expand.set.count_params f4))) (let ((term$17 ($Nat.for term$15 0 pars$16 (lambda (i$17) (lambda (term$18) ($Kind.Term.app term$18 ($Kind.Term.hol Bits.e))))))) (let ((term$18 ($List.for args$0 term$17 (lambda (arg$18) (lambda (term$19) ($Kind.Term.app term$19 arg$18)))))) ($Maybe.some term$18)))))))))))) ('Kind.Term.lam (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) Maybe.none))) ('Kind.Term.app (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) Maybe.none))) ('Kind.Term.let (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((f8 (get self6 3))) Maybe.none)))) ('Kind.Term.def (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((f8 (get self6 3))) Maybe.none)))) ('Kind.Term.ann (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((f8 (get self6 3))) Maybe.none)))) ('Kind.Term.gol (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((f8 (get self6 3))) Maybe.none)))) ('Kind.Term.hol (let ((f6 (get self6 1))) Maybe.none)) ('Kind.Term.nat (let ((f6 (get self6 1))) Maybe.none)) ('Kind.Term.chr (let ((f6 (get self6 1))) Maybe.none)) ('Kind.Term.str (let ((f6 (get self6 1))) Maybe.none)) ('Kind.Term.num (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((f8 (get self6 3))) Maybe.none)))) ('Kind.Term.cse (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((f8 (get self6 3))) (let ((f9 (get self6 4))) (let ((f10 (get self6 5))) (let ((f11 (get self6 6))) Maybe.none))))))) ('Kind.Term.new (let ((f6 (get self6 1))) Maybe.none)) ('Kind.Term.get (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) Maybe.none))) ('Kind.Term.set (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((f8 (get self6 3))) Maybe.none)))) ('Kind.Term.ope (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((f8 (get self6 3))) Maybe.none)))) ('Kind.Term.ori (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) Maybe.none))))))))))) ('Kind.Term.lam (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) Maybe.none))) ('Kind.Term.app (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) Maybe.none))) ('Kind.Term.let (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) Maybe.none)))) ('Kind.Term.def (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) Maybe.none)))) ('Kind.Term.ann (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) Maybe.none)))) ('Kind.Term.gol (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) Maybe.none)))) ('Kind.Term.hol (let ((f1 (get self1 1))) Maybe.none)) ('Kind.Term.nat (let ((f1 (get self1 1))) Maybe.none)) ('Kind.Term.chr (let ((f1 (get self1 1))) Maybe.none)) ('Kind.Term.str (let ((f1 (get self1 1))) Maybe.none)) ('Kind.Term.num (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) Maybe.none)))) ('Kind.Term.cse (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((f6 (get self1 6))) Maybe.none))))))) ('Kind.Term.new (let ((f1 (get self1 1))) Maybe.none)) ('Kind.Term.get (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) Maybe.none))) ('Kind.Term.set (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) Maybe.none)))) ('Kind.Term.ope (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) Maybe.none)))) ('Kind.Term.ori (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) Maybe.none))))))))))) (let ((self1 got$3)) (case (get self1 0) ('Maybe.none ($Kind.Term.check.expand.new.pair args$0 type$1 defs$2)) ('Maybe.some (let ((f1 (get self1 1))) ($Maybe.some f1)))))))
(define Kind.Term.check.expand.new (lambda (args$0) (lambda (type$1) (lambda (defs$2) ($Kind.Term.check.expand.new args$0 type$1 defs$2)))))
(define ($Kind.Term.check.expand.get.selector fkey$0 ctor$1 defs$2 rett$3) (let ((self0 ($Kind.Term.reduce ctor$1 defs$2))) (case (get self0 0) ('Kind.Term.var (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) rett$3))) ('Kind.Term.ref (let ((f0 (get self0 1))) rett$3)) ('Kind.Term.typ rett$3) ('Kind.Term.all (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) ($Kind.Term.lam f2 (lambda (x$9) (let ((body$10 ((f4 Kind.Term.typ) Kind.Term.typ))) (let ((rett$11 (let ((self7 ($String.eql f2 fkey$0))) (case self7 (#t x$9) (#f rett$3))))) ($Kind.Term.check.expand.get.selector fkey$0 body$10 defs$2 rett$11))))))))))) ('Kind.Term.lam (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) rett$3))) ('Kind.Term.app (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) rett$3))) ('Kind.Term.let (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) rett$3)))) ('Kind.Term.def (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) rett$3)))) ('Kind.Term.ann (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) rett$3)))) ('Kind.Term.gol (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) rett$3)))) ('Kind.Term.hol (let ((f0 (get self0 1))) rett$3)) ('Kind.Term.nat (let ((f0 (get self0 1))) rett$3)) ('Kind.Term.chr (let ((f0 (get self0 1))) rett$3)) ('Kind.Term.str (let ((f0 (get self0 1))) rett$3)) ('Kind.Term.num (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) rett$3)))) ('Kind.Term.cse (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((f5 (get self0 6))) rett$3))))))) ('Kind.Term.new (let ((f0 (get self0 1))) rett$3)) ('Kind.Term.get (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) rett$3))) ('Kind.Term.set (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) rett$3)))) ('Kind.Term.ope (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) rett$3)))) ('Kind.Term.ori (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) rett$3))))))
(define Kind.Term.check.expand.get.selector (lambda (fkey$0) (lambda (ctor$1) (lambda (defs$2) (lambda (rett$3) ($Kind.Term.check.expand.get.selector fkey$0 ctor$1 defs$2 rett$3))))))
(define ($Kind.Term.check.expand.get expr$0 fkey$1 etyp$2 defs$3) (let ((self0 ($Kind.Term.reduce etyp$2 defs$3))) (case (get self0 0) ('Kind.Term.var (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) Maybe.none))) ('Kind.Term.ref (let ((f0 (get self0 1))) Maybe.none)) ('Kind.Term.typ Maybe.none) ('Kind.Term.all (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((self5 ($Kind.Term.reduce ((f4 Kind.Term.typ) Kind.Term.typ) defs$3))) (case (get self5 0) ('Kind.Term.var (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) Maybe.none))) ('Kind.Term.ref (let ((f5 (get self5 1))) Maybe.none)) ('Kind.Term.typ Maybe.none) ('Kind.Term.all (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) (let ((f8 (get self5 4))) (let ((f9 (get self5 5))) (let ((term$14 ($Kind.Term.app expr$0 ($Kind.Term.lam "" (lambda ($14) ($Kind.Term.hol Bits.e)))))) (let ((rett$15 ($Kind.Term.ref ($String.concat fkey$1 "_field")))) (let ((sele$16 ($Kind.Term.check.expand.get.selector fkey$1 f8 defs$3 rett$15))) ($Maybe.some ($Kind.Term.app term$14 sele$16))))))))))) ('Kind.Term.lam (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) Maybe.none))) ('Kind.Term.app (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) Maybe.none))) ('Kind.Term.let (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) Maybe.none)))) ('Kind.Term.def (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) Maybe.none)))) ('Kind.Term.ann (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) Maybe.none)))) ('Kind.Term.gol (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) Maybe.none)))) ('Kind.Term.hol (let ((f5 (get self5 1))) Maybe.none)) ('Kind.Term.nat (let ((f5 (get self5 1))) Maybe.none)) ('Kind.Term.chr (let ((f5 (get self5 1))) Maybe.none)) ('Kind.Term.str (let ((f5 (get self5 1))) Maybe.none)) ('Kind.Term.num (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) Maybe.none)))) ('Kind.Term.cse (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) (let ((f8 (get self5 4))) (let ((f9 (get self5 5))) (let ((f10 (get self5 6))) Maybe.none))))))) ('Kind.Term.new (let ((f5 (get self5 1))) Maybe.none)) ('Kind.Term.get (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) Maybe.none))) ('Kind.Term.set (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) Maybe.none)))) ('Kind.Term.ope (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) Maybe.none)))) ('Kind.Term.ori (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) Maybe.none))))))))))) ('Kind.Term.lam (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) Maybe.none))) ('Kind.Term.app (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) Maybe.none))) ('Kind.Term.let (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) Maybe.none)))) ('Kind.Term.def (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) Maybe.none)))) ('Kind.Term.ann (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) Maybe.none)))) ('Kind.Term.gol (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) Maybe.none)))) ('Kind.Term.hol (let ((f0 (get self0 1))) Maybe.none)) ('Kind.Term.nat (let ((f0 (get self0 1))) Maybe.none)) ('Kind.Term.chr (let ((f0 (get self0 1))) Maybe.none)) ('Kind.Term.str (let ((f0 (get self0 1))) Maybe.none)) ('Kind.Term.num (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) Maybe.none)))) ('Kind.Term.cse (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((f5 (get self0 6))) Maybe.none))))))) ('Kind.Term.new (let ((f0 (get self0 1))) Maybe.none)) ('Kind.Term.get (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) Maybe.none))) ('Kind.Term.set (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) Maybe.none)))) ('Kind.Term.ope (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) Maybe.none)))) ('Kind.Term.ori (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) Maybe.none))))))
(define Kind.Term.check.expand.get (lambda (expr$0) (lambda (fkey$1) (lambda (etyp$2) (lambda (defs$3) ($Kind.Term.check.expand.get expr$0 fkey$1 etyp$2 defs$3))))))
(define ($Kind.Term.check.expand.set.selector fkey$0 fval$1 ctor$2 defs$3 rett$4) (let ((self0 ($Kind.Term.reduce ctor$2 defs$3))) (case (get self0 0) ('Kind.Term.var (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) rett$4))) ('Kind.Term.ref (let ((f0 (get self0 1))) rett$4)) ('Kind.Term.typ rett$4) ('Kind.Term.all (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) ($Kind.Term.lam f2 (lambda (x$10) (let ((body$11 ((f4 Kind.Term.typ) Kind.Term.typ))) (let ((rett$12 ($Kind.Term.app rett$4 (let ((self7 ($String.eql f2 fkey$0))) (case self7 (#t fval$1) (#f x$10)))))) ($Kind.Term.check.expand.set.selector fkey$0 fval$1 body$11 defs$3 rett$12))))))))))) ('Kind.Term.lam (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) rett$4))) ('Kind.Term.app (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) rett$4))) ('Kind.Term.let (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) rett$4)))) ('Kind.Term.def (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) rett$4)))) ('Kind.Term.ann (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) rett$4)))) ('Kind.Term.gol (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) rett$4)))) ('Kind.Term.hol (let ((f0 (get self0 1))) rett$4)) ('Kind.Term.nat (let ((f0 (get self0 1))) rett$4)) ('Kind.Term.chr (let ((f0 (get self0 1))) rett$4)) ('Kind.Term.str (let ((f0 (get self0 1))) rett$4)) ('Kind.Term.num (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) rett$4)))) ('Kind.Term.cse (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((f5 (get self0 6))) rett$4))))))) ('Kind.Term.new (let ((f0 (get self0 1))) rett$4)) ('Kind.Term.get (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) rett$4))) ('Kind.Term.set (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) rett$4)))) ('Kind.Term.ope (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) rett$4)))) ('Kind.Term.ori (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) rett$4))))))
(define Kind.Term.check.expand.set.selector (lambda (fkey$0) (lambda (fval$1) (lambda (ctor$2) (lambda (defs$3) (lambda (rett$4) ($Kind.Term.check.expand.set.selector fkey$0 fval$1 ctor$2 defs$3 rett$4)))))))
(define ($Kind.Term.check.expand.set expr$0 fkey$1 fval$2 etyp$3 defs$4) (let ((self0 ($Kind.Term.reduce etyp$3 defs$4))) (case (get self0 0) ('Kind.Term.var (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) Maybe.none))) ('Kind.Term.ref (let ((f0 (get self0 1))) Maybe.none)) ('Kind.Term.typ Maybe.none) ('Kind.Term.all (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((self5 ($Kind.Term.reduce ((f4 Kind.Term.typ) Kind.Term.typ) defs$4))) (case (get self5 0) ('Kind.Term.var (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) Maybe.none))) ('Kind.Term.ref (let ((f5 (get self5 1))) Maybe.none)) ('Kind.Term.typ Maybe.none) ('Kind.Term.all (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) (let ((f8 (get self5 4))) (let ((f9 (get self5 5))) (let ((term$15 ($Kind.Term.app expr$0 ($Kind.Term.lam "" (lambda ($15) ($Kind.Term.hol Bits.e)))))) (let ((tnam$16 ($Maybe.default ($Kind.Term.check.get_name_of_self_type.slice f1) ""))) (let ((rett$17 ($Kind.Term.ref ($String.concat tnam$16 ($String.concat "." f7))))) (let ((pars$18 ($Kind.Term.check.expand.set.count_params f3))) (let ((rett$19 ($Nat.for rett$17 0 pars$18 (lambda (i$19) (lambda (rett$20) ($Kind.Term.app rett$20 ($Kind.Term.hol Bits.e))))))) (let ((sele$20 ($Kind.Term.check.expand.set.selector fkey$1 fval$2 f8 defs$4 rett$19))) ($Maybe.some ($Kind.Term.app term$15 sele$20)))))))))))))) ('Kind.Term.lam (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) Maybe.none))) ('Kind.Term.app (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) Maybe.none))) ('Kind.Term.let (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) Maybe.none)))) ('Kind.Term.def (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) Maybe.none)))) ('Kind.Term.ann (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) Maybe.none)))) ('Kind.Term.gol (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) Maybe.none)))) ('Kind.Term.hol (let ((f5 (get self5 1))) Maybe.none)) ('Kind.Term.nat (let ((f5 (get self5 1))) Maybe.none)) ('Kind.Term.chr (let ((f5 (get self5 1))) Maybe.none)) ('Kind.Term.str (let ((f5 (get self5 1))) Maybe.none)) ('Kind.Term.num (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) Maybe.none)))) ('Kind.Term.cse (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) (let ((f8 (get self5 4))) (let ((f9 (get self5 5))) (let ((f10 (get self5 6))) Maybe.none))))))) ('Kind.Term.new (let ((f5 (get self5 1))) Maybe.none)) ('Kind.Term.get (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) Maybe.none))) ('Kind.Term.set (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) Maybe.none)))) ('Kind.Term.ope (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) Maybe.none)))) ('Kind.Term.ori (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) Maybe.none))))))))))) ('Kind.Term.lam (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) Maybe.none))) ('Kind.Term.app (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) Maybe.none))) ('Kind.Term.let (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) Maybe.none)))) ('Kind.Term.def (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) Maybe.none)))) ('Kind.Term.ann (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) Maybe.none)))) ('Kind.Term.gol (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) Maybe.none)))) ('Kind.Term.hol (let ((f0 (get self0 1))) Maybe.none)) ('Kind.Term.nat (let ((f0 (get self0 1))) Maybe.none)) ('Kind.Term.chr (let ((f0 (get self0 1))) Maybe.none)) ('Kind.Term.str (let ((f0 (get self0 1))) Maybe.none)) ('Kind.Term.num (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) Maybe.none)))) ('Kind.Term.cse (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((f5 (get self0 6))) Maybe.none))))))) ('Kind.Term.new (let ((f0 (get self0 1))) Maybe.none)) ('Kind.Term.get (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) Maybe.none))) ('Kind.Term.set (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) Maybe.none)))) ('Kind.Term.ope (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) Maybe.none)))) ('Kind.Term.ori (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) Maybe.none))))))
(define Kind.Term.check.expand.set (lambda (expr$0) (lambda (fkey$1) (lambda (fval$2) (lambda (etyp$3) (lambda (defs$4) ($Kind.Term.check.expand.set expr$0 fkey$1 fval$2 etyp$3 defs$4)))))))
(define ($String.at index$0 str$1) (let ((self0 str$1)) (case (<= (kstring-length self0) 0) (#t Maybe.none) (#f (let ((f0 (char->integer (kstring-head self0)))) (let ((f1 (kstring-tail self0))) (let ((self2 index$0)) (case (= self2 0) (#t ($Maybe.some f0)) (#f (let ((f2 (- self2 1))) ($String.at f2 f1)))))))))))
(define String.at (lambda (index$0) (lambda (str$1) ($String.at index$0 str$1))))
(define ($String.last xs$0) ($String.at ($Nat.pred ($String.length xs$0)) xs$0))
(define String.last (lambda (xs$0) ($String.last xs$0)))
(define ($Kind.Term.check.expand.ope skip_cmp$0 oper$1 arg0$2 arg1$3 otyp$4 defs$5) (let ((self0 ($Bool.and ($U16.eql ($Maybe.default ($String.last oper$1) 120) 63) skip_cmp$0))) (case self0 (#t Maybe.none) (#f (let ((type_name$6 ($Kind.Term.check.get_name_of_self_type otyp$4 defs$5))) (let ((self1 type_name$6)) (case (get self1 0) ('Maybe.none Maybe.none) ('Maybe.some (let ((f1 (get self1 1))) (let ((oper_name$8 (let ((self2 ($String.eql oper$1 "+"))) (case self2 (#t ($Maybe.some "add")) (#f (let ((self2 ($String.eql oper$1 "-"))) (case self2 (#t ($Maybe.some "sub")) (#f (let ((self2 ($String.eql oper$1 "*"))) (case self2 (#t ($Maybe.some "mul")) (#f (let ((self2 ($String.eql oper$1 "/"))) (case self2 (#t ($Maybe.some "div")) (#f (let ((self2 ($String.eql oper$1 "**"))) (case self2 (#t ($Maybe.some "pow")) (#f (let ((self2 ($String.eql oper$1 "%"))) (case self2 (#t ($Maybe.some "mod")) (#f (let ((self2 ($String.eql oper$1 "<?"))) (case self2 (#t ($Maybe.some "ltn")) (#f (let ((self2 ($String.eql oper$1 "<=?"))) (case self2 (#t ($Maybe.some "lte")) (#f (let ((self2 ($String.eql oper$1 "=?"))) (case self2 (#t ($Maybe.some "eql")) (#f (let ((self2 ($String.eql oper$1 ">=?"))) (case self2 (#t ($Maybe.some "gte")) (#f (let ((self2 ($String.eql oper$1 ">?"))) (case self2 (#t ($Maybe.some "gtn")) (#f (let ((self2 ($String.eql oper$1 "&&"))) (case self2 (#t ($Maybe.some "and")) (#f (let ((self2 ($String.eql oper$1 "||"))) (case self2 (#t ($Maybe.some "or")) (#f Maybe.none))))))))))))))))))))))))))))))))))))))))) (let ((self3 oper_name$8)) (case (get self3 0) ('Maybe.none Maybe.none) ('Maybe.some (let ((f3 (get self3 1))) (let ((term$10 ($Kind.Term.ref ($String.concat f1 ($String.concat "." f3))))) (let ((term$11 ($Kind.Term.app term$10 arg0$2))) (let ((term$12 ($Kind.Term.app term$11 arg1$3))) ($Maybe.some term$12))))))))))))))))))
(define Kind.Term.check.expand.ope (lambda (skip_cmp$0) (lambda (oper$1) (lambda (arg0$2) (lambda (arg1$3) (lambda (otyp$4) (lambda (defs$5) ($Kind.Term.check.expand.ope skip_cmp$0 oper$1 arg0$2 arg1$3 otyp$4 defs$5))))))))
(define ($BitsSet.has bits$0 set$1) (let ((self0 ($BitsMap.get bits$0 set$1))) (case (get self0 0) ('Maybe.none Bool.false) ('Maybe.some (let ((f0 (get self0 1))) Bool.true)))))
(define BitsSet.has (lambda (bits$0) (lambda (set$1) ($BitsSet.has bits$0 set$1))))
(define ($BitsSet.mut.has bits$0 set$1) ($BitsSet.has bits$0 set$1))
(define BitsSet.mut.has (lambda (bits$0) (lambda (set$1) ($BitsSet.mut.has bits$0 set$1))))
(define ($Kind.Term.equal.extra_holes.funari term$0 arity$1) (let ((self0 term$0)) (case (get self0 0) ('Kind.Term.var (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($Maybe.some ($Pair.new f0 arity$1))))) ('Kind.Term.ref (let ((f0 (get self0 1))) ($Maybe.some ($Pair.new f0 arity$1)))) ('Kind.Term.typ Maybe.none) ('Kind.Term.all (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) Maybe.none)))))) ('Kind.Term.lam (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) Maybe.none))) ('Kind.Term.app (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($Kind.Term.equal.extra_holes.funari f0 ($Nat.succ arity$1))))) ('Kind.Term.let (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) Maybe.none)))) ('Kind.Term.def (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) Maybe.none)))) ('Kind.Term.ann (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) Maybe.none)))) ('Kind.Term.gol (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) Maybe.none)))) ('Kind.Term.hol (let ((f0 (get self0 1))) Maybe.none)) ('Kind.Term.nat (let ((f0 (get self0 1))) Maybe.none)) ('Kind.Term.chr (let ((f0 (get self0 1))) Maybe.none)) ('Kind.Term.str (let ((f0 (get self0 1))) Maybe.none)) ('Kind.Term.num (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) Maybe.none)))) ('Kind.Term.cse (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((f5 (get self0 6))) Maybe.none))))))) ('Kind.Term.new (let ((f0 (get self0 1))) Maybe.none)) ('Kind.Term.get (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) Maybe.none))) ('Kind.Term.set (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) Maybe.none)))) ('Kind.Term.ope (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) Maybe.none)))) ('Kind.Term.ori (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($Kind.Term.equal.extra_holes.funari f1 arity$1)))))))
(define Kind.Term.equal.extra_holes.funari (lambda (term$0) (lambda (arity$1) ($Kind.Term.equal.extra_holes.funari term$0 arity$1))))
(define ($Kind.Term.has_holes term$0) (let ((self0 term$0)) (case (get self0 0) ('Kind.Term.var (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) Bool.false))) ('Kind.Term.ref (let ((f0 (get self0 1))) Bool.false)) ('Kind.Term.typ Bool.false) ('Kind.Term.all (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) ($Bool.or ($Kind.Term.has_holes f3) ($Kind.Term.has_holes ((f4 Kind.Term.typ) Kind.Term.typ))))))))) ('Kind.Term.lam (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($Kind.Term.has_holes (f1 Kind.Term.typ))))) ('Kind.Term.app (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($Bool.or ($Kind.Term.has_holes f0) ($Kind.Term.has_holes f1))))) ('Kind.Term.let (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) ($Bool.or ($Kind.Term.has_holes f1) ($Kind.Term.has_holes (f2 Kind.Term.typ))))))) ('Kind.Term.def (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) ($Bool.or ($Kind.Term.has_holes f1) ($Kind.Term.has_holes (f2 Kind.Term.typ))))))) ('Kind.Term.ann (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) ($Bool.or ($Kind.Term.has_holes f1) ($Kind.Term.has_holes f2)))))) ('Kind.Term.gol (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) Bool.false)))) ('Kind.Term.hol (let ((f0 (get self0 1))) Bool.true)) ('Kind.Term.nat (let ((f0 (get self0 1))) Bool.false)) ('Kind.Term.chr (let ((f0 (get self0 1))) Bool.false)) ('Kind.Term.str (let ((f0 (get self0 1))) Bool.false)) ('Kind.Term.num (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) Bool.false)))) ('Kind.Term.cse (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((f5 (get self0 6))) Bool.false))))))) ('Kind.Term.new (let ((f0 (get self0 1))) Bool.false)) ('Kind.Term.get (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) Bool.false))) ('Kind.Term.set (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) Bool.false)))) ('Kind.Term.ope (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) Bool.false)))) ('Kind.Term.ori (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($Kind.Term.has_holes f1)))))))
(define Kind.Term.has_holes (lambda (term$0) ($Kind.Term.has_holes term$0)))
(define ($Kind.Term.equal.hole path$0 term$1) (let ((self0 term$1)) (case (get self0 0) ('Kind.Term.var (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((self2 ($Kind.Term.has_holes term$1))) (case self2 (#t ($Kind.Check.result ($Maybe.some Bool.true) List.nil)) (#f ($Kind.Check.result ($Maybe.some Bool.true) ($List.cons ($Kind.Error.patch path$0 ($Kind.Term.normalize term$1 Kind.Map.new)) List.nil)))))))) ('Kind.Term.ref (let ((f0 (get self0 1))) (let ((self1 ($Kind.Term.has_holes term$1))) (case self1 (#t ($Kind.Check.result ($Maybe.some Bool.true) List.nil)) (#f ($Kind.Check.result ($Maybe.some Bool.true) ($List.cons ($Kind.Error.patch path$0 ($Kind.Term.normalize term$1 Kind.Map.new)) List.nil))))))) ('Kind.Term.typ (let ((self0 ($Kind.Term.has_holes term$1))) (case self0 (#t ($Kind.Check.result ($Maybe.some Bool.true) List.nil)) (#f ($Kind.Check.result ($Maybe.some Bool.true) ($List.cons ($Kind.Error.patch path$0 ($Kind.Term.normalize term$1 Kind.Map.new)) List.nil)))))) ('Kind.Term.all (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((self5 ($Kind.Term.has_holes term$1))) (case self5 (#t ($Kind.Check.result ($Maybe.some Bool.true) List.nil)) (#f ($Kind.Check.result ($Maybe.some Bool.true) ($List.cons ($Kind.Error.patch path$0 ($Kind.Term.normalize term$1 Kind.Map.new)) List.nil))))))))))) ('Kind.Term.lam (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((self2 ($Kind.Term.has_holes term$1))) (case self2 (#t ($Kind.Check.result ($Maybe.some Bool.true) List.nil)) (#f ($Kind.Check.result ($Maybe.some Bool.true) ($List.cons ($Kind.Error.patch path$0 ($Kind.Term.normalize term$1 Kind.Map.new)) List.nil)))))))) ('Kind.Term.app (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((self2 ($Kind.Term.has_holes term$1))) (case self2 (#t ($Kind.Check.result ($Maybe.some Bool.true) List.nil)) (#f ($Kind.Check.result ($Maybe.some Bool.true) ($List.cons ($Kind.Error.patch path$0 ($Kind.Term.normalize term$1 Kind.Map.new)) List.nil)))))))) ('Kind.Term.let (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((self3 ($Kind.Term.has_holes term$1))) (case self3 (#t ($Kind.Check.result ($Maybe.some Bool.true) List.nil)) (#f ($Kind.Check.result ($Maybe.some Bool.true) ($List.cons ($Kind.Error.patch path$0 ($Kind.Term.normalize term$1 Kind.Map.new)) List.nil))))))))) ('Kind.Term.def (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((self3 ($Kind.Term.has_holes term$1))) (case self3 (#t ($Kind.Check.result ($Maybe.some Bool.true) List.nil)) (#f ($Kind.Check.result ($Maybe.some Bool.true) ($List.cons ($Kind.Error.patch path$0 ($Kind.Term.normalize term$1 Kind.Map.new)) List.nil))))))))) ('Kind.Term.ann (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((self3 ($Kind.Term.has_holes term$1))) (case self3 (#t ($Kind.Check.result ($Maybe.some Bool.true) List.nil)) (#f ($Kind.Check.result ($Maybe.some Bool.true) ($List.cons ($Kind.Error.patch path$0 ($Kind.Term.normalize term$1 Kind.Map.new)) List.nil))))))))) ('Kind.Term.gol (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((self3 ($Kind.Term.has_holes term$1))) (case self3 (#t ($Kind.Check.result ($Maybe.some Bool.true) List.nil)) (#f ($Kind.Check.result ($Maybe.some Bool.true) ($List.cons ($Kind.Error.patch path$0 ($Kind.Term.normalize term$1 Kind.Map.new)) List.nil))))))))) ('Kind.Term.hol (let ((f0 (get self0 1))) ($Kind.Check.result ($Maybe.some Bool.true) List.nil))) ('Kind.Term.nat (let ((f0 (get self0 1))) (let ((self1 ($Kind.Term.has_holes term$1))) (case self1 (#t ($Kind.Check.result ($Maybe.some Bool.true) List.nil)) (#f ($Kind.Check.result ($Maybe.some Bool.true) ($List.cons ($Kind.Error.patch path$0 ($Kind.Term.normalize term$1 Kind.Map.new)) List.nil))))))) ('Kind.Term.chr (let ((f0 (get self0 1))) (let ((self1 ($Kind.Term.has_holes term$1))) (case self1 (#t ($Kind.Check.result ($Maybe.some Bool.true) List.nil)) (#f ($Kind.Check.result ($Maybe.some Bool.true) ($List.cons ($Kind.Error.patch path$0 ($Kind.Term.normalize term$1 Kind.Map.new)) List.nil))))))) ('Kind.Term.str (let ((f0 (get self0 1))) (let ((self1 ($Kind.Term.has_holes term$1))) (case self1 (#t ($Kind.Check.result ($Maybe.some Bool.true) List.nil)) (#f ($Kind.Check.result ($Maybe.some Bool.true) ($List.cons ($Kind.Error.patch path$0 ($Kind.Term.normalize term$1 Kind.Map.new)) List.nil))))))) ('Kind.Term.num (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((self3 ($Kind.Term.has_holes term$1))) (case self3 (#t ($Kind.Check.result ($Maybe.some Bool.true) List.nil)) (#f ($Kind.Check.result ($Maybe.some Bool.true) ($List.cons ($Kind.Error.patch path$0 ($Kind.Term.normalize term$1 Kind.Map.new)) List.nil))))))))) ('Kind.Term.cse (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((f5 (get self0 6))) (let ((self6 ($Kind.Term.has_holes term$1))) (case self6 (#t ($Kind.Check.result ($Maybe.some Bool.true) List.nil)) (#f ($Kind.Check.result ($Maybe.some Bool.true) ($List.cons ($Kind.Error.patch path$0 ($Kind.Term.normalize term$1 Kind.Map.new)) List.nil)))))))))))) ('Kind.Term.new (let ((f0 (get self0 1))) (let ((self1 ($Kind.Term.has_holes term$1))) (case self1 (#t ($Kind.Check.result ($Maybe.some Bool.true) List.nil)) (#f ($Kind.Check.result ($Maybe.some Bool.true) ($List.cons ($Kind.Error.patch path$0 ($Kind.Term.normalize term$1 Kind.Map.new)) List.nil))))))) ('Kind.Term.get (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((self2 ($Kind.Term.has_holes term$1))) (case self2 (#t ($Kind.Check.result ($Maybe.some Bool.true) List.nil)) (#f ($Kind.Check.result ($Maybe.some Bool.true) ($List.cons ($Kind.Error.patch path$0 ($Kind.Term.normalize term$1 Kind.Map.new)) List.nil)))))))) ('Kind.Term.set (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((self3 ($Kind.Term.has_holes term$1))) (case self3 (#t ($Kind.Check.result ($Maybe.some Bool.true) List.nil)) (#f ($Kind.Check.result ($Maybe.some Bool.true) ($List.cons ($Kind.Error.patch path$0 ($Kind.Term.normalize term$1 Kind.Map.new)) List.nil))))))))) ('Kind.Term.ope (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((self3 ($Kind.Term.has_holes term$1))) (case self3 (#t ($Kind.Check.result ($Maybe.some Bool.true) List.nil)) (#f ($Kind.Check.result ($Maybe.some Bool.true) ($List.cons ($Kind.Error.patch path$0 ($Kind.Term.normalize term$1 Kind.Map.new)) List.nil))))))))) ('Kind.Term.ori (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((self2 ($Kind.Term.has_holes term$1))) (case self2 (#t ($Kind.Check.result ($Maybe.some Bool.true) List.nil)) (#f ($Kind.Check.result ($Maybe.some Bool.true) ($List.cons ($Kind.Error.patch path$0 ($Kind.Term.normalize term$1 Kind.Map.new)) List.nil)))))))))))
(define Kind.Term.equal.hole (lambda (path$0) (lambda (term$1) ($Kind.Term.equal.hole path$0 term$1))))
(define ($Kind.Term.equal.extra_holes.filler a$0 b$1) (let ((self0 a$0)) (case (get self0 0) ('Kind.Term.var (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((self2 b$1)) (case (get self2 0) ('Kind.Term.var (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))) ('Kind.Term.ref (let ((f2 (get self2 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.typ ($Kind.Check.result ($Maybe.some Unit.new) List.nil)) ('Kind.Term.all (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) (let ((f5 (get self2 4))) (let ((f6 (get self2 5))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))))) ('Kind.Term.lam (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))) ('Kind.Term.app (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))) ('Kind.Term.let (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.def (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.ann (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.gol (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.hol (let ((f2 (get self2 1))) (let ((self3 ($Kind.Term.equal.hole f2 a$0))) (case (get self3 0) ('Kind.Check.result (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((self5 f3)) (case (get self5 0) ('Maybe.none ($Kind.Check.result Maybe.none f4)) ('Maybe.some (let ((f5 (get self5 1))) (let ((self6 ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) (case (get self6 0) ('Kind.Check.result (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) ($Kind.Check.result f6 ($List.concat f4 f7)))))))))))))))))) ('Kind.Term.nat (let ((f2 (get self2 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.chr (let ((f2 (get self2 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.str (let ((f2 (get self2 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.num (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.cse (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) (let ((f5 (get self2 4))) (let ((f6 (get self2 5))) (let ((f7 (get self2 6))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))))))) ('Kind.Term.new (let ((f2 (get self2 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.get (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))) ('Kind.Term.set (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.ope (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.ori (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) ($Kind.Term.equal.extra_holes.filler a$0 f3))))))))) ('Kind.Term.ref (let ((f0 (get self0 1))) (let ((self1 b$1)) (case (get self1 0) ('Kind.Term.var (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))) ('Kind.Term.ref (let ((f1 (get self1 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.typ ($Kind.Check.result ($Maybe.some Unit.new) List.nil)) ('Kind.Term.all (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))))) ('Kind.Term.lam (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))) ('Kind.Term.app (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))) ('Kind.Term.let (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.def (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.ann (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.gol (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.hol (let ((f1 (get self1 1))) (let ((self2 ($Kind.Term.equal.hole f1 a$0))) (case (get self2 0) ('Kind.Check.result (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((self4 f2)) (case (get self4 0) ('Maybe.none ($Kind.Check.result Maybe.none f3)) ('Maybe.some (let ((f4 (get self4 1))) (let ((self5 ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) (case (get self5 0) ('Kind.Check.result (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) ($Kind.Check.result f5 ($List.concat f3 f6)))))))))))))))))) ('Kind.Term.nat (let ((f1 (get self1 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.chr (let ((f1 (get self1 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.str (let ((f1 (get self1 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.num (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.cse (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((f6 (get self1 6))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))))))) ('Kind.Term.new (let ((f1 (get self1 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.get (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))) ('Kind.Term.set (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.ope (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.ori (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) ($Kind.Term.equal.extra_holes.filler a$0 f2)))))))) ('Kind.Term.typ (let ((self0 b$1)) (case (get self0 0) ('Kind.Term.var (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))) ('Kind.Term.ref (let ((f0 (get self0 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.typ ($Kind.Check.result ($Maybe.some Unit.new) List.nil)) ('Kind.Term.all (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))))) ('Kind.Term.lam (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))) ('Kind.Term.app (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))) ('Kind.Term.let (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.def (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.ann (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.gol (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.hol (let ((f0 (get self0 1))) (let ((self1 ($Kind.Term.equal.hole f0 a$0))) (case (get self1 0) ('Kind.Check.result (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((self3 f1)) (case (get self3 0) ('Maybe.none ($Kind.Check.result Maybe.none f2)) ('Maybe.some (let ((f3 (get self3 1))) (let ((self4 ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) (case (get self4 0) ('Kind.Check.result (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) ($Kind.Check.result f4 ($List.concat f2 f5)))))))))))))))))) ('Kind.Term.nat (let ((f0 (get self0 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.chr (let ((f0 (get self0 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.str (let ((f0 (get self0 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.num (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.cse (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((f5 (get self0 6))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))))))) ('Kind.Term.new (let ((f0 (get self0 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.get (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))) ('Kind.Term.set (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.ope (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.ori (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($Kind.Term.equal.extra_holes.filler a$0 f1))))))) ('Kind.Term.all (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((self5 b$1)) (case (get self5 0) ('Kind.Term.var (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))) ('Kind.Term.ref (let ((f5 (get self5 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.typ ($Kind.Check.result ($Maybe.some Unit.new) List.nil)) ('Kind.Term.all (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) (let ((f8 (get self5 4))) (let ((f9 (get self5 5))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))))) ('Kind.Term.lam (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))) ('Kind.Term.app (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))) ('Kind.Term.let (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.def (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.ann (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.gol (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.hol (let ((f5 (get self5 1))) (let ((self6 ($Kind.Term.equal.hole f5 a$0))) (case (get self6 0) ('Kind.Check.result (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((self8 f6)) (case (get self8 0) ('Maybe.none ($Kind.Check.result Maybe.none f7)) ('Maybe.some (let ((f8 (get self8 1))) (let ((self9 ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) (case (get self9 0) ('Kind.Check.result (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) ($Kind.Check.result f9 ($List.concat f7 f10)))))))))))))))))) ('Kind.Term.nat (let ((f5 (get self5 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.chr (let ((f5 (get self5 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.str (let ((f5 (get self5 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.num (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.cse (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) (let ((f8 (get self5 4))) (let ((f9 (get self5 5))) (let ((f10 (get self5 6))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))))))) ('Kind.Term.new (let ((f5 (get self5 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.get (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))) ('Kind.Term.set (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.ope (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.ori (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) ($Kind.Term.equal.extra_holes.filler a$0 f6)))))))))))) ('Kind.Term.lam (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((self2 b$1)) (case (get self2 0) ('Kind.Term.var (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))) ('Kind.Term.ref (let ((f2 (get self2 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.typ ($Kind.Check.result ($Maybe.some Unit.new) List.nil)) ('Kind.Term.all (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) (let ((f5 (get self2 4))) (let ((f6 (get self2 5))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))))) ('Kind.Term.lam (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))) ('Kind.Term.app (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))) ('Kind.Term.let (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.def (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.ann (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.gol (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.hol (let ((f2 (get self2 1))) (let ((self3 ($Kind.Term.equal.hole f2 a$0))) (case (get self3 0) ('Kind.Check.result (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((self5 f3)) (case (get self5 0) ('Maybe.none ($Kind.Check.result Maybe.none f4)) ('Maybe.some (let ((f5 (get self5 1))) (let ((self6 ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) (case (get self6 0) ('Kind.Check.result (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) ($Kind.Check.result f6 ($List.concat f4 f7)))))))))))))))))) ('Kind.Term.nat (let ((f2 (get self2 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.chr (let ((f2 (get self2 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.str (let ((f2 (get self2 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.num (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.cse (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) (let ((f5 (get self2 4))) (let ((f6 (get self2 5))) (let ((f7 (get self2 6))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))))))) ('Kind.Term.new (let ((f2 (get self2 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.get (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))) ('Kind.Term.set (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.ope (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.ori (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) ($Kind.Term.equal.extra_holes.filler a$0 f3))))))))) ('Kind.Term.app (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((self2 b$1)) (case (get self2 0) ('Kind.Term.var (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))) ('Kind.Term.ref (let ((f2 (get self2 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.typ ($Kind.Check.result ($Maybe.some Unit.new) List.nil)) ('Kind.Term.all (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) (let ((f5 (get self2 4))) (let ((f6 (get self2 5))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))))) ('Kind.Term.lam (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))) ('Kind.Term.app (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((self4 ($Kind.Term.equal.extra_holes.filler f0 f2))) (case (get self4 0) ('Kind.Check.result (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((self6 f4)) (case (get self6 0) ('Maybe.none ($Kind.Check.result Maybe.none f5)) ('Maybe.some (let ((f6 (get self6 1))) (let ((self7 ($Kind.Term.equal.extra_holes.filler f1 f3))) (case (get self7 0) ('Kind.Check.result (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) ($Kind.Check.result f7 ($List.concat f5 f8))))))))))))))))))) ('Kind.Term.let (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.def (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.ann (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.gol (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.hol (let ((f2 (get self2 1))) (let ((self3 ($Kind.Term.equal.hole f2 a$0))) (case (get self3 0) ('Kind.Check.result (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((self5 f3)) (case (get self5 0) ('Maybe.none ($Kind.Check.result Maybe.none f4)) ('Maybe.some (let ((f5 (get self5 1))) (let ((self6 ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) (case (get self6 0) ('Kind.Check.result (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) ($Kind.Check.result f6 ($List.concat f4 f7)))))))))))))))))) ('Kind.Term.nat (let ((f2 (get self2 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.chr (let ((f2 (get self2 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.str (let ((f2 (get self2 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.num (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.cse (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) (let ((f5 (get self2 4))) (let ((f6 (get self2 5))) (let ((f7 (get self2 6))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))))))) ('Kind.Term.new (let ((f2 (get self2 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.get (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))) ('Kind.Term.set (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.ope (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.ori (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) ($Kind.Term.equal.extra_holes.filler a$0 f3))))))))) ('Kind.Term.let (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((self3 b$1)) (case (get self3 0) ('Kind.Term.var (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))) ('Kind.Term.ref (let ((f3 (get self3 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.typ ($Kind.Check.result ($Maybe.some Unit.new) List.nil)) ('Kind.Term.all (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) (let ((f7 (get self3 5))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))))) ('Kind.Term.lam (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))) ('Kind.Term.app (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))) ('Kind.Term.let (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.def (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.ann (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.gol (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.hol (let ((f3 (get self3 1))) (let ((self4 ($Kind.Term.equal.hole f3 a$0))) (case (get self4 0) ('Kind.Check.result (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((self6 f4)) (case (get self6 0) ('Maybe.none ($Kind.Check.result Maybe.none f5)) ('Maybe.some (let ((f6 (get self6 1))) (let ((self7 ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) (case (get self7 0) ('Kind.Check.result (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) ($Kind.Check.result f7 ($List.concat f5 f8)))))))))))))))))) ('Kind.Term.nat (let ((f3 (get self3 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.chr (let ((f3 (get self3 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.str (let ((f3 (get self3 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.num (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.cse (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) (let ((f7 (get self3 5))) (let ((f8 (get self3 6))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))))))) ('Kind.Term.new (let ((f3 (get self3 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.get (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))) ('Kind.Term.set (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.ope (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.ori (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) ($Kind.Term.equal.extra_holes.filler a$0 f4)))))))))) ('Kind.Term.def (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((self3 b$1)) (case (get self3 0) ('Kind.Term.var (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))) ('Kind.Term.ref (let ((f3 (get self3 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.typ ($Kind.Check.result ($Maybe.some Unit.new) List.nil)) ('Kind.Term.all (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) (let ((f7 (get self3 5))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))))) ('Kind.Term.lam (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))) ('Kind.Term.app (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))) ('Kind.Term.let (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.def (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.ann (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.gol (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.hol (let ((f3 (get self3 1))) (let ((self4 ($Kind.Term.equal.hole f3 a$0))) (case (get self4 0) ('Kind.Check.result (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((self6 f4)) (case (get self6 0) ('Maybe.none ($Kind.Check.result Maybe.none f5)) ('Maybe.some (let ((f6 (get self6 1))) (let ((self7 ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) (case (get self7 0) ('Kind.Check.result (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) ($Kind.Check.result f7 ($List.concat f5 f8)))))))))))))))))) ('Kind.Term.nat (let ((f3 (get self3 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.chr (let ((f3 (get self3 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.str (let ((f3 (get self3 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.num (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.cse (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) (let ((f7 (get self3 5))) (let ((f8 (get self3 6))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))))))) ('Kind.Term.new (let ((f3 (get self3 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.get (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))) ('Kind.Term.set (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.ope (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.ori (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) ($Kind.Term.equal.extra_holes.filler a$0 f4)))))))))) ('Kind.Term.ann (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((self3 b$1)) (case (get self3 0) ('Kind.Term.var (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))) ('Kind.Term.ref (let ((f3 (get self3 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.typ ($Kind.Check.result ($Maybe.some Unit.new) List.nil)) ('Kind.Term.all (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) (let ((f7 (get self3 5))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))))) ('Kind.Term.lam (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))) ('Kind.Term.app (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))) ('Kind.Term.let (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.def (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.ann (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.gol (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.hol (let ((f3 (get self3 1))) (let ((self4 ($Kind.Term.equal.hole f3 a$0))) (case (get self4 0) ('Kind.Check.result (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((self6 f4)) (case (get self6 0) ('Maybe.none ($Kind.Check.result Maybe.none f5)) ('Maybe.some (let ((f6 (get self6 1))) (let ((self7 ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) (case (get self7 0) ('Kind.Check.result (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) ($Kind.Check.result f7 ($List.concat f5 f8)))))))))))))))))) ('Kind.Term.nat (let ((f3 (get self3 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.chr (let ((f3 (get self3 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.str (let ((f3 (get self3 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.num (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.cse (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) (let ((f7 (get self3 5))) (let ((f8 (get self3 6))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))))))) ('Kind.Term.new (let ((f3 (get self3 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.get (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))) ('Kind.Term.set (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.ope (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.ori (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) ($Kind.Term.equal.extra_holes.filler a$0 f4)))))))))) ('Kind.Term.gol (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((self3 b$1)) (case (get self3 0) ('Kind.Term.var (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))) ('Kind.Term.ref (let ((f3 (get self3 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.typ ($Kind.Check.result ($Maybe.some Unit.new) List.nil)) ('Kind.Term.all (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) (let ((f7 (get self3 5))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))))) ('Kind.Term.lam (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))) ('Kind.Term.app (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))) ('Kind.Term.let (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.def (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.ann (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.gol (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.hol (let ((f3 (get self3 1))) (let ((self4 ($Kind.Term.equal.hole f3 a$0))) (case (get self4 0) ('Kind.Check.result (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((self6 f4)) (case (get self6 0) ('Maybe.none ($Kind.Check.result Maybe.none f5)) ('Maybe.some (let ((f6 (get self6 1))) (let ((self7 ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) (case (get self7 0) ('Kind.Check.result (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) ($Kind.Check.result f7 ($List.concat f5 f8)))))))))))))))))) ('Kind.Term.nat (let ((f3 (get self3 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.chr (let ((f3 (get self3 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.str (let ((f3 (get self3 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.num (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.cse (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) (let ((f7 (get self3 5))) (let ((f8 (get self3 6))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))))))) ('Kind.Term.new (let ((f3 (get self3 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.get (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))) ('Kind.Term.set (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.ope (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.ori (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) ($Kind.Term.equal.extra_holes.filler a$0 f4)))))))))) ('Kind.Term.hol (let ((f0 (get self0 1))) (let ((self1 ($Kind.Term.equal.hole f0 b$1))) (case (get self1 0) ('Kind.Check.result (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((self3 f1)) (case (get self3 0) ('Maybe.none ($Kind.Check.result Maybe.none f2)) ('Maybe.some (let ((f3 (get self3 1))) (let ((self4 ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) (case (get self4 0) ('Kind.Check.result (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) ($Kind.Check.result f4 ($List.concat f2 f5)))))))))))))))))) ('Kind.Term.nat (let ((f0 (get self0 1))) (let ((self1 b$1)) (case (get self1 0) ('Kind.Term.var (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))) ('Kind.Term.ref (let ((f1 (get self1 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.typ ($Kind.Check.result ($Maybe.some Unit.new) List.nil)) ('Kind.Term.all (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))))) ('Kind.Term.lam (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))) ('Kind.Term.app (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))) ('Kind.Term.let (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.def (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.ann (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.gol (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.hol (let ((f1 (get self1 1))) (let ((self2 ($Kind.Term.equal.hole f1 a$0))) (case (get self2 0) ('Kind.Check.result (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((self4 f2)) (case (get self4 0) ('Maybe.none ($Kind.Check.result Maybe.none f3)) ('Maybe.some (let ((f4 (get self4 1))) (let ((self5 ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) (case (get self5 0) ('Kind.Check.result (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) ($Kind.Check.result f5 ($List.concat f3 f6)))))))))))))))))) ('Kind.Term.nat (let ((f1 (get self1 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.chr (let ((f1 (get self1 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.str (let ((f1 (get self1 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.num (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.cse (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((f6 (get self1 6))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))))))) ('Kind.Term.new (let ((f1 (get self1 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.get (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))) ('Kind.Term.set (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.ope (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.ori (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) ($Kind.Term.equal.extra_holes.filler a$0 f2)))))))) ('Kind.Term.chr (let ((f0 (get self0 1))) (let ((self1 b$1)) (case (get self1 0) ('Kind.Term.var (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))) ('Kind.Term.ref (let ((f1 (get self1 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.typ ($Kind.Check.result ($Maybe.some Unit.new) List.nil)) ('Kind.Term.all (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))))) ('Kind.Term.lam (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))) ('Kind.Term.app (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))) ('Kind.Term.let (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.def (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.ann (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.gol (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.hol (let ((f1 (get self1 1))) (let ((self2 ($Kind.Term.equal.hole f1 a$0))) (case (get self2 0) ('Kind.Check.result (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((self4 f2)) (case (get self4 0) ('Maybe.none ($Kind.Check.result Maybe.none f3)) ('Maybe.some (let ((f4 (get self4 1))) (let ((self5 ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) (case (get self5 0) ('Kind.Check.result (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) ($Kind.Check.result f5 ($List.concat f3 f6)))))))))))))))))) ('Kind.Term.nat (let ((f1 (get self1 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.chr (let ((f1 (get self1 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.str (let ((f1 (get self1 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.num (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.cse (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((f6 (get self1 6))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))))))) ('Kind.Term.new (let ((f1 (get self1 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.get (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))) ('Kind.Term.set (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.ope (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.ori (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) ($Kind.Term.equal.extra_holes.filler a$0 f2)))))))) ('Kind.Term.str (let ((f0 (get self0 1))) (let ((self1 b$1)) (case (get self1 0) ('Kind.Term.var (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))) ('Kind.Term.ref (let ((f1 (get self1 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.typ ($Kind.Check.result ($Maybe.some Unit.new) List.nil)) ('Kind.Term.all (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))))) ('Kind.Term.lam (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))) ('Kind.Term.app (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))) ('Kind.Term.let (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.def (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.ann (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.gol (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.hol (let ((f1 (get self1 1))) (let ((self2 ($Kind.Term.equal.hole f1 a$0))) (case (get self2 0) ('Kind.Check.result (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((self4 f2)) (case (get self4 0) ('Maybe.none ($Kind.Check.result Maybe.none f3)) ('Maybe.some (let ((f4 (get self4 1))) (let ((self5 ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) (case (get self5 0) ('Kind.Check.result (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) ($Kind.Check.result f5 ($List.concat f3 f6)))))))))))))))))) ('Kind.Term.nat (let ((f1 (get self1 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.chr (let ((f1 (get self1 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.str (let ((f1 (get self1 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.num (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.cse (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((f6 (get self1 6))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))))))) ('Kind.Term.new (let ((f1 (get self1 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.get (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))) ('Kind.Term.set (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.ope (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.ori (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) ($Kind.Term.equal.extra_holes.filler a$0 f2)))))))) ('Kind.Term.num (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((self3 b$1)) (case (get self3 0) ('Kind.Term.var (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))) ('Kind.Term.ref (let ((f3 (get self3 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.typ ($Kind.Check.result ($Maybe.some Unit.new) List.nil)) ('Kind.Term.all (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) (let ((f7 (get self3 5))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))))) ('Kind.Term.lam (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))) ('Kind.Term.app (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))) ('Kind.Term.let (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.def (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.ann (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.gol (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.hol (let ((f3 (get self3 1))) (let ((self4 ($Kind.Term.equal.hole f3 a$0))) (case (get self4 0) ('Kind.Check.result (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((self6 f4)) (case (get self6 0) ('Maybe.none ($Kind.Check.result Maybe.none f5)) ('Maybe.some (let ((f6 (get self6 1))) (let ((self7 ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) (case (get self7 0) ('Kind.Check.result (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) ($Kind.Check.result f7 ($List.concat f5 f8)))))))))))))))))) ('Kind.Term.nat (let ((f3 (get self3 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.chr (let ((f3 (get self3 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.str (let ((f3 (get self3 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.num (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.cse (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) (let ((f7 (get self3 5))) (let ((f8 (get self3 6))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))))))) ('Kind.Term.new (let ((f3 (get self3 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.get (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))) ('Kind.Term.set (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.ope (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.ori (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) ($Kind.Term.equal.extra_holes.filler a$0 f4)))))))))) ('Kind.Term.cse (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((f5 (get self0 6))) (let ((self6 b$1)) (case (get self6 0) ('Kind.Term.var (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))) ('Kind.Term.ref (let ((f6 (get self6 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.typ ($Kind.Check.result ($Maybe.some Unit.new) List.nil)) ('Kind.Term.all (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((f8 (get self6 3))) (let ((f9 (get self6 4))) (let ((f10 (get self6 5))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))))) ('Kind.Term.lam (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))) ('Kind.Term.app (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))) ('Kind.Term.let (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((f8 (get self6 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.def (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((f8 (get self6 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.ann (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((f8 (get self6 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.gol (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((f8 (get self6 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.hol (let ((f6 (get self6 1))) (let ((self7 ($Kind.Term.equal.hole f6 a$0))) (case (get self7 0) ('Kind.Check.result (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((self9 f7)) (case (get self9 0) ('Maybe.none ($Kind.Check.result Maybe.none f8)) ('Maybe.some (let ((f9 (get self9 1))) (let ((self10 ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) (case (get self10 0) ('Kind.Check.result (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) ($Kind.Check.result f10 ($List.concat f8 f11)))))))))))))))))) ('Kind.Term.nat (let ((f6 (get self6 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.chr (let ((f6 (get self6 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.str (let ((f6 (get self6 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.num (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((f8 (get self6 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.cse (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((f8 (get self6 3))) (let ((f9 (get self6 4))) (let ((f10 (get self6 5))) (let ((f11 (get self6 6))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))))))) ('Kind.Term.new (let ((f6 (get self6 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.get (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))) ('Kind.Term.set (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((f8 (get self6 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.ope (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((f8 (get self6 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.ori (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) ($Kind.Term.equal.extra_holes.filler a$0 f7))))))))))))) ('Kind.Term.new (let ((f0 (get self0 1))) (let ((self1 b$1)) (case (get self1 0) ('Kind.Term.var (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))) ('Kind.Term.ref (let ((f1 (get self1 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.typ ($Kind.Check.result ($Maybe.some Unit.new) List.nil)) ('Kind.Term.all (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))))) ('Kind.Term.lam (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))) ('Kind.Term.app (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))) ('Kind.Term.let (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.def (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.ann (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.gol (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.hol (let ((f1 (get self1 1))) (let ((self2 ($Kind.Term.equal.hole f1 a$0))) (case (get self2 0) ('Kind.Check.result (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((self4 f2)) (case (get self4 0) ('Maybe.none ($Kind.Check.result Maybe.none f3)) ('Maybe.some (let ((f4 (get self4 1))) (let ((self5 ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) (case (get self5 0) ('Kind.Check.result (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) ($Kind.Check.result f5 ($List.concat f3 f6)))))))))))))))))) ('Kind.Term.nat (let ((f1 (get self1 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.chr (let ((f1 (get self1 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.str (let ((f1 (get self1 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.num (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.cse (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((f6 (get self1 6))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))))))) ('Kind.Term.new (let ((f1 (get self1 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.get (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))) ('Kind.Term.set (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.ope (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.ori (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) ($Kind.Term.equal.extra_holes.filler a$0 f2)))))))) ('Kind.Term.get (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((self2 b$1)) (case (get self2 0) ('Kind.Term.var (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))) ('Kind.Term.ref (let ((f2 (get self2 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.typ ($Kind.Check.result ($Maybe.some Unit.new) List.nil)) ('Kind.Term.all (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) (let ((f5 (get self2 4))) (let ((f6 (get self2 5))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))))) ('Kind.Term.lam (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))) ('Kind.Term.app (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))) ('Kind.Term.let (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.def (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.ann (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.gol (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.hol (let ((f2 (get self2 1))) (let ((self3 ($Kind.Term.equal.hole f2 a$0))) (case (get self3 0) ('Kind.Check.result (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((self5 f3)) (case (get self5 0) ('Maybe.none ($Kind.Check.result Maybe.none f4)) ('Maybe.some (let ((f5 (get self5 1))) (let ((self6 ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) (case (get self6 0) ('Kind.Check.result (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) ($Kind.Check.result f6 ($List.concat f4 f7)))))))))))))))))) ('Kind.Term.nat (let ((f2 (get self2 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.chr (let ((f2 (get self2 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.str (let ((f2 (get self2 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.num (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.cse (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) (let ((f5 (get self2 4))) (let ((f6 (get self2 5))) (let ((f7 (get self2 6))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))))))) ('Kind.Term.new (let ((f2 (get self2 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.get (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))) ('Kind.Term.set (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.ope (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.ori (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) ($Kind.Term.equal.extra_holes.filler a$0 f3))))))))) ('Kind.Term.set (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((self3 b$1)) (case (get self3 0) ('Kind.Term.var (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))) ('Kind.Term.ref (let ((f3 (get self3 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.typ ($Kind.Check.result ($Maybe.some Unit.new) List.nil)) ('Kind.Term.all (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) (let ((f7 (get self3 5))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))))) ('Kind.Term.lam (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))) ('Kind.Term.app (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))) ('Kind.Term.let (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.def (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.ann (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.gol (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.hol (let ((f3 (get self3 1))) (let ((self4 ($Kind.Term.equal.hole f3 a$0))) (case (get self4 0) ('Kind.Check.result (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((self6 f4)) (case (get self6 0) ('Maybe.none ($Kind.Check.result Maybe.none f5)) ('Maybe.some (let ((f6 (get self6 1))) (let ((self7 ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) (case (get self7 0) ('Kind.Check.result (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) ($Kind.Check.result f7 ($List.concat f5 f8)))))))))))))))))) ('Kind.Term.nat (let ((f3 (get self3 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.chr (let ((f3 (get self3 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.str (let ((f3 (get self3 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.num (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.cse (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) (let ((f7 (get self3 5))) (let ((f8 (get self3 6))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))))))) ('Kind.Term.new (let ((f3 (get self3 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.get (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))) ('Kind.Term.set (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.ope (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.ori (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) ($Kind.Term.equal.extra_holes.filler a$0 f4)))))))))) ('Kind.Term.ope (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((self3 b$1)) (case (get self3 0) ('Kind.Term.var (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))) ('Kind.Term.ref (let ((f3 (get self3 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.typ ($Kind.Check.result ($Maybe.some Unit.new) List.nil)) ('Kind.Term.all (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) (let ((f7 (get self3 5))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))))) ('Kind.Term.lam (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))) ('Kind.Term.app (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))) ('Kind.Term.let (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.def (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.ann (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.gol (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.hol (let ((f3 (get self3 1))) (let ((self4 ($Kind.Term.equal.hole f3 a$0))) (case (get self4 0) ('Kind.Check.result (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((self6 f4)) (case (get self6 0) ('Maybe.none ($Kind.Check.result Maybe.none f5)) ('Maybe.some (let ((f6 (get self6 1))) (let ((self7 ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) (case (get self7 0) ('Kind.Check.result (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) ($Kind.Check.result f7 ($List.concat f5 f8)))))))))))))))))) ('Kind.Term.nat (let ((f3 (get self3 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.chr (let ((f3 (get self3 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.str (let ((f3 (get self3 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.num (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.cse (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) (let ((f7 (get self3 5))) (let ((f8 (get self3 6))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))))))) ('Kind.Term.new (let ((f3 (get self3 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.get (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))) ('Kind.Term.set (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.ope (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))) ('Kind.Term.ori (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) ($Kind.Term.equal.extra_holes.filler a$0 f4)))))))))) ('Kind.Term.ori (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($Kind.Term.equal.extra_holes.filler f1 b$1)))))))
(define Kind.Term.equal.extra_holes.filler (lambda (a$0) (lambda (b$1) ($Kind.Term.equal.extra_holes.filler a$0 b$1))))
(define ($Kind.Term.equal.extra_holes a$0 b$1) (let ((self0 ($Kind.Term.equal.extra_holes.funari a$0 0))) (case (get self0 0) ('Maybe.none ($Kind.Check.result ($Maybe.some Unit.new) List.nil)) ('Maybe.some (let ((f0 (get self0 1))) (let ((self1 ($Kind.Term.equal.extra_holes.funari b$1 0))) (case (get self1 0) ('Maybe.none ($Kind.Check.result ($Maybe.some Unit.new) List.nil)) ('Maybe.some (let ((f1 (get self1 1))) (let ((self2 f0)) (case (get self2 0) ('Pair.new (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((self4 f1)) (case (get self4 0) ('Pair.new (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((same_fun$8 ($String.eql f2 f4))) (let ((same_ari$9 ($Nat.eql f3 f5))) (let ((self8 ($Bool.and same_fun$8 same_ari$9))) (case self8 (#t ($Kind.Term.equal.extra_holes.filler a$0 b$1)) (#f ($Kind.Check.result ($Maybe.some Unit.new) List.nil)))))))))))))))))))))))))
(define Kind.Term.equal.extra_holes (lambda (a$0) (lambda (b$1) ($Kind.Term.equal.extra_holes a$0 b$1))))
(define ($BitsSet.set bits$0 set$1) ($BitsMap.set bits$0 Unit.new set$1))
(define BitsSet.set (lambda (bits$0) (lambda (set$1) ($BitsSet.set bits$0 set$1))))
(define ($BitsSet.mut.set bits$0 set$1) ($BitsSet.set bits$0 set$1))
(define BitsSet.mut.set (lambda (bits$0) (lambda (set$1) ($BitsSet.mut.set bits$0 set$1))))
(define ($Bool.eql a$0 b$1) (let ((self0 a$0)) (case self0 (#t b$1) (#f ($Bool.not b$1)))))
(define Bool.eql (lambda (a$0) (lambda (b$1) ($Bool.eql a$0 b$1))))
(define ($Kind.Term.equal.go a$0 b$1 defs$2 lv$3 seen$4) (let ((ah$5 ($Kind.Term.serialize ($Kind.Term.reduce a$0 Kind.Map.new) lv$3 Bool.false))) (let ((bh$6 ($Kind.Term.serialize ($Kind.Term.reduce b$1 Kind.Map.new) lv$3 Bool.true))) (let ((self2 ($Bits.eql ah$5 bh$6))) (case self2 (#t ($Kind.Check.result ($Maybe.some Bool.true) List.nil)) (#f (let ((a1$7 ($Kind.Term.reduce a$0 defs$2))) (let ((b1$8 ($Kind.Term.reduce b$1 defs$2))) (let ((ah$9 ($Kind.Term.serialize a1$7 lv$3 Bool.false))) (let ((bh$10 ($Kind.Term.serialize b1$8 lv$3 Bool.true))) (let ((self6 ($Bits.eql ah$9 bh$10))) (case self6 (#t ($Kind.Check.result ($Maybe.some Bool.true) List.nil)) (#f (let ((id$11 ($Bits.concat ah$9 bh$10))) (let ((self7 ($BitsSet.mut.has id$11 seen$4))) (case self7 (#t (let ((self7 ($Kind.Term.equal.extra_holes a$0 b$1))) (case (get self7 0) ('Kind.Check.result (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((self9 f7)) (case (get self9 0) ('Maybe.none ($Kind.Check.result Maybe.none f8)) ('Maybe.some (let ((f9 (get self9 1))) (let ((self10 ($Kind.Check.result ($Maybe.some Bool.true) List.nil))) (case (get self10 0) ('Kind.Check.result (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) ($Kind.Check.result f10 ($List.concat f8 f11))))))))))))))))) (#f (let ((self7 a1$7)) (case (get self7 0) ('Kind.Term.var (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((self9 b1$8)) (case (get self9 0) ('Kind.Term.var (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))) ('Kind.Term.ref (let ((f9 (get self9 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.typ ($Kind.Check.result ($Maybe.some Bool.false) List.nil)) ('Kind.Term.all (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))))) ('Kind.Term.lam (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))) ('Kind.Term.app (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))) ('Kind.Term.let (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.def (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.ann (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.gol (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.hol (let ((f9 (get self9 1))) ($Kind.Term.equal.hole f9 a$0))) ('Kind.Term.nat (let ((f9 (get self9 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.chr (let ((f9 (get self9 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.str (let ((f9 (get self9 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.num (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.cse (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) (let ((f14 (get self9 6))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))))))) ('Kind.Term.new (let ((f9 (get self9 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.get (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))) ('Kind.Term.set (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.ope (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.ori (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))))))) ('Kind.Term.ref (let ((f7 (get self7 1))) (let ((self8 b1$8)) (case (get self8 0) ('Kind.Term.var (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))) ('Kind.Term.ref (let ((f8 (get self8 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.typ ($Kind.Check.result ($Maybe.some Bool.false) List.nil)) ('Kind.Term.all (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) (let ((f11 (get self8 4))) (let ((f12 (get self8 5))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))))) ('Kind.Term.lam (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))) ('Kind.Term.app (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))) ('Kind.Term.let (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.def (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.ann (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.gol (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.hol (let ((f8 (get self8 1))) ($Kind.Term.equal.hole f8 a$0))) ('Kind.Term.nat (let ((f8 (get self8 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.chr (let ((f8 (get self8 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.str (let ((f8 (get self8 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.num (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.cse (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) (let ((f11 (get self8 4))) (let ((f12 (get self8 5))) (let ((f13 (get self8 6))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))))))) ('Kind.Term.new (let ((f8 (get self8 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.get (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))) ('Kind.Term.set (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.ope (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.ori (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))))))) ('Kind.Term.typ (let ((self7 b1$8)) (case (get self7 0) ('Kind.Term.var (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))) ('Kind.Term.ref (let ((f7 (get self7 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.typ ($Kind.Check.result ($Maybe.some Bool.false) List.nil)) ('Kind.Term.all (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((f9 (get self7 3))) (let ((f10 (get self7 4))) (let ((f11 (get self7 5))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))))) ('Kind.Term.lam (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))) ('Kind.Term.app (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))) ('Kind.Term.let (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((f9 (get self7 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.def (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((f9 (get self7 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.ann (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((f9 (get self7 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.gol (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((f9 (get self7 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.hol (let ((f7 (get self7 1))) ($Kind.Term.equal.hole f7 a$0))) ('Kind.Term.nat (let ((f7 (get self7 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.chr (let ((f7 (get self7 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.str (let ((f7 (get self7 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.num (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((f9 (get self7 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.cse (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((f9 (get self7 3))) (let ((f10 (get self7 4))) (let ((f11 (get self7 5))) (let ((f12 (get self7 6))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))))))) ('Kind.Term.new (let ((f7 (get self7 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.get (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))) ('Kind.Term.set (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((f9 (get self7 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.ope (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((f9 (get self7 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.ori (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))))) ('Kind.Term.all (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((f9 (get self7 3))) (let ((f10 (get self7 4))) (let ((f11 (get self7 5))) (let ((self12 b1$8)) (case (get self12 0) ('Kind.Term.var (let ((f12 (get self12 1))) (let ((f13 (get self12 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))) ('Kind.Term.ref (let ((f12 (get self12 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.typ ($Kind.Check.result ($Maybe.some Bool.false) List.nil)) ('Kind.Term.all (let ((f12 (get self12 1))) (let ((f13 (get self12 2))) (let ((f14 (get self12 3))) (let ((f15 (get self12 4))) (let ((f16 (get self12 5))) (let ((seen$22 ($BitsSet.mut.set id$11 seen$4))) (let ((a1_body$23 ((f11 ($Kind.Term.var f8 lv$3)) ($Kind.Term.var f9 ($Nat.succ lv$3))))) (let ((b1_body$24 ((f16 ($Kind.Term.var f13 lv$3)) ($Kind.Term.var f14 ($Nat.succ lv$3))))) (let ((eq_self$25 ($String.eql f8 f13))) (let ((eq_eras$26 ($Bool.eql f7 f12))) (let ((self22 ($Bool.and eq_self$25 eq_eras$26))) (case self22 (#t (let ((self22 ($Kind.Term.equal.go f10 f15 defs$2 lv$3 seen$22))) (case (get self22 0) ('Kind.Check.result (let ((f22 (get self22 1))) (let ((f23 (get self22 2))) (let ((self24 f22)) (case (get self24 0) ('Maybe.none ($Kind.Check.result Maybe.none f23)) ('Maybe.some (let ((f24 (get self24 1))) (let ((self25 (let ((self25 ($Kind.Term.equal.go a1_body$23 b1_body$24 defs$2 ($Nat.succ ($Nat.succ lv$3)) seen$22))) (case (get self25 0) ('Kind.Check.result (let ((f25 (get self25 1))) (let ((f26 (get self25 2))) (let ((self27 f25)) (case (get self27 0) ('Maybe.none ($Kind.Check.result Maybe.none f26)) ('Maybe.some (let ((f27 (get self27 1))) (let ((self28 ($Kind.Check.result ($Maybe.some ($Bool.and f24 f27)) List.nil))) (case (get self28 0) ('Kind.Check.result (let ((f28 (get self28 1))) (let ((f29 (get self28 2))) ($Kind.Check.result f28 ($List.concat f26 f29)))))))))))))))))) (case (get self25 0) ('Kind.Check.result (let ((f25 (get self25 1))) (let ((f26 (get self25 2))) ($Kind.Check.result f25 ($List.concat f23 f26))))))))))))))))) (#f ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))))))))))))) ('Kind.Term.lam (let ((f12 (get self12 1))) (let ((f13 (get self12 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))) ('Kind.Term.app (let ((f12 (get self12 1))) (let ((f13 (get self12 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))) ('Kind.Term.let (let ((f12 (get self12 1))) (let ((f13 (get self12 2))) (let ((f14 (get self12 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.def (let ((f12 (get self12 1))) (let ((f13 (get self12 2))) (let ((f14 (get self12 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.ann (let ((f12 (get self12 1))) (let ((f13 (get self12 2))) (let ((f14 (get self12 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.gol (let ((f12 (get self12 1))) (let ((f13 (get self12 2))) (let ((f14 (get self12 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.hol (let ((f12 (get self12 1))) ($Kind.Term.equal.hole f12 a$0))) ('Kind.Term.nat (let ((f12 (get self12 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.chr (let ((f12 (get self12 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.str (let ((f12 (get self12 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.num (let ((f12 (get self12 1))) (let ((f13 (get self12 2))) (let ((f14 (get self12 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.cse (let ((f12 (get self12 1))) (let ((f13 (get self12 2))) (let ((f14 (get self12 3))) (let ((f15 (get self12 4))) (let ((f16 (get self12 5))) (let ((f17 (get self12 6))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))))))) ('Kind.Term.new (let ((f12 (get self12 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.get (let ((f12 (get self12 1))) (let ((f13 (get self12 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))) ('Kind.Term.set (let ((f12 (get self12 1))) (let ((f13 (get self12 2))) (let ((f14 (get self12 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.ope (let ((f12 (get self12 1))) (let ((f13 (get self12 2))) (let ((f14 (get self12 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.ori (let ((f12 (get self12 1))) (let ((f13 (get self12 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))))))))))) ('Kind.Term.lam (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((self9 b1$8)) (case (get self9 0) ('Kind.Term.var (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))) ('Kind.Term.ref (let ((f9 (get self9 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.typ ($Kind.Check.result ($Maybe.some Bool.false) List.nil)) ('Kind.Term.all (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))))) ('Kind.Term.lam (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((seen$16 ($BitsSet.mut.set id$11 seen$4))) (let ((a1_body$17 (f8 ($Kind.Term.var f7 lv$3)))) (let ((b1_body$18 (f10 ($Kind.Term.var f9 lv$3)))) (let ((self14 ($Kind.Term.equal.go a1_body$17 b1_body$18 defs$2 ($Nat.succ lv$3) seen$16))) (case (get self14 0) ('Kind.Check.result (let ((f14 (get self14 1))) (let ((f15 (get self14 2))) (let ((self16 f14)) (case (get self16 0) ('Maybe.none ($Kind.Check.result Maybe.none f15)) ('Maybe.some (let ((f16 (get self16 1))) (let ((self17 ($Kind.Check.result ($Maybe.some f16) List.nil))) (case (get self17 0) ('Kind.Check.result (let ((f17 (get self17 1))) (let ((f18 (get self17 2))) ($Kind.Check.result f17 ($List.concat f15 f18)))))))))))))))))))))) ('Kind.Term.app (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))) ('Kind.Term.let (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.def (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.ann (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.gol (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.hol (let ((f9 (get self9 1))) ($Kind.Term.equal.hole f9 a$0))) ('Kind.Term.nat (let ((f9 (get self9 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.chr (let ((f9 (get self9 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.str (let ((f9 (get self9 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.num (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.cse (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) (let ((f14 (get self9 6))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))))))) ('Kind.Term.new (let ((f9 (get self9 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.get (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))) ('Kind.Term.set (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.ope (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.ori (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))))))) ('Kind.Term.app (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((self9 b1$8)) (case (get self9 0) ('Kind.Term.var (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))) ('Kind.Term.ref (let ((f9 (get self9 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.typ ($Kind.Check.result ($Maybe.some Bool.false) List.nil)) ('Kind.Term.all (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))))) ('Kind.Term.lam (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))) ('Kind.Term.app (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((seen$16 ($BitsSet.mut.set id$11 seen$4))) (let ((self12 ($Kind.Term.equal.go f7 f9 defs$2 lv$3 seen$16))) (case (get self12 0) ('Kind.Check.result (let ((f12 (get self12 1))) (let ((f13 (get self12 2))) (let ((self14 f12)) (case (get self14 0) ('Maybe.none ($Kind.Check.result Maybe.none f13)) ('Maybe.some (let ((f14 (get self14 1))) (let ((self15 (let ((self15 ($Kind.Term.equal.go f8 f10 defs$2 lv$3 seen$16))) (case (get self15 0) ('Kind.Check.result (let ((f15 (get self15 1))) (let ((f16 (get self15 2))) (let ((self17 f15)) (case (get self17 0) ('Maybe.none ($Kind.Check.result Maybe.none f16)) ('Maybe.some (let ((f17 (get self17 1))) (let ((self18 ($Kind.Check.result ($Maybe.some ($Bool.and f14 f17)) List.nil))) (case (get self18 0) ('Kind.Check.result (let ((f18 (get self18 1))) (let ((f19 (get self18 2))) ($Kind.Check.result f18 ($List.concat f16 f19)))))))))))))))))) (case (get self15 0) ('Kind.Check.result (let ((f15 (get self15 1))) (let ((f16 (get self15 2))) ($Kind.Check.result f15 ($List.concat f13 f16)))))))))))))))))))) ('Kind.Term.let (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.def (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.ann (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.gol (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.hol (let ((f9 (get self9 1))) ($Kind.Term.equal.hole f9 a$0))) ('Kind.Term.nat (let ((f9 (get self9 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.chr (let ((f9 (get self9 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.str (let ((f9 (get self9 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.num (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.cse (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) (let ((f14 (get self9 6))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))))))) ('Kind.Term.new (let ((f9 (get self9 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.get (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))) ('Kind.Term.set (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.ope (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.ori (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))))))) ('Kind.Term.let (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((f9 (get self7 3))) (let ((self10 b1$8)) (case (get self10 0) ('Kind.Term.var (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))) ('Kind.Term.ref (let ((f10 (get self10 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.typ ($Kind.Check.result ($Maybe.some Bool.false) List.nil)) ('Kind.Term.all (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) (let ((f13 (get self10 4))) (let ((f14 (get self10 5))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))))) ('Kind.Term.lam (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))) ('Kind.Term.app (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))) ('Kind.Term.let (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) (let ((seen$18 ($BitsSet.mut.set id$11 seen$4))) (let ((a1_body$19 (f9 ($Kind.Term.var f7 lv$3)))) (let ((b1_body$20 (f12 ($Kind.Term.var f10 lv$3)))) (let ((self16 ($Kind.Term.equal.go f8 f11 defs$2 lv$3 seen$18))) (case (get self16 0) ('Kind.Check.result (let ((f16 (get self16 1))) (let ((f17 (get self16 2))) (let ((self18 f16)) (case (get self18 0) ('Maybe.none ($Kind.Check.result Maybe.none f17)) ('Maybe.some (let ((f18 (get self18 1))) (let ((self19 (let ((self19 ($Kind.Term.equal.go a1_body$19 b1_body$20 defs$2 ($Nat.succ lv$3) seen$18))) (case (get self19 0) ('Kind.Check.result (let ((f19 (get self19 1))) (let ((f20 (get self19 2))) (let ((self21 f19)) (case (get self21 0) ('Maybe.none ($Kind.Check.result Maybe.none f20)) ('Maybe.some (let ((f21 (get self21 1))) (let ((self22 ($Kind.Check.result ($Maybe.some ($Bool.and f18 f21)) List.nil))) (case (get self22 0) ('Kind.Check.result (let ((f22 (get self22 1))) (let ((f23 (get self22 2))) ($Kind.Check.result f22 ($List.concat f20 f23)))))))))))))))))) (case (get self19 0) ('Kind.Check.result (let ((f19 (get self19 1))) (let ((f20 (get self19 2))) ($Kind.Check.result f19 ($List.concat f17 f20))))))))))))))))))))))) ('Kind.Term.def (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.ann (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.gol (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.hol (let ((f10 (get self10 1))) ($Kind.Term.equal.hole f10 a$0))) ('Kind.Term.nat (let ((f10 (get self10 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.chr (let ((f10 (get self10 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.str (let ((f10 (get self10 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.num (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.cse (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) (let ((f13 (get self10 4))) (let ((f14 (get self10 5))) (let ((f15 (get self10 6))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))))))) ('Kind.Term.new (let ((f10 (get self10 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.get (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))) ('Kind.Term.set (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.ope (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.ori (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))))))))) ('Kind.Term.def (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((f9 (get self7 3))) (let ((self10 b1$8)) (case (get self10 0) ('Kind.Term.var (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))) ('Kind.Term.ref (let ((f10 (get self10 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.typ ($Kind.Check.result ($Maybe.some Bool.false) List.nil)) ('Kind.Term.all (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) (let ((f13 (get self10 4))) (let ((f14 (get self10 5))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))))) ('Kind.Term.lam (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))) ('Kind.Term.app (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))) ('Kind.Term.let (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.def (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.ann (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.gol (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.hol (let ((f10 (get self10 1))) ($Kind.Term.equal.hole f10 a$0))) ('Kind.Term.nat (let ((f10 (get self10 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.chr (let ((f10 (get self10 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.str (let ((f10 (get self10 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.num (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.cse (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) (let ((f13 (get self10 4))) (let ((f14 (get self10 5))) (let ((f15 (get self10 6))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))))))) ('Kind.Term.new (let ((f10 (get self10 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.get (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))) ('Kind.Term.set (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.ope (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.ori (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))))))))) ('Kind.Term.ann (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((f9 (get self7 3))) (let ((self10 b1$8)) (case (get self10 0) ('Kind.Term.var (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))) ('Kind.Term.ref (let ((f10 (get self10 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.typ ($Kind.Check.result ($Maybe.some Bool.false) List.nil)) ('Kind.Term.all (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) (let ((f13 (get self10 4))) (let ((f14 (get self10 5))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))))) ('Kind.Term.lam (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))) ('Kind.Term.app (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))) ('Kind.Term.let (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.def (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.ann (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.gol (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.hol (let ((f10 (get self10 1))) ($Kind.Term.equal.hole f10 a$0))) ('Kind.Term.nat (let ((f10 (get self10 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.chr (let ((f10 (get self10 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.str (let ((f10 (get self10 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.num (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.cse (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) (let ((f13 (get self10 4))) (let ((f14 (get self10 5))) (let ((f15 (get self10 6))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))))))) ('Kind.Term.new (let ((f10 (get self10 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.get (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))) ('Kind.Term.set (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.ope (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.ori (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))))))))) ('Kind.Term.gol (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((f9 (get self7 3))) (let ((self10 b1$8)) (case (get self10 0) ('Kind.Term.var (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))) ('Kind.Term.ref (let ((f10 (get self10 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.typ ($Kind.Check.result ($Maybe.some Bool.false) List.nil)) ('Kind.Term.all (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) (let ((f13 (get self10 4))) (let ((f14 (get self10 5))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))))) ('Kind.Term.lam (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))) ('Kind.Term.app (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))) ('Kind.Term.let (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.def (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.ann (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.gol (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.hol (let ((f10 (get self10 1))) ($Kind.Term.equal.hole f10 a$0))) ('Kind.Term.nat (let ((f10 (get self10 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.chr (let ((f10 (get self10 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.str (let ((f10 (get self10 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.num (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.cse (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) (let ((f13 (get self10 4))) (let ((f14 (get self10 5))) (let ((f15 (get self10 6))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))))))) ('Kind.Term.new (let ((f10 (get self10 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.get (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))) ('Kind.Term.set (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.ope (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.ori (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))))))))) ('Kind.Term.hol (let ((f7 (get self7 1))) ($Kind.Term.equal.hole f7 b$1))) ('Kind.Term.nat (let ((f7 (get self7 1))) (let ((self8 b1$8)) (case (get self8 0) ('Kind.Term.var (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))) ('Kind.Term.ref (let ((f8 (get self8 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.typ ($Kind.Check.result ($Maybe.some Bool.false) List.nil)) ('Kind.Term.all (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) (let ((f11 (get self8 4))) (let ((f12 (get self8 5))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))))) ('Kind.Term.lam (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))) ('Kind.Term.app (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))) ('Kind.Term.let (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.def (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.ann (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.gol (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.hol (let ((f8 (get self8 1))) ($Kind.Term.equal.hole f8 a$0))) ('Kind.Term.nat (let ((f8 (get self8 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.chr (let ((f8 (get self8 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.str (let ((f8 (get self8 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.num (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.cse (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) (let ((f11 (get self8 4))) (let ((f12 (get self8 5))) (let ((f13 (get self8 6))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))))))) ('Kind.Term.new (let ((f8 (get self8 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.get (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))) ('Kind.Term.set (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.ope (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.ori (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))))))) ('Kind.Term.chr (let ((f7 (get self7 1))) (let ((self8 b1$8)) (case (get self8 0) ('Kind.Term.var (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))) ('Kind.Term.ref (let ((f8 (get self8 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.typ ($Kind.Check.result ($Maybe.some Bool.false) List.nil)) ('Kind.Term.all (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) (let ((f11 (get self8 4))) (let ((f12 (get self8 5))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))))) ('Kind.Term.lam (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))) ('Kind.Term.app (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))) ('Kind.Term.let (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.def (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.ann (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.gol (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.hol (let ((f8 (get self8 1))) ($Kind.Term.equal.hole f8 a$0))) ('Kind.Term.nat (let ((f8 (get self8 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.chr (let ((f8 (get self8 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.str (let ((f8 (get self8 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.num (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.cse (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) (let ((f11 (get self8 4))) (let ((f12 (get self8 5))) (let ((f13 (get self8 6))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))))))) ('Kind.Term.new (let ((f8 (get self8 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.get (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))) ('Kind.Term.set (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.ope (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.ori (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))))))) ('Kind.Term.str (let ((f7 (get self7 1))) (let ((self8 b1$8)) (case (get self8 0) ('Kind.Term.var (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))) ('Kind.Term.ref (let ((f8 (get self8 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.typ ($Kind.Check.result ($Maybe.some Bool.false) List.nil)) ('Kind.Term.all (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) (let ((f11 (get self8 4))) (let ((f12 (get self8 5))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))))) ('Kind.Term.lam (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))) ('Kind.Term.app (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))) ('Kind.Term.let (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.def (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.ann (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.gol (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.hol (let ((f8 (get self8 1))) ($Kind.Term.equal.hole f8 a$0))) ('Kind.Term.nat (let ((f8 (get self8 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.chr (let ((f8 (get self8 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.str (let ((f8 (get self8 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.num (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.cse (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) (let ((f11 (get self8 4))) (let ((f12 (get self8 5))) (let ((f13 (get self8 6))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))))))) ('Kind.Term.new (let ((f8 (get self8 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.get (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))) ('Kind.Term.set (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.ope (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.ori (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))))))) ('Kind.Term.num (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((f9 (get self7 3))) (let ((self10 b1$8)) (case (get self10 0) ('Kind.Term.var (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))) ('Kind.Term.ref (let ((f10 (get self10 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.typ ($Kind.Check.result ($Maybe.some Bool.false) List.nil)) ('Kind.Term.all (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) (let ((f13 (get self10 4))) (let ((f14 (get self10 5))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))))) ('Kind.Term.lam (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))) ('Kind.Term.app (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))) ('Kind.Term.let (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.def (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.ann (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.gol (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.hol (let ((f10 (get self10 1))) ($Kind.Term.equal.hole f10 a$0))) ('Kind.Term.nat (let ((f10 (get self10 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.chr (let ((f10 (get self10 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.str (let ((f10 (get self10 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.num (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.cse (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) (let ((f13 (get self10 4))) (let ((f14 (get self10 5))) (let ((f15 (get self10 6))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))))))) ('Kind.Term.new (let ((f10 (get self10 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.get (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))) ('Kind.Term.set (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.ope (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.ori (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))))))))) ('Kind.Term.cse (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((f9 (get self7 3))) (let ((f10 (get self7 4))) (let ((f11 (get self7 5))) (let ((f12 (get self7 6))) (let ((self13 b1$8)) (case (get self13 0) ('Kind.Term.var (let ((f13 (get self13 1))) (let ((f14 (get self13 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))) ('Kind.Term.ref (let ((f13 (get self13 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.typ ($Kind.Check.result ($Maybe.some Bool.false) List.nil)) ('Kind.Term.all (let ((f13 (get self13 1))) (let ((f14 (get self13 2))) (let ((f15 (get self13 3))) (let ((f16 (get self13 4))) (let ((f17 (get self13 5))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))))) ('Kind.Term.lam (let ((f13 (get self13 1))) (let ((f14 (get self13 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))) ('Kind.Term.app (let ((f13 (get self13 1))) (let ((f14 (get self13 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))) ('Kind.Term.let (let ((f13 (get self13 1))) (let ((f14 (get self13 2))) (let ((f15 (get self13 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.def (let ((f13 (get self13 1))) (let ((f14 (get self13 2))) (let ((f15 (get self13 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.ann (let ((f13 (get self13 1))) (let ((f14 (get self13 2))) (let ((f15 (get self13 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.gol (let ((f13 (get self13 1))) (let ((f14 (get self13 2))) (let ((f15 (get self13 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.hol (let ((f13 (get self13 1))) ($Kind.Term.equal.hole f13 a$0))) ('Kind.Term.nat (let ((f13 (get self13 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.chr (let ((f13 (get self13 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.str (let ((f13 (get self13 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.num (let ((f13 (get self13 1))) (let ((f14 (get self13 2))) (let ((f15 (get self13 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.cse (let ((f13 (get self13 1))) (let ((f14 (get self13 2))) (let ((f15 (get self13 3))) (let ((f16 (get self13 4))) (let ((f17 (get self13 5))) (let ((f18 (get self13 6))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))))))) ('Kind.Term.new (let ((f13 (get self13 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.get (let ((f13 (get self13 1))) (let ((f14 (get self13 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))) ('Kind.Term.set (let ((f13 (get self13 1))) (let ((f14 (get self13 2))) (let ((f15 (get self13 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.ope (let ((f13 (get self13 1))) (let ((f14 (get self13 2))) (let ((f15 (get self13 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.ori (let ((f13 (get self13 1))) (let ((f14 (get self13 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))))))))))) ('Kind.Term.new (let ((f7 (get self7 1))) (let ((self8 b1$8)) (case (get self8 0) ('Kind.Term.var (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))) ('Kind.Term.ref (let ((f8 (get self8 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.typ ($Kind.Check.result ($Maybe.some Bool.false) List.nil)) ('Kind.Term.all (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) (let ((f11 (get self8 4))) (let ((f12 (get self8 5))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))))) ('Kind.Term.lam (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))) ('Kind.Term.app (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))) ('Kind.Term.let (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.def (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.ann (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.gol (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.hol (let ((f8 (get self8 1))) ($Kind.Term.equal.hole f8 a$0))) ('Kind.Term.nat (let ((f8 (get self8 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.chr (let ((f8 (get self8 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.str (let ((f8 (get self8 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.num (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.cse (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) (let ((f11 (get self8 4))) (let ((f12 (get self8 5))) (let ((f13 (get self8 6))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))))))) ('Kind.Term.new (let ((f8 (get self8 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.get (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))) ('Kind.Term.set (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.ope (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.ori (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))))))) ('Kind.Term.get (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((self9 b1$8)) (case (get self9 0) ('Kind.Term.var (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))) ('Kind.Term.ref (let ((f9 (get self9 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.typ ($Kind.Check.result ($Maybe.some Bool.false) List.nil)) ('Kind.Term.all (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))))) ('Kind.Term.lam (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))) ('Kind.Term.app (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))) ('Kind.Term.let (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.def (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.ann (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.gol (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.hol (let ((f9 (get self9 1))) ($Kind.Term.equal.hole f9 a$0))) ('Kind.Term.nat (let ((f9 (get self9 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.chr (let ((f9 (get self9 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.str (let ((f9 (get self9 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.num (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.cse (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) (let ((f14 (get self9 6))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))))))) ('Kind.Term.new (let ((f9 (get self9 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.get (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))) ('Kind.Term.set (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.ope (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.ori (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))))))) ('Kind.Term.set (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((f9 (get self7 3))) (let ((self10 b1$8)) (case (get self10 0) ('Kind.Term.var (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))) ('Kind.Term.ref (let ((f10 (get self10 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.typ ($Kind.Check.result ($Maybe.some Bool.false) List.nil)) ('Kind.Term.all (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) (let ((f13 (get self10 4))) (let ((f14 (get self10 5))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))))) ('Kind.Term.lam (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))) ('Kind.Term.app (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))) ('Kind.Term.let (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.def (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.ann (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.gol (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.hol (let ((f10 (get self10 1))) ($Kind.Term.equal.hole f10 a$0))) ('Kind.Term.nat (let ((f10 (get self10 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.chr (let ((f10 (get self10 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.str (let ((f10 (get self10 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.num (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.cse (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) (let ((f13 (get self10 4))) (let ((f14 (get self10 5))) (let ((f15 (get self10 6))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))))))) ('Kind.Term.new (let ((f10 (get self10 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.get (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))) ('Kind.Term.set (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.ope (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.ori (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))))))))) ('Kind.Term.ope (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((f9 (get self7 3))) (let ((self10 b1$8)) (case (get self10 0) ('Kind.Term.var (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))) ('Kind.Term.ref (let ((f10 (get self10 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.typ ($Kind.Check.result ($Maybe.some Bool.false) List.nil)) ('Kind.Term.all (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) (let ((f13 (get self10 4))) (let ((f14 (get self10 5))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))))) ('Kind.Term.lam (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))) ('Kind.Term.app (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))) ('Kind.Term.let (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.def (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.ann (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.gol (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.hol (let ((f10 (get self10 1))) ($Kind.Term.equal.hole f10 a$0))) ('Kind.Term.nat (let ((f10 (get self10 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.chr (let ((f10 (get self10 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.str (let ((f10 (get self10 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.num (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.cse (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) (let ((f13 (get self10 4))) (let ((f14 (get self10 5))) (let ((f15 (get self10 6))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))))))) ('Kind.Term.new (let ((f10 (get self10 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.get (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))) ('Kind.Term.set (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.ope (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.ori (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))))))))) ('Kind.Term.ori (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((self9 b1$8)) (case (get self9 0) ('Kind.Term.var (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))) ('Kind.Term.ref (let ((f9 (get self9 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.typ ($Kind.Check.result ($Maybe.some Bool.false) List.nil)) ('Kind.Term.all (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))))) ('Kind.Term.lam (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))) ('Kind.Term.app (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))) ('Kind.Term.let (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.def (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.ann (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.gol (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.hol (let ((f9 (get self9 1))) ($Kind.Term.equal.hole f9 a$0))) ('Kind.Term.nat (let ((f9 (get self9 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.chr (let ((f9 (get self9 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.str (let ((f9 (get self9 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.num (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.cse (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) (let ((f14 (get self9 6))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))))))) ('Kind.Term.new (let ((f9 (get self9 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.get (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))) ('Kind.Term.set (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.ope (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))) ('Kind.Term.ori (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))))))))))))))))))))))))))
(define Kind.Term.equal.go (lambda (a$0) (lambda (b$1) (lambda (defs$2) (lambda (lv$3) (lambda (seen$4) ($Kind.Term.equal.go a$0 b$1 defs$2 lv$3 seen$4)))))))
(define BitsSet.new BitsMap.new)
(define ($BitsSet.mut.new a$0) BitsSet.new)
(define BitsSet.mut.new (lambda (a$0) ($BitsSet.mut.new a$0)))
(define ($Kind.Term.check term$0 type$1 defs$2 ctx$3 path$4 orig$5) (let ((self0 (let ((self0 term$0)) (case (get self0 0) ('Kind.Term.var (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((self2 ($List.at_last f1 ctx$3))) (case (get self2 0) ('Maybe.none ($Kind.Check.result type$1 ($List.cons ($Kind.Error.undefined_reference orig$5 f0) List.nil))) ('Maybe.some (let ((f2 (get self2 1))) ($Kind.Check.result ($Maybe.some (let ((self3 f2)) (case (get self3 0) ('Pair.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) f4)))))) List.nil)))))))) ('Kind.Term.ref (let ((f0 (get self0 1))) (let ((self1 ($Kind.Map.get f0 defs$2))) (case (get self1 0) ('Maybe.none ($Kind.Check.result type$1 ($List.cons ($Kind.Error.undefined_reference orig$5 f0) List.nil))) ('Maybe.some (let ((f1 (get self1 1))) (let ((self2 f1)) (case (get self2 0) ('Kind.Def.new (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) (let ((f5 (get self2 4))) (let ((f6 (get self2 5))) (let ((f7 (get self2 6))) (let ((f8 (get self2 7))) (let ((f9 (get self2 8))) (let ((f10 (get self2 9))) (let ((ref_name$17 f5)) (let ((ref_type$18 f7)) (let ((ref_term$19 f6)) (let ((ref_stat$20 f10)) (let ((self15 ref_stat$20)) (case (get self15 0) ('Kind.Status.init ($Kind.Check.result ($Maybe.some ref_type$18) ($List.cons ($Kind.Error.waiting ref_name$17) List.nil))) ('Kind.Status.wait ($Kind.Check.result ($Maybe.some ref_type$18) List.nil)) ('Kind.Status.done (let ((f15 (get self15 1))) ($Kind.Check.result ($Maybe.some ref_type$18) List.nil))) ('Kind.Status.fail (let ((f15 (get self15 1))) ($Kind.Check.result ($Maybe.some ref_type$18) ($List.cons ($Kind.Error.indirect ref_name$17) List.nil)))))))))))))))))))))))))))) ('Kind.Term.typ ($Kind.Check.result ($Maybe.some Kind.Term.typ) List.nil)) ('Kind.Term.all (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((ctx_size$11 ($List.length ctx$3))) (let ((self_var$12 ($Kind.Term.var f1 ctx_size$11))) (let ((body_var$13 ($Kind.Term.var f2 ($Nat.succ ctx_size$11)))) (let ((body_ctx$14 ($List.cons ($Pair.new f2 f3) ($List.cons ($Pair.new f1 term$0) ctx$3)))) (let ((self9 ($Kind.Term.check f3 ($Maybe.some Kind.Term.typ) defs$2 ctx$3 ($Kind.Path.Maybe.Builder.o path$4) orig$5))) (case (get self9 0) ('Kind.Check.result (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((self11 f9)) (case (get self11 0) ('Maybe.none ($Kind.Check.result Maybe.none f10)) ('Maybe.some (let ((f11 (get self11 1))) (let ((self12 (let ((self12 ($Kind.Term.check ((f4 self_var$12) body_var$13) ($Maybe.some Kind.Term.typ) defs$2 body_ctx$14 ($Kind.Path.Maybe.Builder.i path$4) orig$5))) (case (get self12 0) ('Kind.Check.result (let ((f12 (get self12 1))) (let ((f13 (get self12 2))) (let ((self14 f12)) (case (get self14 0) ('Maybe.none ($Kind.Check.result Maybe.none f13)) ('Maybe.some (let ((f14 (get self14 1))) (let ((self15 ($Kind.Check.result ($Maybe.some Kind.Term.typ) List.nil))) (case (get self15 0) ('Kind.Check.result (let ((f15 (get self15 1))) (let ((f16 (get self15 2))) ($Kind.Check.result f15 ($List.concat f13 f16)))))))))))))))))) (case (get self12 0) ('Kind.Check.result (let ((f12 (get self12 1))) (let ((f13 (get self12 2))) ($Kind.Check.result f12 ($List.concat f10 f13)))))))))))))))))))))))))) ('Kind.Term.lam (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((self2 type$1)) (case (get self2 0) ('Maybe.none (let ((lam_type$8 ($Kind.Term.hol Bits.e))) (let ((lam_term$9 ($Kind.Term.ann Bool.false term$0 lam_type$8))) ($Kind.Term.check.patch lam_term$9 type$1 path$4)))) ('Maybe.some (let ((f2 (get self2 1))) (let ((typv$9 ($Kind.Term.reduce f2 defs$2))) (let ((self4 typv$9)) (case (get self4 0) ('Kind.Term.var (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((expected$12 ($Either.left "function"))) (let ((detected$13 ($Either.right f2))) ($Kind.Check.result type$1 ($List.cons ($Kind.Error.type_mismatch orig$5 expected$12 detected$13 ctx$3) List.nil))))))) ('Kind.Term.ref (let ((f4 (get self4 1))) (let ((expected$11 ($Either.left "function"))) (let ((detected$12 ($Either.right f2))) ($Kind.Check.result type$1 ($List.cons ($Kind.Error.type_mismatch orig$5 expected$11 detected$12 ctx$3) List.nil)))))) ('Kind.Term.typ (let ((expected$10 ($Either.left "function"))) (let ((detected$11 ($Either.right f2))) ($Kind.Check.result type$1 ($List.cons ($Kind.Error.type_mismatch orig$5 expected$10 detected$11 ctx$3) List.nil))))) ('Kind.Term.all (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((f6 (get self4 3))) (let ((f7 (get self4 4))) (let ((f8 (get self4 5))) (let ((ctx_size$15 ($List.length ctx$3))) (let ((self_var$16 term$0)) (let ((body_var$17 ($Kind.Term.var f0 ctx_size$15))) (let ((body_typ$18 ((f8 self_var$16) body_var$17))) (let ((body_ctx$19 ($List.cons ($Pair.new f0 f7) ctx$3))) (let ((self14 ($Kind.Term.check (f1 body_var$17) ($Maybe.some body_typ$18) defs$2 body_ctx$19 ($Kind.Path.Maybe.Builder.o path$4) orig$5))) (case (get self14 0) ('Kind.Check.result (let ((f14 (get self14 1))) (let ((f15 (get self14 2))) (let ((self16 f14)) (case (get self16 0) ('Maybe.none ($Kind.Check.result Maybe.none f15)) ('Maybe.some (let ((f16 (get self16 1))) (let ((self17 ($Kind.Check.result ($Maybe.some f2) List.nil))) (case (get self17 0) ('Kind.Check.result (let ((f17 (get self17 1))) (let ((f18 (get self17 2))) ($Kind.Check.result f17 ($List.concat f15 f18))))))))))))))))))))))))))) ('Kind.Term.lam (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((expected$12 ($Either.left "function"))) (let ((detected$13 ($Either.right f2))) ($Kind.Check.result type$1 ($List.cons ($Kind.Error.type_mismatch orig$5 expected$12 detected$13 ctx$3) List.nil))))))) ('Kind.Term.app (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((expected$12 ($Either.left "function"))) (let ((detected$13 ($Either.right f2))) ($Kind.Check.result type$1 ($List.cons ($Kind.Error.type_mismatch orig$5 expected$12 detected$13 ctx$3) List.nil))))))) ('Kind.Term.let (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((f6 (get self4 3))) (let ((expected$13 ($Either.left "function"))) (let ((detected$14 ($Either.right f2))) ($Kind.Check.result type$1 ($List.cons ($Kind.Error.type_mismatch orig$5 expected$13 detected$14 ctx$3) List.nil)))))))) ('Kind.Term.def (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((f6 (get self4 3))) (let ((expected$13 ($Either.left "function"))) (let ((detected$14 ($Either.right f2))) ($Kind.Check.result type$1 ($List.cons ($Kind.Error.type_mismatch orig$5 expected$13 detected$14 ctx$3) List.nil)))))))) ('Kind.Term.ann (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((f6 (get self4 3))) (let ((expected$13 ($Either.left "function"))) (let ((detected$14 ($Either.right f2))) ($Kind.Check.result type$1 ($List.cons ($Kind.Error.type_mismatch orig$5 expected$13 detected$14 ctx$3) List.nil)))))))) ('Kind.Term.gol (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((f6 (get self4 3))) (let ((expected$13 ($Either.left "function"))) (let ((detected$14 ($Either.right f2))) ($Kind.Check.result type$1 ($List.cons ($Kind.Error.type_mismatch orig$5 expected$13 detected$14 ctx$3) List.nil)))))))) ('Kind.Term.hol (let ((f4 (get self4 1))) (let ((expected$11 ($Either.left "function"))) (let ((detected$12 ($Either.right f2))) ($Kind.Check.result type$1 ($List.cons ($Kind.Error.type_mismatch orig$5 expected$11 detected$12 ctx$3) List.nil)))))) ('Kind.Term.nat (let ((f4 (get self4 1))) (let ((expected$11 ($Either.left "function"))) (let ((detected$12 ($Either.right f2))) ($Kind.Check.result type$1 ($List.cons ($Kind.Error.type_mismatch orig$5 expected$11 detected$12 ctx$3) List.nil)))))) ('Kind.Term.chr (let ((f4 (get self4 1))) (let ((expected$11 ($Either.left "function"))) (let ((detected$12 ($Either.right f2))) ($Kind.Check.result type$1 ($List.cons ($Kind.Error.type_mismatch orig$5 expected$11 detected$12 ctx$3) List.nil)))))) ('Kind.Term.str (let ((f4 (get self4 1))) (let ((expected$11 ($Either.left "function"))) (let ((detected$12 ($Either.right f2))) ($Kind.Check.result type$1 ($List.cons ($Kind.Error.type_mismatch orig$5 expected$11 detected$12 ctx$3) List.nil)))))) ('Kind.Term.num (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((f6 (get self4 3))) (let ((expected$13 ($Either.left "function"))) (let ((detected$14 ($Either.right f2))) ($Kind.Check.result type$1 ($List.cons ($Kind.Error.type_mismatch orig$5 expected$13 detected$14 ctx$3) List.nil)))))))) ('Kind.Term.cse (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((f6 (get self4 3))) (let ((f7 (get self4 4))) (let ((f8 (get self4 5))) (let ((f9 (get self4 6))) (let ((expected$16 ($Either.left "function"))) (let ((detected$17 ($Either.right f2))) ($Kind.Check.result type$1 ($List.cons ($Kind.Error.type_mismatch orig$5 expected$16 detected$17 ctx$3) List.nil))))))))))) ('Kind.Term.new (let ((f4 (get self4 1))) (let ((expected$11 ($Either.left "function"))) (let ((detected$12 ($Either.right f2))) ($Kind.Check.result type$1 ($List.cons ($Kind.Error.type_mismatch orig$5 expected$11 detected$12 ctx$3) List.nil)))))) ('Kind.Term.get (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((expected$12 ($Either.left "function"))) (let ((detected$13 ($Either.right f2))) ($Kind.Check.result type$1 ($List.cons ($Kind.Error.type_mismatch orig$5 expected$12 detected$13 ctx$3) List.nil))))))) ('Kind.Term.set (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((f6 (get self4 3))) (let ((expected$13 ($Either.left "function"))) (let ((detected$14 ($Either.right f2))) ($Kind.Check.result type$1 ($List.cons ($Kind.Error.type_mismatch orig$5 expected$13 detected$14 ctx$3) List.nil)))))))) ('Kind.Term.ope (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((f6 (get self4 3))) (let ((expected$13 ($Either.left "function"))) (let ((detected$14 ($Either.right f2))) ($Kind.Check.result type$1 ($List.cons ($Kind.Error.type_mismatch orig$5 expected$13 detected$14 ctx$3) List.nil)))))))) ('Kind.Term.ori (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((expected$12 ($Either.left "function"))) (let ((detected$13 ($Either.right f2))) ($Kind.Check.result type$1 ($List.cons ($Kind.Error.type_mismatch orig$5 expected$12 detected$13 ctx$3) List.nil))))))))))))))))) ('Kind.Term.app (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((self2 ($Kind.Term.check f0 Maybe.none defs$2 ctx$3 ($Kind.Path.Maybe.Builder.o path$4) orig$5))) (case (get self2 0) ('Kind.Check.result (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((self4 f2)) (case (get self4 0) ('Maybe.none ($Kind.Check.result Maybe.none f3)) ('Maybe.some (let ((f4 (get self4 1))) (let ((func_typ$11 ($Kind.Term.reduce f4 defs$2))) (let ((self6 (let ((self6 func_typ$11)) (case (get self6 0) ('Kind.Term.var (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((expected$14 ($Either.left "function"))) (let ((detected$15 ($Either.right func_typ$11))) (let ((orig$16 (let ((self10 f0)) (case (get self10 0) ('Kind.Term.var (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) orig$5))) ('Kind.Term.ref (let ((f10 (get self10 1))) orig$5)) ('Kind.Term.typ orig$5) ('Kind.Term.all (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) (let ((f13 (get self10 4))) (let ((f14 (get self10 5))) orig$5)))))) ('Kind.Term.lam (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) orig$5))) ('Kind.Term.app (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) orig$5))) ('Kind.Term.let (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) orig$5)))) ('Kind.Term.def (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) orig$5)))) ('Kind.Term.ann (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) orig$5)))) ('Kind.Term.gol (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) orig$5)))) ('Kind.Term.hol (let ((f10 (get self10 1))) orig$5)) ('Kind.Term.nat (let ((f10 (get self10 1))) orig$5)) ('Kind.Term.chr (let ((f10 (get self10 1))) orig$5)) ('Kind.Term.str (let ((f10 (get self10 1))) orig$5)) ('Kind.Term.num (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) orig$5)))) ('Kind.Term.cse (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) (let ((f13 (get self10 4))) (let ((f14 (get self10 5))) (let ((f15 (get self10 6))) orig$5))))))) ('Kind.Term.new (let ((f10 (get self10 1))) orig$5)) ('Kind.Term.get (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) orig$5))) ('Kind.Term.set (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) orig$5)))) ('Kind.Term.ope (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) orig$5)))) ('Kind.Term.ori (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) ($Maybe.some f10)))))))) ($Kind.Check.result type$1 ($List.cons ($Kind.Error.type_mismatch orig$16 expected$14 detected$15 ctx$3) List.nil)))))))) ('Kind.Term.ref (let ((f6 (get self6 1))) (let ((expected$13 ($Either.left "function"))) (let ((detected$14 ($Either.right func_typ$11))) (let ((orig$15 (let ((self9 f0)) (case (get self9 0) ('Kind.Term.var (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) orig$5))) ('Kind.Term.ref (let ((f9 (get self9 1))) orig$5)) ('Kind.Term.typ orig$5) ('Kind.Term.all (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) orig$5)))))) ('Kind.Term.lam (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) orig$5))) ('Kind.Term.app (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) orig$5))) ('Kind.Term.let (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) orig$5)))) ('Kind.Term.def (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) orig$5)))) ('Kind.Term.ann (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) orig$5)))) ('Kind.Term.gol (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) orig$5)))) ('Kind.Term.hol (let ((f9 (get self9 1))) orig$5)) ('Kind.Term.nat (let ((f9 (get self9 1))) orig$5)) ('Kind.Term.chr (let ((f9 (get self9 1))) orig$5)) ('Kind.Term.str (let ((f9 (get self9 1))) orig$5)) ('Kind.Term.num (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) orig$5)))) ('Kind.Term.cse (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) (let ((f14 (get self9 6))) orig$5))))))) ('Kind.Term.new (let ((f9 (get self9 1))) orig$5)) ('Kind.Term.get (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) orig$5))) ('Kind.Term.set (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) orig$5)))) ('Kind.Term.ope (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) orig$5)))) ('Kind.Term.ori (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) ($Maybe.some f9)))))))) ($Kind.Check.result type$1 ($List.cons ($Kind.Error.type_mismatch orig$15 expected$13 detected$14 ctx$3) List.nil))))))) ('Kind.Term.typ (let ((expected$12 ($Either.left "function"))) (let ((detected$13 ($Either.right func_typ$11))) (let ((orig$14 (let ((self8 f0)) (case (get self8 0) ('Kind.Term.var (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) orig$5))) ('Kind.Term.ref (let ((f8 (get self8 1))) orig$5)) ('Kind.Term.typ orig$5) ('Kind.Term.all (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) (let ((f11 (get self8 4))) (let ((f12 (get self8 5))) orig$5)))))) ('Kind.Term.lam (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) orig$5))) ('Kind.Term.app (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) orig$5))) ('Kind.Term.let (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) orig$5)))) ('Kind.Term.def (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) orig$5)))) ('Kind.Term.ann (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) orig$5)))) ('Kind.Term.gol (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) orig$5)))) ('Kind.Term.hol (let ((f8 (get self8 1))) orig$5)) ('Kind.Term.nat (let ((f8 (get self8 1))) orig$5)) ('Kind.Term.chr (let ((f8 (get self8 1))) orig$5)) ('Kind.Term.str (let ((f8 (get self8 1))) orig$5)) ('Kind.Term.num (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) orig$5)))) ('Kind.Term.cse (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) (let ((f11 (get self8 4))) (let ((f12 (get self8 5))) (let ((f13 (get self8 6))) orig$5))))))) ('Kind.Term.new (let ((f8 (get self8 1))) orig$5)) ('Kind.Term.get (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) orig$5))) ('Kind.Term.set (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) orig$5)))) ('Kind.Term.ope (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) orig$5)))) ('Kind.Term.ori (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) ($Maybe.some f8)))))))) ($Kind.Check.result type$1 ($List.cons ($Kind.Error.type_mismatch orig$14 expected$12 detected$13 ctx$3) List.nil)))))) ('Kind.Term.all (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((f8 (get self6 3))) (let ((f9 (get self6 4))) (let ((f10 (get self6 5))) (let ((self11 ($Kind.Term.check f1 ($Maybe.some f9) defs$2 ctx$3 ($Kind.Path.Maybe.Builder.i path$4) orig$5))) (case (get self11 0) ('Kind.Check.result (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) (let ((self13 f11)) (case (get self13 0) ('Maybe.none ($Kind.Check.result Maybe.none f12)) ('Maybe.some (let ((f13 (get self13 1))) (let ((self14 ($Kind.Check.result ($Maybe.some ((f10 f0) f1)) List.nil))) (case (get self14 0) ('Kind.Check.result (let ((f14 (get self14 1))) (let ((f15 (get self14 2))) ($Kind.Check.result f14 ($List.concat f12 f15)))))))))))))))))))))) ('Kind.Term.lam (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((expected$14 ($Either.left "function"))) (let ((detected$15 ($Either.right func_typ$11))) (let ((orig$16 (let ((self10 f0)) (case (get self10 0) ('Kind.Term.var (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) orig$5))) ('Kind.Term.ref (let ((f10 (get self10 1))) orig$5)) ('Kind.Term.typ orig$5) ('Kind.Term.all (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) (let ((f13 (get self10 4))) (let ((f14 (get self10 5))) orig$5)))))) ('Kind.Term.lam (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) orig$5))) ('Kind.Term.app (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) orig$5))) ('Kind.Term.let (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) orig$5)))) ('Kind.Term.def (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) orig$5)))) ('Kind.Term.ann (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) orig$5)))) ('Kind.Term.gol (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) orig$5)))) ('Kind.Term.hol (let ((f10 (get self10 1))) orig$5)) ('Kind.Term.nat (let ((f10 (get self10 1))) orig$5)) ('Kind.Term.chr (let ((f10 (get self10 1))) orig$5)) ('Kind.Term.str (let ((f10 (get self10 1))) orig$5)) ('Kind.Term.num (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) orig$5)))) ('Kind.Term.cse (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) (let ((f13 (get self10 4))) (let ((f14 (get self10 5))) (let ((f15 (get self10 6))) orig$5))))))) ('Kind.Term.new (let ((f10 (get self10 1))) orig$5)) ('Kind.Term.get (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) orig$5))) ('Kind.Term.set (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) orig$5)))) ('Kind.Term.ope (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) orig$5)))) ('Kind.Term.ori (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) ($Maybe.some f10)))))))) ($Kind.Check.result type$1 ($List.cons ($Kind.Error.type_mismatch orig$16 expected$14 detected$15 ctx$3) List.nil)))))))) ('Kind.Term.app (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((expected$14 ($Either.left "function"))) (let ((detected$15 ($Either.right func_typ$11))) (let ((orig$16 (let ((self10 f0)) (case (get self10 0) ('Kind.Term.var (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) orig$5))) ('Kind.Term.ref (let ((f10 (get self10 1))) orig$5)) ('Kind.Term.typ orig$5) ('Kind.Term.all (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) (let ((f13 (get self10 4))) (let ((f14 (get self10 5))) orig$5)))))) ('Kind.Term.lam (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) orig$5))) ('Kind.Term.app (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) orig$5))) ('Kind.Term.let (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) orig$5)))) ('Kind.Term.def (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) orig$5)))) ('Kind.Term.ann (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) orig$5)))) ('Kind.Term.gol (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) orig$5)))) ('Kind.Term.hol (let ((f10 (get self10 1))) orig$5)) ('Kind.Term.nat (let ((f10 (get self10 1))) orig$5)) ('Kind.Term.chr (let ((f10 (get self10 1))) orig$5)) ('Kind.Term.str (let ((f10 (get self10 1))) orig$5)) ('Kind.Term.num (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) orig$5)))) ('Kind.Term.cse (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) (let ((f13 (get self10 4))) (let ((f14 (get self10 5))) (let ((f15 (get self10 6))) orig$5))))))) ('Kind.Term.new (let ((f10 (get self10 1))) orig$5)) ('Kind.Term.get (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) orig$5))) ('Kind.Term.set (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) orig$5)))) ('Kind.Term.ope (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) orig$5)))) ('Kind.Term.ori (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) ($Maybe.some f10)))))))) ($Kind.Check.result type$1 ($List.cons ($Kind.Error.type_mismatch orig$16 expected$14 detected$15 ctx$3) List.nil)))))))) ('Kind.Term.let (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((f8 (get self6 3))) (let ((expected$15 ($Either.left "function"))) (let ((detected$16 ($Either.right func_typ$11))) (let ((orig$17 (let ((self11 f0)) (case (get self11 0) ('Kind.Term.var (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) orig$5))) ('Kind.Term.ref (let ((f11 (get self11 1))) orig$5)) ('Kind.Term.typ orig$5) ('Kind.Term.all (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) (let ((f13 (get self11 3))) (let ((f14 (get self11 4))) (let ((f15 (get self11 5))) orig$5)))))) ('Kind.Term.lam (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) orig$5))) ('Kind.Term.app (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) orig$5))) ('Kind.Term.let (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) (let ((f13 (get self11 3))) orig$5)))) ('Kind.Term.def (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) (let ((f13 (get self11 3))) orig$5)))) ('Kind.Term.ann (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) (let ((f13 (get self11 3))) orig$5)))) ('Kind.Term.gol (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) (let ((f13 (get self11 3))) orig$5)))) ('Kind.Term.hol (let ((f11 (get self11 1))) orig$5)) ('Kind.Term.nat (let ((f11 (get self11 1))) orig$5)) ('Kind.Term.chr (let ((f11 (get self11 1))) orig$5)) ('Kind.Term.str (let ((f11 (get self11 1))) orig$5)) ('Kind.Term.num (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) (let ((f13 (get self11 3))) orig$5)))) ('Kind.Term.cse (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) (let ((f13 (get self11 3))) (let ((f14 (get self11 4))) (let ((f15 (get self11 5))) (let ((f16 (get self11 6))) orig$5))))))) ('Kind.Term.new (let ((f11 (get self11 1))) orig$5)) ('Kind.Term.get (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) orig$5))) ('Kind.Term.set (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) (let ((f13 (get self11 3))) orig$5)))) ('Kind.Term.ope (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) (let ((f13 (get self11 3))) orig$5)))) ('Kind.Term.ori (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) ($Maybe.some f11)))))))) ($Kind.Check.result type$1 ($List.cons ($Kind.Error.type_mismatch orig$17 expected$15 detected$16 ctx$3) List.nil))))))))) ('Kind.Term.def (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((f8 (get self6 3))) (let ((expected$15 ($Either.left "function"))) (let ((detected$16 ($Either.right func_typ$11))) (let ((orig$17 (let ((self11 f0)) (case (get self11 0) ('Kind.Term.var (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) orig$5))) ('Kind.Term.ref (let ((f11 (get self11 1))) orig$5)) ('Kind.Term.typ orig$5) ('Kind.Term.all (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) (let ((f13 (get self11 3))) (let ((f14 (get self11 4))) (let ((f15 (get self11 5))) orig$5)))))) ('Kind.Term.lam (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) orig$5))) ('Kind.Term.app (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) orig$5))) ('Kind.Term.let (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) (let ((f13 (get self11 3))) orig$5)))) ('Kind.Term.def (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) (let ((f13 (get self11 3))) orig$5)))) ('Kind.Term.ann (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) (let ((f13 (get self11 3))) orig$5)))) ('Kind.Term.gol (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) (let ((f13 (get self11 3))) orig$5)))) ('Kind.Term.hol (let ((f11 (get self11 1))) orig$5)) ('Kind.Term.nat (let ((f11 (get self11 1))) orig$5)) ('Kind.Term.chr (let ((f11 (get self11 1))) orig$5)) ('Kind.Term.str (let ((f11 (get self11 1))) orig$5)) ('Kind.Term.num (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) (let ((f13 (get self11 3))) orig$5)))) ('Kind.Term.cse (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) (let ((f13 (get self11 3))) (let ((f14 (get self11 4))) (let ((f15 (get self11 5))) (let ((f16 (get self11 6))) orig$5))))))) ('Kind.Term.new (let ((f11 (get self11 1))) orig$5)) ('Kind.Term.get (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) orig$5))) ('Kind.Term.set (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) (let ((f13 (get self11 3))) orig$5)))) ('Kind.Term.ope (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) (let ((f13 (get self11 3))) orig$5)))) ('Kind.Term.ori (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) ($Maybe.some f11)))))))) ($Kind.Check.result type$1 ($List.cons ($Kind.Error.type_mismatch orig$17 expected$15 detected$16 ctx$3) List.nil))))))))) ('Kind.Term.ann (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((f8 (get self6 3))) (let ((expected$15 ($Either.left "function"))) (let ((detected$16 ($Either.right func_typ$11))) (let ((orig$17 (let ((self11 f0)) (case (get self11 0) ('Kind.Term.var (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) orig$5))) ('Kind.Term.ref (let ((f11 (get self11 1))) orig$5)) ('Kind.Term.typ orig$5) ('Kind.Term.all (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) (let ((f13 (get self11 3))) (let ((f14 (get self11 4))) (let ((f15 (get self11 5))) orig$5)))))) ('Kind.Term.lam (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) orig$5))) ('Kind.Term.app (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) orig$5))) ('Kind.Term.let (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) (let ((f13 (get self11 3))) orig$5)))) ('Kind.Term.def (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) (let ((f13 (get self11 3))) orig$5)))) ('Kind.Term.ann (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) (let ((f13 (get self11 3))) orig$5)))) ('Kind.Term.gol (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) (let ((f13 (get self11 3))) orig$5)))) ('Kind.Term.hol (let ((f11 (get self11 1))) orig$5)) ('Kind.Term.nat (let ((f11 (get self11 1))) orig$5)) ('Kind.Term.chr (let ((f11 (get self11 1))) orig$5)) ('Kind.Term.str (let ((f11 (get self11 1))) orig$5)) ('Kind.Term.num (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) (let ((f13 (get self11 3))) orig$5)))) ('Kind.Term.cse (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) (let ((f13 (get self11 3))) (let ((f14 (get self11 4))) (let ((f15 (get self11 5))) (let ((f16 (get self11 6))) orig$5))))))) ('Kind.Term.new (let ((f11 (get self11 1))) orig$5)) ('Kind.Term.get (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) orig$5))) ('Kind.Term.set (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) (let ((f13 (get self11 3))) orig$5)))) ('Kind.Term.ope (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) (let ((f13 (get self11 3))) orig$5)))) ('Kind.Term.ori (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) ($Maybe.some f11)))))))) ($Kind.Check.result type$1 ($List.cons ($Kind.Error.type_mismatch orig$17 expected$15 detected$16 ctx$3) List.nil))))))))) ('Kind.Term.gol (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((f8 (get self6 3))) (let ((expected$15 ($Either.left "function"))) (let ((detected$16 ($Either.right func_typ$11))) (let ((orig$17 (let ((self11 f0)) (case (get self11 0) ('Kind.Term.var (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) orig$5))) ('Kind.Term.ref (let ((f11 (get self11 1))) orig$5)) ('Kind.Term.typ orig$5) ('Kind.Term.all (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) (let ((f13 (get self11 3))) (let ((f14 (get self11 4))) (let ((f15 (get self11 5))) orig$5)))))) ('Kind.Term.lam (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) orig$5))) ('Kind.Term.app (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) orig$5))) ('Kind.Term.let (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) (let ((f13 (get self11 3))) orig$5)))) ('Kind.Term.def (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) (let ((f13 (get self11 3))) orig$5)))) ('Kind.Term.ann (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) (let ((f13 (get self11 3))) orig$5)))) ('Kind.Term.gol (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) (let ((f13 (get self11 3))) orig$5)))) ('Kind.Term.hol (let ((f11 (get self11 1))) orig$5)) ('Kind.Term.nat (let ((f11 (get self11 1))) orig$5)) ('Kind.Term.chr (let ((f11 (get self11 1))) orig$5)) ('Kind.Term.str (let ((f11 (get self11 1))) orig$5)) ('Kind.Term.num (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) (let ((f13 (get self11 3))) orig$5)))) ('Kind.Term.cse (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) (let ((f13 (get self11 3))) (let ((f14 (get self11 4))) (let ((f15 (get self11 5))) (let ((f16 (get self11 6))) orig$5))))))) ('Kind.Term.new (let ((f11 (get self11 1))) orig$5)) ('Kind.Term.get (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) orig$5))) ('Kind.Term.set (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) (let ((f13 (get self11 3))) orig$5)))) ('Kind.Term.ope (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) (let ((f13 (get self11 3))) orig$5)))) ('Kind.Term.ori (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) ($Maybe.some f11)))))))) ($Kind.Check.result type$1 ($List.cons ($Kind.Error.type_mismatch orig$17 expected$15 detected$16 ctx$3) List.nil))))))))) ('Kind.Term.hol (let ((f6 (get self6 1))) (let ((expected$13 ($Either.left "function"))) (let ((detected$14 ($Either.right func_typ$11))) (let ((orig$15 (let ((self9 f0)) (case (get self9 0) ('Kind.Term.var (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) orig$5))) ('Kind.Term.ref (let ((f9 (get self9 1))) orig$5)) ('Kind.Term.typ orig$5) ('Kind.Term.all (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) orig$5)))))) ('Kind.Term.lam (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) orig$5))) ('Kind.Term.app (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) orig$5))) ('Kind.Term.let (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) orig$5)))) ('Kind.Term.def (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) orig$5)))) ('Kind.Term.ann (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) orig$5)))) ('Kind.Term.gol (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) orig$5)))) ('Kind.Term.hol (let ((f9 (get self9 1))) orig$5)) ('Kind.Term.nat (let ((f9 (get self9 1))) orig$5)) ('Kind.Term.chr (let ((f9 (get self9 1))) orig$5)) ('Kind.Term.str (let ((f9 (get self9 1))) orig$5)) ('Kind.Term.num (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) orig$5)))) ('Kind.Term.cse (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) (let ((f14 (get self9 6))) orig$5))))))) ('Kind.Term.new (let ((f9 (get self9 1))) orig$5)) ('Kind.Term.get (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) orig$5))) ('Kind.Term.set (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) orig$5)))) ('Kind.Term.ope (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) orig$5)))) ('Kind.Term.ori (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) ($Maybe.some f9)))))))) ($Kind.Check.result type$1 ($List.cons ($Kind.Error.type_mismatch orig$15 expected$13 detected$14 ctx$3) List.nil))))))) ('Kind.Term.nat (let ((f6 (get self6 1))) (let ((expected$13 ($Either.left "function"))) (let ((detected$14 ($Either.right func_typ$11))) (let ((orig$15 (let ((self9 f0)) (case (get self9 0) ('Kind.Term.var (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) orig$5))) ('Kind.Term.ref (let ((f9 (get self9 1))) orig$5)) ('Kind.Term.typ orig$5) ('Kind.Term.all (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) orig$5)))))) ('Kind.Term.lam (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) orig$5))) ('Kind.Term.app (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) orig$5))) ('Kind.Term.let (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) orig$5)))) ('Kind.Term.def (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) orig$5)))) ('Kind.Term.ann (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) orig$5)))) ('Kind.Term.gol (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) orig$5)))) ('Kind.Term.hol (let ((f9 (get self9 1))) orig$5)) ('Kind.Term.nat (let ((f9 (get self9 1))) orig$5)) ('Kind.Term.chr (let ((f9 (get self9 1))) orig$5)) ('Kind.Term.str (let ((f9 (get self9 1))) orig$5)) ('Kind.Term.num (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) orig$5)))) ('Kind.Term.cse (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) (let ((f14 (get self9 6))) orig$5))))))) ('Kind.Term.new (let ((f9 (get self9 1))) orig$5)) ('Kind.Term.get (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) orig$5))) ('Kind.Term.set (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) orig$5)))) ('Kind.Term.ope (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) orig$5)))) ('Kind.Term.ori (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) ($Maybe.some f9)))))))) ($Kind.Check.result type$1 ($List.cons ($Kind.Error.type_mismatch orig$15 expected$13 detected$14 ctx$3) List.nil))))))) ('Kind.Term.chr (let ((f6 (get self6 1))) (let ((expected$13 ($Either.left "function"))) (let ((detected$14 ($Either.right func_typ$11))) (let ((orig$15 (let ((self9 f0)) (case (get self9 0) ('Kind.Term.var (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) orig$5))) ('Kind.Term.ref (let ((f9 (get self9 1))) orig$5)) ('Kind.Term.typ orig$5) ('Kind.Term.all (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) orig$5)))))) ('Kind.Term.lam (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) orig$5))) ('Kind.Term.app (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) orig$5))) ('Kind.Term.let (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) orig$5)))) ('Kind.Term.def (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) orig$5)))) ('Kind.Term.ann (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) orig$5)))) ('Kind.Term.gol (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) orig$5)))) ('Kind.Term.hol (let ((f9 (get self9 1))) orig$5)) ('Kind.Term.nat (let ((f9 (get self9 1))) orig$5)) ('Kind.Term.chr (let ((f9 (get self9 1))) orig$5)) ('Kind.Term.str (let ((f9 (get self9 1))) orig$5)) ('Kind.Term.num (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) orig$5)))) ('Kind.Term.cse (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) (let ((f14 (get self9 6))) orig$5))))))) ('Kind.Term.new (let ((f9 (get self9 1))) orig$5)) ('Kind.Term.get (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) orig$5))) ('Kind.Term.set (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) orig$5)))) ('Kind.Term.ope (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) orig$5)))) ('Kind.Term.ori (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) ($Maybe.some f9)))))))) ($Kind.Check.result type$1 ($List.cons ($Kind.Error.type_mismatch orig$15 expected$13 detected$14 ctx$3) List.nil))))))) ('Kind.Term.str (let ((f6 (get self6 1))) (let ((expected$13 ($Either.left "function"))) (let ((detected$14 ($Either.right func_typ$11))) (let ((orig$15 (let ((self9 f0)) (case (get self9 0) ('Kind.Term.var (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) orig$5))) ('Kind.Term.ref (let ((f9 (get self9 1))) orig$5)) ('Kind.Term.typ orig$5) ('Kind.Term.all (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) orig$5)))))) ('Kind.Term.lam (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) orig$5))) ('Kind.Term.app (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) orig$5))) ('Kind.Term.let (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) orig$5)))) ('Kind.Term.def (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) orig$5)))) ('Kind.Term.ann (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) orig$5)))) ('Kind.Term.gol (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) orig$5)))) ('Kind.Term.hol (let ((f9 (get self9 1))) orig$5)) ('Kind.Term.nat (let ((f9 (get self9 1))) orig$5)) ('Kind.Term.chr (let ((f9 (get self9 1))) orig$5)) ('Kind.Term.str (let ((f9 (get self9 1))) orig$5)) ('Kind.Term.num (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) orig$5)))) ('Kind.Term.cse (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) (let ((f14 (get self9 6))) orig$5))))))) ('Kind.Term.new (let ((f9 (get self9 1))) orig$5)) ('Kind.Term.get (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) orig$5))) ('Kind.Term.set (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) orig$5)))) ('Kind.Term.ope (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) orig$5)))) ('Kind.Term.ori (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) ($Maybe.some f9)))))))) ($Kind.Check.result type$1 ($List.cons ($Kind.Error.type_mismatch orig$15 expected$13 detected$14 ctx$3) List.nil))))))) ('Kind.Term.num (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((f8 (get self6 3))) (let ((expected$15 ($Either.left "function"))) (let ((detected$16 ($Either.right func_typ$11))) (let ((orig$17 (let ((self11 f0)) (case (get self11 0) ('Kind.Term.var (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) orig$5))) ('Kind.Term.ref (let ((f11 (get self11 1))) orig$5)) ('Kind.Term.typ orig$5) ('Kind.Term.all (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) (let ((f13 (get self11 3))) (let ((f14 (get self11 4))) (let ((f15 (get self11 5))) orig$5)))))) ('Kind.Term.lam (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) orig$5))) ('Kind.Term.app (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) orig$5))) ('Kind.Term.let (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) (let ((f13 (get self11 3))) orig$5)))) ('Kind.Term.def (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) (let ((f13 (get self11 3))) orig$5)))) ('Kind.Term.ann (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) (let ((f13 (get self11 3))) orig$5)))) ('Kind.Term.gol (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) (let ((f13 (get self11 3))) orig$5)))) ('Kind.Term.hol (let ((f11 (get self11 1))) orig$5)) ('Kind.Term.nat (let ((f11 (get self11 1))) orig$5)) ('Kind.Term.chr (let ((f11 (get self11 1))) orig$5)) ('Kind.Term.str (let ((f11 (get self11 1))) orig$5)) ('Kind.Term.num (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) (let ((f13 (get self11 3))) orig$5)))) ('Kind.Term.cse (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) (let ((f13 (get self11 3))) (let ((f14 (get self11 4))) (let ((f15 (get self11 5))) (let ((f16 (get self11 6))) orig$5))))))) ('Kind.Term.new (let ((f11 (get self11 1))) orig$5)) ('Kind.Term.get (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) orig$5))) ('Kind.Term.set (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) (let ((f13 (get self11 3))) orig$5)))) ('Kind.Term.ope (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) (let ((f13 (get self11 3))) orig$5)))) ('Kind.Term.ori (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) ($Maybe.some f11)))))))) ($Kind.Check.result type$1 ($List.cons ($Kind.Error.type_mismatch orig$17 expected$15 detected$16 ctx$3) List.nil))))))))) ('Kind.Term.cse (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((f8 (get self6 3))) (let ((f9 (get self6 4))) (let ((f10 (get self6 5))) (let ((f11 (get self6 6))) (let ((expected$18 ($Either.left "function"))) (let ((detected$19 ($Either.right func_typ$11))) (let ((orig$20 (let ((self14 f0)) (case (get self14 0) ('Kind.Term.var (let ((f14 (get self14 1))) (let ((f15 (get self14 2))) orig$5))) ('Kind.Term.ref (let ((f14 (get self14 1))) orig$5)) ('Kind.Term.typ orig$5) ('Kind.Term.all (let ((f14 (get self14 1))) (let ((f15 (get self14 2))) (let ((f16 (get self14 3))) (let ((f17 (get self14 4))) (let ((f18 (get self14 5))) orig$5)))))) ('Kind.Term.lam (let ((f14 (get self14 1))) (let ((f15 (get self14 2))) orig$5))) ('Kind.Term.app (let ((f14 (get self14 1))) (let ((f15 (get self14 2))) orig$5))) ('Kind.Term.let (let ((f14 (get self14 1))) (let ((f15 (get self14 2))) (let ((f16 (get self14 3))) orig$5)))) ('Kind.Term.def (let ((f14 (get self14 1))) (let ((f15 (get self14 2))) (let ((f16 (get self14 3))) orig$5)))) ('Kind.Term.ann (let ((f14 (get self14 1))) (let ((f15 (get self14 2))) (let ((f16 (get self14 3))) orig$5)))) ('Kind.Term.gol (let ((f14 (get self14 1))) (let ((f15 (get self14 2))) (let ((f16 (get self14 3))) orig$5)))) ('Kind.Term.hol (let ((f14 (get self14 1))) orig$5)) ('Kind.Term.nat (let ((f14 (get self14 1))) orig$5)) ('Kind.Term.chr (let ((f14 (get self14 1))) orig$5)) ('Kind.Term.str (let ((f14 (get self14 1))) orig$5)) ('Kind.Term.num (let ((f14 (get self14 1))) (let ((f15 (get self14 2))) (let ((f16 (get self14 3))) orig$5)))) ('Kind.Term.cse (let ((f14 (get self14 1))) (let ((f15 (get self14 2))) (let ((f16 (get self14 3))) (let ((f17 (get self14 4))) (let ((f18 (get self14 5))) (let ((f19 (get self14 6))) orig$5))))))) ('Kind.Term.new (let ((f14 (get self14 1))) orig$5)) ('Kind.Term.get (let ((f14 (get self14 1))) (let ((f15 (get self14 2))) orig$5))) ('Kind.Term.set (let ((f14 (get self14 1))) (let ((f15 (get self14 2))) (let ((f16 (get self14 3))) orig$5)))) ('Kind.Term.ope (let ((f14 (get self14 1))) (let ((f15 (get self14 2))) (let ((f16 (get self14 3))) orig$5)))) ('Kind.Term.ori (let ((f14 (get self14 1))) (let ((f15 (get self14 2))) ($Maybe.some f14)))))))) ($Kind.Check.result type$1 ($List.cons ($Kind.Error.type_mismatch orig$20 expected$18 detected$19 ctx$3) List.nil)))))))))))) ('Kind.Term.new (let ((f6 (get self6 1))) (let ((expected$13 ($Either.left "function"))) (let ((detected$14 ($Either.right func_typ$11))) (let ((orig$15 (let ((self9 f0)) (case (get self9 0) ('Kind.Term.var (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) orig$5))) ('Kind.Term.ref (let ((f9 (get self9 1))) orig$5)) ('Kind.Term.typ orig$5) ('Kind.Term.all (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) orig$5)))))) ('Kind.Term.lam (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) orig$5))) ('Kind.Term.app (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) orig$5))) ('Kind.Term.let (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) orig$5)))) ('Kind.Term.def (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) orig$5)))) ('Kind.Term.ann (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) orig$5)))) ('Kind.Term.gol (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) orig$5)))) ('Kind.Term.hol (let ((f9 (get self9 1))) orig$5)) ('Kind.Term.nat (let ((f9 (get self9 1))) orig$5)) ('Kind.Term.chr (let ((f9 (get self9 1))) orig$5)) ('Kind.Term.str (let ((f9 (get self9 1))) orig$5)) ('Kind.Term.num (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) orig$5)))) ('Kind.Term.cse (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) (let ((f14 (get self9 6))) orig$5))))))) ('Kind.Term.new (let ((f9 (get self9 1))) orig$5)) ('Kind.Term.get (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) orig$5))) ('Kind.Term.set (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) orig$5)))) ('Kind.Term.ope (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) orig$5)))) ('Kind.Term.ori (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) ($Maybe.some f9)))))))) ($Kind.Check.result type$1 ($List.cons ($Kind.Error.type_mismatch orig$15 expected$13 detected$14 ctx$3) List.nil))))))) ('Kind.Term.get (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((expected$14 ($Either.left "function"))) (let ((detected$15 ($Either.right func_typ$11))) (let ((orig$16 (let ((self10 f0)) (case (get self10 0) ('Kind.Term.var (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) orig$5))) ('Kind.Term.ref (let ((f10 (get self10 1))) orig$5)) ('Kind.Term.typ orig$5) ('Kind.Term.all (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) (let ((f13 (get self10 4))) (let ((f14 (get self10 5))) orig$5)))))) ('Kind.Term.lam (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) orig$5))) ('Kind.Term.app (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) orig$5))) ('Kind.Term.let (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) orig$5)))) ('Kind.Term.def (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) orig$5)))) ('Kind.Term.ann (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) orig$5)))) ('Kind.Term.gol (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) orig$5)))) ('Kind.Term.hol (let ((f10 (get self10 1))) orig$5)) ('Kind.Term.nat (let ((f10 (get self10 1))) orig$5)) ('Kind.Term.chr (let ((f10 (get self10 1))) orig$5)) ('Kind.Term.str (let ((f10 (get self10 1))) orig$5)) ('Kind.Term.num (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) orig$5)))) ('Kind.Term.cse (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) (let ((f13 (get self10 4))) (let ((f14 (get self10 5))) (let ((f15 (get self10 6))) orig$5))))))) ('Kind.Term.new (let ((f10 (get self10 1))) orig$5)) ('Kind.Term.get (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) orig$5))) ('Kind.Term.set (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) orig$5)))) ('Kind.Term.ope (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) orig$5)))) ('Kind.Term.ori (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) ($Maybe.some f10)))))))) ($Kind.Check.result type$1 ($List.cons ($Kind.Error.type_mismatch orig$16 expected$14 detected$15 ctx$3) List.nil)))))))) ('Kind.Term.set (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((f8 (get self6 3))) (let ((expected$15 ($Either.left "function"))) (let ((detected$16 ($Either.right func_typ$11))) (let ((orig$17 (let ((self11 f0)) (case (get self11 0) ('Kind.Term.var (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) orig$5))) ('Kind.Term.ref (let ((f11 (get self11 1))) orig$5)) ('Kind.Term.typ orig$5) ('Kind.Term.all (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) (let ((f13 (get self11 3))) (let ((f14 (get self11 4))) (let ((f15 (get self11 5))) orig$5)))))) ('Kind.Term.lam (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) orig$5))) ('Kind.Term.app (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) orig$5))) ('Kind.Term.let (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) (let ((f13 (get self11 3))) orig$5)))) ('Kind.Term.def (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) (let ((f13 (get self11 3))) orig$5)))) ('Kind.Term.ann (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) (let ((f13 (get self11 3))) orig$5)))) ('Kind.Term.gol (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) (let ((f13 (get self11 3))) orig$5)))) ('Kind.Term.hol (let ((f11 (get self11 1))) orig$5)) ('Kind.Term.nat (let ((f11 (get self11 1))) orig$5)) ('Kind.Term.chr (let ((f11 (get self11 1))) orig$5)) ('Kind.Term.str (let ((f11 (get self11 1))) orig$5)) ('Kind.Term.num (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) (let ((f13 (get self11 3))) orig$5)))) ('Kind.Term.cse (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) (let ((f13 (get self11 3))) (let ((f14 (get self11 4))) (let ((f15 (get self11 5))) (let ((f16 (get self11 6))) orig$5))))))) ('Kind.Term.new (let ((f11 (get self11 1))) orig$5)) ('Kind.Term.get (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) orig$5))) ('Kind.Term.set (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) (let ((f13 (get self11 3))) orig$5)))) ('Kind.Term.ope (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) (let ((f13 (get self11 3))) orig$5)))) ('Kind.Term.ori (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) ($Maybe.some f11)))))))) ($Kind.Check.result type$1 ($List.cons ($Kind.Error.type_mismatch orig$17 expected$15 detected$16 ctx$3) List.nil))))))))) ('Kind.Term.ope (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((f8 (get self6 3))) (let ((expected$15 ($Either.left "function"))) (let ((detected$16 ($Either.right func_typ$11))) (let ((orig$17 (let ((self11 f0)) (case (get self11 0) ('Kind.Term.var (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) orig$5))) ('Kind.Term.ref (let ((f11 (get self11 1))) orig$5)) ('Kind.Term.typ orig$5) ('Kind.Term.all (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) (let ((f13 (get self11 3))) (let ((f14 (get self11 4))) (let ((f15 (get self11 5))) orig$5)))))) ('Kind.Term.lam (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) orig$5))) ('Kind.Term.app (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) orig$5))) ('Kind.Term.let (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) (let ((f13 (get self11 3))) orig$5)))) ('Kind.Term.def (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) (let ((f13 (get self11 3))) orig$5)))) ('Kind.Term.ann (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) (let ((f13 (get self11 3))) orig$5)))) ('Kind.Term.gol (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) (let ((f13 (get self11 3))) orig$5)))) ('Kind.Term.hol (let ((f11 (get self11 1))) orig$5)) ('Kind.Term.nat (let ((f11 (get self11 1))) orig$5)) ('Kind.Term.chr (let ((f11 (get self11 1))) orig$5)) ('Kind.Term.str (let ((f11 (get self11 1))) orig$5)) ('Kind.Term.num (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) (let ((f13 (get self11 3))) orig$5)))) ('Kind.Term.cse (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) (let ((f13 (get self11 3))) (let ((f14 (get self11 4))) (let ((f15 (get self11 5))) (let ((f16 (get self11 6))) orig$5))))))) ('Kind.Term.new (let ((f11 (get self11 1))) orig$5)) ('Kind.Term.get (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) orig$5))) ('Kind.Term.set (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) (let ((f13 (get self11 3))) orig$5)))) ('Kind.Term.ope (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) (let ((f13 (get self11 3))) orig$5)))) ('Kind.Term.ori (let ((f11 (get self11 1))) (let ((f12 (get self11 2))) ($Maybe.some f11)))))))) ($Kind.Check.result type$1 ($List.cons ($Kind.Error.type_mismatch orig$17 expected$15 detected$16 ctx$3) List.nil))))))))) ('Kind.Term.ori (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((expected$14 ($Either.left "function"))) (let ((detected$15 ($Either.right func_typ$11))) (let ((orig$16 (let ((self10 f0)) (case (get self10 0) ('Kind.Term.var (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) orig$5))) ('Kind.Term.ref (let ((f10 (get self10 1))) orig$5)) ('Kind.Term.typ orig$5) ('Kind.Term.all (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) (let ((f13 (get self10 4))) (let ((f14 (get self10 5))) orig$5)))))) ('Kind.Term.lam (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) orig$5))) ('Kind.Term.app (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) orig$5))) ('Kind.Term.let (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) orig$5)))) ('Kind.Term.def (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) orig$5)))) ('Kind.Term.ann (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) orig$5)))) ('Kind.Term.gol (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) orig$5)))) ('Kind.Term.hol (let ((f10 (get self10 1))) orig$5)) ('Kind.Term.nat (let ((f10 (get self10 1))) orig$5)) ('Kind.Term.chr (let ((f10 (get self10 1))) orig$5)) ('Kind.Term.str (let ((f10 (get self10 1))) orig$5)) ('Kind.Term.num (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) orig$5)))) ('Kind.Term.cse (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) (let ((f13 (get self10 4))) (let ((f14 (get self10 5))) (let ((f15 (get self10 6))) orig$5))))))) ('Kind.Term.new (let ((f10 (get self10 1))) orig$5)) ('Kind.Term.get (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) orig$5))) ('Kind.Term.set (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) orig$5)))) ('Kind.Term.ope (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((f12 (get self10 3))) orig$5)))) ('Kind.Term.ori (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) ($Maybe.some f10)))))))) ($Kind.Check.result type$1 ($List.cons ($Kind.Error.type_mismatch orig$16 expected$14 detected$15 ctx$3) List.nil)))))))))))) (case (get self6 0) ('Kind.Check.result (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) ($Kind.Check.result f6 ($List.concat f3 f7)))))))))))))))))))) ('Kind.Term.let (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((ctx_size$9 ($List.length ctx$3))) (let ((self4 ($Kind.Term.check f1 Maybe.none defs$2 ctx$3 ($Kind.Path.Maybe.Builder.o path$4) orig$5))) (case (get self4 0) ('Kind.Check.result (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((self6 f4)) (case (get self6 0) ('Maybe.none ($Kind.Check.result Maybe.none f5)) ('Maybe.some (let ((f6 (get self6 1))) (let ((body_val$13 (f2 ($Kind.Term.var f0 ctx_size$9)))) (let ((body_ctx$14 ($List.cons ($Pair.new f0 f6) ctx$3))) (let ((self9 (let ((self9 ($Kind.Term.check body_val$13 type$1 defs$2 body_ctx$14 ($Kind.Path.Maybe.Builder.i path$4) orig$5))) (case (get self9 0) ('Kind.Check.result (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((self11 f9)) (case (get self11 0) ('Maybe.none ($Kind.Check.result Maybe.none f10)) ('Maybe.some (let ((f11 (get self11 1))) (let ((self12 ($Kind.Check.result ($Maybe.some f11) List.nil))) (case (get self12 0) ('Kind.Check.result (let ((f12 (get self12 1))) (let ((f13 (get self12 2))) ($Kind.Check.result f12 ($List.concat f10 f13)))))))))))))))))) (case (get self9 0) ('Kind.Check.result (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) ($Kind.Check.result f9 ($List.concat f5 f10))))))))))))))))))))))) ('Kind.Term.def (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((ctx_size$9 ($List.length ctx$3))) (let ((self4 ($Kind.Term.check f1 Maybe.none defs$2 ctx$3 ($Kind.Path.Maybe.Builder.o path$4) orig$5))) (case (get self4 0) ('Kind.Check.result (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((self6 f4)) (case (get self6 0) ('Maybe.none ($Kind.Check.result Maybe.none f5)) ('Maybe.some (let ((f6 (get self6 1))) (let ((body_val$13 (f2 f1))) (let ((body_ctx$14 ($List.cons ($Pair.new f0 f6) ctx$3))) (let ((self9 (let ((self9 ($Kind.Term.check body_val$13 type$1 defs$2 body_ctx$14 ($Kind.Path.Maybe.Builder.i path$4) orig$5))) (case (get self9 0) ('Kind.Check.result (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((self11 f9)) (case (get self11 0) ('Maybe.none ($Kind.Check.result Maybe.none f10)) ('Maybe.some (let ((f11 (get self11 1))) (let ((self12 ($Kind.Check.result ($Maybe.some f11) List.nil))) (case (get self12 0) ('Kind.Check.result (let ((f12 (get self12 1))) (let ((f13 (get self12 2))) ($Kind.Check.result f12 ($List.concat f10 f13)))))))))))))))))) (case (get self9 0) ('Kind.Check.result (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) ($Kind.Check.result f9 ($List.concat f5 f10))))))))))))))))))))))) ('Kind.Term.ann (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((self3 f0)) (case self3 (#t ($Kind.Check.result ($Maybe.some f2) List.nil)) (#f (let ((self3 ($Kind.Term.check f1 ($Maybe.some f2) defs$2 ctx$3 ($Kind.Path.Maybe.Builder.o path$4) orig$5))) (case (get self3 0) ('Kind.Check.result (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((self5 f3)) (case (get self5 0) ('Maybe.none ($Kind.Check.result Maybe.none f4)) ('Maybe.some (let ((f5 (get self5 1))) (let ((self6 (let ((self6 ($Kind.Term.check f2 ($Maybe.some Kind.Term.typ) defs$2 ctx$3 ($Kind.Path.Maybe.Builder.i path$4) orig$5))) (case (get self6 0) ('Kind.Check.result (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((self8 f6)) (case (get self8 0) ('Maybe.none ($Kind.Check.result Maybe.none f7)) ('Maybe.some (let ((f8 (get self8 1))) (let ((self9 ($Kind.Check.result ($Maybe.some f2) List.nil))) (case (get self9 0) ('Kind.Check.result (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) ($Kind.Check.result f9 ($List.concat f7 f10)))))))))))))))))) (case (get self6 0) ('Kind.Check.result (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) ($Kind.Check.result f6 ($List.concat f4 f7))))))))))))))))))))))) ('Kind.Term.gol (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) ($Kind.Check.result type$1 ($List.cons ($Kind.Error.show_goal f0 f1 f2 type$1 ctx$3) List.nil)))))) ('Kind.Term.hol (let ((f0 (get self0 1))) ($Kind.Check.result type$1 List.nil))) ('Kind.Term.nat (let ((f0 (get self0 1))) (let ((self1 type$1)) (case (get self1 0) ('Maybe.none ($Kind.Term.check.direct ($Kind.Term.ref "Nat") defs$2)) ('Maybe.some (let ((f1 (get self1 1))) (let ((tnam$8 ($Kind.Term.check.get_name_of_self_type f1 defs$2))) (let ((self3 tnam$8)) (case (get self3 0) ('Maybe.none ($Kind.Term.check.direct ($Kind.Term.ref "Nat") defs$2)) ('Maybe.some (let ((f3 (get self3 1))) (let ((self4 ($String.eql f3 "Nat"))) (case self4 (#t ($Kind.Term.check.direct ($Kind.Term.ref "Nat") defs$2)) (#f (let ((cast$10 ($Kind.Term.ref ($String.concat f3 ".from_nat")))) (let ((cast$11 ($Kind.Term.app cast$10 term$0))) ($Kind.Term.check.patch cast$11 type$1 path$4))))))))))))))))) ('Kind.Term.chr (let ((f0 (get self0 1))) ($Kind.Term.check.direct ($Kind.Term.ref "Char") defs$2))) ('Kind.Term.str (let ((f0 (get self0 1))) ($Kind.Term.check.direct ($Kind.Term.ref "String") defs$2))) ('Kind.Term.num (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((dsug$9 ($Kind.Term.check.expand.num f0 f1 f2 type$1 defs$2))) ($Kind.Term.check.patch dsug$9 type$1 path$4)))))) ('Kind.Term.cse (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((f5 (get self0 6))) (let ((expr$12 f1)) (let ((self7 ($Kind.Term.check expr$12 Maybe.none defs$2 ctx$3 ($Kind.Path.Maybe.Builder.o path$4) orig$5))) (case (get self7 0) ('Kind.Check.result (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((self9 f7)) (case (get self9 0) ('Maybe.none ($Kind.Check.result Maybe.none f8)) ('Maybe.some (let ((f9 (get self9 1))) (let ((self10 (let ((self10 ($Kind.Term.check.infer_types_of_with f3 defs$2 ctx$3 path$4 orig$5))) (case (get self10 0) ('Kind.Check.result (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) (let ((self12 f10)) (case (get self12 0) ('Maybe.none ($Kind.Check.result Maybe.none f11)) ('Maybe.some (let ((f12 (get self12 1))) (let ((dsug$19 ($Kind.Term.check.expand.cse f1 f2 f12 f4 f5 f9 type$1 defs$2 ctx$3))) (let ((self14 (let ((self14 dsug$19)) (case (get self14 0) ('Maybe.none ($Kind.Term.check.cant_infer term$0 type$1 ctx$3 orig$5)) ('Maybe.some (let ((f14 (get self14 1))) ($Kind.Term.check.patch f14 type$1 path$4))))))) (case (get self14 0) ('Kind.Check.result (let ((f14 (get self14 1))) (let ((f15 (get self14 2))) ($Kind.Check.result f14 ($List.concat f11 f15))))))))))))))))))) (case (get self10 0) ('Kind.Check.result (let ((f10 (get self10 1))) (let ((f11 (get self10 2))) ($Kind.Check.result f10 ($List.concat f8 f11)))))))))))))))))))))))) ('Kind.Term.new (let ((f0 (get self0 1))) (let ((dsug$7 ($Kind.Term.check.expand.new f0 type$1 defs$2))) (let ((self2 dsug$7)) (case (get self2 0) ('Maybe.none ($Kind.Term.check.cant_infer term$0 type$1 ctx$3 orig$5)) ('Maybe.some (let ((f2 (get self2 1))) ($Kind.Term.check.patch f2 type$1 path$4)))))))) ('Kind.Term.get (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((expr$8 f0)) (let ((self3 ($Kind.Term.check expr$8 Maybe.none defs$2 ctx$3 ($Kind.Path.Maybe.Builder.o path$4) orig$5))) (case (get self3 0) ('Kind.Check.result (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((self5 f3)) (case (get self5 0) ('Maybe.none ($Kind.Check.result Maybe.none f4)) ('Maybe.some (let ((f5 (get self5 1))) (let ((dsug$12 ($Kind.Term.check.expand.get f0 f1 f5 defs$2))) (let ((self7 (let ((self7 dsug$12)) (case (get self7 0) ('Maybe.none ($Kind.Term.check.cant_infer term$0 type$1 ctx$3 orig$5)) ('Maybe.some (let ((f7 (get self7 1))) ($Kind.Term.check.patch f7 type$1 path$4))))))) (case (get self7 0) ('Kind.Check.result (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) ($Kind.Check.result f7 ($List.concat f4 f8))))))))))))))))))))) ('Kind.Term.set (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((expr$9 f0)) (let ((self4 ($Kind.Term.check expr$9 Maybe.none defs$2 ctx$3 ($Kind.Path.Maybe.Builder.o path$4) orig$5))) (case (get self4 0) ('Kind.Check.result (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((self6 f4)) (case (get self6 0) ('Maybe.none ($Kind.Check.result Maybe.none f5)) ('Maybe.some (let ((f6 (get self6 1))) (let ((dsug$13 ($Kind.Term.check.expand.set f0 f1 f2 f6 defs$2))) (let ((self8 (let ((self8 dsug$13)) (case (get self8 0) ('Maybe.none ($Kind.Term.check.cant_infer term$0 type$1 ctx$3 orig$5)) ('Maybe.some (let ((f8 (get self8 1))) ($Kind.Term.check.patch f8 type$1 path$4))))))) (case (get self8 0) ('Kind.Check.result (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) ($Kind.Check.result f8 ($List.concat f5 f9)))))))))))))))))))))) ('Kind.Term.ope (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((otyp$9 ($Maybe.default type$1 ($Kind.Term.hol Bits.e)))) (let ((dsug$10 ($Kind.Term.check.expand.ope Bool.true f0 f1 f2 otyp$9 defs$2))) (let ((self5 dsug$10)) (case (get self5 0) ('Maybe.none (let ((self5 ($Kind.Term.check f1 Maybe.none defs$2 ctx$3 ($Kind.Path.Maybe.Builder.o path$4) orig$5))) (case (get self5 0) ('Kind.Check.result (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((self7 f5)) (case (get self7 0) ('Maybe.none ($Kind.Check.result Maybe.none f6)) ('Maybe.some (let ((f7 (get self7 1))) (let ((dsug$14 ($Kind.Term.check.expand.ope Bool.false f0 f1 f2 f7 defs$2))) (let ((self9 (let ((self9 dsug$14)) (case (get self9 0) ('Maybe.none ($Kind.Term.check.cant_infer term$0 type$1 ctx$3 orig$5)) ('Maybe.some (let ((f9 (get self9 1))) ($Kind.Term.check.patch f9 type$1 path$4))))))) (case (get self9 0) ('Kind.Check.result (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) ($Kind.Check.result f9 ($List.concat f6 f10)))))))))))))))))) ('Maybe.some (let ((f5 (get self5 1))) ($Kind.Term.check.patch f5 type$1 path$4))))))))))) ('Kind.Term.ori (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($Kind.Term.check f1 type$1 defs$2 ctx$3 path$4 ($Maybe.some f0))))))))) (case (get self0 0) ('Kind.Check.result (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((self2 f0)) (case (get self2 0) ('Maybe.none ($Kind.Check.result Maybe.none f1)) ('Maybe.some (let ((f2 (get self2 1))) (let ((self3 (let ((self3 type$1)) (case (get self3 0) ('Maybe.none ($Kind.Check.result ($Maybe.some f2) List.nil)) ('Maybe.some (let ((f3 (get self3 1))) (let ((self4 ($Kind.Term.equal.go f3 f2 defs$2 ($List.length ctx$3) ($BitsSet.mut.new Unit.new)))) (case (get self4 0) ('Kind.Check.result (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((self6 f4)) (case (get self6 0) ('Maybe.none ($Kind.Check.result Maybe.none f5)) ('Maybe.some (let ((f6 (get self6 1))) (let ((self7 (let ((self7 f6)) (case self7 (#t ($Kind.Check.result ($Maybe.some f3) List.nil)) (#f ($Kind.Check.result type$1 ($List.cons ($Kind.Error.type_mismatch orig$5 ($Either.right f3) ($Either.right f2) ctx$3) List.nil))))))) (case (get self7 0) ('Kind.Check.result (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) ($Kind.Check.result f7 ($List.concat f5 f8)))))))))))))))))))))) (case (get self3 0) ('Kind.Check.result (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) ($Kind.Check.result f3 ($List.concat f1 f4)))))))))))))))))
(define Kind.Term.check (lambda (term$0) (lambda (type$1) (lambda (defs$2) (lambda (ctx$3) (lambda (path$4) (lambda (orig$5) ($Kind.Term.check term$0 type$1 defs$2 ctx$3 path$4 orig$5))))))))
(define ($Kind.Path.patch_at.list path$1 list$2 cont$3) (let ((self0 path$1)) (case (if (eq? self0 #b1) 2 (bitwise-and self0 #b1)) (2 List.nil) (0 (let ((f0 (bitwise-arithmetic-shift-right self0 #b1))) (let ((self1 list$2)) (case (get self1 0) ('List.nil List.nil) ('List.cons (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) ($List.cons ((cont$3 f0) f1) f2)))))))) (1 (let ((f0 (bitwise-arithmetic-shift-right self0 #b1))) (let ((self1 list$2)) (case (get self1 0) ('List.nil List.nil) ('List.cons (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) ($List.cons f1 ($Kind.Path.patch_at.list f0 f2 cont$3))))))))))))
(define Kind.Path.patch_at.list (lambda (path$1) (lambda (list$2) (lambda (cont$3) ($Kind.Path.patch_at.list path$1 list$2 cont$3)))))
(define ($Kind.Term.patch_at path$0 term$1 fn$2) (let ((self0 term$1)) (case (get self0 0) ('Kind.Term.var (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((self2 path$0)) (case (if (eq? self2 #b1) 2 (bitwise-and self2 #b1)) (2 (fn$2 term$1)) (0 (let ((f2 (bitwise-arithmetic-shift-right self2 #b1))) term$1)) (1 (let ((f2 (bitwise-arithmetic-shift-right self2 #b1))) term$1))))))) ('Kind.Term.ref (let ((f0 (get self0 1))) (let ((self1 path$0)) (case (if (eq? self1 #b1) 2 (bitwise-and self1 #b1)) (2 (fn$2 term$1)) (0 (let ((f1 (bitwise-arithmetic-shift-right self1 #b1))) term$1)) (1 (let ((f1 (bitwise-arithmetic-shift-right self1 #b1))) term$1)))))) ('Kind.Term.typ (let ((self0 path$0)) (case (if (eq? self0 #b1) 2 (bitwise-and self0 #b1)) (2 (fn$2 term$1)) (0 (let ((f0 (bitwise-arithmetic-shift-right self0 #b1))) term$1)) (1 (let ((f0 (bitwise-arithmetic-shift-right self0 #b1))) term$1))))) ('Kind.Term.all (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((self5 path$0)) (case (if (eq? self5 #b1) 2 (bitwise-and self5 #b1)) (2 (fn$2 term$1)) (0 (let ((f5 (bitwise-arithmetic-shift-right self5 #b1))) ($Kind.Term.all f0 f1 f2 ($Kind.Term.patch_at f5 f3 fn$2) f4))) (1 (let ((f5 (bitwise-arithmetic-shift-right self5 #b1))) ($Kind.Term.all f0 f1 f2 f3 (lambda (s$9) (lambda (x$10) ($Kind.Term.patch_at f5 ((f4 s$9) x$10) fn$2)))))))))))))) ('Kind.Term.lam (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((self2 path$0)) (case (if (eq? self2 #b1) 2 (bitwise-and self2 #b1)) (2 (fn$2 term$1)) (0 (let ((f2 (bitwise-arithmetic-shift-right self2 #b1))) ($Kind.Term.lam f0 (lambda (x$6) ($Kind.Term.patch_at ($Bits.tail path$0) (f1 x$6) fn$2))))) (1 (let ((f2 (bitwise-arithmetic-shift-right self2 #b1))) ($Kind.Term.lam f0 (lambda (x$6) ($Kind.Term.patch_at ($Bits.tail path$0) (f1 x$6) fn$2)))))))))) ('Kind.Term.app (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((self2 path$0)) (case (if (eq? self2 #b1) 2 (bitwise-and self2 #b1)) (2 (fn$2 term$1)) (0 (let ((f2 (bitwise-arithmetic-shift-right self2 #b1))) ($Kind.Term.app ($Kind.Term.patch_at f2 f0 fn$2) f1))) (1 (let ((f2 (bitwise-arithmetic-shift-right self2 #b1))) ($Kind.Term.app f0 ($Kind.Term.patch_at f2 f1 fn$2))))))))) ('Kind.Term.let (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((self3 path$0)) (case (if (eq? self3 #b1) 2 (bitwise-and self3 #b1)) (2 (fn$2 term$1)) (0 (let ((f3 (bitwise-arithmetic-shift-right self3 #b1))) ($Kind.Term.let f0 ($Kind.Term.patch_at f3 f1 fn$2) f2))) (1 (let ((f3 (bitwise-arithmetic-shift-right self3 #b1))) ($Kind.Term.let f0 f1 (lambda (x$7) ($Kind.Term.patch_at f3 (f2 x$7) fn$2))))))))))) ('Kind.Term.def (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((self3 path$0)) (case (if (eq? self3 #b1) 2 (bitwise-and self3 #b1)) (2 (fn$2 term$1)) (0 (let ((f3 (bitwise-arithmetic-shift-right self3 #b1))) ($Kind.Term.def f0 ($Kind.Term.patch_at f3 f1 fn$2) f2))) (1 (let ((f3 (bitwise-arithmetic-shift-right self3 #b1))) ($Kind.Term.def f0 f1 (lambda (x$7) ($Kind.Term.patch_at f3 (f2 x$7) fn$2))))))))))) ('Kind.Term.ann (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((self3 path$0)) (case (if (eq? self3 #b1) 2 (bitwise-and self3 #b1)) (2 (fn$2 term$1)) (0 (let ((f3 (bitwise-arithmetic-shift-right self3 #b1))) ($Kind.Term.ann f0 ($Kind.Term.patch_at f3 f1 fn$2) f2))) (1 (let ((f3 (bitwise-arithmetic-shift-right self3 #b1))) ($Kind.Term.ann f0 f1 ($Kind.Term.patch_at f3 f2 fn$2)))))))))) ('Kind.Term.gol (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((self3 path$0)) (case (if (eq? self3 #b1) 2 (bitwise-and self3 #b1)) (2 (fn$2 term$1)) (0 (let ((f3 (bitwise-arithmetic-shift-right self3 #b1))) term$1)) (1 (let ((f3 (bitwise-arithmetic-shift-right self3 #b1))) term$1)))))))) ('Kind.Term.hol (let ((f0 (get self0 1))) (let ((self1 path$0)) (case (if (eq? self1 #b1) 2 (bitwise-and self1 #b1)) (2 (fn$2 term$1)) (0 (let ((f1 (bitwise-arithmetic-shift-right self1 #b1))) term$1)) (1 (let ((f1 (bitwise-arithmetic-shift-right self1 #b1))) term$1)))))) ('Kind.Term.nat (let ((f0 (get self0 1))) (let ((self1 path$0)) (case (if (eq? self1 #b1) 2 (bitwise-and self1 #b1)) (2 (fn$2 term$1)) (0 (let ((f1 (bitwise-arithmetic-shift-right self1 #b1))) term$1)) (1 (let ((f1 (bitwise-arithmetic-shift-right self1 #b1))) term$1)))))) ('Kind.Term.chr (let ((f0 (get self0 1))) (let ((self1 path$0)) (case (if (eq? self1 #b1) 2 (bitwise-and self1 #b1)) (2 (fn$2 term$1)) (0 (let ((f1 (bitwise-arithmetic-shift-right self1 #b1))) term$1)) (1 (let ((f1 (bitwise-arithmetic-shift-right self1 #b1))) term$1)))))) ('Kind.Term.str (let ((f0 (get self0 1))) (let ((self1 path$0)) (case (if (eq? self1 #b1) 2 (bitwise-and self1 #b1)) (2 (fn$2 term$1)) (0 (let ((f1 (bitwise-arithmetic-shift-right self1 #b1))) term$1)) (1 (let ((f1 (bitwise-arithmetic-shift-right self1 #b1))) term$1)))))) ('Kind.Term.num (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((self3 path$0)) (case (if (eq? self3 #b1) 2 (bitwise-and self3 #b1)) (2 (fn$2 term$1)) (0 (let ((f3 (bitwise-arithmetic-shift-right self3 #b1))) term$1)) (1 (let ((f3 (bitwise-arithmetic-shift-right self3 #b1))) term$1)))))))) ('Kind.Term.cse (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((f5 (get self0 6))) (let ((self6 path$0)) (case (if (eq? self6 #b1) 2 (bitwise-and self6 #b1)) (2 (fn$2 term$1)) (0 (let ((f6 (bitwise-arithmetic-shift-right self6 #b1))) ($Kind.Term.cse f0 ($Kind.Term.patch_at f6 f1 fn$2) f2 f3 f4 f5))) (1 (let ((f6 (bitwise-arithmetic-shift-right self6 #b1))) term$1))))))))))) ('Kind.Term.new (let ((f0 (get self0 1))) (let ((self1 path$0)) (case (if (eq? self1 #b1) 2 (bitwise-and self1 #b1)) (2 (fn$2 term$1)) (0 (let ((f1 (bitwise-arithmetic-shift-right self1 #b1))) ($Kind.Term.new ($Kind.Path.patch_at.list path$0 f0 (lambda (arg_path$5) (lambda (arg$6) ($Kind.Term.patch_at arg_path$5 arg$6 fn$2))))))) (1 (let ((f1 (bitwise-arithmetic-shift-right self1 #b1))) ($Kind.Term.new ($Kind.Path.patch_at.list path$0 f0 (lambda (arg_path$5) (lambda (arg$6) ($Kind.Term.patch_at arg_path$5 arg$6 fn$2))))))))))) ('Kind.Term.get (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((self2 path$0)) (case (if (eq? self2 #b1) 2 (bitwise-and self2 #b1)) (2 (fn$2 term$1)) (0 (let ((f2 (bitwise-arithmetic-shift-right self2 #b1))) ($Kind.Term.get ($Kind.Term.patch_at f2 f0 fn$2) f1))) (1 (let ((f2 (bitwise-arithmetic-shift-right self2 #b1))) ($Kind.Term.get ($Kind.Term.patch_at f2 f0 fn$2) f1)))))))) ('Kind.Term.set (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((self3 path$0)) (case (if (eq? self3 #b1) 2 (bitwise-and self3 #b1)) (2 (fn$2 term$1)) (0 (let ((f3 (bitwise-arithmetic-shift-right self3 #b1))) ($Kind.Term.set ($Kind.Term.patch_at f3 f0 fn$2) f1 f2))) (1 (let ((f3 (bitwise-arithmetic-shift-right self3 #b1))) ($Kind.Term.set f0 f1 ($Kind.Term.patch_at f3 f2 fn$2)))))))))) ('Kind.Term.ope (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((self3 path$0)) (case (if (eq? self3 #b1) 2 (bitwise-and self3 #b1)) (2 (fn$2 term$1)) (0 (let ((f3 (bitwise-arithmetic-shift-right self3 #b1))) ($Kind.Term.ope f0 ($Kind.Term.patch_at f3 f1 fn$2) f2))) (1 (let ((f3 (bitwise-arithmetic-shift-right self3 #b1))) ($Kind.Term.ope f0 f1 ($Kind.Term.patch_at f3 f2 fn$2)))))))))) ('Kind.Term.ori (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($Kind.Term.ori f0 ($Kind.Term.patch_at path$0 f1 fn$2))))))))
(define Kind.Term.patch_at (lambda (path$0) (lambda (term$1) (lambda (fn$2) ($Kind.Term.patch_at path$0 term$1 fn$2)))))
(define ($Kind.Synth.fix file$0 code$1 orig$2 name$3 term$4 type$5 isct$6 arit$7 defs$8 errs$9 fixd$10) (let ((self0 errs$9)) (case (get self0 0) ('List.nil (let ((self0 fixd$10)) (case self0 (#t (let ((type$11 ($Kind.Term.bind List.nil (lambda (x$11) ($Bits.i x$11)) type$5))) (let ((term$12 ($Kind.Term.bind List.nil (lambda (x$12) ($Bits.o x$12)) term$4))) (let ((defs$13 ($Kind.Map.set name$3 ($Kind.Def.new file$0 code$1 orig$2 name$3 term$12 type$11 isct$6 arit$7 Kind.Status.init) defs$8))) ((let ((self3 IO.monad)) (case (get self3 0) ('Monad.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) f4))))) ($Maybe.some defs$13)))))) (#f ((let ((self0 IO.monad)) (case (get self0 0) ('Monad.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) f1))))) Maybe.none))))) ('List.cons (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((self2 f0)) (case (get self2 0) ('Kind.Error.type_mismatch (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) (let ((f5 (get self2 4))) ($Kind.Synth.fix file$0 code$1 orig$2 name$3 term$4 type$5 isct$6 arit$7 defs$8 f1 fixd$10)))))) ('Kind.Error.show_goal (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) (let ((f5 (get self2 4))) (let ((f6 (get self2 5))) ($Kind.Synth.fix file$0 code$1 orig$2 name$3 term$4 type$5 isct$6 arit$7 defs$8 f1 fixd$10))))))) ('Kind.Error.waiting (let ((f2 (get self2 1))) (((let ((self3 IO.monad)) (case (get self3 0) ('Monad.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) f3))))) ($Kind.Synth.one f2 defs$8)) (lambda (new_defs$14) (let ((self4 new_defs$14)) (case (get self4 0) ('Maybe.none ($Kind.Synth.fix file$0 code$1 orig$2 name$3 term$4 type$5 isct$6 arit$7 defs$8 f1 fixd$10)) ('Maybe.some (let ((f4 (get self4 1))) ($Kind.Synth.fix file$0 code$1 orig$2 name$3 term$4 type$5 isct$6 arit$7 f4 f1 Bool.true))))))))) ('Kind.Error.indirect (let ((f2 (get self2 1))) ($Kind.Synth.fix file$0 code$1 orig$2 name$3 term$4 type$5 isct$6 arit$7 defs$8 f1 fixd$10))) ('Kind.Error.patch (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((self4 f2)) (case (if (eq? self4 #b1) 2 (bitwise-and self4 #b1)) (2 ((let ((self4 IO.monad)) (case (get self4 0) ('Monad.new (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) f5))))) Maybe.none)) (0 (let ((f4 (bitwise-arithmetic-shift-right self4 #b1))) (let ((term$16 ($Kind.Term.patch_at f4 term$4 (lambda (x$16) f3)))) ($Kind.Synth.fix file$0 code$1 orig$2 name$3 term$16 type$5 isct$6 arit$7 defs$8 f1 Bool.true)))) (1 (let ((f4 (bitwise-arithmetic-shift-right self4 #b1))) (let ((type$16 ($Kind.Term.patch_at f4 type$5 (lambda (x$16) f3)))) ($Kind.Synth.fix file$0 code$1 orig$2 name$3 term$4 type$16 isct$6 arit$7 defs$8 f1 Bool.true))))))))) ('Kind.Error.undefined_reference (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (((let ((self4 IO.monad)) (case (get self4 0) ('Monad.new (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) f4))))) ($Kind.Synth.one f3 defs$8)) (lambda (new_defs$15) (let ((self5 new_defs$15)) (case (get self5 0) ('Maybe.none ($Kind.Synth.fix file$0 code$1 orig$2 name$3 term$4 type$5 isct$6 arit$7 defs$8 f1 fixd$10)) ('Maybe.some (let ((f5 (get self5 1))) ($Kind.Synth.fix file$0 code$1 orig$2 name$3 term$4 type$5 isct$6 arit$7 f5 f1 Bool.true)))))))))) ('Kind.Error.cant_infer (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) ($Kind.Synth.fix file$0 code$1 orig$2 name$3 term$4 type$5 isct$6 arit$7 defs$8 f1 fixd$10)))))))))))))
(define Kind.Synth.fix (lambda (file$0) (lambda (code$1) (lambda (orig$2) (lambda (name$3) (lambda (term$4) (lambda (type$5) (lambda (isct$6) (lambda (arit$7) (lambda (defs$8) (lambda (errs$9) (lambda (fixd$10) ($Kind.Synth.fix file$0 code$1 orig$2 name$3 term$4 type$5 isct$6 arit$7 defs$8 errs$9 fixd$10)))))))))))))
(define ($Kind.Status.fail errors$0) (vector 'Kind.Status.fail errors$0))
(define Kind.Status.fail (lambda (errors$0) ($Kind.Status.fail errors$0)))
(define ($Kind.Synth.one name$0 defs$1) (let ((self0 ($Kind.Map.get name$0 defs$1))) (case (get self0 0) ('Maybe.none (((let ((self0 IO.monad)) (case (get self0 0) ('Monad.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) f0))))) IO.get_time) (lambda (time_a$2) (((let ((self1 IO.monad)) (case (get self1 0) ('Monad.new (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) f1))))) ($Kind.Synth.load name$0 defs$1)) (lambda (loaded$3) (let ((self2 loaded$3)) (case (get self2 0) ('Maybe.none ((let ((self2 IO.monad)) (case (get self2 0) ('Monad.new (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) f3))))) Maybe.none)) ('Maybe.some (let ((f2 (get self2 1))) (((let ((self3 IO.monad)) (case (get self3 0) ('Monad.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) f3))))) IO.get_time) (lambda (time_b$5) (((let ((self4 IO.monad)) (case (get self4 0) ('Monad.new (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) f4))))) ($Kind.Synth.one name$0 f2)) (lambda (result$6) (((let ((self5 IO.monad)) (case (get self5 0) ('Monad.new (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) f5))))) IO.get_time) (lambda (time_c$7) ((let ((self6 IO.monad)) (case (get self6 0) ('Monad.new (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) f7))))) result$6)))))))))))))))) ('Maybe.some (let ((f0 (get self0 1))) (let ((self1 f0)) (case (get self1 0) ('Kind.Def.new (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((f6 (get self1 6))) (let ((f7 (get self1 7))) (let ((f8 (get self1 8))) (let ((f9 (get self1 9))) (let ((file$12 f1)) (let ((code$13 f2)) (let ((orig$14 f3)) (let ((name$15 f4)) (let ((term$16 f5)) (let ((type$17 f6)) (let ((isct$18 f7)) (let ((arit$19 f8)) (let ((stat$20 f9)) (let ((self19 stat$20)) (case (get self19 0) ('Kind.Status.init (let ((defs$21 ($Kind.Map.set name$15 ($Kind.Def.new file$12 code$13 orig$14 name$15 term$16 type$17 isct$18 arit$19 Kind.Status.wait) defs$1))) (let ((checked$22 (let ((self20 ($Kind.Term.check type$17 ($Maybe.some Kind.Term.typ) defs$21 List.nil ($Kind.Path.Maybe.Builder.i Kind.Path.Maybe.Builder.nil) Maybe.none))) (case (get self20 0) ('Kind.Check.result (let ((f20 (get self20 1))) (let ((f21 (get self20 2))) (let ((self22 f20)) (case (get self22 0) ('Maybe.none ($Kind.Check.result Maybe.none f21)) ('Maybe.some (let ((f22 (get self22 1))) (let ((self23 (let ((self23 ($Kind.Term.check term$16 ($Maybe.some type$17) defs$21 List.nil ($Kind.Path.Maybe.Builder.o Kind.Path.Maybe.Builder.nil) Maybe.none))) (case (get self23 0) ('Kind.Check.result (let ((f23 (get self23 1))) (let ((f24 (get self23 2))) (let ((self25 f23)) (case (get self25 0) ('Maybe.none ($Kind.Check.result Maybe.none f24)) ('Maybe.some (let ((f25 (get self25 1))) (let ((self26 ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) (case (get self26 0) ('Kind.Check.result (let ((f26 (get self26 1))) (let ((f27 (get self26 2))) ($Kind.Check.result f26 ($List.concat f24 f27)))))))))))))))))) (case (get self23 0) ('Kind.Check.result (let ((f23 (get self23 1))) (let ((f24 (get self23 2))) ($Kind.Check.result f23 ($List.concat f21 f24)))))))))))))))))) (let ((self21 checked$22)) (case (get self21 0) ('Kind.Check.result (let ((f21 (get self21 1))) (let ((f22 (get self21 2))) (let ((self23 ($List.is_empty f22))) (case self23 (#t (let ((defs$25 ($Kind.Map.def file$12 code$13 orig$14 name$15 term$16 type$17 isct$18 arit$19 Bool.true defs$21))) ((let ((self24 IO.monad)) (case (get self24 0) ('Monad.new (let ((f24 (get self24 1))) (let ((f25 (get self24 2))) f25))))) ($Maybe.some defs$25)))) (#f (((let ((self23 IO.monad)) (case (get self23 0) ('Monad.new (let ((f23 (get self23 1))) (let ((f24 (get self23 2))) f23))))) ($Kind.Synth.fix file$12 code$13 orig$14 name$15 term$16 type$17 isct$18 arit$19 defs$21 f22 Bool.false)) (lambda (fixed$25) (let ((self24 fixed$25)) (case (get self24 0) ('Maybe.none (let ((stat$26 ($Kind.Status.fail f22))) (let ((defs$27 ($Kind.Map.set name$15 ($Kind.Def.new file$12 code$13 orig$14 name$15 term$16 type$17 isct$18 arit$19 stat$26) defs$21))) ((let ((self26 IO.monad)) (case (get self26 0) ('Monad.new (let ((f26 (get self26 1))) (let ((f27 (get self26 2))) f27))))) ($Maybe.some defs$27))))) ('Maybe.some (let ((f24 (get self24 1))) ($Kind.Synth.one name$15 f24)))))))))))))))))) ('Kind.Status.wait ((let ((self19 IO.monad)) (case (get self19 0) ('Monad.new (let ((f19 (get self19 1))) (let ((f20 (get self19 2))) f20))))) ($Maybe.some defs$1))) ('Kind.Status.done (let ((f19 (get self19 1))) ((let ((self20 IO.monad)) (case (get self20 0) ('Monad.new (let ((f20 (get self20 1))) (let ((f21 (get self20 2))) f21))))) ($Maybe.some defs$1)))) ('Kind.Status.fail (let ((f19 (get self19 1))) ((let ((self20 IO.monad)) (case (get self20 0) ('Monad.new (let ((f20 (get self20 1))) (let ((f21 (get self20 2))) f21))))) ($Maybe.some defs$1))))))))))))))))))))))))))))))))
(define Kind.Synth.one (lambda (name$0) (lambda (defs$1) ($Kind.Synth.one name$0 defs$1))))
(define ($BitsMap.from_list xs$1) (let ((self0 xs$1)) (case (get self0 0) ('List.nil BitsMap.new) ('List.cons (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((self2 f0)) (case (get self2 0) ('Pair.new (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) ($BitsMap.set f2 f3 ($BitsMap.from_list f1)))))))))))))
(define BitsMap.from_list (lambda (xs$1) ($BitsMap.from_list xs$1)))
(define Kind.Term.inline.names (let ((inl$0 ($List.cons "Monad.pure" ($List.cons "Monad.bind" ($List.cons "Monad.new" ($List.cons "Parser.monad" ($List.cons "Parser.bind" ($List.cons "Parser.pure" ($List.cons "Kind.Check.pure" ($List.cons "Kind.Check.bind" ($List.cons "Kind.Check.monad" ($List.cons "Kind.Check.value" ($List.cons "Kind.Check.none" List.nil))))))))))))) (let ((kvs$1 ($List.mapped inl$0 (lambda (x$1) ($Pair.new ($Kind.Name.to_bits x$1) Unit.new))))) ($BitsMap.from_list kvs$1))))
(define ($Kind.Term.inline.reduce term$0 defs$1) (let ((self0 term$0)) (case (get self0 0) ('Kind.Term.var (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) term$0))) ('Kind.Term.ref (let ((f0 (get self0 1))) (let ((inli$3 ($BitsSet.has ($Kind.Name.to_bits f0) Kind.Term.inline.names))) (let ((self2 inli$3)) (case self2 (#t (let ((self2 ($Kind.Map.get f0 defs$1))) (case (get self2 0) ('Maybe.none ($Kind.Term.ref f0)) ('Maybe.some (let ((f2 (get self2 1))) (let ((self3 f2)) (case (get self3 0) ('Kind.Def.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) (let ((f7 (get self3 5))) (let ((f8 (get self3 6))) (let ((f9 (get self3 7))) (let ((f10 (get self3 8))) (let ((f11 (get self3 9))) ($Kind.Term.inline.reduce f7 defs$1)))))))))))))))))) (#f term$0)))))) ('Kind.Term.typ term$0) ('Kind.Term.all (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) term$0)))))) ('Kind.Term.lam (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) term$0))) ('Kind.Term.app (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((func$4 ($Kind.Term.inline.reduce f0 defs$1))) (let ((self3 func$4)) (case (get self3 0) ('Kind.Term.var (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) term$0))) ('Kind.Term.ref (let ((f3 (get self3 1))) term$0)) ('Kind.Term.typ term$0) ('Kind.Term.all (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) (let ((f7 (get self3 5))) term$0)))))) ('Kind.Term.lam (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) ($Kind.Term.inline.reduce (f4 f1) defs$1)))) ('Kind.Term.app (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) term$0))) ('Kind.Term.let (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Kind.Term.let f3 f4 (lambda (x$8) ($Kind.Term.inline.reduce ($Kind.Term.app (f5 x$8) f1) defs$1))))))) ('Kind.Term.def (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) term$0)))) ('Kind.Term.ann (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) term$0)))) ('Kind.Term.gol (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) term$0)))) ('Kind.Term.hol (let ((f3 (get self3 1))) term$0)) ('Kind.Term.nat (let ((f3 (get self3 1))) term$0)) ('Kind.Term.chr (let ((f3 (get self3 1))) term$0)) ('Kind.Term.str (let ((f3 (get self3 1))) term$0)) ('Kind.Term.num (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) term$0)))) ('Kind.Term.cse (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) (let ((f7 (get self3 5))) (let ((f8 (get self3 6))) term$0))))))) ('Kind.Term.new (let ((f3 (get self3 1))) term$0)) ('Kind.Term.get (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) term$0))) ('Kind.Term.set (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) term$0)))) ('Kind.Term.ope (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) term$0)))) ('Kind.Term.ori (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) term$0))))))))) ('Kind.Term.let (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) term$0)))) ('Kind.Term.def (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) term$0)))) ('Kind.Term.ann (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) term$0)))) ('Kind.Term.gol (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) term$0)))) ('Kind.Term.hol (let ((f0 (get self0 1))) term$0)) ('Kind.Term.nat (let ((f0 (get self0 1))) term$0)) ('Kind.Term.chr (let ((f0 (get self0 1))) term$0)) ('Kind.Term.str (let ((f0 (get self0 1))) term$0)) ('Kind.Term.num (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) term$0)))) ('Kind.Term.cse (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((f5 (get self0 6))) term$0))))))) ('Kind.Term.new (let ((f0 (get self0 1))) term$0)) ('Kind.Term.get (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) term$0))) ('Kind.Term.set (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) term$0)))) ('Kind.Term.ope (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) term$0)))) ('Kind.Term.ori (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($Kind.Term.inline.reduce f1 defs$1)))))))
(define Kind.Term.inline.reduce (lambda (term$0) (lambda (defs$1) ($Kind.Term.inline.reduce term$0 defs$1))))
(define ($Kind.Term.inline term$0 defs$1) (let ((self0 ($Kind.Term.inline.reduce term$0 defs$1))) (case (get self0 0) ('Kind.Term.var (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($Kind.Term.var f0 f1)))) ('Kind.Term.ref (let ((f0 (get self0 1))) ($Kind.Term.ref f0))) ('Kind.Term.typ Kind.Term.typ) ('Kind.Term.all (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) ($Kind.Term.all f0 f1 f2 ($Kind.Term.inline f3 defs$1) (lambda (s$7) (lambda (x$8) ($Kind.Term.inline ((f4 s$7) x$8) defs$1)))))))))) ('Kind.Term.lam (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($Kind.Term.lam f0 (lambda (x$4) ($Kind.Term.inline (f1 x$4) defs$1)))))) ('Kind.Term.app (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($Kind.Term.app ($Kind.Term.inline f0 defs$1) ($Kind.Term.inline f1 defs$1))))) ('Kind.Term.let (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) ($Kind.Term.let f0 ($Kind.Term.inline f1 defs$1) (lambda (x$5) ($Kind.Term.inline (f2 x$5) defs$1))))))) ('Kind.Term.def (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) ($Kind.Term.def f0 ($Kind.Term.inline f1 defs$1) (lambda (x$5) ($Kind.Term.inline (f2 x$5) defs$1))))))) ('Kind.Term.ann (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) ($Kind.Term.ann f0 ($Kind.Term.inline f1 defs$1) ($Kind.Term.inline f2 defs$1)))))) ('Kind.Term.gol (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) ($Kind.Term.gol f0 f1 f2))))) ('Kind.Term.hol (let ((f0 (get self0 1))) ($Kind.Term.hol f0))) ('Kind.Term.nat (let ((f0 (get self0 1))) ($Kind.Term.nat f0))) ('Kind.Term.chr (let ((f0 (get self0 1))) ($Kind.Term.chr f0))) ('Kind.Term.str (let ((f0 (get self0 1))) ($Kind.Term.str f0))) ('Kind.Term.num (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) term$0)))) ('Kind.Term.cse (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((f5 (get self0 6))) term$0))))))) ('Kind.Term.new (let ((f0 (get self0 1))) term$0)) ('Kind.Term.get (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) term$0))) ('Kind.Term.set (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) term$0)))) ('Kind.Term.ope (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) term$0)))) ('Kind.Term.ori (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($Kind.Term.inline f1 defs$1)))))))
(define Kind.Term.inline (lambda (term$0) (lambda (defs$1) ($Kind.Term.inline term$0 defs$1))))
(define ($BitsMap.values.go xs$1 list$2) (let ((self0 xs$1)) (case (get self0 0) ('BitsMap.new list$2) ('BitsMap.tie (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((list0$6 (let ((self3 f0)) (case (get self3 0) ('Maybe.none list$2) ('Maybe.some (let ((f3 (get self3 1))) ($List.cons f3 list$2))))))) (let ((list1$7 ($BitsMap.values.go f1 list0$6))) (let ((list2$8 ($BitsMap.values.go f2 list1$7))) list2$8))))))))))
(define BitsMap.values.go (lambda (xs$1) (lambda (list$2) ($BitsMap.values.go xs$1 list$2))))
(define ($BitsMap.values xs$1) ($BitsMap.values.go xs$1 List.nil))
(define BitsMap.values (lambda (xs$1) ($BitsMap.values xs$1)))
(define ($Kind.Core.var_name indx$0 name$1 brui$2 vars$3) (let ((self0 indx$0)) (case (= self0 0) (#t (let ((self0 brui$2)) (case (= self0 0) (#t name$1) (#f (let ((f0 (- self0 1))) ($String.concat name$1 ($String.concat "^" ($Nat.show brui$2)))))))) (#f (let ((f0 (- self0 1))) (let ((self1 vars$3)) (case (get self1 0) ('List.nil "unbound") ('List.cons (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((brui$7 (let ((self3 ($String.eql name$1 f1))) (case self3 (#t ($Nat.succ brui$2)) (#f brui$2))))) ($Kind.Core.var_name f0 name$1 brui$7 f2))))))))))))
(define Kind.Core.var_name (lambda (indx$0) (lambda (name$1) (lambda (brui$2) (lambda (vars$3) ($Kind.Core.var_name indx$0 name$1 brui$2 vars$3))))))
(define ($Kind.Name.show name$0) name$0)
(define Kind.Name.show (lambda (name$0) ($Kind.Name.show name$0)))
(define ($Bits.to_nat b$0) (let ((self0 b$0)) (case (if (eq? self0 #b1) 2 (bitwise-and self0 #b1)) (2 0) (0 (let ((f0 (bitwise-arithmetic-shift-right self0 #b1))) ($Nat.mul 2 ($Bits.to_nat f0)))) (1 (let ((f0 (bitwise-arithmetic-shift-right self0 #b1))) ($Nat.succ ($Nat.mul 2 ($Bits.to_nat f0))))))))
(define Bits.to_nat (lambda (b$0) ($Bits.to_nat b$0)))
(define ($U16.show_hex a$0) (let ((self0 a$0)) (case #t (#t (let ((f0 (u16-to-word self0))) ($Nat.to_string_base 16 ($Bits.to_nat ($Word.to_bits f0))))))))
(define U16.show_hex (lambda (a$0) ($U16.show_hex a$0)))
(define ($Kind.Code.escape.char chr$0) (let ((self0 ($U16.eql chr$0 Kind.Code.backslash))) (case self0 (#t ($String.cons Kind.Code.backslash ($String.cons chr$0 String.nil))) (#f (let ((self0 ($U16.eql chr$0 34))) (case self0 (#t ($String.cons Kind.Code.backslash ($String.cons chr$0 String.nil))) (#f (let ((self0 ($U16.eql chr$0 39))) (case self0 (#t ($String.cons Kind.Code.backslash ($String.cons chr$0 String.nil))) (#f (let ((self0 ($U16.btw 32 chr$0 126))) (case self0 (#t ($String.cons chr$0 String.nil)) (#f ($String.concat ($String.cons Kind.Code.backslash String.nil) ($String.concat "u{" ($String.concat ($U16.show_hex chr$0) "}"))))))))))))))))
(define Kind.Code.escape.char (lambda (chr$0) ($Kind.Code.escape.char chr$0)))
(define ($Kind.Code.escape.go str$0 result$1) (let ((self0 str$0)) (case (<= (kstring-length self0) 0) (#t ($String.reverse result$1)) (#f (let ((f0 (char->integer (kstring-head self0)))) (let ((f1 (kstring-tail self0))) ($Kind.Code.escape.go f1 ($String.concat ($String.reverse ($Kind.Code.escape.char f0)) result$1))))))))
(define Kind.Code.escape.go (lambda (str$0) (lambda (result$1) ($Kind.Code.escape.go str$0 result$1))))
(define ($Kind.Code.escape str$0) ($Kind.Code.escape.go str$0 ""))
(define Kind.Code.escape (lambda (str$0) ($Kind.Code.escape str$0)))
(define ($Kind.Core.show.go term$0 indx$1 vars$2) (let ((self0 term$0)) (case (get self0 0) ('Kind.Term.var (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($Kind.Core.var_name ($Nat.pred ($Nat.sub indx$1 f1)) f0 0 vars$2)))) ('Kind.Term.ref (let ((f0 (get self0 1))) ($Kind.Name.show f0))) ('Kind.Term.typ "*") ('Kind.Term.all (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((eras$8 f0)) (let ((init$9 (let ((self6 eras$8)) (case self6 (#t "%") (#f "@"))))) (let ((self$10 ($Kind.Name.show f1))) (let ((name$11 ($Kind.Name.show f2))) (let ((xtyp$12 ($Kind.Core.show.go f3 indx$1 vars$2))) (let ((body$13 ($Kind.Core.show.go ((f4 ($Kind.Term.var f1 indx$1)) ($Kind.Term.var f2 ($Nat.succ indx$1))) ($Nat.succ ($Nat.succ indx$1)) ($List.cons f2 ($List.cons f1 vars$2))))) ($String.flatten ($List.cons init$9 ($List.cons self$10 ($List.cons "(" ($List.cons name$11 ($List.cons ":" ($List.cons xtyp$12 ($List.cons ") " ($List.cons body$13 List.nil))))))))))))))))))))) ('Kind.Term.lam (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((name$5 ($Kind.Name.show f0))) (let ((body$6 ($Kind.Core.show.go (f1 ($Kind.Term.var f0 indx$1)) ($Nat.succ indx$1) ($List.cons f0 vars$2)))) ($String.flatten ($List.cons "#" ($List.cons name$5 ($List.cons " " ($List.cons body$6 List.nil)))))))))) ('Kind.Term.app (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((func$5 ($Kind.Core.show.go f0 indx$1 vars$2))) (let ((argm$6 ($Kind.Core.show.go f1 indx$1 vars$2))) ($String.flatten ($List.cons "(" ($List.cons func$5 ($List.cons " " ($List.cons argm$6 ($List.cons ")" List.nil))))))))))) ('Kind.Term.let (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((name$6 ($Kind.Name.show f0))) (let ((expr$7 ($Kind.Core.show.go f1 indx$1 vars$2))) (let ((body$8 ($Kind.Core.show.go (f2 ($Kind.Term.var f0 indx$1)) ($Nat.succ indx$1) ($List.cons f0 vars$2)))) ($String.flatten ($List.cons "!" ($List.cons name$6 ($List.cons " = " ($List.cons expr$7 ($List.cons "; " ($List.cons body$8 List.nil)))))))))))))) ('Kind.Term.def (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((name$6 ($Kind.Name.show f0))) (let ((expr$7 ($Kind.Core.show.go f1 indx$1 vars$2))) (let ((body$8 ($Kind.Core.show.go (f2 ($Kind.Term.var f0 indx$1)) ($Nat.succ indx$1) ($List.cons f0 vars$2)))) ($String.flatten ($List.cons "$" ($List.cons name$6 ($List.cons " = " ($List.cons expr$7 ($List.cons "; " ($List.cons body$8 List.nil)))))))))))))) ('Kind.Term.ann (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((term$6 ($Kind.Core.show.go f1 indx$1 vars$2))) (let ((type$7 ($Kind.Core.show.go f2 indx$1 vars$2))) ($String.flatten ($List.cons "{" ($List.cons term$6 ($List.cons ":" ($List.cons type$7 ($List.cons "}" List.nil)))))))))))) ('Kind.Term.gol (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) "*")))) ('Kind.Term.hol (let ((f0 (get self0 1))) "*")) ('Kind.Term.nat (let ((f0 (get self0 1))) ($String.flatten ($List.cons "+" ($List.cons ($Nat.show f0) List.nil))))) ('Kind.Term.chr (let ((f0 (get self0 1))) ($String.flatten ($List.cons "'" ($List.cons ($Kind.Code.escape.char f0) ($List.cons "'" List.nil)))))) ('Kind.Term.str (let ((f0 (get self0 1))) ($String.flatten ($List.cons "\"" ($List.cons ($Kind.Code.escape f0) ($List.cons "\"" List.nil)))))) ('Kind.Term.num (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) "*")))) ('Kind.Term.cse (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((f5 (get self0 6))) "*"))))))) ('Kind.Term.new (let ((f0 (get self0 1))) "*")) ('Kind.Term.get (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) "*"))) ('Kind.Term.set (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) "*")))) ('Kind.Term.ope (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) "*")))) ('Kind.Term.ori (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($Kind.Core.show.go f1 indx$1 vars$2)))))))
(define Kind.Core.show.go (lambda (term$0) (lambda (indx$1) (lambda (vars$2) ($Kind.Core.show.go term$0 indx$1 vars$2)))))
(define ($Kind.Core.show term$0) ($Kind.Core.show.go term$0 0 List.nil))
(define Kind.Core.show (lambda (term$0) ($Kind.Core.show term$0)))
(define ($Kind.Defs.core defs$0) (let ((result$1 "")) (let ((result$2 ($List.for ($BitsMap.values defs$0) result$1 (lambda (defn$2) (lambda (result$3) (let ((self3 defn$2)) (case (get self3 0) ('Kind.Def.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) (let ((f7 (get self3 5))) (let ((f8 (get self3 6))) (let ((f9 (get self3 7))) (let ((f10 (get self3 8))) (let ((f11 (get self3 9))) (let ((self12 f11)) (case (get self12 0) ('Kind.Status.init result$3) ('Kind.Status.wait result$3) ('Kind.Status.done (let ((f12 (get self12 1))) (let ((name$14 f6)) (let ((term$15 ($Kind.Core.show f7))) (let ((type$16 ($Kind.Core.show f8))) ($String.flatten ($List.cons result$3 ($List.cons name$14 ($List.cons " : " ($List.cons type$16 ($List.cons " = " ($List.cons term$15 ($List.cons ";\xa;" List.nil))))))))))))) ('Kind.Status.fail (let ((f12 (get self12 1))) result$3))))))))))))))))))))) result$2)))
(define Kind.Defs.core (lambda (defs$0) ($Kind.Defs.core defs$0)))
(define ($Kind.api.io.term_to_core name$0) (((let ((self0 IO.monad)) (case (get self0 0) ('Monad.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) f0))))) ($Kind.Synth.one name$0 Kind.Map.new)) (lambda (new_defs$1) (let ((defs$2 (let ((self1 new_defs$1)) (case (get self1 0) ('Maybe.none Kind.Map.new) ('Maybe.some (let ((f1 (get self1 1))) f1)))))) (let ((defs$3 ($BitsMap.map (lambda (defn$3) (let ((self3 defn$3)) (case (get self3 0) ('Kind.Def.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) (let ((f7 (get self3 5))) (let ((f8 (get self3 6))) (let ((f9 (get self3 7))) (let ((f10 (get self3 8))) (let ((f11 (get self3 9))) (let ((term$13 ($Kind.Term.inline f7 defs$2))) (let ((type$14 ($Kind.Term.inline f8 defs$2))) ($Kind.Def.new f3 f4 f5 f6 term$13 type$14 f9 f10 f11)))))))))))))))) defs$2))) ((let ((self3 IO.monad)) (case (get self3 0) ('Monad.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) f4))))) ($Kind.Defs.core defs$3)))))))
(define Kind.api.io.term_to_core (lambda (name$0) ($Kind.api.io.term_to_core name$0)))
(define ($Kind.Comp.Defs.compile.defn.adjust defn$0 defs$1) (let ((self0 defn$0)) (case (get self0 0) ('Kind.Def.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((f5 (get self0 6))) (let ((f6 (get self0 7))) (let ((f7 (get self0 8))) (let ((f8 (get self0 9))) (let ((term$11 ($Kind.Term.inline f4 defs$1))) (let ((type$12 ($Kind.Term.inline f5 defs$1))) ($Kind.Def.new f0 f1 f2 f3 term$11 type$12 f6 f7 f8))))))))))))))))
(define Kind.Comp.Defs.compile.defn.adjust (lambda (defn$0) (lambda (defs$1) ($Kind.Comp.Defs.compile.defn.adjust defn$0 defs$1))))
(define ($Kind.Comp.var name$0) (vector 'Kind.Comp.var name$0))
(define Kind.Comp.var (lambda (name$0) ($Kind.Comp.var name$0)))
(define Kind.Comp.nil (vector 'Kind.Comp.nil))
(define ($Kind.Comp.ref name$0) (vector 'Kind.Comp.ref name$0))
(define Kind.Comp.ref (lambda (name$0) ($Kind.Comp.ref name$0)))
(define Kind.Comp.Prim.bool (vector 'Kind.Comp.Prim.bool))
(define Kind.Comp.Prim.nat (vector 'Kind.Comp.Prim.nat))
(define Kind.Comp.Prim.bits (vector 'Kind.Comp.Prim.bits))
(define Kind.Comp.Prim.u16 (vector 'Kind.Comp.Prim.u16))
(define Kind.Comp.Prim.u32 (vector 'Kind.Comp.Prim.u32))
(define Kind.Comp.Prim.string (vector 'Kind.Comp.Prim.string))
(define Kind.Comp.Prim.natives ($List.cons ($Pair.new "Bool" Kind.Comp.Prim.bool) ($List.cons ($Pair.new "Nat" Kind.Comp.Prim.nat) ($List.cons ($Pair.new "Bits" Kind.Comp.Prim.bits) ($List.cons ($Pair.new "U16" Kind.Comp.Prim.u16) ($List.cons ($Pair.new "U32" Kind.Comp.Prim.u32) ($List.cons ($Pair.new "String" Kind.Comp.Prim.string) List.nil)))))))
(define ($Kind.Term.equal a$0 b$1 defs$2) (let ((self0 ($Kind.Term.equal.go a$0 b$1 defs$2 0 BitsSet.new))) (case (get self0 0) ('Kind.Check.result (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($Maybe.default f0 Bool.false)))))))
(define Kind.Term.equal (lambda (a$0) (lambda (b$1) (lambda (defs$2) ($Kind.Term.equal a$0 b$1 defs$2)))))
(define ($Kind.Comp.compile.prim_of type$0 defs$1) (let ((result$2 Maybe.none)) (let ((result$3 ($List.for Kind.Comp.Prim.natives result$2 (lambda (prim$3) (lambda (result$4) (let ((self3 prim$3)) (case (get self3 0) ('Pair.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((self5 result$4)) (case (get self5 0) ('Maybe.none (let ((self5 ($Kind.Term.equal type$0 ($Kind.Term.ref f3) defs$1))) (case self5 (#t ($Maybe.some f4)) (#f Maybe.none)))) ('Maybe.some (let ((f5 (get self5 1))) result$4)))))))))))))) result$3)))
(define Kind.Comp.compile.prim_of (lambda (type$0) (lambda (defs$1) ($Kind.Comp.compile.prim_of type$0 defs$1))))
(define ($String.ends_with xs$0 match$1) (let ((xs_reserved$2 ($String.reverse xs$0))) (let ((match_reversed$3 ($String.reverse match$1))) ($String.starts_with xs_reserved$2 match_reversed$3))))
(define String.ends_with (lambda (xs$0) (lambda (match$1) ($String.ends_with xs$0 match$1))))
(define ($Kind.Comp.compile.adt.get_fields term$0) (let ((self0 term$0)) (case (get self0 0) ('Kind.Term.var (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) List.nil))) ('Kind.Term.ref (let ((f0 (get self0 1))) List.nil)) ('Kind.Term.typ List.nil) ('Kind.Term.all (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((head$6 f2)) (let ((tail$7 ($Kind.Comp.compile.adt.get_fields ((f4 ($Kind.Term.var "" 0)) ($Kind.Term.var "" 0))))) (let ((self7 f0)) (case self7 (#t tail$7) (#f ($List.cons head$6 tail$7)))))))))))) ('Kind.Term.lam (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) List.nil))) ('Kind.Term.app (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) List.nil))) ('Kind.Term.let (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) List.nil)))) ('Kind.Term.def (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) List.nil)))) ('Kind.Term.ann (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) List.nil)))) ('Kind.Term.gol (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) List.nil)))) ('Kind.Term.hol (let ((f0 (get self0 1))) List.nil)) ('Kind.Term.nat (let ((f0 (get self0 1))) List.nil)) ('Kind.Term.chr (let ((f0 (get self0 1))) List.nil)) ('Kind.Term.str (let ((f0 (get self0 1))) List.nil)) ('Kind.Term.num (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) List.nil)))) ('Kind.Term.cse (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((f5 (get self0 6))) List.nil))))))) ('Kind.Term.new (let ((f0 (get self0 1))) List.nil)) ('Kind.Term.get (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) List.nil))) ('Kind.Term.set (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) List.nil)))) ('Kind.Term.ope (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) List.nil)))) ('Kind.Term.ori (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) List.nil))))))
(define Kind.Comp.compile.adt.get_fields (lambda (term$0) ($Kind.Comp.compile.adt.get_fields term$0)))
(define ($Kind.Comp.compile.adt.get_constructors term$0) (let ((self0 term$0)) (case (get self0 0) ('Kind.Term.var (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) List.nil))) ('Kind.Term.ref (let ((f0 (get self0 1))) List.nil)) ('Kind.Term.typ List.nil) ('Kind.Term.all (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((tail$6 ($Kind.Comp.compile.adt.get_constructors ((f4 ($Kind.Term.var "" 0)) ($Kind.Term.var "" 0))))) (let ((name$7 f2)) (let ((flds$8 ($Kind.Comp.compile.adt.get_fields f3))) ($List.cons ($Pair.new name$7 flds$8) tail$6)))))))))) ('Kind.Term.lam (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) List.nil))) ('Kind.Term.app (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) List.nil))) ('Kind.Term.let (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) List.nil)))) ('Kind.Term.def (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) List.nil)))) ('Kind.Term.ann (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) List.nil)))) ('Kind.Term.gol (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) List.nil)))) ('Kind.Term.hol (let ((f0 (get self0 1))) List.nil)) ('Kind.Term.nat (let ((f0 (get self0 1))) List.nil)) ('Kind.Term.chr (let ((f0 (get self0 1))) List.nil)) ('Kind.Term.str (let ((f0 (get self0 1))) List.nil)) ('Kind.Term.num (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) List.nil)))) ('Kind.Term.cse (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((f5 (get self0 6))) List.nil))))))) ('Kind.Term.new (let ((f0 (get self0 1))) List.nil)) ('Kind.Term.get (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) List.nil))) ('Kind.Term.set (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) List.nil)))) ('Kind.Term.ope (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) List.nil)))) ('Kind.Term.ori (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) List.nil))))))
(define Kind.Comp.compile.adt.get_constructors (lambda (term$0) ($Kind.Comp.compile.adt.get_constructors term$0)))
(define ($Kind.Comp.Prim.data name$0 ctrs$1) (vector 'Kind.Comp.Prim.data name$0 ctrs$1))
(define Kind.Comp.Prim.data (lambda (name$0) (lambda (ctrs$1) ($Kind.Comp.Prim.data name$0 ctrs$1))))
(define ($Kind.Comp.compile.adt term$0 defs$1) (let ((term$2 ($Kind.Term.reduce term$0 defs$1))) (let ((self1 term$2)) (case (get self1 0) ('Kind.Term.var (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) Maybe.none))) ('Kind.Term.ref (let ((f1 (get self1 1))) Maybe.none)) ('Kind.Term.typ Maybe.none) ('Kind.Term.all (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((self6 ($String.ends_with f2 ".Self"))) (case self6 (#t (let ((body$8 ((f5 ($Kind.Term.var "" 0)) ($Kind.Term.var "" 0)))) (let ((data$9 ($Kind.Comp.compile.adt.get_constructors body$8))) (let ((name$10 ($String.take ($Nat.sub ($String.length f2) 5) f2))) ($Maybe.some ($Kind.Comp.Prim.data name$10 data$9)))))) (#f Maybe.none))))))))) ('Kind.Term.lam (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) Maybe.none))) ('Kind.Term.app (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) Maybe.none))) ('Kind.Term.let (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) Maybe.none)))) ('Kind.Term.def (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) Maybe.none)))) ('Kind.Term.ann (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) Maybe.none)))) ('Kind.Term.gol (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) Maybe.none)))) ('Kind.Term.hol (let ((f1 (get self1 1))) Maybe.none)) ('Kind.Term.nat (let ((f1 (get self1 1))) Maybe.none)) ('Kind.Term.chr (let ((f1 (get self1 1))) Maybe.none)) ('Kind.Term.str (let ((f1 (get self1 1))) Maybe.none)) ('Kind.Term.num (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) Maybe.none)))) ('Kind.Term.cse (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((f6 (get self1 6))) Maybe.none))))))) ('Kind.Term.new (let ((f1 (get self1 1))) Maybe.none)) ('Kind.Term.get (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) Maybe.none))) ('Kind.Term.set (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) Maybe.none)))) ('Kind.Term.ope (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) Maybe.none)))) ('Kind.Term.ori (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) Maybe.none)))))))
(define Kind.Comp.compile.adt (lambda (term$0) (lambda (defs$1) ($Kind.Comp.compile.adt term$0 defs$1))))
(define ($Kind.Comp.eli prim$0 expr$1) (vector 'Kind.Comp.eli prim$0 expr$1))
(define Kind.Comp.eli (lambda (prim$0) (lambda (expr$1) ($Kind.Comp.eli prim$0 expr$1))))
(define ($Kind.Comp.app func$0 argm$1) (vector 'Kind.Comp.app func$0 argm$1))
(define Kind.Comp.app (lambda (func$0) (lambda (argm$1) ($Kind.Comp.app func$0 argm$1))))
(define ($Kind.Comp.let name$0 expr$1 body$2) (vector 'Kind.Comp.let name$0 expr$1 body$2))
(define Kind.Comp.let (lambda (name$0) (lambda (expr$1) (lambda (body$2) ($Kind.Comp.let name$0 expr$1 body$2)))))
(define ($Kind.Comp.nat natx$0) (vector 'Kind.Comp.nat natx$0))
(define Kind.Comp.nat (lambda (natx$0) ($Kind.Comp.nat natx$0)))
(define ($Kind.Comp.chr chrx$0) (vector 'Kind.Comp.chr chrx$0))
(define Kind.Comp.chr (lambda (chrx$0) ($Kind.Comp.chr chrx$0)))
(define ($Kind.Comp.str strx$0) (vector 'Kind.Comp.str strx$0))
(define Kind.Comp.str (lambda (strx$0) ($Kind.Comp.str strx$0)))
(define ($Kind.Comp.lam name$0 body$1) (vector 'Kind.Comp.lam name$0 body$1))
(define Kind.Comp.lam (lambda (name$0) (lambda (body$1) ($Kind.Comp.lam name$0 body$1))))
(define ($Kind.Comp.ins prim$0 expr$1) (vector 'Kind.Comp.ins prim$0 expr$1))
(define Kind.Comp.ins (lambda (prim$0) (lambda (expr$1) ($Kind.Comp.ins prim$0 expr$1))))
(define ($Kind.Comp.compile term$0 type$1 defs$2 size$3) (let ((self0 type$1)) (case (get self0 0) ('Maybe.none (let ((self0 term$0)) (case (get self0 0) ('Kind.Term.var (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($Pair.new ($Kind.Comp.var f0) ($Kind.Term.var f0 f1))))) ('Kind.Term.ref (let ((f0 (get self0 1))) (let ((self1 ($Kind.Map.get f0 defs$2))) (case (get self1 0) ('Maybe.none ($Pair.new Kind.Comp.nil Kind.Term.typ)) ('Maybe.some (let ((f1 (get self1 1))) ($Pair.new ($Kind.Comp.ref f0) (let ((self2 f1)) (case (get self2 0) ('Kind.Def.new (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) (let ((f5 (get self2 4))) (let ((f6 (get self2 5))) (let ((f7 (get self2 6))) (let ((f8 (get self2 7))) (let ((f9 (get self2 8))) (let ((f10 (get self2 9))) f7))))))))))))))))))) ('Kind.Term.typ ($Pair.new Kind.Comp.nil Kind.Term.typ)) ('Kind.Term.all (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) ($Pair.new Kind.Comp.nil Kind.Term.typ))))))) ('Kind.Term.lam (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($Pair.new Kind.Comp.nil Kind.Term.typ)))) ('Kind.Term.app (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((self2 ($Kind.Comp.compile f0 Maybe.none defs$2 size$3))) (case (get self2 0) ('Pair.new (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((self4 ($Kind.Term.reduce f3 defs$2))) (case (get self4 0) ('Kind.Term.var (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) ($Pair.new Kind.Comp.nil Kind.Term.typ)))) ('Kind.Term.ref (let ((f4 (get self4 1))) ($Pair.new Kind.Comp.nil Kind.Term.typ))) ('Kind.Term.typ ($Pair.new Kind.Comp.nil Kind.Term.typ)) ('Kind.Term.all (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((f6 (get self4 3))) (let ((f7 (get self4 4))) (let ((f8 (get self4 5))) (let ((self9 ($Kind.Comp.compile f1 ($Maybe.some f7) defs$2 size$3))) (case (get self9 0) ('Pair.new (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((term_typ$15 ((f8 f0) f1))) (let ((term_cmp$16 (let ((self12 ($Kind.Comp.compile.prim_of f3 defs$2))) (case (get self12 0) ('Maybe.none (let ((self12 ($Kind.Comp.compile.adt f3 defs$2))) (case (get self12 0) ('Maybe.none f2) ('Maybe.some (let ((f12 (get self12 1))) ($Kind.Comp.eli f12 f2)))))) ('Maybe.some (let ((f12 (get self12 1))) ($Kind.Comp.eli f12 f2))))))) (let ((term_cmp$17 (let ((self13 f4)) (case self13 (#t term_cmp$16) (#f ($Kind.Comp.app term_cmp$16 f9)))))) ($Pair.new term_cmp$17 term_typ$15))))))))))))))) ('Kind.Term.lam (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) ($Pair.new Kind.Comp.nil Kind.Term.typ)))) ('Kind.Term.app (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) ($Pair.new Kind.Comp.nil Kind.Term.typ)))) ('Kind.Term.let (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((f6 (get self4 3))) ($Pair.new Kind.Comp.nil Kind.Term.typ))))) ('Kind.Term.def (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((f6 (get self4 3))) ($Pair.new Kind.Comp.nil Kind.Term.typ))))) ('Kind.Term.ann (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((f6 (get self4 3))) ($Pair.new Kind.Comp.nil Kind.Term.typ))))) ('Kind.Term.gol (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((f6 (get self4 3))) ($Pair.new Kind.Comp.nil Kind.Term.typ))))) ('Kind.Term.hol (let ((f4 (get self4 1))) ($Pair.new Kind.Comp.nil Kind.Term.typ))) ('Kind.Term.nat (let ((f4 (get self4 1))) ($Pair.new Kind.Comp.nil Kind.Term.typ))) ('Kind.Term.chr (let ((f4 (get self4 1))) ($Pair.new Kind.Comp.nil Kind.Term.typ))) ('Kind.Term.str (let ((f4 (get self4 1))) ($Pair.new Kind.Comp.nil Kind.Term.typ))) ('Kind.Term.num (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((f6 (get self4 3))) ($Pair.new Kind.Comp.nil Kind.Term.typ))))) ('Kind.Term.cse (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((f6 (get self4 3))) (let ((f7 (get self4 4))) (let ((f8 (get self4 5))) (let ((f9 (get self4 6))) ($Pair.new Kind.Comp.nil Kind.Term.typ)))))))) ('Kind.Term.new (let ((f4 (get self4 1))) ($Pair.new Kind.Comp.nil Kind.Term.typ))) ('Kind.Term.get (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) ($Pair.new Kind.Comp.nil Kind.Term.typ)))) ('Kind.Term.set (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((f6 (get self4 3))) ($Pair.new Kind.Comp.nil Kind.Term.typ))))) ('Kind.Term.ope (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((f6 (get self4 3))) ($Pair.new Kind.Comp.nil Kind.Term.typ))))) ('Kind.Term.ori (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) ($Pair.new Kind.Comp.nil Kind.Term.typ)))))))))))))) ('Kind.Term.let (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((self3 ($Kind.Comp.compile f1 Maybe.none defs$2 size$3))) (case (get self3 0) ('Pair.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((name_uid$9 ($String.concat f0 ($String.concat "$" ($Nat.show size$3))))) (let ((expr_var$10 ($Kind.Term.ann Bool.true ($Kind.Term.var name_uid$9 ($Nat.add size$3 1)) f4))) (let ((self7 ($Kind.Comp.compile (f2 expr_var$10) Maybe.none defs$2 ($Nat.add size$3 1)))) (case (get self7 0) ('Pair.new (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) ($Pair.new ($Kind.Comp.let name_uid$9 f3 f7) f8))))))))))))))))) ('Kind.Term.def (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) ($Kind.Comp.compile (f2 f1) Maybe.none defs$2 size$3))))) ('Kind.Term.ann (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) ($Kind.Comp.compile f1 ($Maybe.some f2) defs$2 size$3))))) ('Kind.Term.gol (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) ($Pair.new Kind.Comp.nil Kind.Term.typ))))) ('Kind.Term.hol (let ((f0 (get self0 1))) ($Pair.new Kind.Comp.nil Kind.Term.typ))) ('Kind.Term.nat (let ((f0 (get self0 1))) ($Pair.new ($Kind.Comp.nat f0) ($Kind.Term.ref "Nat")))) ('Kind.Term.chr (let ((f0 (get self0 1))) ($Pair.new ($Kind.Comp.chr f0) ($Kind.Term.ref "Char")))) ('Kind.Term.str (let ((f0 (get self0 1))) ($Pair.new ($Kind.Comp.str f0) ($Kind.Term.ref "String")))) ('Kind.Term.num (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) ($Pair.new Kind.Comp.nil Kind.Term.typ))))) ('Kind.Term.cse (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((f5 (get self0 6))) ($Pair.new Kind.Comp.nil Kind.Term.typ)))))))) ('Kind.Term.new (let ((f0 (get self0 1))) ($Pair.new Kind.Comp.nil Kind.Term.typ))) ('Kind.Term.get (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($Pair.new Kind.Comp.nil Kind.Term.typ)))) ('Kind.Term.set (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) ($Pair.new Kind.Comp.nil Kind.Term.typ))))) ('Kind.Term.ope (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) ($Pair.new Kind.Comp.nil Kind.Term.typ))))) ('Kind.Term.ori (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($Kind.Comp.compile f1 Maybe.none defs$2 size$3))))))) ('Maybe.some (let ((f0 (get self0 1))) (let ((typv$5 ($Kind.Term.reduce f0 defs$2))) (let ((self2 term$0)) (case (get self2 0) ('Kind.Term.var (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((self4 typv$5)) (case (get self4 0) ('Kind.Term.var (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))) ('Kind.Term.ref (let ((f4 (get self4 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.typ ($Pair.new Kind.Comp.nil Kind.Term.typ)) ('Kind.Term.all (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((f6 (get self4 3))) (let ((f7 (get self4 4))) (let ((f8 (get self4 5))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))))) ('Kind.Term.lam (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))) ('Kind.Term.app (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))) ('Kind.Term.let (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((f6 (get self4 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.def (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((f6 (get self4 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.ann (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((f6 (get self4 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.gol (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((f6 (get self4 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.hol (let ((f4 (get self4 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.nat (let ((f4 (get self4 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.chr (let ((f4 (get self4 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.str (let ((f4 (get self4 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.num (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((f6 (get self4 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.cse (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((f6 (get self4 3))) (let ((f7 (get self4 4))) (let ((f8 (get self4 5))) (let ((f9 (get self4 6))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))))))) ('Kind.Term.new (let ((f4 (get self4 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.get (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))) ('Kind.Term.set (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((f6 (get self4 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.ope (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((f6 (get self4 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.ori (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))))))) ('Kind.Term.ref (let ((f2 (get self2 1))) (let ((self3 typv$5)) (case (get self3 0) ('Kind.Term.var (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))) ('Kind.Term.ref (let ((f3 (get self3 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.typ ($Pair.new Kind.Comp.nil Kind.Term.typ)) ('Kind.Term.all (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) (let ((f7 (get self3 5))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))))) ('Kind.Term.lam (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))) ('Kind.Term.app (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))) ('Kind.Term.let (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.def (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.ann (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.gol (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.hol (let ((f3 (get self3 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.nat (let ((f3 (get self3 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.chr (let ((f3 (get self3 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.str (let ((f3 (get self3 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.num (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.cse (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) (let ((f7 (get self3 5))) (let ((f8 (get self3 6))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))))))) ('Kind.Term.new (let ((f3 (get self3 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.get (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))) ('Kind.Term.set (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.ope (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.ori (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))))))) ('Kind.Term.typ (let ((self2 typv$5)) (case (get self2 0) ('Kind.Term.var (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))) ('Kind.Term.ref (let ((f2 (get self2 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.typ ($Pair.new Kind.Comp.nil Kind.Term.typ)) ('Kind.Term.all (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) (let ((f5 (get self2 4))) (let ((f6 (get self2 5))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))))) ('Kind.Term.lam (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))) ('Kind.Term.app (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))) ('Kind.Term.let (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.def (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.ann (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.gol (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.hol (let ((f2 (get self2 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.nat (let ((f2 (get self2 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.chr (let ((f2 (get self2 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.str (let ((f2 (get self2 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.num (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.cse (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) (let ((f5 (get self2 4))) (let ((f6 (get self2 5))) (let ((f7 (get self2 6))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))))))) ('Kind.Term.new (let ((f2 (get self2 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.get (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))) ('Kind.Term.set (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.ope (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.ori (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))))) ('Kind.Term.all (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) (let ((f5 (get self2 4))) (let ((f6 (get self2 5))) (let ((self7 typv$5)) (case (get self7 0) ('Kind.Term.var (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))) ('Kind.Term.ref (let ((f7 (get self7 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.typ ($Pair.new Kind.Comp.nil Kind.Term.typ)) ('Kind.Term.all (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((f9 (get self7 3))) (let ((f10 (get self7 4))) (let ((f11 (get self7 5))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))))) ('Kind.Term.lam (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))) ('Kind.Term.app (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))) ('Kind.Term.let (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((f9 (get self7 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.def (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((f9 (get self7 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.ann (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((f9 (get self7 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.gol (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((f9 (get self7 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.hol (let ((f7 (get self7 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.nat (let ((f7 (get self7 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.chr (let ((f7 (get self7 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.str (let ((f7 (get self7 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.num (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((f9 (get self7 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.cse (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((f9 (get self7 3))) (let ((f10 (get self7 4))) (let ((f11 (get self7 5))) (let ((f12 (get self7 6))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))))))) ('Kind.Term.new (let ((f7 (get self7 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.get (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))) ('Kind.Term.set (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((f9 (get self7 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.ope (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((f9 (get self7 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.ori (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))))))))))) ('Kind.Term.lam (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((self4 typv$5)) (case (get self4 0) ('Kind.Term.var (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) ($Pair.new Kind.Comp.nil Kind.Term.typ)))) ('Kind.Term.ref (let ((f4 (get self4 1))) ($Pair.new Kind.Comp.nil Kind.Term.typ))) ('Kind.Term.typ ($Pair.new Kind.Comp.nil Kind.Term.typ)) ('Kind.Term.all (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((f6 (get self4 3))) (let ((f7 (get self4 4))) (let ((f8 (get self4 5))) (let ((self_var$13 ($Kind.Term.ann Bool.true term$0 f0))) (let ((name_uid$14 ($String.concat f2 ($String.concat "$" ($Nat.show size$3))))) (let ((name_var$15 ($Kind.Term.ann Bool.true ($Kind.Term.var name_uid$14 ($Nat.add size$3 1)) f7))) (let ((body_typ$16 ((f8 self_var$13) name_var$15))) (let ((self13 ($Kind.Comp.compile (f3 name_var$15) ($Maybe.some body_typ$16) defs$2 ($Nat.add size$3 1)))) (case (get self13 0) ('Pair.new (let ((f13 (get self13 1))) (let ((f14 (get self13 2))) (let ((term_cmp$19 (let ((self15 f4)) (case self15 (#t f13) (#f ($Kind.Comp.lam name_uid$14 f13)))))) (let ((term_cmp$20 (let ((self16 ($Kind.Comp.compile.prim_of f0 defs$2))) (case (get self16 0) ('Maybe.none (let ((self16 ($Kind.Comp.compile.adt f0 defs$2))) (case (get self16 0) ('Maybe.none term_cmp$19) ('Maybe.some (let ((f16 (get self16 1))) ($Kind.Comp.ins f16 term_cmp$19)))))) ('Maybe.some (let ((f16 (get self16 1))) ($Kind.Comp.ins f16 term_cmp$19))))))) ($Pair.new term_cmp$20 f0)))))))))))))))))) ('Kind.Term.lam (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) ($Pair.new Kind.Comp.nil Kind.Term.typ)))) ('Kind.Term.app (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) ($Pair.new Kind.Comp.nil Kind.Term.typ)))) ('Kind.Term.let (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((f6 (get self4 3))) ($Pair.new Kind.Comp.nil Kind.Term.typ))))) ('Kind.Term.def (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((f6 (get self4 3))) ($Pair.new Kind.Comp.nil Kind.Term.typ))))) ('Kind.Term.ann (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((f6 (get self4 3))) ($Pair.new Kind.Comp.nil Kind.Term.typ))))) ('Kind.Term.gol (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((f6 (get self4 3))) ($Pair.new Kind.Comp.nil Kind.Term.typ))))) ('Kind.Term.hol (let ((f4 (get self4 1))) ($Pair.new Kind.Comp.nil Kind.Term.typ))) ('Kind.Term.nat (let ((f4 (get self4 1))) ($Pair.new Kind.Comp.nil Kind.Term.typ))) ('Kind.Term.chr (let ((f4 (get self4 1))) ($Pair.new Kind.Comp.nil Kind.Term.typ))) ('Kind.Term.str (let ((f4 (get self4 1))) ($Pair.new Kind.Comp.nil Kind.Term.typ))) ('Kind.Term.num (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((f6 (get self4 3))) ($Pair.new Kind.Comp.nil Kind.Term.typ))))) ('Kind.Term.cse (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((f6 (get self4 3))) (let ((f7 (get self4 4))) (let ((f8 (get self4 5))) (let ((f9 (get self4 6))) ($Pair.new Kind.Comp.nil Kind.Term.typ)))))))) ('Kind.Term.new (let ((f4 (get self4 1))) ($Pair.new Kind.Comp.nil Kind.Term.typ))) ('Kind.Term.get (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) ($Pair.new Kind.Comp.nil Kind.Term.typ)))) ('Kind.Term.set (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((f6 (get self4 3))) ($Pair.new Kind.Comp.nil Kind.Term.typ))))) ('Kind.Term.ope (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((f6 (get self4 3))) ($Pair.new Kind.Comp.nil Kind.Term.typ))))) ('Kind.Term.ori (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) ($Pair.new Kind.Comp.nil Kind.Term.typ))))))))) ('Kind.Term.app (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((self4 typv$5)) (case (get self4 0) ('Kind.Term.var (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))) ('Kind.Term.ref (let ((f4 (get self4 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.typ ($Pair.new Kind.Comp.nil Kind.Term.typ)) ('Kind.Term.all (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((f6 (get self4 3))) (let ((f7 (get self4 4))) (let ((f8 (get self4 5))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))))) ('Kind.Term.lam (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))) ('Kind.Term.app (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))) ('Kind.Term.let (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((f6 (get self4 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.def (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((f6 (get self4 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.ann (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((f6 (get self4 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.gol (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((f6 (get self4 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.hol (let ((f4 (get self4 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.nat (let ((f4 (get self4 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.chr (let ((f4 (get self4 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.str (let ((f4 (get self4 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.num (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((f6 (get self4 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.cse (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((f6 (get self4 3))) (let ((f7 (get self4 4))) (let ((f8 (get self4 5))) (let ((f9 (get self4 6))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))))))) ('Kind.Term.new (let ((f4 (get self4 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.get (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))) ('Kind.Term.set (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((f6 (get self4 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.ope (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((f6 (get self4 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.ori (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))))))) ('Kind.Term.let (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) (let ((self5 ($Kind.Comp.compile f3 Maybe.none defs$2 size$3))) (case (get self5 0) ('Pair.new (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((name_uid$11 ($String.concat f2 ($String.concat "$" ($Nat.show size$3))))) (let ((expr_var$12 ($Kind.Term.ann Bool.true ($Kind.Term.var name_uid$11 ($Nat.add size$3 1)) f6))) (let ((self9 ($Kind.Comp.compile (f4 expr_var$12) type$1 defs$2 ($Nat.add size$3 1)))) (case (get self9 0) ('Pair.new (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((term_cmp$15 ($Kind.Comp.let name_uid$11 f5 f9))) (let ((term_typ$16 f10)) ($Pair.new term_cmp$15 term_typ$16))))))))))))))))))) ('Kind.Term.def (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) (let ((self5 typv$5)) (case (get self5 0) ('Kind.Term.var (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))) ('Kind.Term.ref (let ((f5 (get self5 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.typ ($Pair.new Kind.Comp.nil Kind.Term.typ)) ('Kind.Term.all (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) (let ((f8 (get self5 4))) (let ((f9 (get self5 5))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))))) ('Kind.Term.lam (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))) ('Kind.Term.app (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))) ('Kind.Term.let (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.def (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.ann (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.gol (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.hol (let ((f5 (get self5 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.nat (let ((f5 (get self5 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.chr (let ((f5 (get self5 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.str (let ((f5 (get self5 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.num (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.cse (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) (let ((f8 (get self5 4))) (let ((f9 (get self5 5))) (let ((f10 (get self5 6))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))))))) ('Kind.Term.new (let ((f5 (get self5 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.get (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))) ('Kind.Term.set (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.ope (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.ori (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))))))))) ('Kind.Term.ann (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) (let ((self5 typv$5)) (case (get self5 0) ('Kind.Term.var (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))) ('Kind.Term.ref (let ((f5 (get self5 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.typ ($Pair.new Kind.Comp.nil Kind.Term.typ)) ('Kind.Term.all (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) (let ((f8 (get self5 4))) (let ((f9 (get self5 5))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))))) ('Kind.Term.lam (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))) ('Kind.Term.app (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))) ('Kind.Term.let (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.def (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.ann (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.gol (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.hol (let ((f5 (get self5 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.nat (let ((f5 (get self5 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.chr (let ((f5 (get self5 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.str (let ((f5 (get self5 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.num (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.cse (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) (let ((f8 (get self5 4))) (let ((f9 (get self5 5))) (let ((f10 (get self5 6))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))))))) ('Kind.Term.new (let ((f5 (get self5 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.get (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))) ('Kind.Term.set (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.ope (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.ori (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))))))))) ('Kind.Term.gol (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) (let ((self5 typv$5)) (case (get self5 0) ('Kind.Term.var (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))) ('Kind.Term.ref (let ((f5 (get self5 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.typ ($Pair.new Kind.Comp.nil Kind.Term.typ)) ('Kind.Term.all (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) (let ((f8 (get self5 4))) (let ((f9 (get self5 5))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))))) ('Kind.Term.lam (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))) ('Kind.Term.app (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))) ('Kind.Term.let (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.def (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.ann (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.gol (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.hol (let ((f5 (get self5 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.nat (let ((f5 (get self5 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.chr (let ((f5 (get self5 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.str (let ((f5 (get self5 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.num (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.cse (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) (let ((f8 (get self5 4))) (let ((f9 (get self5 5))) (let ((f10 (get self5 6))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))))))) ('Kind.Term.new (let ((f5 (get self5 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.get (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))) ('Kind.Term.set (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.ope (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.ori (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))))))))) ('Kind.Term.hol (let ((f2 (get self2 1))) (let ((self3 typv$5)) (case (get self3 0) ('Kind.Term.var (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))) ('Kind.Term.ref (let ((f3 (get self3 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.typ ($Pair.new Kind.Comp.nil Kind.Term.typ)) ('Kind.Term.all (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) (let ((f7 (get self3 5))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))))) ('Kind.Term.lam (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))) ('Kind.Term.app (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))) ('Kind.Term.let (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.def (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.ann (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.gol (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.hol (let ((f3 (get self3 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.nat (let ((f3 (get self3 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.chr (let ((f3 (get self3 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.str (let ((f3 (get self3 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.num (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.cse (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) (let ((f7 (get self3 5))) (let ((f8 (get self3 6))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))))))) ('Kind.Term.new (let ((f3 (get self3 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.get (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))) ('Kind.Term.set (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.ope (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.ori (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))))))) ('Kind.Term.nat (let ((f2 (get self2 1))) (let ((self3 typv$5)) (case (get self3 0) ('Kind.Term.var (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))) ('Kind.Term.ref (let ((f3 (get self3 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.typ ($Pair.new Kind.Comp.nil Kind.Term.typ)) ('Kind.Term.all (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) (let ((f7 (get self3 5))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))))) ('Kind.Term.lam (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))) ('Kind.Term.app (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))) ('Kind.Term.let (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.def (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.ann (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.gol (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.hol (let ((f3 (get self3 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.nat (let ((f3 (get self3 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.chr (let ((f3 (get self3 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.str (let ((f3 (get self3 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.num (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.cse (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) (let ((f7 (get self3 5))) (let ((f8 (get self3 6))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))))))) ('Kind.Term.new (let ((f3 (get self3 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.get (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))) ('Kind.Term.set (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.ope (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.ori (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))))))) ('Kind.Term.chr (let ((f2 (get self2 1))) (let ((self3 typv$5)) (case (get self3 0) ('Kind.Term.var (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))) ('Kind.Term.ref (let ((f3 (get self3 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.typ ($Pair.new Kind.Comp.nil Kind.Term.typ)) ('Kind.Term.all (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) (let ((f7 (get self3 5))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))))) ('Kind.Term.lam (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))) ('Kind.Term.app (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))) ('Kind.Term.let (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.def (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.ann (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.gol (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.hol (let ((f3 (get self3 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.nat (let ((f3 (get self3 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.chr (let ((f3 (get self3 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.str (let ((f3 (get self3 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.num (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.cse (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) (let ((f7 (get self3 5))) (let ((f8 (get self3 6))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))))))) ('Kind.Term.new (let ((f3 (get self3 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.get (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))) ('Kind.Term.set (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.ope (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.ori (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))))))) ('Kind.Term.str (let ((f2 (get self2 1))) (let ((self3 typv$5)) (case (get self3 0) ('Kind.Term.var (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))) ('Kind.Term.ref (let ((f3 (get self3 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.typ ($Pair.new Kind.Comp.nil Kind.Term.typ)) ('Kind.Term.all (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) (let ((f7 (get self3 5))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))))) ('Kind.Term.lam (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))) ('Kind.Term.app (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))) ('Kind.Term.let (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.def (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.ann (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.gol (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.hol (let ((f3 (get self3 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.nat (let ((f3 (get self3 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.chr (let ((f3 (get self3 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.str (let ((f3 (get self3 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.num (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.cse (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) (let ((f7 (get self3 5))) (let ((f8 (get self3 6))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))))))) ('Kind.Term.new (let ((f3 (get self3 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.get (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))) ('Kind.Term.set (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.ope (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.ori (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))))))) ('Kind.Term.num (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) (let ((self5 typv$5)) (case (get self5 0) ('Kind.Term.var (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))) ('Kind.Term.ref (let ((f5 (get self5 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.typ ($Pair.new Kind.Comp.nil Kind.Term.typ)) ('Kind.Term.all (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) (let ((f8 (get self5 4))) (let ((f9 (get self5 5))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))))) ('Kind.Term.lam (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))) ('Kind.Term.app (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))) ('Kind.Term.let (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.def (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.ann (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.gol (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.hol (let ((f5 (get self5 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.nat (let ((f5 (get self5 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.chr (let ((f5 (get self5 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.str (let ((f5 (get self5 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.num (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.cse (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) (let ((f8 (get self5 4))) (let ((f9 (get self5 5))) (let ((f10 (get self5 6))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))))))) ('Kind.Term.new (let ((f5 (get self5 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.get (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))) ('Kind.Term.set (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.ope (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.ori (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))))))))) ('Kind.Term.cse (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) (let ((f5 (get self2 4))) (let ((f6 (get self2 5))) (let ((f7 (get self2 6))) (let ((self8 typv$5)) (case (get self8 0) ('Kind.Term.var (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))) ('Kind.Term.ref (let ((f8 (get self8 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.typ ($Pair.new Kind.Comp.nil Kind.Term.typ)) ('Kind.Term.all (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) (let ((f11 (get self8 4))) (let ((f12 (get self8 5))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))))) ('Kind.Term.lam (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))) ('Kind.Term.app (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))) ('Kind.Term.let (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.def (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.ann (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.gol (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.hol (let ((f8 (get self8 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.nat (let ((f8 (get self8 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.chr (let ((f8 (get self8 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.str (let ((f8 (get self8 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.num (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.cse (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) (let ((f11 (get self8 4))) (let ((f12 (get self8 5))) (let ((f13 (get self8 6))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))))))) ('Kind.Term.new (let ((f8 (get self8 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.get (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))) ('Kind.Term.set (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.ope (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.ori (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))))))))))) ('Kind.Term.new (let ((f2 (get self2 1))) (let ((self3 typv$5)) (case (get self3 0) ('Kind.Term.var (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))) ('Kind.Term.ref (let ((f3 (get self3 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.typ ($Pair.new Kind.Comp.nil Kind.Term.typ)) ('Kind.Term.all (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) (let ((f7 (get self3 5))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))))) ('Kind.Term.lam (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))) ('Kind.Term.app (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))) ('Kind.Term.let (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.def (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.ann (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.gol (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.hol (let ((f3 (get self3 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.nat (let ((f3 (get self3 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.chr (let ((f3 (get self3 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.str (let ((f3 (get self3 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.num (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.cse (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) (let ((f7 (get self3 5))) (let ((f8 (get self3 6))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))))))) ('Kind.Term.new (let ((f3 (get self3 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.get (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))) ('Kind.Term.set (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.ope (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.ori (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))))))) ('Kind.Term.get (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((self4 typv$5)) (case (get self4 0) ('Kind.Term.var (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))) ('Kind.Term.ref (let ((f4 (get self4 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.typ ($Pair.new Kind.Comp.nil Kind.Term.typ)) ('Kind.Term.all (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((f6 (get self4 3))) (let ((f7 (get self4 4))) (let ((f8 (get self4 5))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))))) ('Kind.Term.lam (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))) ('Kind.Term.app (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))) ('Kind.Term.let (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((f6 (get self4 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.def (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((f6 (get self4 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.ann (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((f6 (get self4 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.gol (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((f6 (get self4 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.hol (let ((f4 (get self4 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.nat (let ((f4 (get self4 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.chr (let ((f4 (get self4 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.str (let ((f4 (get self4 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.num (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((f6 (get self4 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.cse (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((f6 (get self4 3))) (let ((f7 (get self4 4))) (let ((f8 (get self4 5))) (let ((f9 (get self4 6))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))))))) ('Kind.Term.new (let ((f4 (get self4 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.get (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))) ('Kind.Term.set (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((f6 (get self4 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.ope (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((f6 (get self4 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.ori (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))))))) ('Kind.Term.set (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) (let ((self5 typv$5)) (case (get self5 0) ('Kind.Term.var (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))) ('Kind.Term.ref (let ((f5 (get self5 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.typ ($Pair.new Kind.Comp.nil Kind.Term.typ)) ('Kind.Term.all (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) (let ((f8 (get self5 4))) (let ((f9 (get self5 5))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))))) ('Kind.Term.lam (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))) ('Kind.Term.app (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))) ('Kind.Term.let (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.def (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.ann (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.gol (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.hol (let ((f5 (get self5 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.nat (let ((f5 (get self5 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.chr (let ((f5 (get self5 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.str (let ((f5 (get self5 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.num (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.cse (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) (let ((f8 (get self5 4))) (let ((f9 (get self5 5))) (let ((f10 (get self5 6))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))))))) ('Kind.Term.new (let ((f5 (get self5 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.get (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))) ('Kind.Term.set (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.ope (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.ori (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))))))))) ('Kind.Term.ope (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) (let ((self5 typv$5)) (case (get self5 0) ('Kind.Term.var (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))) ('Kind.Term.ref (let ((f5 (get self5 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.typ ($Pair.new Kind.Comp.nil Kind.Term.typ)) ('Kind.Term.all (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) (let ((f8 (get self5 4))) (let ((f9 (get self5 5))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))))) ('Kind.Term.lam (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))) ('Kind.Term.app (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))) ('Kind.Term.let (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.def (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.ann (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.gol (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.hol (let ((f5 (get self5 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.nat (let ((f5 (get self5 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.chr (let ((f5 (get self5 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.str (let ((f5 (get self5 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.num (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.cse (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) (let ((f8 (get self5 4))) (let ((f9 (get self5 5))) (let ((f10 (get self5 6))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))))))) ('Kind.Term.new (let ((f5 (get self5 1))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))) ('Kind.Term.get (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))) ('Kind.Term.set (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.ope (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0))))) ('Kind.Term.ori (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) ($Pair.new ($Pair.fst ($Kind.Comp.compile term$0 Maybe.none defs$2 size$3)) f0)))))))))) ('Kind.Term.ori (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) ($Kind.Comp.compile f3 type$1 defs$2 size$3))))))))))))
(define Kind.Comp.compile (lambda (term$0) (lambda (type$1) (lambda (defs$2) (lambda (size$3) ($Kind.Comp.compile term$0 type$1 defs$2 size$3))))))
(define ($Kind.Comp.Defs.compile.defn defn$0 defs$1) (let ((self0 defn$0)) (case (get self0 0) ('Kind.Def.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((f5 (get self0 6))) (let ((f6 (get self0 7))) (let ((f7 (get self0 8))) (let ((f8 (get self0 9))) (let ((self9 ($Kind.Comp.compile f4 ($Maybe.some f5) defs$1 0))) (case (get self9 0) ('Pair.new (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) f9))))))))))))))))))
(define Kind.Comp.Defs.compile.defn (lambda (defn$0) (lambda (defs$1) ($Kind.Comp.Defs.compile.defn defn$0 defs$1))))
(define ($Kind.Comp.Defs.compile defs$0) (let ((defs$1 ($BitsMap.map (lambda (x$1) ($Kind.Comp.Defs.compile.defn.adjust x$1 defs$0)) defs$0))) (let ((defs$2 ($BitsMap.map (lambda (x$2) ($Kind.Comp.Defs.compile.defn x$2 defs$1)) defs$1))) defs$2)))
(define Kind.Comp.Defs.compile (lambda (defs$0) ($Kind.Comp.Defs.compile defs$0)))
(define ($Kind.Comp.dependency_sort.go term$0 defs$1 seen$2 list$3) (let ((self0 term$0)) (case (get self0 0) ('Kind.Comp.nil ($Pair.new seen$2 list$3)) ('Kind.Comp.var (let ((f0 (get self0 1))) ($Pair.new seen$2 list$3))) ('Kind.Comp.ref (let ((f0 (get self0 1))) (let ((self1 ($Kind.Map.get f0 seen$2))) (case (get self1 0) ('Maybe.none (let ((self1 ($Kind.Map.get f0 defs$1))) (case (get self1 0) ('Maybe.none ($Pair.new seen$2 list$3)) ('Maybe.some (let ((f1 (get self1 1))) (let ((term$6 f1)) (let ((seen$7 ($Kind.Map.set f0 Unit.new seen$2))) (let ((self4 ($Kind.Comp.dependency_sort.go term$6 defs$1 seen$7 list$3))) (case (get self4 0) ('Pair.new (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((list$10 ($List.cons ($Pair.new f0 f1) f5))) ($Pair.new f4 list$10)))))))))))))) ('Maybe.some (let ((f1 (get self1 1))) ($Pair.new seen$2 list$3))))))) ('Kind.Comp.lam (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((self2 ($Kind.Comp.dependency_sort.go f1 defs$1 seen$2 list$3))) (case (get self2 0) ('Pair.new (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) ($Pair.new f2 f3))))))))) ('Kind.Comp.app (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((self2 ($Kind.Comp.dependency_sort.go f0 defs$1 seen$2 list$3))) (case (get self2 0) ('Pair.new (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((self4 ($Kind.Comp.dependency_sort.go f1 defs$1 f2 f3))) (case (get self4 0) ('Pair.new (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) ($Pair.new f4 f5)))))))))))))) ('Kind.Comp.let (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((self3 ($Kind.Comp.dependency_sort.go f1 defs$1 seen$2 list$3))) (case (get self3 0) ('Pair.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((self5 ($Kind.Comp.dependency_sort.go f2 defs$1 f3 f4))) (case (get self5 0) ('Pair.new (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) ($Pair.new f5 f6))))))))))))))) ('Kind.Comp.eli (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((self2 ($Kind.Comp.dependency_sort.go f1 defs$1 seen$2 list$3))) (case (get self2 0) ('Pair.new (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) ($Pair.new f2 f3))))))))) ('Kind.Comp.ins (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((self2 ($Kind.Comp.dependency_sort.go f1 defs$1 seen$2 list$3))) (case (get self2 0) ('Pair.new (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) ($Pair.new f2 f3))))))))) ('Kind.Comp.nat (let ((f0 (get self0 1))) ($Pair.new seen$2 list$3))) ('Kind.Comp.chr (let ((f0 (get self0 1))) ($Pair.new seen$2 list$3))) ('Kind.Comp.str (let ((f0 (get self0 1))) ($Pair.new seen$2 list$3))) ('Kind.Comp.txt (let ((f0 (get self0 1))) ($Pair.new seen$2 list$3))))))
(define Kind.Comp.dependency_sort.go (lambda (term$0) (lambda (defs$1) (lambda (seen$2) (lambda (list$3) ($Kind.Comp.dependency_sort.go term$0 defs$1 seen$2 list$3))))))
(define ($Kind.Comp.dependency_sort main$0 defs$1) (let ((term$2 ($Kind.Comp.ref main$0))) (let ((seen$3 Kind.Map.new)) (let ((list$4 List.nil)) (let ((self3 ($Kind.Comp.dependency_sort.go term$2 defs$1 seen$3 list$4))) (case (get self3 0) ('Pair.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) ($List.reverse f4))))))))))
(define Kind.Comp.dependency_sort (lambda (main$0) (lambda (defs$1) ($Kind.Comp.dependency_sort main$0 defs$1))))
(define ($String.take_while f$0 xs$1) (let ((self0 xs$1)) (case (<= (kstring-length self0) 0) (#t String.nil) (#f (let ((f0 (char->integer (kstring-head self0)))) (let ((f1 (kstring-tail self0))) (let ((self2 (f$0 f0))) (case self2 (#t ($String.cons f0 ($String.take_while f$0 f1))) (#f String.nil)))))))))
(define String.take_while (lambda (f$0) (lambda (xs$1) ($String.take_while f$0 xs$1))))
(define ($String.drop_while f$0 xs$1) (let ((self0 xs$1)) (case (<= (kstring-length self0) 0) (#t String.nil) (#f (let ((f0 (char->integer (kstring-head self0)))) (let ((f1 (kstring-tail self0))) (let ((self2 (f$0 f0))) (case self2 (#t ($String.drop_while f$0 f1)) (#f xs$1)))))))))
(define String.drop_while (lambda (f$0) (lambda (xs$1) ($String.drop_while f$0 xs$1))))
(define ($Kind.Comp.replace str$0 vars$1) (let ((self0 str$0)) (case (<= (kstring-length self0) 0) (#t str$0) (#f (let ((f0 (char->integer (kstring-head self0)))) (let ((f1 (kstring-tail self0))) (let ((a$4 f0)) (let ((self3 ($U16.eql a$4 36))) (case self3 (#t (let ((n_str$5 ($String.take_while (lambda (b$5) ($Bool.and ($U16.gte b$5 48) ($U16.lte b$5 57))) f1))) (let ((self4 ($Nat.gtn ($String.length n_str$5) 0))) (case self4 (#t (let ((n_str.tail$6 ($String.drop_while (lambda (b$6) ($Bool.and ($U16.gte b$6 48) ($U16.lte b$6 57))) f1))) ($String.concat ($Maybe.default ($List.get ($Nat.read n_str$5) vars$1) "?") ($Kind.Comp.replace n_str.tail$6 vars$1)))) (#f ($String.cons a$4 ($Kind.Comp.replace f1 vars$1))))))) (#f ($String.cons a$4 ($Kind.Comp.replace f1 vars$1))))))))))))
(define Kind.Comp.replace (lambda (str$0) (lambda (vars$1) ($Kind.Comp.replace str$0 vars$1))))
(define ($List.create.go len$1 create_value$2 result$3) (let ((self0 len$1)) (case (= self0 0) (#t result$3) (#f (let ((f0 (- self0 1))) ($List.create.go f0 create_value$2 ($List.cons (create_value$2 f0) result$3)))))))
(define List.create.go (lambda (len$1) (lambda (create_value$2) (lambda (result$3) ($List.create.go len$1 create_value$2 result$3)))))
(define ($List.create len$1 create_value$2) ($List.create.go len$1 create_value$2 List.nil))
(define List.create (lambda (len$1) (lambda (create_value$2) ($List.create len$1 create_value$2))))
(define ($Kind.Comp.Prim.instantiator.go lang$0 prim$1 depth$2 defs$3 ctor$4 j$5) (let ((self0 ctor$4)) (case (get self0 0) ('Pair.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((self2 ($Nat.eql j$5 f0))) (case self2 (#t ($Kind.Comp.replace f1 ($List.create f0 (lambda (j$8) ($String.concat "x" ($Nat.show j$8)))))) (#f (((let ((self2 (let ((self2 lang$0)) (case (get self2 0) ('Kind.Comp.Language.new (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) (let ((f5 (get self2 4))) f2))))))))) (case (get self2 0) ('Kind.Comp.Grammar.new (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) (let ((f5 (get self2 4))) (let ((f6 (get self2 5))) (let ((f7 (get self2 6))) (let ((f8 (get self2 7))) (let ((f9 (get self2 8))) (let ((f10 (get self2 9))) (let ((f11 (get self2 10))) (let ((f12 (get self2 11))) (let ((f13 (get self2 12))) (let ((f14 (get self2 13))) (let ((f15 (get self2 14))) f6))))))))))))))))) ($String.concat "x" ($Nat.show j$5))) ($Kind.Comp.Prim.instantiator.go lang$0 prim$1 depth$2 defs$3 ctor$4 ($Nat.succ j$5))))))))))))
(define Kind.Comp.Prim.instantiator.go (lambda (lang$0) (lambda (prim$1) (lambda (depth$2) (lambda (defs$3) (lambda (ctor$4) (lambda (j$5) ($Kind.Comp.Prim.instantiator.go lang$0 prim$1 depth$2 defs$3 ctor$4 j$5))))))))
(define ($Kind.Comp.Prim.instantiator lang$0 prim$1 depth$2 defs$3) (let ((shape$4 ((let ((self0 lang$0)) (case (get self0 0) ('Kind.Comp.Language.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) f1))))))) prim$1))) (let ((self1 shape$4)) (case (get self1 0) ('Kind.Comp.Native.new (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((text$7 "x")) (let ((text$8 ($List.for f1 text$7 (lambda (ctor$8) (lambda (text$9) (((let ((self6 (let ((self6 lang$0)) (case (get self6 0) ('Kind.Comp.Language.new (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((f8 (get self6 3))) (let ((f9 (get self6 4))) f6))))))))) (case (get self6 0) ('Kind.Comp.Grammar.new (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((f8 (get self6 3))) (let ((f9 (get self6 4))) (let ((f10 (get self6 5))) (let ((f11 (get self6 6))) (let ((f12 (get self6 7))) (let ((f13 (get self6 8))) (let ((f14 (get self6 9))) (let ((f15 (get self6 10))) (let ((f16 (get self6 11))) (let ((f17 (get self6 12))) (let ((f18 (get self6 13))) (let ((f19 (get self6 14))) f11))))))))))))))))) text$9) ($Kind.Comp.Prim.instantiator.go lang$0 prim$1 depth$2 defs$3 ctor$8 0))))))) (((let ((self5 (let ((self5 lang$0)) (case (get self5 0) ('Kind.Comp.Language.new (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) (let ((f8 (get self5 4))) f5))))))))) (case (get self5 0) ('Kind.Comp.Grammar.new (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) (let ((f8 (get self5 4))) (let ((f9 (get self5 5))) (let ((f10 (get self5 6))) (let ((f11 (get self5 7))) (let ((f12 (get self5 8))) (let ((f13 (get self5 9))) (let ((f14 (get self5 10))) (let ((f15 (get self5 11))) (let ((f16 (get self5 12))) (let ((f17 (get self5 13))) (let ((f18 (get self5 14))) f9))))))))))))))))) "x") text$8))))))))))
(define Kind.Comp.Prim.instantiator (lambda (lang$0) (lambda (prim$1) (lambda (depth$2) (lambda (defs$3) ($Kind.Comp.Prim.instantiator lang$0 prim$1 depth$2 defs$3))))))
(define ($Kind.Comp.get_args.go term$0 args$1) (let ((self0 term$0)) (case (get self0 0) ('Kind.Comp.nil ($Pair.new term$0 args$1)) ('Kind.Comp.var (let ((f0 (get self0 1))) ($Pair.new term$0 args$1))) ('Kind.Comp.ref (let ((f0 (get self0 1))) ($Pair.new term$0 args$1))) ('Kind.Comp.lam (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($Pair.new term$0 args$1)))) ('Kind.Comp.app (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($Kind.Comp.get_args.go f0 ($List.cons f1 args$1))))) ('Kind.Comp.let (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) ($Pair.new term$0 args$1))))) ('Kind.Comp.eli (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($Pair.new term$0 args$1)))) ('Kind.Comp.ins (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($Pair.new term$0 args$1)))) ('Kind.Comp.nat (let ((f0 (get self0 1))) ($Pair.new term$0 args$1))) ('Kind.Comp.chr (let ((f0 (get self0 1))) ($Pair.new term$0 args$1))) ('Kind.Comp.str (let ((f0 (get self0 1))) ($Pair.new term$0 args$1))) ('Kind.Comp.txt (let ((f0 (get self0 1))) ($Pair.new term$0 args$1))))))
(define Kind.Comp.get_args.go (lambda (term$0) (lambda (args$1) ($Kind.Comp.get_args.go term$0 args$1))))
(define ($Kind.Comp.get_args term$0) ($Kind.Comp.get_args.go term$0 List.nil))
(define Kind.Comp.get_args (lambda (term$0) ($Kind.Comp.get_args term$0)))
(define ($Kind.Comp.get_arity term$0) (let ((self0 term$0)) (case (get self0 0) ('Kind.Comp.nil 0) ('Kind.Comp.var (let ((f0 (get self0 1))) 0)) ('Kind.Comp.ref (let ((f0 (get self0 1))) 0)) ('Kind.Comp.lam (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($Nat.add 1 ($Kind.Comp.get_arity f1))))) ('Kind.Comp.app (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) 0))) ('Kind.Comp.let (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) 0)))) ('Kind.Comp.eli (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) 0))) ('Kind.Comp.ins (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) 0))) ('Kind.Comp.nat (let ((f0 (get self0 1))) 0)) ('Kind.Comp.chr (let ((f0 (get self0 1))) 0)) ('Kind.Comp.str (let ((f0 (get self0 1))) 0)) ('Kind.Comp.txt (let ((f0 (get self0 1))) 0)))))
(define Kind.Comp.get_arity (lambda (term$0) ($Kind.Comp.get_arity term$0)))
(define ($List.map f$2 as$3) (let ((self0 as$3)) (case (get self0 0) ('List.nil List.nil) ('List.cons (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($List.cons (f$2 f0) ($List.map f$2 f1))))))))
(define List.map (lambda (f$2) (lambda (as$3) ($List.map f$2 as$3))))
(define ($Kind.Comp.get_vars term$0) (let ((self0 term$0)) (case (get self0 0) ('Kind.Comp.nil ($Pair.new List.nil term$0)) ('Kind.Comp.var (let ((f0 (get self0 1))) ($Pair.new List.nil term$0))) ('Kind.Comp.ref (let ((f0 (get self0 1))) ($Pair.new List.nil term$0))) ('Kind.Comp.lam (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((self2 ($Kind.Comp.get_vars f1))) (case (get self2 0) ('Pair.new (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) ($Pair.new ($List.cons f0 f2) f3))))))))) ('Kind.Comp.app (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($Pair.new List.nil term$0)))) ('Kind.Comp.let (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) ($Pair.new List.nil term$0))))) ('Kind.Comp.eli (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($Pair.new List.nil term$0)))) ('Kind.Comp.ins (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($Pair.new List.nil term$0)))) ('Kind.Comp.nat (let ((f0 (get self0 1))) ($Pair.new List.nil term$0))) ('Kind.Comp.chr (let ((f0 (get self0 1))) ($Pair.new List.nil term$0))) ('Kind.Comp.str (let ((f0 (get self0 1))) ($Pair.new List.nil term$0))) ('Kind.Comp.txt (let ((f0 (get self0 1))) ($Pair.new List.nil term$0))))))
(define Kind.Comp.get_vars (lambda (term$0) ($Kind.Comp.get_vars term$0)))
(define ($Kind.Comp.Prim.inst.go lang$0 name$1 inst$2 vars$3 args$4 depth$5 defs$6) (let ((self0 inst$2)) (case (get self0 0) ('List.nil (let ((self0 vars$3)) (case (get self0 0) ('List.nil Maybe.none) ('List.cons (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) Maybe.none)))))) ('List.cons (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((self2 vars$3)) (case (get self2 0) ('List.nil Maybe.none) ('List.cons (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((self4 ($String.eql name$1 f2))) (case self4 (#t (let ((self4 f0)) (case (get self4 0) ('Pair.new (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((self6 ($Nat.eql f4 ($List.length args$4)))) (case self6 (#t ($Maybe.some ($Kind.Comp.replace f5 ($List.mapped args$4 (lambda (x$13) ($Kind.Comp.transpile.term lang$0 x$13 depth$5 defs$6)))))) (#f Maybe.none))))))))) (#f ($Kind.Comp.Prim.inst.go lang$0 name$1 f1 f3 args$4 depth$5 defs$6)))))))))))))))
(define Kind.Comp.Prim.inst.go (lambda (lang$0) (lambda (name$1) (lambda (inst$2) (lambda (vars$3) (lambda (args$4) (lambda (depth$5) (lambda (defs$6) ($Kind.Comp.Prim.inst.go lang$0 name$1 inst$2 vars$3 args$4 depth$5 defs$6)))))))))
(define ($Kind.Comp.Prim.inst lang$0 term$1 depth$2 defs$3) (let ((self0 term$1)) (case (get self0 0) ('Kind.Comp.nil Maybe.none) ('Kind.Comp.var (let ((f0 (get self0 1))) Maybe.none)) ('Kind.Comp.ref (let ((f0 (get self0 1))) Maybe.none)) ('Kind.Comp.lam (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) Maybe.none))) ('Kind.Comp.app (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) Maybe.none))) ('Kind.Comp.let (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) Maybe.none)))) ('Kind.Comp.eli (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) Maybe.none))) ('Kind.Comp.ins (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((shape$6 ((let ((self2 lang$0)) (case (get self2 0) ('Kind.Comp.Language.new (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) (let ((f5 (get self2 4))) f3))))))) f0))) (let ((self3 shape$6)) (case (get self3 0) ('Kind.Comp.Native.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((self5 ($Kind.Comp.get_vars f1))) (case (get self5 0) ('Pair.new (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((self7 ($Nat.eql ($List.length f3) ($List.length f5)))) (case self7 (#t (let ((self7 ($Kind.Comp.get_args f6))) (case (get self7 0) ('Pair.new (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((self9 f7)) (case (get self9 0) ('Kind.Comp.nil Maybe.none) ('Kind.Comp.var (let ((f9 (get self9 1))) ($Kind.Comp.Prim.inst.go lang$0 f9 f3 f5 f8 depth$2 defs$3))) ('Kind.Comp.ref (let ((f9 (get self9 1))) ($Kind.Comp.Prim.inst.go lang$0 f9 f3 f5 f8 depth$2 defs$3))) ('Kind.Comp.lam (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) Maybe.none))) ('Kind.Comp.app (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) Maybe.none))) ('Kind.Comp.let (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) Maybe.none)))) ('Kind.Comp.eli (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) Maybe.none))) ('Kind.Comp.ins (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) Maybe.none))) ('Kind.Comp.nat (let ((f9 (get self9 1))) Maybe.none)) ('Kind.Comp.chr (let ((f9 (get self9 1))) Maybe.none)) ('Kind.Comp.str (let ((f9 (get self9 1))) Maybe.none)) ('Kind.Comp.txt (let ((f9 (get self9 1))) Maybe.none)))))))))) (#f Maybe.none))))))))))))))))) ('Kind.Comp.nat (let ((f0 (get self0 1))) Maybe.none)) ('Kind.Comp.chr (let ((f0 (get self0 1))) Maybe.none)) ('Kind.Comp.str (let ((f0 (get self0 1))) Maybe.none)) ('Kind.Comp.txt (let ((f0 (get self0 1))) Maybe.none)))))
(define Kind.Comp.Prim.inst (lambda (lang$0) (lambda (term$1) (lambda (depth$2) (lambda (defs$3) ($Kind.Comp.Prim.inst lang$0 term$1 depth$2 defs$3))))))
(define ($Word.fold nil$2 w0$3 w1$4 word$5) (let ((self0 word$5)) (case (get self0 0) ('Word.e nil$2) ('Word.o (let ((f0 (get self0 1))) (w0$3 ($Word.fold nil$2 w0$3 w1$4 f0)))) ('Word.i (let ((f0 (get self0 1))) (w1$4 ($Word.fold nil$2 w0$3 w1$4 f0)))))))
(define Word.fold (lambda (nil$2) (lambda (w0$3) (lambda (w1$4) (lambda (word$5) ($Word.fold nil$2 w0$3 w1$4 word$5))))))
(define ($Word.to_nat word$1) ($Word.fold 0 (Nat.mul 2) (lambda (x$3) ($Nat.succ ($Nat.mul 2 x$3))) word$1))
(define Word.to_nat (lambda (word$1) ($Word.to_nat word$1)))
(define ($U16.to_nat a$0) a$0)
(define U16.to_nat (lambda (a$0) ($U16.to_nat a$0)))
(define ($Kind.Comp.transpile.term lang$0 comp$1 depth$2 defs$3) (let ((go$4 (Kind.Comp.transpile.term lang$0))) (let ((self1 ($Kind.Comp.Prim.inst lang$0 comp$1 depth$2 defs$3))) (case (get self1 0) ('Maybe.none (let ((self1 ($Kind.Comp.Prim.elim lang$0 comp$1 depth$2 defs$3))) (case (get self1 0) ('Maybe.none (let ((self1 comp$1)) (case (get self1 0) ('Kind.Comp.nil (let ((self1 (let ((self1 lang$0)) (case (get self1 0) ('Kind.Comp.Language.new (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) f1))))))))) (case (get self1 0) ('Kind.Comp.Grammar.new (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((f6 (get self1 6))) (let ((f7 (get self1 7))) (let ((f8 (get self1 8))) (let ((f9 (get self1 9))) (let ((f10 (get self1 10))) (let ((f11 (get self1 11))) (let ((f12 (get self1 12))) (let ((f13 (get self1 13))) (let ((f14 (get self1 14))) f1)))))))))))))))))) ('Kind.Comp.var (let ((f1 (get self1 1))) ((let ((self2 (let ((self2 lang$0)) (case (get self2 0) ('Kind.Comp.Language.new (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) (let ((f5 (get self2 4))) f2))))))))) (case (get self2 0) ('Kind.Comp.Grammar.new (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) (let ((f5 (get self2 4))) (let ((f6 (get self2 5))) (let ((f7 (get self2 6))) (let ((f8 (get self2 7))) (let ((f9 (get self2 8))) (let ((f10 (get self2 9))) (let ((f11 (get self2 10))) (let ((f12 (get self2 11))) (let ((f13 (get self2 12))) (let ((f14 (get self2 13))) (let ((f15 (get self2 14))) f3))))))))))))))))) f1))) ('Kind.Comp.ref (let ((f1 (get self1 1))) ((let ((self2 (let ((self2 lang$0)) (case (get self2 0) ('Kind.Comp.Language.new (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) (let ((f5 (get self2 4))) f2))))))))) (case (get self2 0) ('Kind.Comp.Grammar.new (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) (let ((f5 (get self2 4))) (let ((f6 (get self2 5))) (let ((f7 (get self2 6))) (let ((f8 (get self2 7))) (let ((f9 (get self2 8))) (let ((f10 (get self2 9))) (let ((f11 (get self2 10))) (let ((f12 (get self2 11))) (let ((f13 (get self2 12))) (let ((f14 (get self2 13))) (let ((f15 (get self2 14))) f3))))))))))))))))) f1))) ('Kind.Comp.lam (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (((let ((self3 (let ((self3 lang$0)) (case (get self3 0) ('Kind.Comp.Language.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) f3))))))))) (case (get self3 0) ('Kind.Comp.Grammar.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) (let ((f7 (get self3 5))) (let ((f8 (get self3 6))) (let ((f9 (get self3 7))) (let ((f10 (get self3 8))) (let ((f11 (get self3 9))) (let ((f12 (get self3 10))) (let ((f13 (get self3 11))) (let ((f14 (get self3 12))) (let ((f15 (get self3 13))) (let ((f16 (get self3 14))) f7))))))))))))))))) ((let ((self3 (let ((self3 lang$0)) (case (get self3 0) ('Kind.Comp.Language.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) f3))))))))) (case (get self3 0) ('Kind.Comp.Grammar.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) (let ((f7 (get self3 5))) (let ((f8 (get self3 6))) (let ((f9 (get self3 7))) (let ((f10 (get self3 8))) (let ((f11 (get self3 9))) (let ((f12 (get self3 10))) (let ((f13 (get self3 11))) (let ((f14 (get self3 12))) (let ((f15 (get self3 13))) (let ((f16 (get self3 14))) f4))))))))))))))))) f1)) (((go$4 f2) ($Nat.succ depth$2)) defs$3))))) ('Kind.Comp.app (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (((let ((self3 (let ((self3 lang$0)) (case (get self3 0) ('Kind.Comp.Language.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) f3))))))))) (case (get self3 0) ('Kind.Comp.Grammar.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) (let ((f7 (get self3 5))) (let ((f8 (get self3 6))) (let ((f9 (get self3 7))) (let ((f10 (get self3 8))) (let ((f11 (get self3 9))) (let ((f12 (get self3 10))) (let ((f13 (get self3 11))) (let ((f14 (get self3 12))) (let ((f15 (get self3 13))) (let ((f16 (get self3 14))) f8))))))))))))))))) (((go$4 f1) depth$2) defs$3)) (((go$4 f2) depth$2) defs$3))))) ('Kind.Comp.let (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) ((((let ((self4 (let ((self4 lang$0)) (case (get self4 0) ('Kind.Comp.Language.new (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((f6 (get self4 3))) (let ((f7 (get self4 4))) f4))))))))) (case (get self4 0) ('Kind.Comp.Grammar.new (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((f6 (get self4 3))) (let ((f7 (get self4 4))) (let ((f8 (get self4 5))) (let ((f9 (get self4 6))) (let ((f10 (get self4 7))) (let ((f11 (get self4 8))) (let ((f12 (get self4 9))) (let ((f13 (get self4 10))) (let ((f14 (get self4 11))) (let ((f15 (get self4 12))) (let ((f16 (get self4 13))) (let ((f17 (get self4 14))) f10))))))))))))))))) ((let ((self4 (let ((self4 lang$0)) (case (get self4 0) ('Kind.Comp.Language.new (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((f6 (get self4 3))) (let ((f7 (get self4 4))) f4))))))))) (case (get self4 0) ('Kind.Comp.Grammar.new (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((f6 (get self4 3))) (let ((f7 (get self4 4))) (let ((f8 (get self4 5))) (let ((f9 (get self4 6))) (let ((f10 (get self4 7))) (let ((f11 (get self4 8))) (let ((f12 (get self4 9))) (let ((f13 (get self4 10))) (let ((f14 (get self4 11))) (let ((f15 (get self4 12))) (let ((f16 (get self4 13))) (let ((f17 (get self4 14))) f5))))))))))))))))) f1)) (((go$4 f2) depth$2) defs$3)) (((go$4 f3) ($Nat.succ depth$2)) defs$3)))))) ('Kind.Comp.eli (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((self3 f1)) (case (get self3 0) ('Kind.Comp.Prim.bool (((let ((self3 (let ((self3 lang$0)) (case (get self3 0) ('Kind.Comp.Language.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) f3))))))))) (case (get self3 0) ('Kind.Comp.Grammar.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) (let ((f7 (get self3 5))) (let ((f8 (get self3 6))) (let ((f9 (get self3 7))) (let ((f10 (get self3 8))) (let ((f11 (get self3 9))) (let ((f12 (get self3 10))) (let ((f13 (get self3 11))) (let ((f14 (get self3 12))) (let ((f15 (get self3 13))) (let ((f16 (get self3 14))) f8))))))))))))))))) ((let ((self3 (let ((self3 lang$0)) (case (get self3 0) ('Kind.Comp.Language.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) f3))))))))) (case (get self3 0) ('Kind.Comp.Grammar.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) (let ((f7 (get self3 5))) (let ((f8 (get self3 6))) (let ((f9 (get self3 7))) (let ((f10 (get self3 8))) (let ((f11 (get self3 9))) (let ((f12 (get self3 10))) (let ((f13 (get self3 11))) (let ((f14 (get self3 12))) (let ((f15 (get self3 13))) (let ((f16 (get self3 14))) f6))))))))))))))))) "Bool")) (((go$4 f2) depth$2) defs$3))) ('Kind.Comp.Prim.bits (((let ((self3 (let ((self3 lang$0)) (case (get self3 0) ('Kind.Comp.Language.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) f3))))))))) (case (get self3 0) ('Kind.Comp.Grammar.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) (let ((f7 (get self3 5))) (let ((f8 (get self3 6))) (let ((f9 (get self3 7))) (let ((f10 (get self3 8))) (let ((f11 (get self3 9))) (let ((f12 (get self3 10))) (let ((f13 (get self3 11))) (let ((f14 (get self3 12))) (let ((f15 (get self3 13))) (let ((f16 (get self3 14))) f8))))))))))))))))) ((let ((self3 (let ((self3 lang$0)) (case (get self3 0) ('Kind.Comp.Language.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) f3))))))))) (case (get self3 0) ('Kind.Comp.Grammar.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) (let ((f7 (get self3 5))) (let ((f8 (get self3 6))) (let ((f9 (get self3 7))) (let ((f10 (get self3 8))) (let ((f11 (get self3 9))) (let ((f12 (get self3 10))) (let ((f13 (get self3 11))) (let ((f14 (get self3 12))) (let ((f15 (get self3 13))) (let ((f16 (get self3 14))) f6))))))))))))))))) "Bits")) (((go$4 f2) depth$2) defs$3))) ('Kind.Comp.Prim.unit (((let ((self3 (let ((self3 lang$0)) (case (get self3 0) ('Kind.Comp.Language.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) f3))))))))) (case (get self3 0) ('Kind.Comp.Grammar.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) (let ((f7 (get self3 5))) (let ((f8 (get self3 6))) (let ((f9 (get self3 7))) (let ((f10 (get self3 8))) (let ((f11 (get self3 9))) (let ((f12 (get self3 10))) (let ((f13 (get self3 11))) (let ((f14 (get self3 12))) (let ((f15 (get self3 13))) (let ((f16 (get self3 14))) f8))))))))))))))))) ((let ((self3 (let ((self3 lang$0)) (case (get self3 0) ('Kind.Comp.Language.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) f3))))))))) (case (get self3 0) ('Kind.Comp.Grammar.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) (let ((f7 (get self3 5))) (let ((f8 (get self3 6))) (let ((f9 (get self3 7))) (let ((f10 (get self3 8))) (let ((f11 (get self3 9))) (let ((f12 (get self3 10))) (let ((f13 (get self3 11))) (let ((f14 (get self3 12))) (let ((f15 (get self3 13))) (let ((f16 (get self3 14))) f6))))))))))))))))) "Unit")) (((go$4 f2) depth$2) defs$3))) ('Kind.Comp.Prim.nat (((let ((self3 (let ((self3 lang$0)) (case (get self3 0) ('Kind.Comp.Language.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) f3))))))))) (case (get self3 0) ('Kind.Comp.Grammar.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) (let ((f7 (get self3 5))) (let ((f8 (get self3 6))) (let ((f9 (get self3 7))) (let ((f10 (get self3 8))) (let ((f11 (get self3 9))) (let ((f12 (get self3 10))) (let ((f13 (get self3 11))) (let ((f14 (get self3 12))) (let ((f15 (get self3 13))) (let ((f16 (get self3 14))) f8))))))))))))))))) ((let ((self3 (let ((self3 lang$0)) (case (get self3 0) ('Kind.Comp.Language.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) f3))))))))) (case (get self3 0) ('Kind.Comp.Grammar.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) (let ((f7 (get self3 5))) (let ((f8 (get self3 6))) (let ((f9 (get self3 7))) (let ((f10 (get self3 8))) (let ((f11 (get self3 9))) (let ((f12 (get self3 10))) (let ((f13 (get self3 11))) (let ((f14 (get self3 12))) (let ((f15 (get self3 13))) (let ((f16 (get self3 14))) f6))))))))))))))))) "Nat")) (((go$4 f2) depth$2) defs$3))) ('Kind.Comp.Prim.u16 (((let ((self3 (let ((self3 lang$0)) (case (get self3 0) ('Kind.Comp.Language.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) f3))))))))) (case (get self3 0) ('Kind.Comp.Grammar.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) (let ((f7 (get self3 5))) (let ((f8 (get self3 6))) (let ((f9 (get self3 7))) (let ((f10 (get self3 8))) (let ((f11 (get self3 9))) (let ((f12 (get self3 10))) (let ((f13 (get self3 11))) (let ((f14 (get self3 12))) (let ((f15 (get self3 13))) (let ((f16 (get self3 14))) f8))))))))))))))))) ((let ((self3 (let ((self3 lang$0)) (case (get self3 0) ('Kind.Comp.Language.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) f3))))))))) (case (get self3 0) ('Kind.Comp.Grammar.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) (let ((f7 (get self3 5))) (let ((f8 (get self3 6))) (let ((f9 (get self3 7))) (let ((f10 (get self3 8))) (let ((f11 (get self3 9))) (let ((f12 (get self3 10))) (let ((f13 (get self3 11))) (let ((f14 (get self3 12))) (let ((f15 (get self3 13))) (let ((f16 (get self3 14))) f6))))))))))))))))) "U16")) (((go$4 f2) depth$2) defs$3))) ('Kind.Comp.Prim.u32 (((let ((self3 (let ((self3 lang$0)) (case (get self3 0) ('Kind.Comp.Language.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) f3))))))))) (case (get self3 0) ('Kind.Comp.Grammar.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) (let ((f7 (get self3 5))) (let ((f8 (get self3 6))) (let ((f9 (get self3 7))) (let ((f10 (get self3 8))) (let ((f11 (get self3 9))) (let ((f12 (get self3 10))) (let ((f13 (get self3 11))) (let ((f14 (get self3 12))) (let ((f15 (get self3 13))) (let ((f16 (get self3 14))) f8))))))))))))))))) ((let ((self3 (let ((self3 lang$0)) (case (get self3 0) ('Kind.Comp.Language.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) f3))))))))) (case (get self3 0) ('Kind.Comp.Grammar.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) (let ((f7 (get self3 5))) (let ((f8 (get self3 6))) (let ((f9 (get self3 7))) (let ((f10 (get self3 8))) (let ((f11 (get self3 9))) (let ((f12 (get self3 10))) (let ((f13 (get self3 11))) (let ((f14 (get self3 12))) (let ((f15 (get self3 13))) (let ((f16 (get self3 14))) f6))))))))))))))))) "U32")) (((go$4 f2) depth$2) defs$3))) ('Kind.Comp.Prim.string (((let ((self3 (let ((self3 lang$0)) (case (get self3 0) ('Kind.Comp.Language.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) f3))))))))) (case (get self3 0) ('Kind.Comp.Grammar.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) (let ((f7 (get self3 5))) (let ((f8 (get self3 6))) (let ((f9 (get self3 7))) (let ((f10 (get self3 8))) (let ((f11 (get self3 9))) (let ((f12 (get self3 10))) (let ((f13 (get self3 11))) (let ((f14 (get self3 12))) (let ((f15 (get self3 13))) (let ((f16 (get self3 14))) f8))))))))))))))))) ((let ((self3 (let ((self3 lang$0)) (case (get self3 0) ('Kind.Comp.Language.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) f3))))))))) (case (get self3 0) ('Kind.Comp.Grammar.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) (let ((f7 (get self3 5))) (let ((f8 (get self3 6))) (let ((f9 (get self3 7))) (let ((f10 (get self3 8))) (let ((f11 (get self3 9))) (let ((f12 (get self3 10))) (let ((f13 (get self3 11))) (let ((f14 (get self3 12))) (let ((f15 (get self3 13))) (let ((f16 (get self3 14))) f6))))))))))))))))) "String")) (((go$4 f2) depth$2) defs$3))) ('Kind.Comp.Prim.data (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (((go$4 f2) depth$2) defs$3))))))))) ('Kind.Comp.ins (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((self3 f1)) (case (get self3 0) ('Kind.Comp.Prim.bool (((let ((self3 (let ((self3 lang$0)) (case (get self3 0) ('Kind.Comp.Language.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) f3))))))))) (case (get self3 0) ('Kind.Comp.Grammar.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) (let ((f7 (get self3 5))) (let ((f8 (get self3 6))) (let ((f9 (get self3 7))) (let ((f10 (get self3 8))) (let ((f11 (get self3 9))) (let ((f12 (get self3 10))) (let ((f13 (get self3 11))) (let ((f14 (get self3 12))) (let ((f15 (get self3 13))) (let ((f16 (get self3 14))) f8))))))))))))))))) ((let ((self3 (let ((self3 lang$0)) (case (get self3 0) ('Kind.Comp.Language.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) f3))))))))) (case (get self3 0) ('Kind.Comp.Grammar.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) (let ((f7 (get self3 5))) (let ((f8 (get self3 6))) (let ((f9 (get self3 7))) (let ((f10 (get self3 8))) (let ((f11 (get self3 9))) (let ((f12 (get self3 10))) (let ((f13 (get self3 11))) (let ((f14 (get self3 12))) (let ((f15 (get self3 13))) (let ((f16 (get self3 14))) f5))))))))))))))))) "Bool")) (((go$4 f2) depth$2) defs$3))) ('Kind.Comp.Prim.bits (((let ((self3 (let ((self3 lang$0)) (case (get self3 0) ('Kind.Comp.Language.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) f3))))))))) (case (get self3 0) ('Kind.Comp.Grammar.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) (let ((f7 (get self3 5))) (let ((f8 (get self3 6))) (let ((f9 (get self3 7))) (let ((f10 (get self3 8))) (let ((f11 (get self3 9))) (let ((f12 (get self3 10))) (let ((f13 (get self3 11))) (let ((f14 (get self3 12))) (let ((f15 (get self3 13))) (let ((f16 (get self3 14))) f8))))))))))))))))) ((let ((self3 (let ((self3 lang$0)) (case (get self3 0) ('Kind.Comp.Language.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) f3))))))))) (case (get self3 0) ('Kind.Comp.Grammar.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) (let ((f7 (get self3 5))) (let ((f8 (get self3 6))) (let ((f9 (get self3 7))) (let ((f10 (get self3 8))) (let ((f11 (get self3 9))) (let ((f12 (get self3 10))) (let ((f13 (get self3 11))) (let ((f14 (get self3 12))) (let ((f15 (get self3 13))) (let ((f16 (get self3 14))) f5))))))))))))))))) "Bits")) (((go$4 f2) depth$2) defs$3))) ('Kind.Comp.Prim.unit (((let ((self3 (let ((self3 lang$0)) (case (get self3 0) ('Kind.Comp.Language.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) f3))))))))) (case (get self3 0) ('Kind.Comp.Grammar.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) (let ((f7 (get self3 5))) (let ((f8 (get self3 6))) (let ((f9 (get self3 7))) (let ((f10 (get self3 8))) (let ((f11 (get self3 9))) (let ((f12 (get self3 10))) (let ((f13 (get self3 11))) (let ((f14 (get self3 12))) (let ((f15 (get self3 13))) (let ((f16 (get self3 14))) f8))))))))))))))))) ((let ((self3 (let ((self3 lang$0)) (case (get self3 0) ('Kind.Comp.Language.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) f3))))))))) (case (get self3 0) ('Kind.Comp.Grammar.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) (let ((f7 (get self3 5))) (let ((f8 (get self3 6))) (let ((f9 (get self3 7))) (let ((f10 (get self3 8))) (let ((f11 (get self3 9))) (let ((f12 (get self3 10))) (let ((f13 (get self3 11))) (let ((f14 (get self3 12))) (let ((f15 (get self3 13))) (let ((f16 (get self3 14))) f5))))))))))))))))) "Unit")) (((go$4 f2) depth$2) defs$3))) ('Kind.Comp.Prim.nat (((let ((self3 (let ((self3 lang$0)) (case (get self3 0) ('Kind.Comp.Language.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) f3))))))))) (case (get self3 0) ('Kind.Comp.Grammar.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) (let ((f7 (get self3 5))) (let ((f8 (get self3 6))) (let ((f9 (get self3 7))) (let ((f10 (get self3 8))) (let ((f11 (get self3 9))) (let ((f12 (get self3 10))) (let ((f13 (get self3 11))) (let ((f14 (get self3 12))) (let ((f15 (get self3 13))) (let ((f16 (get self3 14))) f8))))))))))))))))) ((let ((self3 (let ((self3 lang$0)) (case (get self3 0) ('Kind.Comp.Language.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) f3))))))))) (case (get self3 0) ('Kind.Comp.Grammar.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) (let ((f7 (get self3 5))) (let ((f8 (get self3 6))) (let ((f9 (get self3 7))) (let ((f10 (get self3 8))) (let ((f11 (get self3 9))) (let ((f12 (get self3 10))) (let ((f13 (get self3 11))) (let ((f14 (get self3 12))) (let ((f15 (get self3 13))) (let ((f16 (get self3 14))) f5))))))))))))))))) "Nat")) (((go$4 f2) depth$2) defs$3))) ('Kind.Comp.Prim.u16 (((let ((self3 (let ((self3 lang$0)) (case (get self3 0) ('Kind.Comp.Language.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) f3))))))))) (case (get self3 0) ('Kind.Comp.Grammar.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) (let ((f7 (get self3 5))) (let ((f8 (get self3 6))) (let ((f9 (get self3 7))) (let ((f10 (get self3 8))) (let ((f11 (get self3 9))) (let ((f12 (get self3 10))) (let ((f13 (get self3 11))) (let ((f14 (get self3 12))) (let ((f15 (get self3 13))) (let ((f16 (get self3 14))) f8))))))))))))))))) ((let ((self3 (let ((self3 lang$0)) (case (get self3 0) ('Kind.Comp.Language.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) f3))))))))) (case (get self3 0) ('Kind.Comp.Grammar.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) (let ((f7 (get self3 5))) (let ((f8 (get self3 6))) (let ((f9 (get self3 7))) (let ((f10 (get self3 8))) (let ((f11 (get self3 9))) (let ((f12 (get self3 10))) (let ((f13 (get self3 11))) (let ((f14 (get self3 12))) (let ((f15 (get self3 13))) (let ((f16 (get self3 14))) f5))))))))))))))))) "U16")) (((go$4 f2) depth$2) defs$3))) ('Kind.Comp.Prim.u32 (((let ((self3 (let ((self3 lang$0)) (case (get self3 0) ('Kind.Comp.Language.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) f3))))))))) (case (get self3 0) ('Kind.Comp.Grammar.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) (let ((f7 (get self3 5))) (let ((f8 (get self3 6))) (let ((f9 (get self3 7))) (let ((f10 (get self3 8))) (let ((f11 (get self3 9))) (let ((f12 (get self3 10))) (let ((f13 (get self3 11))) (let ((f14 (get self3 12))) (let ((f15 (get self3 13))) (let ((f16 (get self3 14))) f8))))))))))))))))) ((let ((self3 (let ((self3 lang$0)) (case (get self3 0) ('Kind.Comp.Language.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) f3))))))))) (case (get self3 0) ('Kind.Comp.Grammar.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) (let ((f7 (get self3 5))) (let ((f8 (get self3 6))) (let ((f9 (get self3 7))) (let ((f10 (get self3 8))) (let ((f11 (get self3 9))) (let ((f12 (get self3 10))) (let ((f13 (get self3 11))) (let ((f14 (get self3 12))) (let ((f15 (get self3 13))) (let ((f16 (get self3 14))) f5))))))))))))))))) "U32")) (((go$4 f2) depth$2) defs$3))) ('Kind.Comp.Prim.string (((let ((self3 (let ((self3 lang$0)) (case (get self3 0) ('Kind.Comp.Language.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) f3))))))))) (case (get self3 0) ('Kind.Comp.Grammar.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) (let ((f7 (get self3 5))) (let ((f8 (get self3 6))) (let ((f9 (get self3 7))) (let ((f10 (get self3 8))) (let ((f11 (get self3 9))) (let ((f12 (get self3 10))) (let ((f13 (get self3 11))) (let ((f14 (get self3 12))) (let ((f15 (get self3 13))) (let ((f16 (get self3 14))) f8))))))))))))))))) ((let ((self3 (let ((self3 lang$0)) (case (get self3 0) ('Kind.Comp.Language.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) f3))))))))) (case (get self3 0) ('Kind.Comp.Grammar.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) (let ((f7 (get self3 5))) (let ((f8 (get self3 6))) (let ((f9 (get self3 7))) (let ((f10 (get self3 8))) (let ((f11 (get self3 9))) (let ((f12 (get self3 10))) (let ((f13 (get self3 11))) (let ((f14 (get self3 12))) (let ((f15 (get self3 13))) (let ((f16 (get self3 14))) f5))))))))))))))))) "String")) (((go$4 f2) depth$2) defs$3))) ('Kind.Comp.Prim.data (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (((go$4 f2) depth$2) defs$3))))))))) ('Kind.Comp.nat (let ((f1 (get self1 1))) ((let ((self2 (let ((self2 lang$0)) (case (get self2 0) ('Kind.Comp.Language.new (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) (let ((f5 (get self2 4))) f2))))))))) (case (get self2 0) ('Kind.Comp.Grammar.new (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) (let ((f5 (get self2 4))) (let ((f6 (get self2 5))) (let ((f7 (get self2 6))) (let ((f8 (get self2 7))) (let ((f9 (get self2 8))) (let ((f10 (get self2 9))) (let ((f11 (get self2 10))) (let ((f12 (get self2 11))) (let ((f13 (get self2 12))) (let ((f14 (get self2 13))) (let ((f15 (get self2 14))) f13))))))))))))))))) f1))) ('Kind.Comp.chr (let ((f1 (get self1 1))) ($Nat.show ($U16.to_nat f1)))) ('Kind.Comp.str (let ((f1 (get self1 1))) ($String.concat "\"" ($String.concat ((let ((self2 (let ((self2 lang$0)) (case (get self2 0) ('Kind.Comp.Language.new (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) (let ((f5 (get self2 4))) f2))))))))) (case (get self2 0) ('Kind.Comp.Grammar.new (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) (let ((f5 (get self2 4))) (let ((f6 (get self2 5))) (let ((f7 (get self2 6))) (let ((f8 (get self2 7))) (let ((f9 (get self2 8))) (let ((f10 (get self2 9))) (let ((f11 (get self2 10))) (let ((f12 (get self2 11))) (let ((f13 (get self2 12))) (let ((f14 (get self2 13))) (let ((f15 (get self2 14))) f12))))))))))))))))) f1) "\"")))) ('Kind.Comp.txt (let ((f1 (get self1 1))) f1))))) ('Maybe.some (let ((f1 (get self1 1))) f1))))) ('Maybe.some (let ((f1 (get self1 1))) f1))))))
(define Kind.Comp.transpile.term (lambda (lang$0) (lambda (comp$1) (lambda (depth$2) (lambda (defs$3) ($Kind.Comp.transpile.term lang$0 comp$1 depth$2 defs$3))))))
(define ($List.seq.go n$0 xs$1) (let ((self0 n$0)) (case (= self0 0) (#t xs$1) (#f (let ((f0 (- self0 1))) ($List.seq.go f0 ($List.cons f0 xs$1)))))))
(define List.seq.go (lambda (n$0) (lambda (xs$1) ($List.seq.go n$0 xs$1))))
(define ($List.seq n$0) ($List.seq.go n$0 List.nil))
(define List.seq (lambda (n$0) ($List.seq n$0)))
(define ($Kind.Comp.txt text$0) (vector 'Kind.Comp.txt text$0))
(define Kind.Comp.txt (lambda (text$0) ($Kind.Comp.txt text$0)))
(define ($Kind.Comp.subst name$0 value$1 term$2) (let ((self0 term$2)) (case (get self0 0) ('Kind.Comp.nil Kind.Comp.nil) ('Kind.Comp.var (let ((f0 (get self0 1))) (let ((self1 ($String.eql name$0 f0))) (case self1 (#t value$1) (#f ($Kind.Comp.var f0)))))) ('Kind.Comp.ref (let ((f0 (get self0 1))) ($Kind.Comp.ref f0))) ('Kind.Comp.lam (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($Kind.Comp.lam f0 (let ((self2 ($String.eql name$0 f0))) (case self2 (#t f1) (#f ($Kind.Comp.subst name$0 value$1 f1)))))))) ('Kind.Comp.app (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($Kind.Comp.app ($Kind.Comp.subst name$0 value$1 f0) ($Kind.Comp.subst name$0 value$1 f1))))) ('Kind.Comp.let (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) ($Kind.Comp.let f0 ($Kind.Comp.subst name$0 value$1 f1) (let ((self3 ($String.eql name$0 f0))) (case self3 (#t f2) (#f ($Kind.Comp.subst name$0 value$1 f2))))))))) ('Kind.Comp.eli (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($Kind.Comp.eli f0 ($Kind.Comp.subst name$0 value$1 f1))))) ('Kind.Comp.ins (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($Kind.Comp.ins f0 ($Kind.Comp.subst name$0 value$1 f1))))) ('Kind.Comp.nat (let ((f0 (get self0 1))) ($Kind.Comp.nat f0))) ('Kind.Comp.chr (let ((f0 (get self0 1))) ($Kind.Comp.chr f0))) ('Kind.Comp.str (let ((f0 (get self0 1))) ($Kind.Comp.str f0))) ('Kind.Comp.txt (let ((f0 (get self0 1))) ($Kind.Comp.txt f0))))))
(define Kind.Comp.subst (lambda (name$0) (lambda (value$1) (lambda (term$2) ($Kind.Comp.subst name$0 value$1 term$2)))))
(define ($Kind.Comp.apply term$0 args$1) (let ((self0 args$1)) (case (get self0 0) ('List.nil term$0) ('List.cons (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((self2 term$0)) (case (get self2 0) ('Kind.Comp.nil ($Kind.Comp.apply ($Kind.Comp.app term$0 f0) f1)) ('Kind.Comp.var (let ((f2 (get self2 1))) ($Kind.Comp.apply ($Kind.Comp.app term$0 f0) f1))) ('Kind.Comp.ref (let ((f2 (get self2 1))) ($Kind.Comp.apply ($Kind.Comp.app term$0 f0) f1))) ('Kind.Comp.lam (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) ($Kind.Comp.apply ($Kind.Comp.subst f2 f0 f3) f1)))) ('Kind.Comp.app (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) ($Kind.Comp.apply ($Kind.Comp.app term$0 f0) f1)))) ('Kind.Comp.let (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) ($Kind.Comp.apply ($Kind.Comp.app term$0 f0) f1))))) ('Kind.Comp.eli (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) ($Kind.Comp.apply ($Kind.Comp.app term$0 f0) f1)))) ('Kind.Comp.ins (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) ($Kind.Comp.apply ($Kind.Comp.app term$0 f0) f1)))) ('Kind.Comp.nat (let ((f2 (get self2 1))) ($Kind.Comp.apply ($Kind.Comp.app term$0 f0) f1))) ('Kind.Comp.chr (let ((f2 (get self2 1))) ($Kind.Comp.apply ($Kind.Comp.app term$0 f0) f1))) ('Kind.Comp.str (let ((f2 (get self2 1))) ($Kind.Comp.apply ($Kind.Comp.app term$0 f0) f1))) ('Kind.Comp.txt (let ((f2 (get self2 1))) ($Kind.Comp.apply ($Kind.Comp.app term$0 f0) f1)))))))))))
(define Kind.Comp.apply (lambda (term$0) (lambda (args$1) ($Kind.Comp.apply term$0 args$1))))
(define ($Kind.Comp.Prim.elim lang$0 term$1 depth$2 defs$3) (let ((self0 ($Kind.Comp.get_args term$1))) (case (get self0 0) ('Pair.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((self2 f0)) (case (get self2 0) ('Kind.Comp.nil Maybe.none) ('Kind.Comp.var (let ((f2 (get self2 1))) Maybe.none)) ('Kind.Comp.ref (let ((f2 (get self2 1))) (let ((self3 ($Kind.Map.get f2 defs$3))) (case (get self3 0) ('Maybe.none Maybe.none) ('Maybe.some (let ((f3 (get self3 1))) (let ((arity$8 ($Kind.Comp.get_arity f3))) (let ((self5 ($Bool.and ($Nat.eql arity$8 ($List.length f1)) ($Nat.gtn arity$8 0)))) (case self5 (#t (let ((inlined_args$9 ($List.map (lambda (arg$9) ($Kind.Comp.transpile.term lang$0 arg$9 depth$2 defs$3)) f1))) (let ((code$10 (((let ((self6 (let ((self6 lang$0)) (case (get self6 0) ('Kind.Comp.Language.new (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((f8 (get self6 3))) (let ((f9 (get self6 4))) f6))))))))) (case (get self6 0) ('Kind.Comp.Grammar.new (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((f8 (get self6 3))) (let ((f9 (get self6 4))) (let ((f10 (get self6 5))) (let ((f11 (get self6 6))) (let ((f12 (get self6 7))) (let ((f13 (get self6 8))) (let ((f14 (get self6 9))) (let ((f15 (get self6 10))) (let ((f16 (get self6 11))) (let ((f17 (get self6 12))) (let ((f18 (get self6 13))) (let ((f19 (get self6 14))) f14))))))))))))))))) f2) inlined_args$9))) ($Maybe.some code$10)))) (#f Maybe.none)))))))))) ('Kind.Comp.lam (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) Maybe.none))) ('Kind.Comp.app (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) Maybe.none))) ('Kind.Comp.let (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) Maybe.none)))) ('Kind.Comp.eli (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((shape$8 ((let ((self4 lang$0)) (case (get self4 0) ('Kind.Comp.Language.new (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((f6 (get self4 3))) (let ((f7 (get self4 4))) f5))))))) f2))) (let ((self5 shape$8)) (case (get self5 0) ('Kind.Comp.Native.new (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((self7 f6)) (case (get self7 0) ('Pair.new (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) (let ((args_len$13 ($List.length f1))) (let ((cses_len$14 ($List.length f8))) (let ((self11 ($Nat.gtn args_len$13 cses_len$14))) (case self11 (#t Maybe.none) (#f (let ((lams_len$15 ($Nat.sub cses_len$14 args_len$13))) (let ((args$16 ($Nat.for f1 0 lams_len$15 (lambda (i$16) (lambda (args$17) ($List.concat args$17 ($List.cons ($Kind.Comp.var ($String.concat "c" ($Nat.show i$16))) List.nil))))))) (let ((self$17 ($String.concat "self" ($Nat.show depth$2)))) (let ((cse_body_list$18 ($List.map (lambda (item$18) (let ((self15 item$18)) (case (get self15 0) ('Pair.new (let ((f15 (get self15 1))) (let ((f16 (get self15 2))) (let ((self17 f15)) (case (get self17 0) ('Pair.new (let ((f17 (get self17 1))) (let ((f18 (get self17 2))) (let ((flds_len$23 ($List.length f18))) (let ((let_args_n$24 ($List.reverse ($List.seq flds_len$23)))) (let ((lam_args_n$25 ($List.reverse ($List.seq lams_len$15)))) (let ((keys$26 ($List.create flds_len$23 (lambda (k$26) ($Kind.Comp.var ($String.concat "f" ($Nat.show ($Nat.add depth$2 k$26)))))))) (let ((argj$27 ($Kind.Comp.apply f16 keys$26))) (let ((body$28 ($Kind.Comp.transpile.term lang$0 argj$27 ($Nat.add ($Nat.add depth$2 flds_len$23) lams_len$15) defs$3))) (let ((body$29 ($List.for lam_args_n$25 body$28 (lambda (i$29) (lambda (body$30) (((let ((self27 (let ((self27 lang$0)) (case (get self27 0) ('Kind.Comp.Language.new (let ((f27 (get self27 1))) (let ((f28 (get self27 2))) (let ((f29 (get self27 3))) (let ((f30 (get self27 4))) f27))))))))) (case (get self27 0) ('Kind.Comp.Grammar.new (let ((f27 (get self27 1))) (let ((f28 (get self27 2))) (let ((f29 (get self27 3))) (let ((f30 (get self27 4))) (let ((f31 (get self27 5))) (let ((f32 (get self27 6))) (let ((f33 (get self27 7))) (let ((f34 (get self27 8))) (let ((f35 (get self27 9))) (let ((f36 (get self27 10))) (let ((f37 (get self27 11))) (let ((f38 (get self27 12))) (let ((f39 (get self27 13))) (let ((f40 (get self27 14))) f31))))))))))))))))) ($String.concat "c" ($Nat.show i$29))) body$30)))))) (let ((text$30 body$29)) (let ((text$31 ($List.for let_args_n$24 text$30 (lambda (k$31) (lambda (text$32) ((((let ((self29 (let ((self29 lang$0)) (case (get self29 0) ('Kind.Comp.Language.new (let ((f29 (get self29 1))) (let ((f30 (get self29 2))) (let ((f31 (get self29 3))) (let ((f32 (get self29 4))) f29))))))))) (case (get self29 0) ('Kind.Comp.Grammar.new (let ((f29 (get self29 1))) (let ((f30 (get self29 2))) (let ((f31 (get self29 3))) (let ((f32 (get self29 4))) (let ((f33 (get self29 5))) (let ((f34 (get self29 6))) (let ((f35 (get self29 7))) (let ((f36 (get self29 8))) (let ((f37 (get self29 9))) (let ((f38 (get self29 10))) (let ((f39 (get self29 11))) (let ((f40 (get self29 12))) (let ((f41 (get self29 13))) (let ((f42 (get self29 14))) f35))))))))))))))))) ($String.concat "f" ($Nat.show ($Nat.add depth$2 k$31)))) ($Kind.Comp.replace ($Maybe.default ($List.get k$31 f18) "") ($List.cons self$17 List.nil))) text$32)))))) ($Pair.new f17 text$31))))))))))))))))))))) ($List.zip f8 args$16)))) (let ((ret$19 (((let ((self15 (let ((self15 lang$0)) (case (get self15 0) ('Kind.Comp.Language.new (let ((f15 (get self15 1))) (let ((f16 (get self15 2))) (let ((f17 (get self15 3))) (let ((f18 (get self15 4))) f15))))))))) (case (get self15 0) ('Kind.Comp.Grammar.new (let ((f15 (get self15 1))) (let ((f16 (get self15 2))) (let ((f17 (get self15 3))) (let ((f18 (get self15 4))) (let ((f19 (get self15 5))) (let ((f20 (get self15 6))) (let ((f21 (get self15 7))) (let ((f22 (get self15 8))) (let ((f23 (get self15 9))) (let ((f24 (get self15 10))) (let ((f25 (get self15 11))) (let ((f26 (get self15 12))) (let ((f27 (get self15 13))) (let ((f28 (get self15 14))) f24))))))))))))))))) ($Kind.Comp.replace f7 ($List.cons self$17 List.nil))) cse_body_list$18))) (let ((ret$20 ((((let ((self16 (let ((self16 lang$0)) (case (get self16 0) ('Kind.Comp.Language.new (let ((f16 (get self16 1))) (let ((f17 (get self16 2))) (let ((f18 (get self16 3))) (let ((f19 (get self16 4))) f16))))))))) (case (get self16 0) ('Kind.Comp.Grammar.new (let ((f16 (get self16 1))) (let ((f17 (get self16 2))) (let ((f18 (get self16 3))) (let ((f19 (get self16 4))) (let ((f20 (get self16 5))) (let ((f21 (get self16 6))) (let ((f22 (get self16 7))) (let ((f23 (get self16 8))) (let ((f24 (get self16 9))) (let ((f25 (get self16 10))) (let ((f26 (get self16 11))) (let ((f27 (get self16 12))) (let ((f28 (get self16 13))) (let ((f29 (get self16 14))) f22))))))))))))))))) self$17) ($Kind.Comp.transpile.term lang$0 f3 depth$2 defs$3)) ret$19))) ($Maybe.some ret$20)))))))))))))))))))))))))) ('Kind.Comp.ins (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) Maybe.none))) ('Kind.Comp.nat (let ((f2 (get self2 1))) Maybe.none)) ('Kind.Comp.chr (let ((f2 (get self2 1))) Maybe.none)) ('Kind.Comp.str (let ((f2 (get self2 1))) Maybe.none)) ('Kind.Comp.txt (let ((f2 (get self2 1))) Maybe.none))))))))))
(define Kind.Comp.Prim.elim (lambda (lang$0) (lambda (term$1) (lambda (depth$2) (lambda (defs$3) ($Kind.Comp.Prim.elim lang$0 term$1 depth$2 defs$3))))))
(define ($Kind.Comp.Prim.eliminator lang$0 prim$1 depth$2 defs$3) (let ((term$4 ($Kind.Comp.eli prim$1 ($Kind.Comp.var "x")))) (let ((text$5 ($Maybe.default ($Kind.Comp.Prim.elim lang$0 term$4 0 defs$3) ""))) (let ((term$6 ($Kind.Comp.lam "x" ($Kind.Comp.txt text$5)))) ($Kind.Comp.transpile.term lang$0 term$6 depth$2 defs$3)))))
(define Kind.Comp.Prim.eliminator (lambda (lang$0) (lambda (prim$1) (lambda (depth$2) (lambda (defs$3) ($Kind.Comp.Prim.eliminator lang$0 prim$1 depth$2 defs$3))))))
(define ($BBT.lookup cmp$2 key$3 map$4) (let ((self0 map$4)) (case (get self0 0) ('BBT.tip Maybe.none) ('BBT.bin (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((self5 ((cmp$2 key$3) f1))) (case (get self5 0) ('Cmp.ltn ($BBT.lookup cmp$2 key$3 f3)) ('Cmp.eql ($Maybe.some f2)) ('Cmp.gtn ($BBT.lookup cmp$2 key$3 f4)))))))))))))
(define BBT.lookup (lambda (cmp$2) (lambda (key$3) (lambda (map$4) ($BBT.lookup cmp$2 key$3 map$4)))))
(define ($U16.cmp a$0 b$1) (let ((self0 ($U16.ltn a$0 b$1))) (case self0 (#t Cmp.ltn) (#f (let ((self0 ($U16.eql a$0 b$1))) (case self0 (#t Cmp.eql) (#f Cmp.gtn)))))))
(define U16.cmp (lambda (a$0) (lambda (b$1) ($U16.cmp a$0 b$1))))
(define ($String.cmp a$0 b$1) (let ((self0 a$0)) (case (<= (kstring-length self0) 0) (#t (let ((self0 b$1)) (case (<= (kstring-length self0) 0) (#t Cmp.eql) (#f (let ((f0 (char->integer (kstring-head self0)))) (let ((f1 (kstring-tail self0))) Cmp.ltn)))))) (#f (let ((f0 (char->integer (kstring-head self0)))) (let ((f1 (kstring-tail self0))) (let ((self2 b$1)) (case (<= (kstring-length self2) 0) (#t Cmp.gtn) (#f (let ((f2 (char->integer (kstring-head self2)))) (let ((f3 (kstring-tail self2))) (let ((self4 ($U16.cmp f0 f2))) (case (get self4 0) ('Cmp.ltn Cmp.ltn) ('Cmp.eql ($String.cmp f1 f3)) ('Cmp.gtn Cmp.gtn))))))))))))))
(define String.cmp (lambda (a$0) (lambda (b$1) ($String.cmp a$0 b$1))))
(define ($Map.get key$1 map$2) ($BBT.lookup String.cmp key$1 map$2))
(define Map.get (lambda (key$1) (lambda (map$2) ($Map.get key$1 map$2))))
(define ($Kind.Comp.transpile.global_definitions lang$0 defs_list$1 defs$2) (let ((code$3 "")) (let ((code$4 ($List.for Kind.Comp.Prim.natives code$3 (lambda (nati$4) (lambda (code$5) (let ((self3 nati$4)) (case (get self3 0) ('Pair.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((code$8 ($String.concat code$5 ((((let ((self5 (let ((self5 lang$0)) (case (get self5 0) ('Kind.Comp.Language.new (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) (let ((f8 (get self5 4))) f5))))))))) (case (get self5 0) ('Kind.Comp.Grammar.new (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) (let ((f8 (get self5 4))) (let ((f9 (get self5 5))) (let ((f10 (get self5 6))) (let ((f11 (get self5 7))) (let ((f12 (get self5 8))) (let ((f13 (get self5 9))) (let ((f14 (get self5 10))) (let ((f15 (get self5 11))) (let ((f16 (get self5 12))) (let ((f17 (get self5 13))) (let ((f18 (get self5 14))) f12))))))))))))))))) ((let ((self5 (let ((self5 lang$0)) (case (get self5 0) ('Kind.Comp.Language.new (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) (let ((f8 (get self5 4))) f5))))))))) (case (get self5 0) ('Kind.Comp.Grammar.new (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) (let ((f8 (get self5 4))) (let ((f9 (get self5 5))) (let ((f10 (get self5 6))) (let ((f11 (get self5 7))) (let ((f12 (get self5 8))) (let ((f13 (get self5 9))) (let ((f14 (get self5 10))) (let ((f15 (get self5 11))) (let ((f16 (get self5 12))) (let ((f17 (get self5 13))) (let ((f18 (get self5 14))) f7))))))))))))))))) f3)) List.nil) ($Kind.Comp.Prim.instantiator lang$0 f4 0 defs$2))))) (let ((code$9 ($String.concat code$8 ((((let ((self6 (let ((self6 lang$0)) (case (get self6 0) ('Kind.Comp.Language.new (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((f8 (get self6 3))) (let ((f9 (get self6 4))) f6))))))))) (case (get self6 0) ('Kind.Comp.Grammar.new (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((f8 (get self6 3))) (let ((f9 (get self6 4))) (let ((f10 (get self6 5))) (let ((f11 (get self6 6))) (let ((f12 (get self6 7))) (let ((f13 (get self6 8))) (let ((f14 (get self6 9))) (let ((f15 (get self6 10))) (let ((f16 (get self6 11))) (let ((f17 (get self6 12))) (let ((f18 (get self6 13))) (let ((f19 (get self6 14))) f13))))))))))))))))) ((let ((self6 (let ((self6 lang$0)) (case (get self6 0) ('Kind.Comp.Language.new (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((f8 (get self6 3))) (let ((f9 (get self6 4))) f6))))))))) (case (get self6 0) ('Kind.Comp.Grammar.new (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((f8 (get self6 3))) (let ((f9 (get self6 4))) (let ((f10 (get self6 5))) (let ((f11 (get self6 6))) (let ((f12 (get self6 7))) (let ((f13 (get self6 8))) (let ((f14 (get self6 9))) (let ((f15 (get self6 10))) (let ((f16 (get self6 11))) (let ((f17 (get self6 12))) (let ((f18 (get self6 13))) (let ((f19 (get self6 14))) f9))))))))))))))))) f3)) List.nil) ($Kind.Comp.Prim.eliminator lang$0 f4 0 defs$2))))) code$9)))))))))))) (let ((code$5 ($List.for defs_list$1 code$4 (lambda (defn$5) (lambda (code$6) (let ((self4 defn$5)) (case (get self4 0) ('Pair.new (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((self6 ($Kind.Comp.get_vars f5))) (case (get self6 0) ('Pair.new (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((inlined_body$11 (let ((self8 ($Map.get f4 (let ((self8 lang$0)) (case (get self8 0) ('Kind.Comp.Language.new (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) (let ((f10 (get self8 3))) (let ((f11 (get self8 4))) f10)))))))))) (case (get self8 0) ('Maybe.none ($Kind.Comp.transpile.term lang$0 f7 0 defs$2)) ('Maybe.some (let ((f8 (get self8 1))) ($Kind.Comp.replace ($Pair.snd f8) f6))))))) (let ((code$12 ($String.concat code$6 ((((let ((self9 (let ((self9 lang$0)) (case (get self9 0) ('Kind.Comp.Language.new (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) f9))))))))) (case (get self9 0) ('Kind.Comp.Grammar.new (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((f12 (get self9 4))) (let ((f13 (get self9 5))) (let ((f14 (get self9 6))) (let ((f15 (get self9 7))) (let ((f16 (get self9 8))) (let ((f17 (get self9 9))) (let ((f18 (get self9 10))) (let ((f19 (get self9 11))) (let ((f20 (get self9 12))) (let ((f21 (get self9 13))) (let ((f22 (get self9 14))) f16))))))))))))))))) f4) f6) inlined_body$11)))) code$12))))))))))))))))) code$5))))
(define Kind.Comp.transpile.global_definitions (lambda (lang$0) (lambda (defs_list$1) (lambda (defs$2) ($Kind.Comp.transpile.global_definitions lang$0 defs_list$1 defs$2)))))
(define ($Kind.Comp.transpile lang$0 main$1 defs$2) (let ((defs_list$3 ($Kind.Comp.dependency_sort main$1 defs$2))) (let ((code$4 (((let ((self1 (let ((self1 lang$0)) (case (get self1 0) ('Kind.Comp.Language.new (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) f1))))))))) (case (get self1 0) ('Kind.Comp.Grammar.new (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((f6 (get self1 6))) (let ((f7 (get self1 7))) (let ((f8 (get self1 8))) (let ((f9 (get self1 9))) (let ((f10 (get self1 10))) (let ((f11 (get self1 11))) (let ((f12 (get self1 12))) (let ((f13 (get self1 13))) (let ((f14 (get self1 14))) f14))))))))))))))))) main$1) ($String.concat (let ((self1 lang$0)) (case (get self1 0) ('Kind.Comp.Language.new (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) f4))))))) ($String.concat "\xa;\xa;" ($Kind.Comp.transpile.global_definitions lang$0 defs_list$3 defs$2)))))) code$4)))
(define Kind.Comp.transpile (lambda (lang$0) (lambda (main$1) (lambda (defs$2) ($Kind.Comp.transpile lang$0 main$1 defs$2)))))
(define ($Kind.Comp.Language.new gram$0 nati$1 opts$2 base$3) (vector 'Kind.Comp.Language.new gram$0 nati$1 opts$2 base$3))
(define Kind.Comp.Language.new (lambda (gram$0) (lambda (nati$1) (lambda (opts$2) (lambda (base$3) ($Kind.Comp.Language.new gram$0 nati$1 opts$2 base$3))))))
(define ($Kind.Comp.Grammar.new null$0 name$1 inst_name$2 elim_name$3 lambda$4 application$5 local_definition$6 global_function$7 global_application$8 select$9 string_literal$10 nat$11 module$12 program$13) (vector 'Kind.Comp.Grammar.new null$0 name$1 inst_name$2 elim_name$3 lambda$4 application$5 local_definition$6 global_function$7 global_application$8 select$9 string_literal$10 nat$11 module$12 program$13))
(define Kind.Comp.Grammar.new (lambda (null$0) (lambda (name$1) (lambda (inst_name$2) (lambda (elim_name$3) (lambda (lambda$4) (lambda (application$5) (lambda (local_definition$6) (lambda (global_function$7) (lambda (global_application$8) (lambda (select$9) (lambda (string_literal$10) (lambda (nat$11) (lambda (module$12) (lambda (program$13) ($Kind.Comp.Grammar.new null$0 name$1 inst_name$2 elim_name$3 lambda$4 application$5 local_definition$6 global_function$7 global_application$8 select$9 string_literal$10 nat$11 module$12 program$13))))))))))))))))
(define Kind.Comp.Target.Scheme.null "'()")
(define ($Kind.Comp.Target.Scheme.name name$0) (let ((self0 ($String.is_empty name$0))) (case self0 (#t "-") (#f name$0))))
(define Kind.Comp.Target.Scheme.name (lambda (name$0) ($Kind.Comp.Target.Scheme.name name$0)))
(define ($Kind.Comp.Target.Scheme.inst_name name$0) ($String.concat name$0 "-inst"))
(define Kind.Comp.Target.Scheme.inst_name (lambda (name$0) ($Kind.Comp.Target.Scheme.inst_name name$0)))
(define ($Kind.Comp.Target.Scheme.elim_name name$0) ($String.concat name$0 "-elim"))
(define Kind.Comp.Target.Scheme.elim_name (lambda (name$0) ($Kind.Comp.Target.Scheme.elim_name name$0)))
(define ($Kind.Comp.Target.Scheme.lambda name$0 body$1) ($String.concat "(lambda (" ($String.concat name$0 ($String.concat ") " ($String.concat body$1 ")")))))
(define Kind.Comp.Target.Scheme.lambda (lambda (name$0) (lambda (body$1) ($Kind.Comp.Target.Scheme.lambda name$0 body$1))))
(define ($Kind.Comp.Target.Scheme.application func$0 argm$1) ($String.concat "(" ($String.concat func$0 ($String.concat " " ($String.concat argm$1 ")")))))
(define Kind.Comp.Target.Scheme.application (lambda (func$0) (lambda (argm$1) ($Kind.Comp.Target.Scheme.application func$0 argm$1))))
(define ($Kind.Comp.Target.Scheme.local_definition name$0 expr$1 body$2) ($String.concat "(let ((" ($String.concat name$0 ($String.concat " " ($String.concat expr$1 ($String.concat ")) " ($String.concat body$2 ")")))))))
(define Kind.Comp.Target.Scheme.local_definition (lambda (name$0) (lambda (expr$1) (lambda (body$2) ($Kind.Comp.Target.Scheme.local_definition name$0 expr$1 body$2)))))
(define ($Kind.Comp.Target.Scheme.global_application name$0 args$1) ($String.concat "($" ($String.concat name$0 ($String.concat " " ($String.concat ($String.join " " args$1) ")")))))
(define Kind.Comp.Target.Scheme.global_application (lambda (name$0) (lambda (args$1) ($Kind.Comp.Target.Scheme.global_application name$0 args$1))))
(define ($Kind.Comp.Target.Scheme.nest_lambdas.aux fun$0 args$1 rem_args$2) (let ((self0 rem_args$2)) (case (get self0 0) ('List.nil ($Kind.Comp.Target.Scheme.global_application fun$0 args$1)) ('List.cons (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($Kind.Comp.Target.Scheme.lambda f0 ($Kind.Comp.Target.Scheme.nest_lambdas.aux fun$0 args$1 f1))))))))
(define Kind.Comp.Target.Scheme.nest_lambdas.aux (lambda (fun$0) (lambda (args$1) (lambda (rem_args$2) ($Kind.Comp.Target.Scheme.nest_lambdas.aux fun$0 args$1 rem_args$2)))))
(define ($Kind.Comp.Target.Scheme.nest_lambdas name$0 args$1) (let ((body$2 ($Kind.Comp.Target.Scheme.nest_lambdas.aux name$0 args$1 args$1))) ($String.concat "(define " ($String.concat name$0 ($String.concat " " ($String.concat body$2 ")\xa;"))))))
(define Kind.Comp.Target.Scheme.nest_lambdas (lambda (name$0) (lambda (args$1) ($Kind.Comp.Target.Scheme.nest_lambdas name$0 args$1))))
(define ($Kind.Comp.Target.Scheme.global_function name$0 args$1 body$2) (let ((self0 args$1)) (case (get self0 0) ('List.nil ($String.concat "(define " ($String.concat name$0 ($String.concat " " ($String.concat body$2 ")\xa;"))))) ('List.cons (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($String.concat "(define ($" ($String.concat name$0 ($String.concat " " ($String.concat ($String.join " " args$1) ($String.concat ") " ($String.concat body$2 ($String.concat ")\xa;" ($Kind.Comp.Target.Scheme.nest_lambdas name$0 args$1))))))))))))))
(define Kind.Comp.Target.Scheme.global_function (lambda (name$0) (lambda (args$1) (lambda (body$2) ($Kind.Comp.Target.Scheme.global_function name$0 args$1 body$2)))))
(define ($Kind.Comp.Target.Scheme.select term$0 cse_body_list$1) (let ((cses$2 "")) (let ((cses$3 ($List.for cse_body_list$1 cses$2 (lambda (cse_body$3) (lambda (cses$4) (let ((self3 cse_body$3)) (case (get self3 0) ('Pair.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) ($String.concat cses$4 ($String.concat " (" ($String.concat f3 ($String.concat " " ($String.concat f4 ")"))))))))))))))) ($String.concat "(case " ($String.concat term$0 ($String.concat cses$3 ")"))))))
(define Kind.Comp.Target.Scheme.select (lambda (term$0) (lambda (cse_body_list$1) ($Kind.Comp.Target.Scheme.select term$0 cse_body_list$1))))
(define ($Char.to_string chr$0) ($String.cons chr$0 String.nil))
(define Char.to_string (lambda (chr$0) ($Char.to_string chr$0)))
(define ($Kind.Comp.Target.Scheme.string_literal str$0) (let ((self0 str$0)) (case (<= (kstring-length self0) 0) (#t "") (#f (let ((f0 (char->integer (kstring-head self0)))) (let ((f1 (kstring-tail self0))) ($String.concat (let ((self2 ($Bool.or ($U16.eql f0 92) ($U16.eql f0 34)))) (case self2 (#t ($String.concat "\\" ($Char.to_string f0))) (#f (let ((self2 ($Bool.and ($U16.gte f0 32) ($U16.lte f0 126)))) (case self2 (#t ($Char.to_string f0)) (#f ($String.concat "\\x" ($String.concat ($U16.show_hex f0) ";")))))))) ($Kind.Comp.Target.Scheme.string_literal f1))))))))
(define Kind.Comp.Target.Scheme.string_literal (lambda (str$0) ($Kind.Comp.Target.Scheme.string_literal str$0)))
(define ($Kind.Comp.Target.Scheme.nat nat$0) ($Nat.show nat$0))
(define Kind.Comp.Target.Scheme.nat (lambda (nat$0) ($Kind.Comp.Target.Scheme.nat nat$0)))
(define Kind.Comp.Target.Scheme.exports ($List.cons "suffix?" ($List.cons "prefix?" ($List.cons "run-all" ($List.cons "run_io" ($List.cons "print-lines" ($List.cons "run_kind" ($List.cons "make-string-view" ($List.cons "string-view?" ($List.cons "string-view-end" ($List.cons "string-view-start" ($List.cons "kstring-length" ($List.cons "kstring-head" ($List.cons "kstring-tail" ($List.cons "string-view-ref" ($List.cons "kstring?" ($List.cons "kstring->string" ($List.cons "kstring-append" ($List.cons "kstring-getter" ($List.cons "kstring_join" List.nil))))))))))))))))))))
(define ($Kind.Comp.Target.Scheme.module name$0 exports$1 defs$2) (let ((code$3 ($String.concat "#!chezscheme\xa;(library (" ($String.concat name$0 ") (export")))) (let ((code$4 ($List.for Kind.Comp.Target.Scheme.exports code$3 (lambda (export$4) (lambda (code$5) ($String.concat code$5 ($String.concat " " export$4))))))) (let ((code$5 ($List.for exports$1 code$4 (lambda (export$5) (lambda (code$6) ($String.concat code$6 ($String.concat " " export$5))))))) (let ((code$6 ($String.concat code$5 ")\xa;"))) (let ((code$7 ($String.concat code$6 "(import (chezscheme))\xa;"))) (let ((code$8 ($String.concat code$7 ($String.concat defs$2 ")")))) code$8)))))))
(define Kind.Comp.Target.Scheme.module (lambda (name$0) (lambda (exports$1) (lambda (defs$2) ($Kind.Comp.Target.Scheme.module name$0 exports$1 defs$2)))))
(define ($Kind.Comp.Target.Scheme.program main$0 defs$1) (let ((code$2 ($String.concat defs$1 ($String.concat "(run_kind " ($String.concat main$0 ")"))))) code$2))
(define Kind.Comp.Target.Scheme.program (lambda (main$0) (lambda (defs$1) ($Kind.Comp.Target.Scheme.program main$0 defs$1))))
(define Kind.Comp.Target.Scheme.grammar ($Kind.Comp.Grammar.new Kind.Comp.Target.Scheme.null Kind.Comp.Target.Scheme.name Kind.Comp.Target.Scheme.inst_name Kind.Comp.Target.Scheme.elim_name Kind.Comp.Target.Scheme.lambda Kind.Comp.Target.Scheme.application Kind.Comp.Target.Scheme.local_definition Kind.Comp.Target.Scheme.global_function Kind.Comp.Target.Scheme.global_application Kind.Comp.Target.Scheme.select Kind.Comp.Target.Scheme.string_literal Kind.Comp.Target.Scheme.nat Kind.Comp.Target.Scheme.module Kind.Comp.Target.Scheme.program))
(define ($Kind.Comp.Native.new inst$0 elim$1) (vector 'Kind.Comp.Native.new inst$0 elim$1))
(define Kind.Comp.Native.new (lambda (inst$0) (lambda (elim$1) ($Kind.Comp.Native.new inst$0 elim$1))))
(define ($Kind.Comp.Target.Scheme.natives prim$0) (let ((self0 prim$0)) (case (get self0 0) ('Kind.Comp.Prim.bool ($Kind.Comp.Native.new ($List.cons ($Pair.new 0 "#t") ($List.cons ($Pair.new 0 "#f") List.nil)) ($Pair.new "$0" ($List.cons ($Pair.new "#t" List.nil) ($List.cons ($Pair.new "#f" List.nil) List.nil))))) ('Kind.Comp.Prim.bits ($Kind.Comp.Native.new ($List.cons ($Pair.new 0 "#b1") ($List.cons ($Pair.new 1 "(bitwise-arithmetic-shift-left $0 #b1)") ($List.cons ($Pair.new 1 "(bitwise-ior (bitwise-arithmetic-shift-left $0 #b1) #b1)") List.nil))) ($Pair.new "(if (eq? $0 #b1) 2 (bitwise-and $0 #b1))" ($List.cons ($Pair.new "2" List.nil) ($List.cons ($Pair.new "0" ($List.cons "(bitwise-arithmetic-shift-right $0 #b1)" List.nil)) ($List.cons ($Pair.new "1" ($List.cons "(bitwise-arithmetic-shift-right $0 #b1)" List.nil)) List.nil)))))) ('Kind.Comp.Prim.unit ($Kind.Comp.Native.new ($List.cons ($Pair.new 0 "#t") List.nil) ($Pair.new "#t" ($List.cons ($Pair.new "#t" List.nil) List.nil)))) ('Kind.Comp.Prim.nat ($Kind.Comp.Native.new ($List.cons ($Pair.new 0 "0") ($List.cons ($Pair.new 1 "(+ $0 1)") List.nil)) ($Pair.new "(= $0 0)" ($List.cons ($Pair.new "#t" List.nil) ($List.cons ($Pair.new "#f" ($List.cons "(- $0 1)" List.nil)) List.nil))))) ('Kind.Comp.Prim.u16 ($Kind.Comp.Native.new ($List.cons ($Pair.new 1 "(word-to-u16 $0)") List.nil) ($Pair.new "#t" ($List.cons ($Pair.new "#t" ($List.cons "(u16-to-word $0)" List.nil)) List.nil)))) ('Kind.Comp.Prim.u32 ($Kind.Comp.Native.new ($List.cons ($Pair.new 1 "(word-to-u 32 $0)") List.nil) ($Pair.new "#t" ($List.cons ($Pair.new "#t" ($List.cons "(u-to-word 32 $0)" List.nil)) List.nil)))) ('Kind.Comp.Prim.string ($Kind.Comp.Native.new ($List.cons ($Pair.new 0 "\"\"") ($List.cons ($Pair.new 2 "(kstring-append (make-string 1 (integer->char $0)) $1)") List.nil)) ($Pair.new "(<= (kstring-length $0) 0)" ($List.cons ($Pair.new "#t" List.nil) ($List.cons ($Pair.new "#f" ($List.cons "(char->integer (kstring-head $0))" ($List.cons "(kstring-tail $0)" List.nil))) List.nil))))) ('Kind.Comp.Prim.data (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($Kind.Comp.Native.new ($List.fold f1 List.nil (lambda (ctr$3) (lambda (result$4) (let ((self4 ctr$3)) (case (get self4 0) ('Pair.new (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((fields_size$7 ($List.length f5))) (let ((fields_vars$8 ($String.join "" ($List.create fields_size$7 (lambda (x$8) ($String.concat " $" ($Nat.show x$8))))))) ($List.cons ($Pair.new fields_size$7 ($String.concat "(vector '" ($String.concat f0 ($String.concat "." ($String.concat f4 ($String.concat fields_vars$8 ")")))))) result$4))))))))))) ($Pair.new "(get $0 0)" ($List.fold f1 List.nil (lambda (ctr$3) (lambda (result$4) (let ((self4 ctr$3)) (case (get self4 0) ('Pair.new (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((fields_size$7 ($List.length f5))) (let ((fields_gets$8 ($List.create fields_size$7 (lambda (i$8) ($String.concat "(get $0 " ($String.concat ($Nat.show ($Nat.succ i$8)) ")")))))) ($List.cons ($Pair.new ($String.concat "'" ($String.concat f0 ($String.concat "." f4))) fields_gets$8) result$4)))))))))))))))))))
(define Kind.Comp.Target.Scheme.natives (lambda (prim$0) ($Kind.Comp.Target.Scheme.natives prim$0)))
(define ($BBT.bin size$2 key$3 val$4 left$5 right$6) (vector 'BBT.bin size$2 key$3 val$4 left$5 right$6))
(define BBT.bin (lambda (size$2) (lambda (key$3) (lambda (val$4) (lambda (left$5) (lambda (right$6) ($BBT.bin size$2 key$3 val$4 left$5 right$6)))))))
(define ($U32.new value$0) (word-to-u 32 value$0))
(define U32.new (lambda (value$0) ($U32.new value$0)))
(define ($Nat.to_u32 n$0) ($U32.new ($Nat.to_word ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ Nat.zero)))))))))))))))))))))))))))))))) n$0)))
(define Nat.to_u32 (lambda (n$0) ($Nat.to_u32 n$0)))
(define BBT.tip (vector 'BBT.tip))
(define ($BBT.singleton key$2 val$3) ($BBT.bin ($Nat.to_u32 1) key$2 val$3 BBT.tip BBT.tip))
(define BBT.singleton (lambda (key$2) (lambda (val$3) ($BBT.singleton key$2 val$3))))
(define ($BBT.size map$2) (let ((self0 map$2)) (case (get self0 0) ('BBT.tip ($Nat.to_u32 0)) ('BBT.bin (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) f0)))))))))
(define BBT.size (lambda (map$2) ($BBT.size map$2)))
(define ($U32.add a$0 b$1) (let ((self0 a$0)) (case #t (#t (let ((f0 (u-to-word 32 self0))) (let ((self1 b$1)) (case #t (#t (let ((f1 (u-to-word 32 self1))) ($U32.new ($Word.add f0 f1)))))))))))
(define U32.add (lambda (a$0) (lambda (b$1) ($U32.add a$0 b$1))))
(define ($U32.mul a$0 b$1) (let ((self0 a$0)) (case #t (#t (let ((f0 (u-to-word 32 self0))) (let ((self1 b$1)) (case #t (#t (let ((f1 (u-to-word 32 self1))) ($U32.new ($Word.mul f0 f1)))))))))))
(define U32.mul (lambda (a$0) (lambda (b$1) ($U32.mul a$0 b$1))))
(define BBT.w ($Nat.to_u32 3))
(define ($U32.ltn a$0 b$1) (let ((self0 a$0)) (case #t (#t (let ((f0 (u-to-word 32 self0))) (let ((self1 b$1)) (case #t (#t (let ((f1 (u-to-word 32 self1))) ($Word.ltn f0 f1))))))))))
(define U32.ltn (lambda (a$0) (lambda (b$1) ($U32.ltn a$0 b$1))))
(define ($U32.from_nat n$0) ($U32.new ($Nat.to_word ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ Nat.zero)))))))))))))))))))))))))))))))) n$0)))
(define U32.from_nat (lambda (n$0) ($U32.from_nat n$0)))
(define ($BBT.node key$2 val$3 left$4 right$5) (let ((size_left$6 ($BBT.size left$4))) (let ((size_right$7 ($BBT.size right$5))) (let ((new_size$8 ($U32.add ($U32.from_nat 1) ($U32.add size_left$6 size_right$7)))) ($BBT.bin new_size$8 key$2 val$3 left$4 right$5)))))
(define BBT.node (lambda (key$2) (lambda (val$3) (lambda (left$4) (lambda (right$5) ($BBT.node key$2 val$3 left$4 right$5))))))
(define ($Cmp.as_gtn cmp$0) (let ((self0 cmp$0)) (case (get self0 0) ('Cmp.ltn Bool.false) ('Cmp.eql Bool.false) ('Cmp.gtn Bool.true))))
(define Cmp.as_gtn (lambda (cmp$0) ($Cmp.as_gtn cmp$0)))
(define ($Word.gtn a$1 b$2) ($Cmp.as_gtn ($Word.cmp a$1 b$2)))
(define Word.gtn (lambda (a$1) (lambda (b$2) ($Word.gtn a$1 b$2))))
(define ($U32.gtn a$0 b$1) (let ((self0 a$0)) (case #t (#t (let ((f0 (u-to-word 32 self0))) (let ((self1 b$1)) (case #t (#t (let ((f1 (u-to-word 32 self1))) ($Word.gtn f0 f1))))))))))
(define U32.gtn (lambda (a$0) (lambda (b$1) ($U32.gtn a$0 b$1))))
(define ($BBT.balance k$2 v$3 l$4 r$5) (let ((size_l$6 ($BBT.size l$4))) (let ((size_r$7 ($BBT.size r$5))) (let ((size_l_plus_size_r$8 ($U32.add size_l$6 size_r$7))) (let ((w_x_size_l$9 ($U32.mul BBT.w size_l$6))) (let ((w_x_size_r$10 ($U32.mul BBT.w size_r$7))) (let ((self5 ($U32.ltn size_l_plus_size_r$8 ($Nat.to_u32 2)))) (case self5 (#t ($BBT.node k$2 v$3 l$4 r$5)) (#f (let ((self5 ($U32.gtn size_r$7 w_x_size_l$9))) (case self5 (#t (let ((self5 r$5)) (case (get self5 0) ('BBT.tip ($BBT.node k$2 v$3 l$4 r$5)) ('BBT.bin (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) (let ((f8 (get self5 4))) (let ((f9 (get self5 5))) (let ((size_rl$16 ($BBT.size f8))) (let ((size_rr$17 ($BBT.size f9))) (let ((self12 ($U32.ltn size_rl$16 size_rr$17))) (case self12 (#t (let ((new_key$18 f6)) (let ((new_val$19 f7)) (let ((new_left$20 ($BBT.node k$2 v$3 l$4 f8))) (let ((new_right$21 f9)) ($BBT.node new_key$18 new_val$19 new_left$20 new_right$21)))))) (#f (let ((self12 f8)) (case (get self12 0) ('BBT.tip ($BBT.node k$2 v$3 l$4 r$5)) ('BBT.bin (let ((f12 (get self12 1))) (let ((f13 (get self12 2))) (let ((f14 (get self12 3))) (let ((f15 (get self12 4))) (let ((f16 (get self12 5))) (let ((new_key$23 f13)) (let ((new_val$24 f14)) (let ((new_left$25 ($BBT.node k$2 v$3 l$4 f15))) (let ((new_right$26 ($BBT.node f6 f7 f16 f9))) ($BBT.node new_key$23 new_val$24 new_left$25 new_right$26))))))))))))))))))))))))))) (#f (let ((self5 ($U32.gtn size_l$6 w_x_size_r$10))) (case self5 (#t (let ((self5 l$4)) (case (get self5 0) ('BBT.tip ($BBT.node k$2 v$3 l$4 r$5)) ('BBT.bin (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) (let ((f8 (get self5 4))) (let ((f9 (get self5 5))) (let ((size_ll$16 ($BBT.size f8))) (let ((size_lr$17 ($BBT.size f9))) (let ((self12 ($U32.ltn size_lr$17 size_ll$16))) (case self12 (#t (let ((new_key$18 f6)) (let ((new_val$19 f7)) (let ((new_left$20 f8)) (let ((new_right$21 ($BBT.node k$2 v$3 f9 r$5))) ($BBT.node new_key$18 new_val$19 new_left$20 new_right$21)))))) (#f (let ((self12 f9)) (case (get self12 0) ('BBT.tip ($BBT.node k$2 v$3 l$4 r$5)) ('BBT.bin (let ((f12 (get self12 1))) (let ((f13 (get self12 2))) (let ((f14 (get self12 3))) (let ((f15 (get self12 4))) (let ((f16 (get self12 5))) (let ((new_key$23 f13)) (let ((new_val$24 f14)) (let ((new_left$25 ($BBT.node f6 f7 f8 f15))) (let ((new_right$26 ($BBT.node k$2 v$3 f16 r$5))) ($BBT.node new_key$23 new_val$24 new_left$25 new_right$26))))))))))))))))))))))))))) (#f ($BBT.node k$2 v$3 l$4 r$5))))))))))))))))
(define BBT.balance (lambda (k$2) (lambda (v$3) (lambda (l$4) (lambda (r$5) ($BBT.balance k$2 v$3 l$4 r$5))))))
(define ($BBT.insert cmp$2 key$3 val$4 map$5) (let ((self0 map$5)) (case (get self0 0) ('BBT.tip ($BBT.singleton key$3 val$4)) ('BBT.bin (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((self5 ((cmp$2 key$3) f1))) (case (get self5 0) ('Cmp.ltn (let ((new_key$11 f1)) (let ((new_val$12 f2)) (let ((new_left$13 ($BBT.insert cmp$2 key$3 val$4 f3))) (let ((new_right$14 f4)) ($BBT.balance new_key$11 new_val$12 new_left$13 new_right$14)))))) ('Cmp.eql ($BBT.node key$3 val$4 f3 f4)) ('Cmp.gtn (let ((new_key$11 f1)) (let ((new_val$12 f2)) (let ((new_left$13 f3)) (let ((new_right$14 ($BBT.insert cmp$2 key$3 val$4 f4))) ($BBT.balance new_key$11 new_val$12 new_left$13 new_right$14)))))))))))))))))
(define BBT.insert (lambda (cmp$2) (lambda (key$3) (lambda (val$4) (lambda (map$5) ($BBT.insert cmp$2 key$3 val$4 map$5))))))
(define ($BBT.from_list.go cmp$2 acc$3 xs$4) (let ((self0 xs$4)) (case (get self0 0) ('List.nil acc$3) ('List.cons (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((key$7 ($Pair.fst f0))) (let ((val$8 ($Pair.snd f0))) (let ((new_acc$9 ($BBT.insert cmp$2 key$7 val$8 acc$3))) ($BBT.from_list.go cmp$2 new_acc$9 f1))))))))))
(define BBT.from_list.go (lambda (cmp$2) (lambda (acc$3) (lambda (xs$4) ($BBT.from_list.go cmp$2 acc$3 xs$4)))))
(define ($BBT.from_list cmp$2 xs$3) ($BBT.from_list.go cmp$2 BBT.tip xs$3))
(define BBT.from_list (lambda (cmp$2) (lambda (xs$3) ($BBT.from_list cmp$2 xs$3))))
(define ($Map.from_list xs$1) ($BBT.from_list String.cmp xs$1))
(define Map.from_list (lambda (xs$1) ($Map.from_list xs$1)))
(define Kind.Comp.Target.Scheme.optimizeds ($Map.from_list ($List.cons ($Pair.new "Bool.not" ($Pair.new 1 "(not $0)")) ($List.cons ($Pair.new "Bool.and" ($Pair.new 2 "(and $0 $1)")) ($List.cons ($Pair.new "Bool.if" ($Pair.new 3 "(if $0 $1 $2)")) ($List.cons ($Pair.new "Bool.or" ($Pair.new 2 "(or $0 $1)")) ($List.cons ($Pair.new "Nat.add" ($Pair.new 2 "(+ $0 $1)")) ($List.cons ($Pair.new "Nat.sub" ($Pair.new 2 "(max (- $0 $1) 0)")) ($List.cons ($Pair.new "Nat.mul" ($Pair.new 2 "(* $0 $1)")) ($List.cons ($Pair.new "Nat.div" ($Pair.new 2 "(div $0 $1)")) ($List.cons ($Pair.new "Nat.mod" ($Pair.new 2 "(mod $0 $1)")) ($List.cons ($Pair.new "Nat.pow" ($Pair.new 2 "(expt $0 $1)")) ($List.cons ($Pair.new "Nat.ltn" ($Pair.new 2 "(< $0 $1)")) ($List.cons ($Pair.new "Nat.lte" ($Pair.new 2 "(<= $0 $1)")) ($List.cons ($Pair.new "Nat.eql" ($Pair.new 2 "(= $0 $1)")) ($List.cons ($Pair.new "Nat.gte" ($Pair.new 2 "(>= $0 $1)")) ($List.cons ($Pair.new "Nat.gtn" ($Pair.new 2 "(> $0 $1)")) ($List.cons ($Pair.new "Nat.to_u16" ($Pair.new 1 "$0")) ($List.cons ($Pair.new "Nat.show" ($Pair.new 1 "(number->string $0)")) ($List.cons ($Pair.new "U16.add" ($Pair.new 2 "(mod (+ $0 $1) 65536)")) ($List.cons ($Pair.new "U16.sub" ($Pair.new 2 "(mod (- $0 $1) 65536)")) ($List.cons ($Pair.new "U16.mul" ($Pair.new 2 "(mod (* $0 $1) 65536)")) ($List.cons ($Pair.new "U16.div" ($Pair.new 2 "(div $0 $1)")) ($List.cons ($Pair.new "U16.mod" ($Pair.new 2 "(mod $0 $1)")) ($List.cons ($Pair.new "U16.pow" ($Pair.new 2 "(mod (expt $0 $1) 65536)")) ($List.cons ($Pair.new "U16.ltn" ($Pair.new 2 "(< $0 $1)")) ($List.cons ($Pair.new "U16.lte" ($Pair.new 2 "(<= $0 $1)")) ($List.cons ($Pair.new "U16.eql" ($Pair.new 2 "(= $0 $1)")) ($List.cons ($Pair.new "U16.gte" ($Pair.new 2 "(>= $0 $1)")) ($List.cons ($Pair.new "U16.gtn" ($Pair.new 2 "(> $0 $1)")) ($List.cons ($Pair.new "U16.inc" ($Pair.new 2 "(+ $0 1)")) ($List.cons ($Pair.new "U16.to_nat" ($Pair.new 1 "$0")) ($List.cons ($Pair.new "String.eql" ($Pair.new 2 "(string=? (kstring->string $0) (kstring->string $1))")) ($List.cons ($Pair.new "String.concat" ($Pair.new 2 "(kstring-append $0 $1)")) List.nil))))))))))))))))))))))))))))))))))
(define Kind.Comp.Target.Scheme.basics "; string-view record type (fast way to get a tail)\xa;(define-record string-view\xa;  ((immutable data)  ; underlying string\xa;   (immutable start) ; start position (inclusive)\xa;   (immutable end))) ; end position (exclusive)\xa;\xa;(define string-view-ref\xa;  (lambda (x y)\xa;    (string-ref (string-view-data x) (+ (string-view-start x) y))))\xa;\xa;(define kstring-tail\xa;  (lambda (x)\xa;    (if (string-view? x)\xa;      (make-string-view\xa;        (string-view-data x)\xa;        (+ (string-view-start x) 1)\xa;        (string-view-end x))\xa;      (make-string-view\xa;        x\xa;        1\xa;        (string-length x)))))\xa;\xa;(define kstring-head\xa;  (lambda (x)\xa;    (if (string-view? x)\xa;      (string-ref (string-view-data x) (string-view-start x))\xa;      (string-ref x 0))))\xa;\xa;(define kstring-length\xa;  (lambda (x)\xa;    (if (string-view? x)\xa;      (- (string-view-end x) (string-view-start x))\xa;      (string-length x))))\xa;\xa;(define kstring?\xa;  (lambda (x)\xa;    (or (string-view? x) (string? x))))\xa;\xa;(define kstring->string\xa;  (lambda (x)\xa;    (if (string-view? x)\xa;      (substring (string-view-data x) (string-view-start x) (string-view-end x))\xa;      x)))\xa;\xa;; TODO depending on x, we could safely append data at the end\xa;(define kstring-append\xa;  (lambda (x y)\xa;    (string-append (kstring->string x) (kstring->string y))))\xa;\xa;(define kstring-getter\xa;  (lambda (x)\xa;    (if (string-view? x)\xa;      string-view-ref\xa;      string-ref)))\xa;\xa;; Joins a list of strings with an intercalated separator\xa;(define (kstring_join sep strs fst)\xa;  (if (null? strs) \xa;    \"\"\xa;    (kstring-append\xa;      (if fst \"\" sep)\xa;      (car strs)\xa;      (kstring_join sep (cdr strs) #f))))\xa;\xa;; Short alias to vector-ref\xa;(define get vector-ref)\xa;\xa;; Converts a Kind word to a native integer\xa;(define (word-to-u16 w)\xa;  (define (word-to-u16-go i w x)\xa;    (cond ((= 16 i) x)\xa;      ((symbol=? 'Word.e (get w 0)) (word-to-u16-go (+ i 1) (vector 'Word.e) x))\xa;      ((symbol=? 'Word.o (get w 0)) (word-to-u16-go (+ i 1) (get w 1) x))\xa;      ((symbol=? 'Word.i (get w 0)) (word-to-u16-go (+ i 1) (get w 1) (fxior x (fxarithmetic-shift-left 1 i))))))\xa;  (word-to-u16-go 0 w 0))\xa;\xa;(define (word-to-u n w)\xa;  (define (word-to-u-go n i w x)\xa;    (cond ((= n i) x)\xa;      ((symbol=? 'Word.e (get w 0)) (word-to-u-go n (+ i 1) (vector 'Word.e) x))\xa;      ((symbol=? 'Word.o (get w 0)) (word-to-u-go n (+ i 1) (get w 1) x))\xa;      ((symbol=? 'Word.i (get w 0)) (word-to-u-go n (+ i 1) (get w 1) (fxior x (fxarithmetic-shift-left 1 i))))))\xa;  (word-to-u-go n 0 w 0))\xa;\xa;; Converts a native integer to a Kind word\xa;(define (u16-to-word x)\xa;  (define (u16-to-word-go i x w)\xa;    (if (= 16 i) w (u16-to-word-go (+ i 1) x\xa;      (if (= (fxand (fxarithmetic-shift-right x (- 15 i)) 1) 0)\xa;        (vector 'Word.o w)\xa;        (vector 'Word.i w)))))\xa;  (u16-to-word-go 0 x (vector 'Word.e)))\xa;\xa;(define (u-to-word n x)\xa;  (define (u-to-word-go n i x w)\xa;    (if (= n i) w (u-to-word-go n (+ i 1) x\xa;      (if (= (fxand (fxarithmetic-shift-right x (- n (+ i 1))) 1) 0)\xa;        (vector 'Word.o w)\xa;        (vector 'Word.i w)))))\xa;  (u-to-word-go n 0 x (vector 'Word.e)))\xa;\xa;(define suffix?\xa;  (lambda (str suff)\xa;    (let ((suff_length (string-length suff))\xa;          (str_length (string-length str)))\xa;      (if (<= suff_length str_length)\xa;        (string=?\xa;          (substring str (- str_length suff_length) str_length)\xa;          suff)\xa;        #f))))\xa;\xa;(define prefix?\xa;  (lambda (str pref)\xa;    (let ((pref_length (string-length pref))\xa;          (str_length (string-length str)))\xa;      (if (<= pref_length str_length)\xa;        (string=?\xa;          (substring str 0 pref_length)\xa;          pref)\xa;        #f))))\xa;\xa;; Returns the last index that chr occurs in str, -1 otherwise\xa;(define (last_index_of chr kstr idx)\xa;  (let ((str (kstring->string kstr)))\xa;    (if (= idx (kstring-length str))\xa;      -1\xa;      (let ((rest (last_index_of chr str (+ idx 1))))\xa;        (if (char=? (string-ref str idx) chr)\xa;          (max idx rest)\xa;          rest)))))\xa;\xa;; Returns the first index that chr occurs in str, -1 otherwise\xa;(define (first_index_of chr kstr idx)\xa;  (let ((str (kstring->string kstr)))\xa;    (if (= idx (string-length str))\xa;      -1\xa;      (if (char=? (string-ref str idx) chr)\xa;        idx\xa;        (first_index_of chr str (+ idx 1))))))\xa;\xa;; Splits a string using an identifier\xa;(define (split_at_first chr kstr)\xa;  (let ((str (kstring->string kstr)))\xa;    (let ((split_idx (first_index_of chr str 0)))\xa;      (if (= split_idx -1)\xa;        str\xa;        (cons\xa;          (substring str 0 split_idx)\xa;          (substring str (+ split_idx 1) (string-length str)))))))\xa;\xa;; Splits a string using an identifier\xa;(define (split_at_last chr kstr)\xa;  (let ((str (kstring->string kstr)))\xa;    (let ((split_idx (last_index_of chr str 0)))\xa;      (if (= split_idx -1)\xa;        str\xa;        (cons\xa;          (substring str 0 split_idx)\xa;          (substring str (+ split_idx 1) (string-length str)))))))\xa;\xa;; Converts a date to a string, in milliseconds\xa;(define (time_to_string time)\xa;  (number->string\xa;    (+ (* (time-second time) 1000)\xa;      (div (time-nanosecond time) 1000000))))\xa;\xa;; Prints a text with a newline\xa;(define (print txt)\xa;  (display (kstring->string txt))\xa;  (display \"\xa;\"))\xa;\xa;; Gets a line from stdin\xa;(define (get_line)\xa;  (let ((port (current-input-port)))\xa;    (get-line port)))\xa;\xa;; Deletes a file\xa;(define (del_file file)\xa;  (delete-file (kstring->string file)))\xa;\xa;; Gets the contents of a file as a string\xa;; If it doesn't exist, returns empty\xa;(define (get_file ifile)\xa;  (let ((file (kstring->string ifile)))\xa;    (if (file-exists? file)\xa;      (let ((port (open-input-file file)))\xa;        (let ((text (get-string-all port)))\xa;          (begin\xa;            (close-input-port port)\xa;            text)))\xa;      \"\")))\xa;\xa;; Sets the contents of a file\xa;(define (set_file file text)\xa;  (system (string-append \"mkdir -p \" (car (split_at_last #\\/ file))))\xa;  (if (file-exists? file) (delete-file file))\xa;  (let ((port (open-output-file file)))\xa;    (begin\xa;      (display text port)\xa;      (close-output-port port))))\xa;\xa;; Returns a list of files in a directory\xa;(define (get_dir path)\xa;  (directory-list path)) \xa;\xa;; Returns the time a file was modified. TODO: test on Windows/Linux\xa;(define (get_file_mtime file)\xa;  (time_to_string (file-modification-time (kstring->string file))))\xa;\xa;; Returns the current time\xa;(define (get_time)\xa;  (time_to_string (current-time)))\xa;\xa;; Performs a single Kind IO action\xa;(define (io_action iname)\xa;  (let ((name (kstring->string iname)))\xa;  (case name\xa;    (\"print\" (lambda (x) (print x)))\xa;    (\"put_string\" (lambda (x) (display x)))\xa;    (\"get_line\" (lambda (x) (get_line)))\xa;    (\"del_file\" (lambda (x) (del_file x)))\xa;    (\"get_file\" (lambda (x) (get_file x)))\xa;    (\"set_file\" (lambda (x) (let ((file_text (split_at_first #\\= (kstring->string x)))) (set_file (car file_text) (cdr file_text)))))\xa;    (\"get_dir\" (lambda (x) (get_dir x)))\xa;    (\"get_file_mtime\" (lambda (x) (get_file_mtime x)))\xa;    (\"get_time\" (lambda (x) (get_time)))\xa;    (\"request\" (lambda (x) \"\"))\xa;    (else (display (string-append \"IO action not found: \" name))))))\xa;\xa;; Runs a Kind IO program\xa;(define (run_io io)\xa;  (case (vector-ref io 0)\xa;    ('IO.end (vector-ref io 1))\xa;    ('IO.ask (let (\xa;      (io_query (vector-ref io 1))\xa;      (io_param (vector-ref io 2))\xa;      (io_then (vector-ref io 3)))\xa;      (run_io (io_then ((io_action io_query) io_param)))))))\xa;\xa;(define (run_kind term)\xa;  (if\xa;    (and\xa;      (vector? term)\xa;      (or\xa;        (eq? (vector-ref term 0) 'IO.ask)\xa;        (eq? (vector-ref term 0) 'IO.end)))\xa;    (run_io term)\xa;    (print term)))\xa;\xa;(define (print-lines args)\xa;  (unless (null? args)\xa;    (display (car args))\xa;    (newline)\xa;    (print-lines (cdr args))))\xa;\xa;(define run-all\xa;    (lambda (p)\xa;      (let ((code (get-datum p)))\xa;        (unless (eq? code #!eof)\xa;          (compile code)\xa;          (run-all p)))))\xa;")
(define Kind.Comp.Target.Scheme.Language ($Kind.Comp.Language.new Kind.Comp.Target.Scheme.grammar Kind.Comp.Target.Scheme.natives Kind.Comp.Target.Scheme.optimizeds Kind.Comp.Target.Scheme.basics))
(define ($Kind.api.io.term_to_scheme name$0) (((let ((self0 IO.monad)) (case (get self0 0) ('Monad.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) f0))))) ($Kind.Synth.one name$0 Kind.Map.new)) (lambda (defs$1) (let ((defs$2 ($Maybe.default defs$1 Kind.Map.new))) (let ((compiled$3 ($Kind.Comp.Defs.compile defs$2))) (let ((schemed$4 ($Kind.Comp.transpile Kind.Comp.Target.Scheme.Language name$0 compiled$3))) ((let ((self4 IO.monad)) (case (get self4 0) ('Monad.new (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) f5))))) schemed$4)))))))
(define Kind.api.io.term_to_scheme (lambda (name$0) ($Kind.api.io.term_to_scheme name$0)))
(define ($Kind.Synth.many names$0 defs$1) (let ((self0 names$0)) (case (get self0 0) ('List.nil ((let ((self0 IO.monad)) (case (get self0 0) ('Monad.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) f1))))) defs$1)) ('List.cons (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (((let ((self2 IO.monad)) (case (get self2 0) ('Monad.new (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) f2))))) ($Kind.Synth.one f0 defs$1)) (lambda (new_defs$4) (let ((self3 new_defs$4)) (case (get self3 0) ('Maybe.none ($Kind.Synth.many f1 defs$1)) ('Maybe.some (let ((f3 (get self3 1))) ($Kind.Synth.many f1 f3)))))))))))))
(define Kind.Synth.many (lambda (names$0) (lambda (defs$1) ($Kind.Synth.many names$0 defs$1))))
(define ($Kind.Comp.dependency_sort.module exports$0 defs$1) (let ((ret$2 ($Pair.new Kind.Map.new List.nil))) (let ((ret$3 ($List.for exports$0 ret$2 (lambda (export$3) (lambda (ret$4) (let ((term$5 ($Kind.Comp.ref export$3))) (let ((self4 ret$4)) (case (get self4 0) ('Pair.new (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) ($Kind.Comp.dependency_sort.go term$5 defs$1 f4 f5)))))))))))) (let ((self2 ret$3)) (case (get self2 0) ('Pair.new (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) ($List.reverse f3)))))))))
(define Kind.Comp.dependency_sort.module (lambda (exports$0) (lambda (defs$1) ($Kind.Comp.dependency_sort.module exports$0 defs$1))))
(define ($Kind.Comp.transpile.module lang$0 name$1 exports$2 defs$3) (let ((defs_list$4 ($Kind.Comp.dependency_sort.module exports$2 defs$3))) (let ((code$5 ((((let ((self1 (let ((self1 lang$0)) (case (get self1 0) ('Kind.Comp.Language.new (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) f1))))))))) (case (get self1 0) ('Kind.Comp.Grammar.new (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((f6 (get self1 6))) (let ((f7 (get self1 7))) (let ((f8 (get self1 8))) (let ((f9 (get self1 9))) (let ((f10 (get self1 10))) (let ((f11 (get self1 11))) (let ((f12 (get self1 12))) (let ((f13 (get self1 13))) (let ((f14 (get self1 14))) f13))))))))))))))))) name$1) exports$2) ($String.concat (let ((self1 lang$0)) (case (get self1 0) ('Kind.Comp.Language.new (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) f4))))))) ($String.concat "\xa;\xa;" ($Kind.Comp.transpile.global_definitions lang$0 defs_list$4 defs$3)))))) code$5)))
(define Kind.Comp.transpile.module (lambda (lang$0) (lambda (name$1) (lambda (exports$2) (lambda (defs$3) ($Kind.Comp.transpile.module lang$0 name$1 exports$2 defs$3))))))
(define ($Kind.api.io.terms_to_scheme_lib name$0 exports$1) (((let ((self0 IO.monad)) (case (get self0 0) ('Monad.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) f0))))) ($Kind.Synth.many exports$1 Kind.Map.new)) (lambda (defs$2) (let ((compiled$3 ($Kind.Comp.Defs.compile defs$2))) (let ((schemed$4 ($Kind.Comp.transpile.module Kind.Comp.Target.Scheme.Language name$0 exports$1 compiled$3))) ((let ((self3 IO.monad)) (case (get self3 0) ('Monad.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) f4))))) schemed$4))))))
(define Kind.api.io.terms_to_scheme_lib (lambda (name$0) (lambda (exports$1) ($Kind.api.io.terms_to_scheme_lib name$0 exports$1))))
(define ($BitsMap.keys.go xs$1 key$2 list$3) (let ((self0 xs$1)) (case (get self0 0) ('BitsMap.new list$3) ('BitsMap.tie (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((list0$7 (let ((self3 f0)) (case (get self3 0) ('Maybe.none list$3) ('Maybe.some (let ((f3 (get self3 1))) ($List.cons ($Bits.reverse key$2) list$3))))))) (let ((list1$8 ($BitsMap.keys.go f1 ($Bits.o key$2) list0$7))) (let ((list2$9 ($BitsMap.keys.go f2 ($Bits.i key$2) list1$8))) list2$9))))))))))
(define BitsMap.keys.go (lambda (xs$1) (lambda (key$2) (lambda (list$3) ($BitsMap.keys.go xs$1 key$2 list$3)))))
(define ($BitsMap.keys xs$1) ($List.reverse ($BitsMap.keys.go xs$1 Bits.e List.nil)))
(define BitsMap.keys (lambda (xs$1) ($BitsMap.keys xs$1)))
(define ($Kind.Synth.file file$0 defs$1) (((let ((self0 IO.monad)) (case (get self0 0) ('Monad.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) f0))))) ($IO.get_file file$0)) (lambda (code$2) (let ((read$3 ($Kind.Defs.read file$0 code$2 defs$1))) (let ((self2 read$3)) (case (get self2 0) ('Either.left (let ((f2 (get self2 1))) ((let ((self3 IO.monad)) (case (get self3 0) ('Monad.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) f4))))) ($Either.left f2)))) ('Either.right (let ((f2 (get self2 1))) (let ((file_defs$5 f2)) (let ((file_keys$6 ($BitsMap.keys file_defs$5))) (let ((file_nams$7 ($List.mapped file_keys$6 Kind.Name.from_bits))) (((let ((self6 IO.monad)) (case (get self6 0) ('Monad.new (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) f6))))) ($Kind.Synth.many file_nams$7 file_defs$5)) (lambda (defs$8) ((let ((self7 IO.monad)) (case (get self7 0) ('Monad.new (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) f8))))) ($Either.right ($Pair.new file_nams$7 defs$8))))))))))))))))
(define Kind.Synth.file (lambda (file$0) (lambda (defs$1) ($Kind.Synth.file file$0 defs$1))))
(define ($IO.put_string text$0) ($IO.ask "put_string" text$0 (lambda (skip$1) ($IO.end Unit.new))))
(define IO.put_string (lambda (text$0) ($IO.put_string text$0)))
(define ($IO.print text$0) ($IO.put_string ($String.concat text$0 "\xa;")))
(define IO.print (lambda (text$0) ($IO.print text$0)))
(define ($Kind.Term.show.as_nat.go term$0) (let ((self0 term$0)) (case (get self0 0) ('Kind.Term.var (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) Maybe.none))) ('Kind.Term.ref (let ((f0 (get self0 1))) (let ((self1 ($String.eql f0 "Nat.zero"))) (case self1 (#t ($Maybe.some 0)) (#f Maybe.none))))) ('Kind.Term.typ Maybe.none) ('Kind.Term.all (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) Maybe.none)))))) ('Kind.Term.lam (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) Maybe.none))) ('Kind.Term.app (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((self2 f0)) (case (get self2 0) ('Kind.Term.var (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) Maybe.none))) ('Kind.Term.ref (let ((f2 (get self2 1))) (let ((self3 ($String.eql f2 "Nat.succ"))) (case self3 (#t (((let ((self3 Maybe.monad)) (case (get self3 0) ('Monad.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) f3))))) ($Kind.Term.show.as_nat.go f1)) (lambda (pred$4) ((let ((self4 Maybe.monad)) (case (get self4 0) ('Monad.new (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) f5))))) ($Nat.succ pred$4))))) (#f Maybe.none))))) ('Kind.Term.typ Maybe.none) ('Kind.Term.all (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) (let ((f5 (get self2 4))) (let ((f6 (get self2 5))) Maybe.none)))))) ('Kind.Term.lam (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) Maybe.none))) ('Kind.Term.app (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) Maybe.none))) ('Kind.Term.let (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) Maybe.none)))) ('Kind.Term.def (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) Maybe.none)))) ('Kind.Term.ann (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) Maybe.none)))) ('Kind.Term.gol (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) Maybe.none)))) ('Kind.Term.hol (let ((f2 (get self2 1))) Maybe.none)) ('Kind.Term.nat (let ((f2 (get self2 1))) Maybe.none)) ('Kind.Term.chr (let ((f2 (get self2 1))) Maybe.none)) ('Kind.Term.str (let ((f2 (get self2 1))) Maybe.none)) ('Kind.Term.num (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) Maybe.none)))) ('Kind.Term.cse (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) (let ((f5 (get self2 4))) (let ((f6 (get self2 5))) (let ((f7 (get self2 6))) Maybe.none))))))) ('Kind.Term.new (let ((f2 (get self2 1))) Maybe.none)) ('Kind.Term.get (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) Maybe.none))) ('Kind.Term.set (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) Maybe.none)))) ('Kind.Term.ope (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) Maybe.none)))) ('Kind.Term.ori (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) Maybe.none)))))))) ('Kind.Term.let (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) Maybe.none)))) ('Kind.Term.def (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) Maybe.none)))) ('Kind.Term.ann (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) Maybe.none)))) ('Kind.Term.gol (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) Maybe.none)))) ('Kind.Term.hol (let ((f0 (get self0 1))) Maybe.none)) ('Kind.Term.nat (let ((f0 (get self0 1))) Maybe.none)) ('Kind.Term.chr (let ((f0 (get self0 1))) Maybe.none)) ('Kind.Term.str (let ((f0 (get self0 1))) Maybe.none)) ('Kind.Term.num (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) Maybe.none)))) ('Kind.Term.cse (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((f5 (get self0 6))) Maybe.none))))))) ('Kind.Term.new (let ((f0 (get self0 1))) Maybe.none)) ('Kind.Term.get (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) Maybe.none))) ('Kind.Term.set (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) Maybe.none)))) ('Kind.Term.ope (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) Maybe.none)))) ('Kind.Term.ori (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) Maybe.none))))))
(define Kind.Term.show.as_nat.go (lambda (term$0) ($Kind.Term.show.as_nat.go term$0)))
(define ($Kind.Term.show.as_nat term$0) ($Maybe.mapped ($Kind.Term.show.as_nat.go term$0) Nat.show))
(define Kind.Term.show.as_nat (lambda (term$0) ($Kind.Term.show.as_nat term$0)))
(define ($Kind.Term.show.is_ref term$0 name$1) (let ((self0 term$0)) (case (get self0 0) ('Kind.Term.var (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) Bool.false))) ('Kind.Term.ref (let ((f0 (get self0 1))) ($String.eql name$1 f0))) ('Kind.Term.typ Bool.false) ('Kind.Term.all (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) Bool.false)))))) ('Kind.Term.lam (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) Bool.false))) ('Kind.Term.app (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) Bool.false))) ('Kind.Term.let (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) Bool.false)))) ('Kind.Term.def (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) Bool.false)))) ('Kind.Term.ann (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) Bool.false)))) ('Kind.Term.gol (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) Bool.false)))) ('Kind.Term.hol (let ((f0 (get self0 1))) Bool.false)) ('Kind.Term.nat (let ((f0 (get self0 1))) Bool.false)) ('Kind.Term.chr (let ((f0 (get self0 1))) Bool.false)) ('Kind.Term.str (let ((f0 (get self0 1))) Bool.false)) ('Kind.Term.num (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) Bool.false)))) ('Kind.Term.cse (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((f5 (get self0 6))) Bool.false))))))) ('Kind.Term.new (let ((f0 (get self0 1))) Bool.false)) ('Kind.Term.get (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) Bool.false))) ('Kind.Term.set (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) Bool.false)))) ('Kind.Term.ope (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) Bool.false)))) ('Kind.Term.ori (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) Bool.false))))))
(define Kind.Term.show.is_ref (lambda (term$0) (lambda (name$1) ($Kind.Term.show.is_ref term$0 name$1))))
(define ($Kind.Term.show.app.done term$0 path$1 args$2) (let ((arity$3 ($List.length args$2))) (let ((self1 ($Bool.and ($Kind.Term.show.is_ref term$0 "Equal") ($Nat.eql arity$3 3)))) (case self1 (#t (let ((func$4 ($Kind.Term.show.go term$0 path$1))) (let ((eq_lft$5 ($Maybe.default ($List.at 1 args$2) "?"))) (let ((eq_rgt$6 ($Maybe.default ($List.at 2 args$2) "?"))) ($String.flatten ($List.cons eq_lft$5 ($List.cons " == " ($List.cons eq_rgt$6 List.nil)))))))) (#f (let ((func$4 ($Kind.Term.show.go term$0 path$1))) (let ((wrap$5 (let ((self2 func$4)) (case (<= (kstring-length self2) 0) (#t Bool.false) (#f (let ((f2 (char->integer (kstring-head self2)))) (let ((f3 (kstring-tail self2))) ($U16.eql f2 40)))))))) (let ((args$6 ($String.join "," args$2))) (let ((func$7 (let ((self4 wrap$5)) (case self4 (#t ($String.flatten ($List.cons "(" ($List.cons func$4 ($List.cons ")" List.nil))))) (#f func$4))))) ($String.flatten ($List.cons func$7 ($List.cons "(" ($List.cons args$6 ($List.cons ")" List.nil))))))))))))))
(define Kind.Term.show.app.done (lambda (term$0) (lambda (path$1) (lambda (args$2) ($Kind.Term.show.app.done term$0 path$1 args$2)))))
(define ($Kind.Term.show.app term$0 path$1 args$2) (let ((self0 term$0)) (case (get self0 0) ('Kind.Term.var (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($Kind.Term.show.app.done term$0 path$1 args$2)))) ('Kind.Term.ref (let ((f0 (get self0 1))) ($Kind.Term.show.app.done term$0 path$1 args$2))) ('Kind.Term.typ ($Kind.Term.show.app.done term$0 path$1 args$2)) ('Kind.Term.all (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) ($Kind.Term.show.app.done term$0 path$1 args$2))))))) ('Kind.Term.lam (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($Kind.Term.show.app.done term$0 path$1 args$2)))) ('Kind.Term.app (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($Kind.Term.show.app f0 ($Kind.Path.Maybe.Builder.o path$1) ($List.cons ($Kind.Term.show.go f1 ($Kind.Path.Maybe.Builder.i path$1)) args$2))))) ('Kind.Term.let (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) ($Kind.Term.show.app.done term$0 path$1 args$2))))) ('Kind.Term.def (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) ($Kind.Term.show.app.done term$0 path$1 args$2))))) ('Kind.Term.ann (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) ($Kind.Term.show.app.done term$0 path$1 args$2))))) ('Kind.Term.gol (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) ($Kind.Term.show.app.done term$0 path$1 args$2))))) ('Kind.Term.hol (let ((f0 (get self0 1))) ($Kind.Term.show.app.done term$0 path$1 args$2))) ('Kind.Term.nat (let ((f0 (get self0 1))) ($Kind.Term.show.app.done term$0 path$1 args$2))) ('Kind.Term.chr (let ((f0 (get self0 1))) ($Kind.Term.show.app.done term$0 path$1 args$2))) ('Kind.Term.str (let ((f0 (get self0 1))) ($Kind.Term.show.app.done term$0 path$1 args$2))) ('Kind.Term.num (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) ($Kind.Term.show.app.done term$0 path$1 args$2))))) ('Kind.Term.cse (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((f5 (get self0 6))) ($Kind.Term.show.app.done term$0 path$1 args$2)))))))) ('Kind.Term.new (let ((f0 (get self0 1))) ($Kind.Term.show.app.done term$0 path$1 args$2))) ('Kind.Term.get (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($Kind.Term.show.app.done term$0 path$1 args$2)))) ('Kind.Term.set (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) ($Kind.Term.show.app.done term$0 path$1 args$2))))) ('Kind.Term.ope (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) ($Kind.Term.show.app.done term$0 path$1 args$2))))) ('Kind.Term.ori (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($Kind.Term.show.app f1 path$1 args$2)))))))
(define Kind.Term.show.app (lambda (term$0) (lambda (path$1) (lambda (args$2) ($Kind.Term.show.app term$0 path$1 args$2)))))
(define ($BitsMap.to_list xs$1) ($List.reverse ($BitsMap.to_list.go xs$1 Bits.e List.nil)))
(define BitsMap.to_list (lambda (xs$1) ($BitsMap.to_list xs$1)))
(define ($Kind.Term.show.go term$0 path$1) (let ((self0 ($Kind.Term.show.as_nat term$0))) (case (get self0 0) ('Maybe.none (let ((self0 term$0)) (case (get self0 0) ('Kind.Term.var (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($Kind.Name.show f0)))) ('Kind.Term.ref (let ((f0 (get self0 1))) (let ((name$3 ($Kind.Name.show f0))) (let ((self2 path$1)) (case (get self2 0) ('Maybe.none name$3) ('Maybe.some (let ((f2 (get self2 1))) (let ((path_val$5 ($Bits.concat ($Kind.Path.Builder.to_bits f2) ($Bits.i Bits.e)))) (let ((path_str$6 ($Nat.show ($Bits.to_nat path_val$5)))) ($String.flatten ($List.cons name$3 ($List.cons ($Kind.Code.color "2" ($String.concat "-" path_str$6)) List.nil)))))))))))) ('Kind.Term.typ "Type") ('Kind.Term.all (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((eras$7 f0)) (let ((self$8 ($Kind.Name.show f1))) (let ((name$9 ($Kind.Name.show f2))) (let ((type$10 ($Kind.Term.show.go f3 ($Kind.Path.Maybe.Builder.o path$1)))) (let ((open$11 (let ((self9 eras$7)) (case self9 (#t "<") (#f "("))))) (let ((clos$12 (let ((self10 eras$7)) (case self10 (#t ">") (#f ")"))))) (let ((body$13 ($Kind.Term.show.go ((f4 ($Kind.Term.var f1 0)) ($Kind.Term.var f2 0)) ($Kind.Path.Maybe.Builder.i path$1)))) ($String.flatten ($List.cons self$8 ($List.cons open$11 ($List.cons name$9 ($List.cons ":" ($List.cons type$10 ($List.cons clos$12 ($List.cons " " ($List.cons body$13 List.nil)))))))))))))))))))))) ('Kind.Term.lam (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((name$4 ($Kind.Name.show f0))) (let ((body$5 ($Kind.Term.show.go (f1 ($Kind.Term.var f0 0)) ($Kind.Path.Maybe.Builder.o path$1)))) ($String.flatten ($List.cons "(" ($List.cons name$4 ($List.cons ") " ($List.cons body$5 List.nil)))))))))) ('Kind.Term.app (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($Kind.Term.show.app term$0 path$1 List.nil)))) ('Kind.Term.let (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((name$5 ($Kind.Name.show f0))) (let ((expr$6 ($Kind.Term.show.go f1 ($Kind.Path.Maybe.Builder.o path$1)))) (let ((body$7 ($Kind.Term.show.go (f2 ($Kind.Term.var f0 0)) ($Kind.Path.Maybe.Builder.i path$1)))) ($String.flatten ($List.cons "let " ($List.cons name$5 ($List.cons " = " ($List.cons expr$6 ($List.cons "; " ($List.cons body$7 List.nil)))))))))))))) ('Kind.Term.def (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((name$5 ($Kind.Name.show f0))) (let ((expr$6 ($Kind.Term.show.go f1 ($Kind.Path.Maybe.Builder.o path$1)))) (let ((body$7 ($Kind.Term.show.go (f2 ($Kind.Term.var f0 0)) ($Kind.Path.Maybe.Builder.i path$1)))) ($String.flatten ($List.cons "def " ($List.cons name$5 ($List.cons " = " ($List.cons expr$6 ($List.cons "; " ($List.cons body$7 List.nil)))))))))))))) ('Kind.Term.ann (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((term$5 ($Kind.Term.show.go f1 ($Kind.Path.Maybe.Builder.o path$1)))) (let ((type$6 ($Kind.Term.show.go f2 ($Kind.Path.Maybe.Builder.i path$1)))) ($String.flatten ($List.cons term$5 ($List.cons "::" ($List.cons type$6 List.nil)))))))))) ('Kind.Term.gol (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((name$5 ($Kind.Name.show f0))) ($String.flatten ($List.cons "?" ($List.cons name$5 List.nil)))))))) ('Kind.Term.hol (let ((f0 (get self0 1))) "_")) ('Kind.Term.nat (let ((f0 (get self0 1))) ($String.flatten ($List.cons ($Nat.show f0) List.nil)))) ('Kind.Term.chr (let ((f0 (get self0 1))) ($String.flatten ($List.cons "'" ($List.cons ($Kind.Code.escape.char f0) ($List.cons "'" List.nil)))))) ('Kind.Term.str (let ((f0 (get self0 1))) ($String.flatten ($List.cons "\"" ($List.cons ($Kind.Code.escape f0) ($List.cons "\"" List.nil)))))) ('Kind.Term.num (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) ($String.flatten ($List.cons (let ((self3 f0)) (case (get self3 0) ('Maybe.none "") ('Maybe.some (let ((f3 (get self3 1))) (let ((self4 f3)) (case self4 (#t "+") (#f "-"))))))) ($List.cons ($Nat.show f1) ($List.cons (let ((self3 f2)) (case (get self3 0) ('Maybe.none "") ('Maybe.some (let ((f3 (get self3 1))) ($String.concat "." ($Nat.show f3)))))) List.nil)))))))) ('Kind.Term.cse (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((f5 (get self0 6))) (let ((expr$8 ($Kind.Term.show.go f1 ($Kind.Path.Maybe.Builder.o path$1)))) (let ((name$9 ($Kind.Name.show f2))) (let ((wyth$10 ($String.join "; " ($List.mapped f3 (lambda (with_var$10) (let ((self9 with_var$10)) (case (get self9 0) ('Kind.Ann.new (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) (let ((f11 (get self9 3))) (let ((self12 f11)) (case (get self12 0) ('Maybe.none f9) ('Maybe.some (let ((f12 (get self12 1))) ($String.concat f9 ($String.concat ": " ($Kind.Term.show.go f12 Maybe.none)))))))))))))))))) (let ((cses$11 ($BitsMap.to_list f4))) (let ((cses$12 ($String.join "" ($List.mapped cses$11 (lambda (x$12) (let ((name$13 ($Kind.Name.from_bits ($Pair.fst x$12)))) (let ((term$14 ($Kind.Term.show.go ($Pair.snd x$12) Maybe.none))) ($String.flatten ($List.cons name$13 ($List.cons ": " ($List.cons term$14 ($List.cons ", " List.nil)))))))))))) (let ((moti$13 (let ((self11 f5)) (case (get self11 0) ('Maybe.none "") ('Maybe.some (let ((f11 (get self11 1))) ($String.flatten ($List.cons ": " ($List.cons ($Kind.Term.show.go f11 Maybe.none) List.nil))))))))) ($String.flatten ($List.cons "case " ($List.cons expr$8 ($List.cons " as " ($List.cons name$9 ($List.cons wyth$10 ($List.cons " { " ($List.cons cses$12 ($List.cons "}" ($List.cons moti$13 List.nil))))))))))))))))))))))) ('Kind.Term.new (let ((f0 (get self0 1))) (let ((args$3 (($List.fold f0 (lambda (path$3) List.nil) (lambda (arg$3) (lambda (res$4) (lambda (path$5) ($List.cons ($Kind.Term.show.go arg$3 path$5) (res$4 ($Kind.Path.Maybe.Builder.o path$5))))))) path$1))) ($String.flatten ($List.cons "{" ($List.cons ($String.join "," args$3) ($List.cons "}" List.nil))))))) ('Kind.Term.get (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((expr$4 ($Kind.Term.show.go f0 ($Kind.Path.Maybe.Builder.o path$1)))) ($String.flatten ($List.cons expr$4 ($List.cons "@" ($List.cons f1 List.nil)))))))) ('Kind.Term.set (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((expr$5 ($Kind.Term.show.go f0 ($Kind.Path.Maybe.Builder.o path$1)))) (let ((fval$6 ($Kind.Term.show.go f2 ($Kind.Path.Maybe.Builder.i path$1)))) ($String.flatten ($List.cons expr$5 ($List.cons "@" ($List.cons f1 ($List.cons " <- " ($List.cons fval$6 List.nil)))))))))))) ('Kind.Term.ope (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((arg0$5 ($Kind.Term.show.go f1 ($Kind.Path.Maybe.Builder.o path$1)))) (let ((arg1$6 ($Kind.Term.show.go f2 ($Kind.Path.Maybe.Builder.i path$1)))) ($String.flatten ($List.cons "(" ($List.cons arg0$5 ($List.cons " " ($List.cons f0 ($List.cons " " ($List.cons arg1$6 ($List.cons ")" List.nil)))))))))))))) ('Kind.Term.ori (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($Kind.Term.show.go f1 path$1))))))) ('Maybe.some (let ((f0 (get self0 1))) f0)))))
(define Kind.Term.show.go (lambda (term$0) (lambda (path$1) ($Kind.Term.show.go term$0 path$1))))
(define ($Kind.Term.show term$0) ($Kind.Term.show.go term$0 Maybe.none))
(define Kind.Term.show (lambda (term$0) ($Kind.Term.show term$0)))
(define ($Kind.Defs.report.types defs$0 names$1) (let ((types$2 "")) (let ((types$3 ($List.for names$1 types$2 (lambda (name$3) (lambda (types$4) (let ((self3 ($Kind.Map.get name$3 defs$0))) (case (get self3 0) ('Maybe.none types$4) ('Maybe.some (let ((f3 (get self3 1))) (let ((self4 f3)) (case (get self4 0) ('Kind.Def.new (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((f6 (get self4 3))) (let ((f7 (get self4 4))) (let ((f8 (get self4 5))) (let ((f9 (get self4 6))) (let ((f10 (get self4 7))) (let ((f11 (get self4 8))) (let ((f12 (get self4 9))) ($String.concat types$4 ($String.concat name$3 ($String.concat ": " ($String.concat ($Kind.Term.show f9) "\xa;"))))))))))))))))))))))))) types$3)))
(define Kind.Defs.report.types (lambda (defs$0) (lambda (names$1) ($Kind.Defs.report.types defs$0 names$1))))
(define ($List.filter f$1 xs$2) (let ((self0 xs$2)) (case (get self0 0) ('List.nil List.nil) ('List.cons (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((self2 (f$1 f0))) (case self2 (#t ($List.cons f0 ($List.filter f$1 f1))) (#f ($List.filter f$1 f1))))))))))
(define List.filter (lambda (f$1) (lambda (xs$2) ($List.filter f$1 xs$2))))
(define ($Kind.Error.is_undef error$0) (let ((self0 error$0)) (case (get self0 0) ('Kind.Error.type_mismatch (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) Bool.false))))) ('Kind.Error.show_goal (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) Bool.false)))))) ('Kind.Error.waiting (let ((f0 (get self0 1))) Bool.false)) ('Kind.Error.indirect (let ((f0 (get self0 1))) Bool.false)) ('Kind.Error.patch (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) Bool.false))) ('Kind.Error.undefined_reference (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) Bool.true))) ('Kind.Error.cant_infer (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) Bool.false)))))))
(define Kind.Error.is_undef (lambda (error$0) ($Kind.Error.is_undef error$0)))
(define ($Kind.Error.is_mistake error$0) (let ((self0 error$0)) (case (get self0 0) ('Kind.Error.type_mismatch (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) Bool.true))))) ('Kind.Error.show_goal (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) Bool.false)))))) ('Kind.Error.waiting (let ((f0 (get self0 1))) Bool.false)) ('Kind.Error.indirect (let ((f0 (get self0 1))) Bool.false)) ('Kind.Error.patch (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) Bool.false))) ('Kind.Error.undefined_reference (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) Bool.false))) ('Kind.Error.cant_infer (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) Bool.true)))))))
(define Kind.Error.is_mistake (lambda (error$0) ($Kind.Error.is_mistake error$0)))
(define ($Kind.Error.is_goal error$0) (let ((self0 error$0)) (case (get self0 0) ('Kind.Error.type_mismatch (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) Bool.false))))) ('Kind.Error.show_goal (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) Bool.true)))))) ('Kind.Error.waiting (let ((f0 (get self0 1))) Bool.false)) ('Kind.Error.indirect (let ((f0 (get self0 1))) Bool.false)) ('Kind.Error.patch (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) Bool.false))) ('Kind.Error.undefined_reference (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) Bool.false))) ('Kind.Error.cant_infer (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) Bool.false)))))))
(define Kind.Error.is_goal (lambda (error$0) ($Kind.Error.is_goal error$0)))
(define ($Kind.Error.relevant errors$0) (let ((undefs$1 ($List.filter Kind.Error.is_undef errors$0))) (let ((mistakes$2 ($List.filter Kind.Error.is_mistake errors$0))) (let ((goals$3 ($List.filter Kind.Error.is_goal errors$0))) (let ((self3 undefs$1)) (case (get self3 0) ('List.nil (let ((self3 mistakes$2)) (case (get self3 0) ('List.nil goals$3) ('List.cons (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) ($List.concat ($List.cons f3 List.nil) goals$3))))))) ('List.cons (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) ($List.concat undefs$1 goals$3))))))))))
(define Kind.Error.relevant (lambda (errors$0) ($Kind.Error.relevant errors$0)))
(define ($Kind.Context.show context$0) (let ((self0 context$0)) (case (get self0 0) ('List.nil "") ('List.cons (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((self2 f0)) (case (get self2 0) ('Pair.new (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((name$5 ($Kind.Name.show f2))) (let ((type$6 ($Kind.Term.show ($Kind.Term.normalize f3 Kind.Map.new)))) (let ((rest$7 ($Kind.Context.show f1))) ($String.concat rest$7 ($String.concat "- " ($String.concat name$5 ($String.concat ": " ($String.concat type$6 "\xa;")))))))))))))))))))
(define Kind.Context.show (lambda (context$0) ($Kind.Context.show context$0)))
(define ($Kind.Term.expand_at path$0 term$1 defs$2) ($Kind.Term.patch_at path$0 term$1 (lambda (term$3) (let ((self1 term$3)) (case (get self1 0) ('Kind.Term.var (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) term$3))) ('Kind.Term.ref (let ((f1 (get self1 1))) (let ((self2 ($Kind.Map.get f1 defs$2))) (case (get self2 0) ('Maybe.none ($Kind.Term.ref f1)) ('Maybe.some (let ((f2 (get self2 1))) (let ((self3 f2)) (case (get self3 0) ('Kind.Def.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (let ((f5 (get self3 3))) (let ((f6 (get self3 4))) (let ((f7 (get self3 5))) (let ((f8 (get self3 6))) (let ((f9 (get self3 7))) (let ((f10 (get self3 8))) (let ((f11 (get self3 9))) f7)))))))))))))))))) ('Kind.Term.typ term$3) ('Kind.Term.all (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) term$3)))))) ('Kind.Term.lam (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) term$3))) ('Kind.Term.app (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) term$3))) ('Kind.Term.let (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) term$3)))) ('Kind.Term.def (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) term$3)))) ('Kind.Term.ann (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) term$3)))) ('Kind.Term.gol (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) term$3)))) ('Kind.Term.hol (let ((f1 (get self1 1))) term$3)) ('Kind.Term.nat (let ((f1 (get self1 1))) term$3)) ('Kind.Term.chr (let ((f1 (get self1 1))) term$3)) ('Kind.Term.str (let ((f1 (get self1 1))) term$3)) ('Kind.Term.num (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) term$3)))) ('Kind.Term.cse (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) (let ((f4 (get self1 4))) (let ((f5 (get self1 5))) (let ((f6 (get self1 6))) term$3))))))) ('Kind.Term.new (let ((f1 (get self1 1))) term$3)) ('Kind.Term.get (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) term$3))) ('Kind.Term.set (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) term$3)))) ('Kind.Term.ope (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) (let ((f3 (get self1 3))) term$3)))) ('Kind.Term.ori (let ((f1 (get self1 1))) (let ((f2 (get self1 2))) term$3))))))))
(define Kind.Term.expand_at (lambda (path$0) (lambda (term$1) (lambda (defs$2) ($Kind.Term.expand_at path$0 term$1 defs$2)))))
(define ($Kind.Term.expand_ct term$0 defs$1 arity$2) (let ((self0 term$0)) (case (get self0 0) ('Kind.Term.var (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($Kind.Term.var f0 f1)))) ('Kind.Term.ref (let ((f0 (get self0 1))) (let ((self1 ($Kind.Map.get f0 defs$1))) (case (get self1 0) ('Maybe.none ($Kind.Term.ref f0)) ('Maybe.some (let ((f1 (get self1 1))) (let ((self2 f1)) (case (get self2 0) ('Kind.Def.new (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((f4 (get self2 3))) (let ((f5 (get self2 4))) (let ((f6 (get self2 5))) (let ((f7 (get self2 6))) (let ((f8 (get self2 7))) (let ((f9 (get self2 8))) (let ((f10 (get self2 9))) (let ((self11 ($Bool.and f8 ($Nat.gtn arity$2 f9)))) (case self11 (#t f6) (#f ($Kind.Term.ref f0)))))))))))))))))))))) ('Kind.Term.typ Kind.Term.typ) ('Kind.Term.all (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) ($Kind.Term.all f0 f1 f2 ($Kind.Term.expand_ct f3 defs$1 0) (lambda (s$8) (lambda (x$9) ($Kind.Term.expand_ct ((f4 s$8) x$9) defs$1 0)))))))))) ('Kind.Term.lam (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($Kind.Term.lam f0 (lambda (x$5) ($Kind.Term.expand_ct (f1 x$5) defs$1 0)))))) ('Kind.Term.app (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($Kind.Term.app ($Kind.Term.expand_ct f0 defs$1 ($Nat.succ arity$2)) ($Kind.Term.expand_ct f1 defs$1 0))))) ('Kind.Term.let (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) ($Kind.Term.let f0 ($Kind.Term.expand_ct f1 defs$1 0) (lambda (x$6) ($Kind.Term.expand_ct (f2 x$6) defs$1 0))))))) ('Kind.Term.def (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) ($Kind.Term.def f0 ($Kind.Term.expand_ct f1 defs$1 0) (lambda (x$6) ($Kind.Term.expand_ct (f2 x$6) defs$1 0))))))) ('Kind.Term.ann (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) ($Kind.Term.ann f0 ($Kind.Term.expand_ct f1 defs$1 0) ($Kind.Term.expand_ct f2 defs$1 0)))))) ('Kind.Term.gol (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) ($Kind.Term.gol f0 f1 f2))))) ('Kind.Term.hol (let ((f0 (get self0 1))) ($Kind.Term.hol f0))) ('Kind.Term.nat (let ((f0 (get self0 1))) ($Kind.Term.nat f0))) ('Kind.Term.chr (let ((f0 (get self0 1))) ($Kind.Term.chr f0))) ('Kind.Term.str (let ((f0 (get self0 1))) ($Kind.Term.str f0))) ('Kind.Term.num (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) term$0)))) ('Kind.Term.cse (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((f5 (get self0 6))) term$0))))))) ('Kind.Term.new (let ((f0 (get self0 1))) term$0)) ('Kind.Term.get (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) term$0))) ('Kind.Term.set (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) term$0)))) ('Kind.Term.ope (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) term$0)))) ('Kind.Term.ori (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($Kind.Term.ori f0 f1)))))))
(define Kind.Term.expand_ct (lambda (term$0) (lambda (defs$1) (lambda (arity$2) ($Kind.Term.expand_ct term$0 defs$1 arity$2)))))
(define ($Kind.Term.expand dref$0 term$1 defs$2) (let ((term$3 ($Kind.Term.normalize term$1 Kind.Map.new))) (let ((term$4 ($List.for dref$0 term$3 (lambda (path$4) (lambda (term$5) (let ((term$6 ($Kind.Term.expand_at path$4 term$5 defs$2))) (let ((term$7 ($Kind.Term.normalize term$6 Kind.Map.new))) (let ((term$8 ($Kind.Term.expand_ct term$7 defs$2 0))) (let ((term$9 ($Kind.Term.normalize term$8 Kind.Map.new))) term$9))))))))) term$4)))
(define Kind.Term.expand (lambda (dref$0) (lambda (term$1) (lambda (defs$2) ($Kind.Term.expand dref$0 term$1 defs$2)))))
(define ($Kind.Error.show error$0 defs$1) (let ((self0 error$0)) (case (get self0 0) ('Kind.Error.type_mismatch (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((expected$6 (let ((self4 f1)) (case (get self4 0) ('Either.left (let ((f4 (get self4 1))) f4)) ('Either.right (let ((f4 (get self4 1))) ($Kind.Term.show ($Kind.Term.normalize f4 BitsMap.new)))))))) (let ((detected$7 (let ((self5 f2)) (case (get self5 0) ('Either.left (let ((f5 (get self5 1))) f5)) ('Either.right (let ((f5 (get self5 1))) ($Kind.Term.show ($Kind.Term.normalize f5 BitsMap.new)))))))) ($String.concat "Type mismatch.\xa;" ($String.concat "- Expected: " ($String.concat expected$6 ($String.concat "\xa;" ($String.concat "- Detected: " ($String.concat detected$7 ($String.concat "\xa;" (let ((self6 f3)) (case (get self6 0) ('List.nil "") ('List.cons (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) ($String.concat "With context:\xa;" ($Kind.Context.show f3))))))))))))))))))))) ('Kind.Error.show_goal (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) (let ((goal_name$7 ($String.concat "Goal ?" ($String.concat ($Kind.Name.show f0) ":\xa;")))) (let ((with_type$8 (let ((self6 f3)) (case (get self6 0) ('Maybe.none "") ('Maybe.some (let ((f6 (get self6 1))) (let ((goal$9 ($Kind.Term.expand f1 f6 defs$1))) ($String.concat "With type: " ($String.concat (let ((self8 f2)) (case self8 (#t ($Kind.Term.show.go goal$9 ($Maybe.some (lambda (x$10) x$10)))) (#f ($Kind.Term.show goal$9)))) "\xa;"))))))))) (let ((with_ctxt$9 (let ((self7 f4)) (case (get self7 0) ('List.nil "") ('List.cons (let ((f7 (get self7 1))) (let ((f8 (get self7 2))) ($String.concat "With context:\xa;" ($Kind.Context.show f4))))))))) ($String.flatten ($List.cons goal_name$7 ($List.cons with_type$8 ($List.cons with_ctxt$9 List.nil))))))))))))) ('Kind.Error.waiting (let ((f0 (get self0 1))) ($String.concat "Waiting for '" ($String.concat f0 "'.")))) ('Kind.Error.indirect (let ((f0 (get self0 1))) ($String.concat "Error on dependency '" ($String.concat f0 "'.")))) ('Kind.Error.patch (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($String.concat "Patching: " ($Kind.Term.show f1))))) ('Kind.Error.undefined_reference (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($String.concat "Undefined reference: " ($String.concat ($Kind.Name.show f1) "\xa;"))))) ('Kind.Error.cant_infer (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((term$5 ($Kind.Term.show f1))) (let ((context$6 ($Kind.Context.show f2))) ($String.concat "Can't infer type of: " ($String.concat term$5 ($String.concat "\xa;" ($String.concat "With context:\xa;" context$6)))))))))))))
(define Kind.Error.show (lambda (error$0) (lambda (defs$1) ($Kind.Error.show error$0 defs$1))))
(define ($Kind.Error.origin error$0) (let ((self0 error$0)) (case (get self0 0) ('Kind.Error.type_mismatch (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) f0))))) ('Kind.Error.show_goal (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) (let ((f3 (get self0 4))) (let ((f4 (get self0 5))) Maybe.none)))))) ('Kind.Error.waiting (let ((f0 (get self0 1))) Maybe.none)) ('Kind.Error.indirect (let ((f0 (get self0 1))) Maybe.none)) ('Kind.Error.patch (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) Maybe.none))) ('Kind.Error.undefined_reference (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) f0))) ('Kind.Error.cant_infer (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) f0)))))))
(define Kind.Error.origin (lambda (error$0) ($Kind.Error.origin error$0)))
(define ($Kind.Defs.report.errors defs$0) (let ((errors$1 "")) (let ((errors$2 ($List.for ($BitsMap.keys defs$0) errors$1 (lambda (key$2) (lambda (errors$3) (let ((name$4 ($Kind.Name.from_bits key$2))) (let ((defn$5 ($Kind.Map.get name$4 defs$0))) (let ((self5 defn$5)) (case (get self5 0) ('Maybe.none errors$3) ('Maybe.some (let ((f5 (get self5 1))) (let ((self6 f5)) (case (get self6 0) ('Kind.Def.new (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (let ((f8 (get self6 3))) (let ((f9 (get self6 4))) (let ((f10 (get self6 5))) (let ((f11 (get self6 6))) (let ((f12 (get self6 7))) (let ((f13 (get self6 8))) (let ((f14 (get self6 9))) (let ((self15 f14)) (case (get self15 0) ('Kind.Status.init errors$3) ('Kind.Status.wait errors$3) ('Kind.Status.done (let ((f15 (get self15 1))) errors$3)) ('Kind.Status.fail (let ((f15 (get self15 1))) (let ((self16 f15)) (case (get self16 0) ('List.nil errors$3) ('List.cons (let ((f16 (get self16 1))) (let ((f17 (get self16 2))) (let ((name_str$19 f9)) (let ((rel_errs$20 ($Kind.Error.relevant f15))) (let ((errors$21 ($List.for rel_errs$20 errors$3 (lambda (err$21) (lambda (errors$22) (let ((err_msg$23 ($Kind.Error.show err$21 defs$0))) (let ((ori_val$24 ($Kind.Error.origin err$21))) (let ((self24 ori_val$24)) (case (get self24 0) ('Maybe.none ($String.concat errors$22 ($String.concat err_msg$23 "\xa;"))) ('Maybe.some (let ((f24 (get self24 1))) (let ((self25 f24)) (case (get self25 0) ('Pair.new (let ((f25 (get self25 1))) (let ((f26 (get self25 2))) (let ((inside$28 ($String.concat "Inside '" ($String.concat f6 "':\xa;")))) (let ((source$29 ($Kind.Code.highlight f7 f25 f25 f26))) ($String.concat errors$22 ($String.concat err_msg$23 ($String.concat inside$28 ($String.concat source$29 ($String.concat "\xa;" "\xa;"))))))))))))))))))))))) errors$21))))))))))))))))))))))))))))))))))) errors$2)))
(define Kind.Defs.report.errors (lambda (defs$0) ($Kind.Defs.report.errors defs$0)))
(define ($Kind.Defs.report defs$0 names$1) (let ((types$2 ($Kind.Defs.report.types defs$0 names$1))) (let ((errors$3 ($Kind.Defs.report.errors defs$0))) (let ((errors$4 (let ((self2 errors$3)) (case (<= (kstring-length self2) 0) (#t "All terms check.") (#f (let ((f2 (char->integer (kstring-head self2)))) (let ((f3 (kstring-tail self2))) errors$3))))))) ($String.concat types$2 ($String.concat "\xa;" errors$4))))))
(define Kind.Defs.report (lambda (defs$0) (lambda (names$1) ($Kind.Defs.report defs$0 names$1))))
(define ($IO.set_file name$0 content$1) ($IO.ask "set_file" ($String.concat name$0 ($String.concat "=" content$1)) (lambda (ok$2) ($IO.end Unit.new))))
(define IO.set_file (lambda (name$0) (lambda (content$1) ($IO.set_file name$0 content$1))))
(define ($Kind.Synth.load.cached.set_file name$0 value$1) ($IO.set_file ($Kind.Synth.load.cached.name name$0) value$1))
(define Kind.Synth.load.cached.set_file (lambda (name$0) (lambda (value$1) ($Kind.Synth.load.cached.set_file name$0 value$1))))
(define ($Bool.show b$0) (let ((self0 b$0)) (case self0 (#t "Bool.true") (#f "Bool.false"))))
(define Bool.show (lambda (b$0) ($Bool.show b$0)))
(define ($Kind.Defs.cache.go kvs$0) (let ((self0 kvs$0)) (case (get self0 0) ('List.nil ((let ((self0 IO.monad)) (case (get self0 0) ('Monad.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) f1))))) Unit.new)) ('List.cons (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((self2 f0)) (case (get self2 0) ('Pair.new (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((self4 f3)) (case (get self4 0) ('Kind.Def.new (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) (let ((f6 (get self4 3))) (let ((f7 (get self4 4))) (let ((f8 (get self4 5))) (let ((f9 (get self4 6))) (let ((f10 (get self4 7))) (let ((f11 (get self4 8))) (let ((f12 (get self4 9))) (let ((self13 f12)) (case (get self13 0) ('Kind.Status.init ($Kind.Defs.cache.go f1)) ('Kind.Status.wait ($Kind.Defs.cache.go f1)) ('Kind.Status.done (let ((f13 (get self13 1))) (((let ((self14 IO.monad)) (case (get self14 0) ('Monad.new (let ((f14 (get self14 1))) (let ((f15 (get self14 2))) f14))))) ($IO.get_file_mtime f4)) (lambda (time$15) (((let ((self15 IO.monad)) (case (get self15 0) ('Monad.new (let ((f15 (get self15 1))) (let ((f16 (get self15 2))) f15))))) ($Kind.Synth.load.cached.set_file ($String.concat f2 ".term") ($Kind.Core.show f8))) (lambda ($16) (((let ((self16 IO.monad)) (case (get self16 0) ('Monad.new (let ((f16 (get self16 1))) (let ((f17 (get self16 2))) f16))))) ($Kind.Synth.load.cached.set_file ($String.concat f2 ".type") ($Kind.Core.show f9))) (lambda ($17) (((let ((self17 IO.monad)) (case (get self17 0) ('Monad.new (let ((f17 (get self17 1))) (let ((f18 (get self17 2))) f17))))) ($Kind.Synth.load.cached.set_file ($String.concat f2 ".isct") ($Bool.show f10))) (lambda ($18) (((let ((self18 IO.monad)) (case (get self18 0) ('Monad.new (let ((f18 (get self18 1))) (let ((f19 (get self18 2))) f18))))) ($Kind.Synth.load.cached.set_file ($String.concat f2 ".arit") ($Nat.show f11))) (lambda ($19) (((let ((self19 IO.monad)) (case (get self19 0) ('Monad.new (let ((f19 (get self19 1))) (let ((f20 (get self19 2))) f19))))) ($Kind.Synth.load.cached.set_file ($String.concat f2 ".file") f4)) (lambda ($20) (((let ((self20 IO.monad)) (case (get self20 0) ('Monad.new (let ((f20 (get self20 1))) (let ((f21 (get self20 2))) f20))))) ($Kind.Synth.load.cached.set_file ($String.concat f2 ".time") time$15)) (lambda ($21) ($Kind.Defs.cache.go f1))))))))))))))))) ('Kind.Status.fail (let ((f13 (get self13 1))) ($Kind.Defs.cache.go f1))))))))))))))))))))))))))))
(define Kind.Defs.cache.go (lambda (kvs$0) ($Kind.Defs.cache.go kvs$0)))
(define ($Kind.Defs.cache defs$0) ($Kind.Defs.cache.go ($Kind.Map.to_list defs$0)))
(define Kind.Defs.cache (lambda (defs$0) ($Kind.Defs.cache defs$0)))
(define ($Kind.api.io.check_file file$0) (((let ((self0 IO.monad)) (case (get self0 0) ('Monad.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) f0))))) ($Kind.Synth.file file$0 Kind.Map.new)) (lambda (loaded$1) (let ((self1 loaded$1)) (case (get self1 0) ('Either.left (let ((f1 (get self1 1))) (((let ((self2 IO.monad)) (case (get self2 0) ('Monad.new (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) f2))))) ($IO.print ($String.flatten ($List.cons "On '" ($List.cons file$0 ($List.cons "':" List.nil)))))) (lambda ($3) ($IO.print f1))))) ('Either.right (let ((f1 (get self1 1))) (let ((self2 f1)) (case (get self2 0) ('Pair.new (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) (let ((nams$5 f2)) (let ((defs$6 f3)) (let ((self6 nams$5)) (case (get self6 0) ('List.nil ($IO.print ($String.concat "File not found or empty: '" ($String.concat file$0 "'.")))) ('List.cons (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) (((let ((self8 IO.monad)) (case (get self8 0) ('Monad.new (let ((f8 (get self8 1))) (let ((f9 (get self8 2))) f8))))) ($IO.print ($Kind.Defs.report defs$6 nams$5))) (lambda ($9) ($Kind.Defs.cache defs$6))))))))))))))))))))))
(define Kind.api.io.check_file (lambda (file$0) ($Kind.api.io.check_file file$0)))
(define ($Kind.Synth.files.go files$0 defs$1) (let ((self0 files$0)) (case (get self0 0) ('List.nil ((let ((self0 IO.monad)) (case (get self0 0) ('Monad.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) f1))))) ($Pair.new List.nil defs$1))) ('List.cons (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (((let ((self2 IO.monad)) (case (get self2 0) ('Monad.new (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) f2))))) ($Kind.Synth.file f0 defs$1)) (lambda (file_synth$4) (let ((self3 file_synth$4)) (case (get self3 0) ('Either.left (let ((f3 (get self3 1))) ($Kind.Synth.files.go f1 defs$1))) ('Either.right (let ((f3 (get self3 1))) (let ((nams$6 ($Pair.fst f3))) (let ((defs$7 ($Pair.snd f3))) (((let ((self6 IO.monad)) (case (get self6 0) ('Monad.new (let ((f6 (get self6 1))) (let ((f7 (get self6 2))) f6))))) ($Kind.Synth.files.go f1 defs$7)) (lambda (rest$8) (let ((nams$9 ($List.concat nams$6 ($Pair.fst rest$8)))) (let ((defs$10 ($Pair.snd rest$8))) ((let ((self9 IO.monad)) (case (get self9 0) ('Monad.new (let ((f9 (get self9 1))) (let ((f10 (get self9 2))) f10))))) ($Pair.new nams$9 defs$10))))))))))))))))))))
(define Kind.Synth.files.go (lambda (files$0) (lambda (defs$1) ($Kind.Synth.files.go files$0 defs$1))))
(define ($Kind.Synth.remove_duplicate_names names$0) (let ((map$1 ($List.fold names$0 Kind.Map.new (lambda (name$1) ((Kind.Map.set name$1) Unit.new))))) ($List.mapped ($BitsMap.keys map$1) Kind.Name.from_bits)))
(define Kind.Synth.remove_duplicate_names (lambda (names$0) ($Kind.Synth.remove_duplicate_names names$0)))
(define ($Kind.Synth.files files$0 defs$1) (((let ((self0 IO.monad)) (case (get self0 0) ('Monad.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) f0))))) ($Kind.Synth.files.go files$0 defs$1)) (lambda (got$2) (let ((nams$3 ($Kind.Synth.remove_duplicate_names ($Pair.fst got$2)))) (let ((defs$4 ($Pair.snd got$2))) ((let ((self3 IO.monad)) (case (get self3 0) ('Monad.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) f4))))) ($Pair.new nams$3 defs$4)))))))
(define Kind.Synth.files (lambda (files$0) (lambda (defs$1) ($Kind.Synth.files files$0 defs$1))))
(define ($Kind.api.io.check_files files$0) (((let ((self0 IO.monad)) (case (get self0 0) ('Monad.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) f0))))) ($Kind.Synth.files files$0 Kind.Map.new)) (lambda (loaded$1) (let ((nams$2 ($Pair.fst loaded$1))) (let ((defs$3 ($Pair.snd loaded$1))) (let ((self3 nams$2)) (case (get self3 0) ('List.nil ($IO.print "No valid Kind file found.")) ('List.cons (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) (((let ((self5 IO.monad)) (case (get self5 0) ('Monad.new (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) f5))))) ($IO.print ($Kind.Defs.report defs$3 nams$2))) (lambda ($6) ($Kind.Defs.cache defs$3)))))))))))))
(define Kind.api.io.check_files (lambda (files$0) ($Kind.api.io.check_files files$0)))
(define ($Kind.api.io.check_term name$0) (((let ((self0 IO.monad)) (case (get self0 0) ('Monad.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) f0))))) ($Kind.Synth.one name$0 Kind.Map.new)) (lambda (defs$1) (let ((self1 defs$1)) (case (get self1 0) ('Maybe.none (let ((notfound$2 ($String.concat "Term not found: '" ($String.concat name$0 "'.")))) (let ((filelist$3 ($List.mapped ($Kind.Synth.files_of name$0) (lambda (x$3) ($String.concat "'" ($String.concat x$3 "'")))))) (let ((searched$4 ($String.concat "Searched on: " ($String.concat ($String.join ", " filelist$3) ".")))) ($IO.print ($String.concat notfound$2 ($String.concat "\xa;" searched$4))))))) ('Maybe.some (let ((f1 (get self1 1))) (((let ((self2 IO.monad)) (case (get self2 0) ('Monad.new (let ((f2 (get self2 1))) (let ((f3 (get self2 2))) f2))))) ($IO.print ($Kind.Defs.report f1 ($List.cons name$0 List.nil)))) (lambda ($3) ($Kind.Defs.cache f1))))))))))
(define Kind.api.io.check_term (lambda (name$0) ($Kind.api.io.check_term name$0)))
(define ($Kind.api.io.show_term name$0) (((let ((self0 IO.monad)) (case (get self0 0) ('Monad.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) f0))))) ($Kind.Synth.one name$0 Kind.Map.new)) (lambda (new_defs$1) ($IO.print (let ((self1 new_defs$1)) (case (get self1 0) ('Maybe.none (let ((notfound$2 ($String.concat "Term not found: '" ($String.concat name$0 "'.")))) (let ((filelist$3 ($List.mapped ($Kind.Synth.files_of name$0) (lambda (x$3) ($String.concat "'" ($String.concat x$3 "'")))))) (let ((searched$4 ($String.concat "Searched on: " ($String.concat ($String.join ", " filelist$3) ".")))) ($String.concat notfound$2 ($String.concat "\xa;" searched$4)))))) ('Maybe.some (let ((f1 (get self1 1))) (let ((defs$3 f1)) (let ((defn$4 ($Kind.Map.get name$0 defs$3))) (let ((self4 defn$4)) (case (get self4 0) ('Maybe.none ($String.concat "Term not found: '" ($String.concat name$0 "'."))) ('Maybe.some (let ((f4 (get self4 1))) (let ((self5 f4)) (case (get self5 0) ('Kind.Def.new (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) (let ((f8 (get self5 4))) (let ((f9 (get self5 5))) (let ((f10 (get self5 6))) (let ((f11 (get self5 7))) (let ((f12 (get self5 8))) (let ((f13 (get self5 9))) (let ((term$15 f9)) ($Kind.Term.show term$15))))))))))))))))))))))))))))
(define Kind.api.io.show_term (lambda (name$0) ($Kind.api.io.show_term name$0)))
(define ($Kind.api.io.show_term_normal name$0) (((let ((self0 IO.monad)) (case (get self0 0) ('Monad.new (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) f0))))) ($Kind.Synth.one name$0 Kind.Map.new)) (lambda (new_defs$1) ($IO.print (let ((self1 new_defs$1)) (case (get self1 0) ('Maybe.none (let ((notfound$2 ($String.concat "Term not found: '" ($String.concat name$0 "'.")))) (let ((filelist$3 ($List.mapped ($Kind.Synth.files_of name$0) (lambda (x$3) ($String.concat "'" ($String.concat x$3 "'")))))) (let ((searched$4 ($String.concat "Searched on: " ($String.concat ($String.join ", " filelist$3) ".")))) ($String.concat notfound$2 ($String.concat "\xa;" searched$4)))))) ('Maybe.some (let ((f1 (get self1 1))) (let ((defs$3 f1)) (let ((defn$4 ($Kind.Map.get name$0 defs$3))) (let ((self4 defn$4)) (case (get self4 0) ('Maybe.none ($String.concat "Term not found: '" ($String.concat name$0 "'."))) ('Maybe.some (let ((f4 (get self4 1))) (let ((self5 f4)) (case (get self5 0) ('Kind.Def.new (let ((f5 (get self5 1))) (let ((f6 (get self5 2))) (let ((f7 (get self5 3))) (let ((f8 (get self5 4))) (let ((f9 (get self5 5))) (let ((f10 (get self5 6))) (let ((f11 (get self5 7))) (let ((f12 (get self5 8))) (let ((f13 (get self5 9))) (let ((term$15 f9)) (let ((norm$16 ($Kind.Term.normalize term$15 defs$3))) ($Kind.Term.show norm$16)))))))))))))))))))))))))))))
(define Kind.api.io.show_term_normal (lambda (name$0) ($Kind.api.io.show_term_normal name$0)))
(define ($IO.purify io$1) (let ((self0 io$1)) (case (get self0 0) ('IO.end (let ((f0 (get self0 1))) f0)) ('IO.ask (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) (let ((f2 (get self0 3))) ($IO.purify (f2 "")))))))))
(define IO.purify (lambda (io$1) ($IO.purify io$1)))
(define ($Kind.api.check_code code$0) (let ((self0 ($Kind.Defs.read "Main.kind" code$0 Kind.Map.new))) (case (get self0 0) ('Either.left (let ((f0 (get self0 1))) f0)) ('Either.right (let ((f0 (get self0 1))) ($IO.purify (let ((defs$2 f0)) (let ((nams$3 ($List.mapped ($BitsMap.keys defs$2) Kind.Name.from_bits))) (((let ((self3 IO.monad)) (case (get self3 0) ('Monad.new (let ((f3 (get self3 1))) (let ((f4 (get self3 2))) f3))))) ($Kind.Synth.many nams$3 defs$2)) (lambda (defs$4) ((let ((self4 IO.monad)) (case (get self4 0) ('Monad.new (let ((f4 (get self4 1))) (let ((f5 (get self4 2))) f5))))) ($Kind.Defs.report defs$4 nams$3))))))))))))
(define Kind.api.check_code (lambda (code$0) ($Kind.api.check_code code$0)))
(define ($Kind.Term.read code$0) (let ((self0 (Kind.Parser.term ($Parser.State.new Maybe.none "" 0 0 code$0)))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))) Maybe.none)) ('Parser.Reply.value (let ((f0 (get self0 1))) (let ((f1 (get self0 2))) ($Maybe.some f1)))))))
(define Kind.Term.read (lambda (code$0) ($Kind.Term.read code$0)))
)