; Short alias to vector-ref
(define get vector-ref)

; Converts a Kind word to a native integer
(define (word-to-u16 w)
  (define (word-to-u16-go i w x)
    (cond ((= 16 i) x)
      ((symbol=? 'Word.e (get w 0)) (word-to-u16-go (+ i 1) (vector 'Word.e) x))
      ((symbol=? 'Word.o (get w 0)) (word-to-u16-go (+ i 1) (get w 1) x))
      ((symbol=? 'Word.i (get w 0)) (word-to-u16-go (+ i 1) (get w 1) (fxior x (fxarithmetic-shift-left 1 i))))))
  (word-to-u16-go 0 w 0))

; Converts a native integer to a Kind word
(define (u16-to-word x)
  (define (u16-to-word-go i x w)
    (if (= 16 i) w (u16-to-word-go (+ i 1) x
      (if (= (fxand (fxarithmetic-shift-right x (- 15 i)) 1) 0)
        (vector 'Word.o w)
        (vector 'Word.i w)))))
  (u16-to-word-go 0 x (vector 'Word.e)))

; Joins a list of strings with an intercalated separator
(define (string_join sep strs fst)
  (if (null? strs) 
    ""
    (string-append
      (if fst "" sep)
      (car strs)
      (string_join sep (cdr strs) #f))))

; Returns the last index that chr occurs in str, -1 otherwise
(define (last_index_of chr str idx)
  (if (= idx (string-length str))
    -1
    (let ((rest (last_index_of chr str (+ idx 1))))
      (if (char=? (string-ref str idx) chr)
        (max idx rest)
        rest))))

; Returns the first index that chr occurs in str, -1 otherwise
(define (first_index_of chr str idx)
  (if (= idx (string-length str))
    -1
    (if (char=? (string-ref str idx) chr)
      idx
      (first_index_of chr str (+ idx 1)))))

; Splits a string using an identifier
(define (split_at_first chr str)
  (let ((split_idx (first_index_of chr str 0)))
    (if (= split_idx -1)
      str
      (cons
        (substring str 0 split_idx)
        (substring str (+ split_idx 1) (string-length str))))))

; Splits a string using an identifier
(define (split_at_last chr str)
  (let ((split_idx (last_index_of chr str 0)))
    (if (= split_idx -1)
      str
      (cons
        (substring str 0 split_idx)
        (substring str (+ split_idx 1) (string-length str))))))

; Converts a date to a string, in milliseconds
(define (time_to_string time)
  (number->string
    (+ (* (time-second time) 1000)
      (div (time-nanosecond time) 1000000))))

; Prints a text with a newline
(define (print txt)
  (display txt)
  (display "
"))

; Gets a line from stdin
(define (get_line)
  (let ((port (current-input-port)))
    (get-line port)))

; Deletes a file
(define (del_file file)
  (delete-file file))

; Gets the contents of a file as a string
; If it doesn't exist, returns empty
(define (get_file file)
  (if (file-exists? file)
    (let ((port (open-input-file file)))
      (let ((text (get-string-all port)))
        (begin
          (close-input-port port)
          text)))
    ""))

; Sets the contents of a file
(define (set_file file text)
  (system (string-append "mkdir -p " (car (split_at_last #\/ file))))
  (if (file-exists? file) (delete-file file))
  (let ((port (open-output-file file)))
    (begin
      (display text port)
      (close-output-port port))))

; Returns a list of files in a directory
(define (get_dir path)
  (directory-list path)) 

; Returns the time a file was modified. TODO: test on Windows/Linux
(define (get_file_mtime file)
  (time_to_string (file-modification-time file)))

; Returns the current time
(define (get_time)
  (time_to_string (current-time)))

; Performs a single Kind IO action
(define (io_action name)
  (case name
    ("print" (lambda (x) (print x)))
    ("put_string" (lambda (x) (display x)))
    ("get_line" (lambda (x) (get_line)))
    ("del_file" (lambda (x) (del_file x)))
    ("get_file" (lambda (x) (get_file x)))
    ("set_file" (lambda (x) (let ((file_text (split_at_first #\= x))) (set_file (car file_text) (cdr file_text)))))
    ("get_dir" (lambda (x) (get_dir x)))
    ("get_file_mtime" (lambda (x) (get_file_mtime x)))
    ("get_time" (lambda (x) (get_time)))))

; Runs a Kind IO program
(define (run_io io)
  (case (get io 0)
    ('IO.end (get io 0))
    ('IO.ask (let (
      (io_query (get io 1))
      (io_param (get io 2))
      (io_then (get io 3)))
      (run_io (io_then ((io_action io_query) io_param)))))))

(define Bool-inst (lambda (x) ((x #t) #f)))
(define Bool-elim (lambda (x) (let ((self0 x)) (case self0 (#t (let () (lambda (c0) (lambda (c1) c0)))) (#f (let () (lambda (c0) (lambda (c1) c1))))))))
(define Nat-inst (lambda (x) ((x 0) (lambda (x0) (+ x0 1)))))
(define Nat-elim (lambda (x) (let ((self0 x)) (case (= self0 0) (#t (let () (lambda (c0) (lambda (c1) c0)))) (#f (let ((f0 (- self0 1))) (lambda (c0) (lambda (c1) (c1 f0)))))))))
(define U16-inst (lambda (x) (x (lambda (x0) (word-to-u16 x0)))))
(define U16-elim (lambda (x) (let ((self0 x)) (case #t (#t (let ((f0 (u16-to-word self0))) (lambda (c0) (c0 f0))))))))
(define String-inst (lambda (x) ((x "") (lambda (x0) (lambda (x1) (string-append (make-string 1 (integer->char x0)) x1))))))
(define String-elim (lambda (x) (let ((self0 x)) (case (= (string-length self0) 0) (#t (let () (lambda (c0) (lambda (c1) c0)))) (#f (let ((f0 (char->integer (string-ref self0 0)))(f1 (let ((_str_ self0)) (substring _str_ 1 (string-length _str_))))) (lambda (c0) (lambda (c1) ((c1 f0) f1)))))))))
(define ($IO.ask query$1 param$2 then$3) (vector 'IO.ask query$1 param$2 then$3))
(define IO.ask (lambda (query$1) (lambda (param$2) (lambda (then$3) ($IO.ask query$1 param$2 then$3)))))
(define ($IO.bind a$2 f$3) (let ((self0 a$2)) (case (get self0 0) ('IO.end (let ((f0 (get self0 1))) (f$3 f0))) ('IO.ask (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($IO.ask f0 f1 (lambda (x$7) ($IO.bind (f2 x$7) f$3))))))))
(define IO.bind (lambda (a$2) (lambda (f$3) ($IO.bind a$2 f$3))))
(define ($IO.end value$1) (vector 'IO.end value$1))
(define IO.end (lambda (value$1) ($IO.end value$1)))
(define ($IO.monad) (vector 'Monad.new IO.bind IO.end))
(define IO.monad ($IO.monad))
(define ($IO.get_file name$0) ($IO.ask "get_file" name$0 (lambda (file$1) ($IO.end file$1))))
(define IO.get_file (lambda (name$0) ($IO.get_file name$0)))
(define ($Parser.Reply.value idx$1 code$2 val$3) (vector 'Parser.Reply.value idx$1 code$2 val$3))
(define Parser.Reply.value (lambda (idx$1) (lambda (code$2) (lambda (val$3) ($Parser.Reply.value idx$1 code$2 val$3)))))
(define ($Bool.true) #t)
(define Bool.true ($Bool.true))
(define ($Bool.false) #f)
(define Bool.false ($Bool.false))
(define ($Parser.is_eof idx$0 code$1) (let ((self0 code$1)) (case (= (string-length self0) 0) (#t (let () ($Parser.Reply.value idx$0 code$1 Bool.true))) (#f (let ((f0 (char->integer (string-ref self0 0)))(f1 (let ((_str_ self0)) (substring _str_ 1 (string-length _str_))))) ($Parser.Reply.value idx$0 code$1 Bool.false))))))
(define Parser.is_eof (lambda (idx$0) (lambda (code$1) ($Parser.is_eof idx$0 code$1))))
(define ($Parser.Reply.error idx$1 code$2 err$3) (vector 'Parser.Reply.error idx$1 code$2 err$3))
(define Parser.Reply.error (lambda (idx$1) (lambda (code$2) (lambda (err$3) ($Parser.Reply.error idx$1 code$2 err$3)))))
(define ($Maybe.some value$1) (vector 'Maybe.some value$1))
(define Maybe.some (lambda (value$1) ($Maybe.some value$1)))
(define ($Parser.ErrorAt.new idx$0 code$1 err$2) (vector 'Parser.ErrorAt.new idx$0 code$1 err$2))
(define Parser.ErrorAt.new (lambda (idx$0) (lambda (code$1) (lambda (err$2) ($Parser.ErrorAt.new idx$0 code$1 err$2)))))
(define ($Nat.gtn n$0 m$1) (> n$0 m$1))
(define Nat.gtn (lambda (n$0) (lambda (m$1) ($Nat.gtn n$0 m$1))))
(define ($Parser.ErrorAt.combine a$0 b$1) (let ((self0 a$0)) (case (get self0 0) ('Maybe.none (let () b$1)) ('Maybe.some (let ((f0 (get self0 1))) (let ((self1 b$1)) (case (get self1 0) ('Maybe.none (let () a$0)) ('Maybe.some (let ((f1 (get self1 1))) (let ((self2 f0)) (case (get self2 0) ('Parser.ErrorAt.new (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))) (let ((self5 f1)) (case (get self5 0) ('Parser.ErrorAt.new (let ((f5 (get self5 1))(f6 (get self5 2))(f7 (get self5 3))) (let ((self8 ($Nat.gtn f2 f5))) (case self8 (#t (let () a$0)) (#f (let () b$1)))))))))))))))))))))
(define Parser.ErrorAt.combine (lambda (a$0) (lambda (b$1) ($Parser.ErrorAt.combine a$0 b$1))))
(define ($Parser.first_of.go pars$1 err$2 idx$3 code$4) (let ((self0 pars$1)) (case (get self0 0) ('List.nil (let () (let ((self0 err$2)) (case (get self0 0) ('Maybe.none (let () ($Parser.Reply.error idx$3 code$4 "No parse."))) ('Maybe.some (let ((f0 (get self0 1))) (let ((self1 f0)) (case (get self1 0) ('Parser.ErrorAt.new (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))) ($Parser.Reply.error f1 f2 f3))))))))))) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((parsed$7 ((f0 idx$3) code$4))) (let ((self3 parsed$7)) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (let ((neo$11 ($Maybe.some ($Parser.ErrorAt.new f3 f4 f5)))) (let ((err$12 ($Parser.ErrorAt.combine neo$11 err$2))) ($Parser.first_of.go f1 err$12 idx$3 code$4))))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.value f3 f4 f5)))))))))))
(define Parser.first_of.go (lambda (pars$1) (lambda (err$2) (lambda (idx$3) (lambda (code$4) ($Parser.first_of.go pars$1 err$2 idx$3 code$4))))))
(define ($Maybe.none) (vector 'Maybe.none))
(define Maybe.none ($Maybe.none))
(define ($Parser.first_of pars$1) ((Parser.first_of.go pars$1) Maybe.none))
(define Parser.first_of (lambda (pars$1) ($Parser.first_of pars$1)))
(define ($List.cons head$1 tail$2) (vector 'List.cons head$1 tail$2))
(define List.cons (lambda (head$1) (lambda (tail$2) ($List.cons head$1 tail$2))))
(define ($List.nil) (vector 'List.nil))
(define List.nil ($List.nil))
(define ($Parser.many.go parse$1 values$2 idx$3 code$4) (let ((self0 ((parse$1 idx$3) code$4))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.value idx$3 code$4 (values$2 List.nil)))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.many.go parse$1 (lambda (xs$8) (values$2 ($List.cons f2 xs$8))) f0 f1))))))
(define Parser.many.go (lambda (parse$1) (lambda (values$2) (lambda (idx$3) (lambda (code$4) ($Parser.many.go parse$1 values$2 idx$3 code$4))))))
(define ($Parser.many parser$1) ((Parser.many.go parser$1) (lambda (x$2) x$2)))
(define Parser.many (lambda (parser$1) ($Parser.many parser$1)))
(define ($Unit.new) (vector 'Unit.new))
(define Unit.new ($Unit.new))
(define ($String.cons head$0 tail$1) (string-append (make-string 1 (integer->char head$0)) tail$1))
(define String.cons (lambda (head$0) (lambda (tail$1) ($String.cons head$0 tail$1))))
(define ($String.concat as$0 bs$1) (string-append as$0 bs$1))
(define String.concat (lambda (as$0) (lambda (bs$1) ($String.concat as$0 bs$1))))
(define ($String.flatten.go xs$0 res$1) (let ((self0 xs$0)) (case (get self0 0) ('List.nil (let () res$1)) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) ($String.flatten.go f1 ($String.concat res$1 f0)))))))
(define String.flatten.go (lambda (xs$0) (lambda (res$1) ($String.flatten.go xs$0 res$1))))
(define ($String.flatten xs$0) ($String.flatten.go xs$0 ""))
(define String.flatten (lambda (xs$0) ($String.flatten xs$0)))
(define ($Cmp.as_eql cmp$0) (let ((self0 cmp$0)) (case (get self0 0) ('Cmp.ltn (let () Bool.false)) ('Cmp.eql (let () Bool.true)) ('Cmp.gtn (let () Bool.false)))))
(define Cmp.as_eql (lambda (cmp$0) ($Cmp.as_eql cmp$0)))
(define ($Cmp.ltn) (vector 'Cmp.ltn))
(define Cmp.ltn ($Cmp.ltn))
(define ($Cmp.gtn) (vector 'Cmp.gtn))
(define Cmp.gtn ($Cmp.gtn))
(define ($Word.cmp.go a$1 b$2 c$3) ((let ((self0 a$1)) (case (get self0 0) ('Word.e (let () (lambda (b$4) c$3))) ('Word.o (let ((f0 (get self0 1))) (lambda (b$6) ((let ((self2 b$6)) (case (get self2 0) ('Word.e (let () (lambda (a.pred$7) c$3))) ('Word.o (let ((f2 (get self2 1))) (lambda (a.pred$9) ($Word.cmp.go a.pred$9 f2 c$3)))) ('Word.i (let ((f2 (get self2 1))) (lambda (a.pred$9) ($Word.cmp.go a.pred$9 f2 Cmp.ltn)))))) f0)))) ('Word.i (let ((f0 (get self0 1))) (lambda (b$6) ((let ((self2 b$6)) (case (get self2 0) ('Word.e (let () (lambda (a.pred$7) c$3))) ('Word.o (let ((f2 (get self2 1))) (lambda (a.pred$9) ($Word.cmp.go a.pred$9 f2 Cmp.gtn)))) ('Word.i (let ((f2 (get self2 1))) (lambda (a.pred$9) ($Word.cmp.go a.pred$9 f2 c$3)))))) f0)))))) b$2))
(define Word.cmp.go (lambda (a$1) (lambda (b$2) (lambda (c$3) ($Word.cmp.go a$1 b$2 c$3)))))
(define ($Cmp.eql) (vector 'Cmp.eql))
(define Cmp.eql ($Cmp.eql))
(define ($Word.cmp a$1 b$2) ($Word.cmp.go a$1 b$2 Cmp.eql))
(define Word.cmp (lambda (a$1) (lambda (b$2) ($Word.cmp a$1 b$2))))
(define ($Word.eql a$1 b$2) ($Cmp.as_eql ($Word.cmp a$1 b$2)))
(define Word.eql (lambda (a$1) (lambda (b$2) ($Word.eql a$1 b$2))))
(define ($U16.eql a$0 b$1) (= a$0 b$1))
(define U16.eql (lambda (a$0) (lambda (b$1) ($U16.eql a$0 b$1))))
(define ($Nat.succ pred$0) (+ pred$0 1))
(define Nat.succ (lambda (pred$0) ($Nat.succ pred$0)))
(define ($String.nil) "")
(define String.nil ($String.nil))
(define ($Parser.text.go text$0 idx$1 code$2) (let ((self0 text$0)) (case (= (string-length self0) 0) (#t (let () ($Parser.Reply.value idx$1 code$2 Unit.new))) (#f (let ((f0 (char->integer (string-ref self0 0)))(f1 (let ((_str_ self0)) (substring _str_ 1 (string-length _str_))))) (let ((self2 code$2)) (case (= (string-length self2) 0) (#t (let () (let ((error$5 ($String.flatten ($List.cons "Expected '" ($List.cons text$0 ($List.cons "', found end of file." List.nil)))))) ($Parser.Reply.error idx$1 code$2 error$5)))) (#f (let ((f2 (char->integer (string-ref self2 0)))(f3 (let ((_str_ self2)) (substring _str_ 1 (string-length _str_))))) (let ((self4 ($U16.eql f0 f2))) (case self4 (#t (let () ($Parser.text f1 ($Nat.succ idx$1) f3))) (#f (let () (let ((error$7 ($String.flatten ($List.cons "Expected '" ($List.cons text$0 ($List.cons "', found '" ($List.cons ($String.cons f2 String.nil) ($List.cons "'." List.nil)))))))) ($Parser.Reply.error idx$1 code$2 error$7)))))))))))))))
(define Parser.text.go (lambda (text$0) (lambda (idx$1) (lambda (code$2) ($Parser.text.go text$0 idx$1 code$2)))))
(define ($Parser.text text$0 idx$1 code$2) (let ((self0 ($Parser.text.go text$0 idx$1 code$2))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error idx$1 code$2 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.value f0 f1 f2))))))
(define Parser.text (lambda (text$0) (lambda (idx$1) (lambda (code$2) ($Parser.text text$0 idx$1 code$2)))))
(define ($Parser.eof idx$0 code$1) (let ((self0 code$1)) (case (= (string-length self0) 0) (#t (let () ($Parser.Reply.value idx$0 code$1 Unit.new))) (#f (let ((f0 (char->integer (string-ref self0 0)))(f1 (let ((_str_ self0)) (substring _str_ 1 (string-length _str_))))) ($Parser.Reply.error idx$0 code$1 "Expected end-of-file."))))))
(define Parser.eof (lambda (idx$0) (lambda (code$1) ($Parser.eof idx$0 code$1))))
(define ($List.reverse.go xs$1 res$2) (let ((self0 xs$1)) (case (get self0 0) ('List.nil (let () res$2)) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) ($List.reverse.go f1 ($List.cons f0 res$2)))))))
(define List.reverse.go (lambda (xs$1) (lambda (res$2) ($List.reverse.go xs$1 res$2))))
(define ($List.reverse xs$1) ($List.reverse.go xs$1 List.nil))
(define List.reverse (lambda (xs$1) ($List.reverse xs$1)))
(define ($Parser.until.go until$1 parse$2 values$3 idx$4 code$5) (let ((until_reply$6 ((until$1 idx$4) code$5))) (let ((self1 until_reply$6)) (case (get self1 0) ('Parser.Reply.error (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))) (let ((reply$10 ((parse$2 idx$4) code$5))) (let ((self5 reply$10)) (case (get self5 0) ('Parser.Reply.error (let ((f5 (get self5 1))(f6 (get self5 2))(f7 (get self5 3))) ($Parser.Reply.error f5 f6 f7))) ('Parser.Reply.value (let ((f5 (get self5 1))(f6 (get self5 2))(f7 (get self5 3))) ($Parser.until.go until$1 parse$2 ($List.cons f7 values$3) f5 f6)))))))) ('Parser.Reply.value (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))) ($Parser.Reply.value f1 f2 ($List.reverse values$3))))))))
(define Parser.until.go (lambda (until$1) (lambda (parse$2) (lambda (values$3) (lambda (idx$4) (lambda (code$5) ($Parser.until.go until$1 parse$2 values$3 idx$4 code$5)))))))
(define ($Parser.until until$1 parse$2) (((Parser.until.go until$1) parse$2) List.nil))
(define Parser.until (lambda (until$1) (lambda (parse$2) ($Parser.until until$1 parse$2))))
(define ($Parser.one idx$0 code$1) (let ((self0 code$1)) (case (= (string-length self0) 0) (#t (let () ($Parser.Reply.error idx$0 code$1 "Unexpected end of file."))) (#f (let ((f0 (char->integer (string-ref self0 0)))(f1 (let ((_str_ self0)) (substring _str_ 1 (string-length _str_))))) ($Parser.Reply.value ($Nat.succ idx$0) f1 f0))))))
(define Parser.one (lambda (idx$0) (lambda (code$1) ($Parser.one idx$0 code$1))))
(define ($Kind.Parser.spaces) ($Parser.many ($Parser.first_of ($List.cons (Parser.text " ") ($List.cons (Parser.text "\x9;") ($List.cons (Parser.text "\xA;") ($List.cons (lambda (idx$0) (lambda (code$1) (let ((self2 ($Parser.text "//" idx$0 code$1))) (case (get self2 0) ('Parser.Reply.error (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))) ($Parser.Reply.error f2 f3 f4))) ('Parser.Reply.value (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))) (let ((endl_or_eof$5 ($Parser.first_of ($List.cons (Parser.text "\xA;") ($List.cons Parser.eof List.nil))))) (let ((self6 ((($Parser.until endl_or_eof$5 Parser.one) f2) f3))) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Parser.Reply.error f6 f7 f8))) ('Parser.Reply.value (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Parser.Reply.value f6 f7 Unit.new)))))))))))) List.nil)))))))
(define Kind.Parser.spaces ($Kind.Parser.spaces))
(define ($Parser.get_index idx$0 code$1) ($Parser.Reply.value idx$0 code$1 idx$0))
(define Parser.get_index (lambda (idx$0) (lambda (code$1) ($Parser.get_index idx$0 code$1))))
(define ($Kind.Parser.init idx$0 code$1) (let ((self0 ((Kind.Parser.spaces idx$0) code$1))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ($Parser.get_index f0 f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.value f3 f4 f5))))))))))
(define Kind.Parser.init (lambda (idx$0) (lambda (code$1) ($Kind.Parser.init idx$0 code$1))))
(define ($Parser.many1 parser$1 idx$2 code$3) (let ((self0 ((parser$1 idx$2) code$3))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ((($Parser.many parser$1) f0) f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.value f3 f4 ($List.cons f2 f5)))))))))))
(define Parser.many1 (lambda (parser$1) (lambda (idx$2) (lambda (code$3) ($Parser.many1 parser$1 idx$2 code$3)))))
(define ($Bool.and a$0 b$1) (and a$0 b$1))
(define Bool.and (lambda (a$0) (lambda (b$1) ($Bool.and a$0 b$1))))
(define ($Cmp.as_lte cmp$0) (let ((self0 cmp$0)) (case (get self0 0) ('Cmp.ltn (let () Bool.true)) ('Cmp.eql (let () Bool.true)) ('Cmp.gtn (let () Bool.false)))))
(define Cmp.as_lte (lambda (cmp$0) ($Cmp.as_lte cmp$0)))
(define ($Word.lte a$1 b$2) ($Cmp.as_lte ($Word.cmp a$1 b$2)))
(define Word.lte (lambda (a$1) (lambda (b$2) ($Word.lte a$1 b$2))))
(define ($U16.lte a$0 b$1) (<= a$0 b$1))
(define U16.lte (lambda (a$0) (lambda (b$1) ($U16.lte a$0 b$1))))
(define ($U16.btw a$0 b$1 c$2) ($Bool.and ($U16.lte a$0 b$1) ($U16.lte b$1 c$2)))
(define U16.btw (lambda (a$0) (lambda (b$1) (lambda (c$2) ($U16.btw a$0 b$1 c$2)))))
(define ($Kind.Name.is_letter chr$0) (let ((self0 ($U16.btw 65 chr$0 90))) (case self0 (#t (let () Bool.true)) (#f (let () (let ((self0 ($U16.btw 97 chr$0 122))) (case self0 (#t (let () Bool.true)) (#f (let () (let ((self0 ($U16.btw 48 chr$0 57))) (case self0 (#t (let () Bool.true)) (#f (let () (let ((self0 ($U16.eql 46 chr$0))) (case self0 (#t (let () Bool.true)) (#f (let () (let ((self0 ($U16.eql 95 chr$0))) (case self0 (#t (let () Bool.true)) (#f (let () (let ((self0 ($U16.eql 94 chr$0))) (case self0 (#t (let () Bool.true)) (#f (let () Bool.false)))))))))))))))))))))))))
(define Kind.Name.is_letter (lambda (chr$0) ($Kind.Name.is_letter chr$0)))
(define ($Kind.Parser.letter idx$0 code$1) (let ((self0 code$1)) (case (= (string-length self0) 0) (#t (let () ($Parser.Reply.error idx$0 code$1 "Unexpected eof."))) (#f (let ((f0 (char->integer (string-ref self0 0)))(f1 (let ((_str_ self0)) (substring _str_ 1 (string-length _str_))))) (let ((self2 ($Kind.Name.is_letter f0))) (case self2 (#t (let () ($Parser.Reply.value ($Nat.succ idx$0) f1 f0))) (#f (let () ($Parser.Reply.error idx$0 code$1 "Expected letter."))))))))))
(define Kind.Parser.letter (lambda (idx$0) (lambda (code$1) ($Kind.Parser.letter idx$0 code$1))))
(define ($List.fold list$1 nil$3 cons$4) (let ((self0 list$1)) (case (get self0 0) ('List.nil (let () nil$3)) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) ((cons$4 f0) ($List.fold f1 nil$3 cons$4)))))))
(define List.fold (lambda (list$1) (lambda (nil$3) (lambda (cons$4) ($List.fold list$1 nil$3 cons$4)))))
(define ($Kind.Parser.name1 idx$0 code$1) (let ((self0 ((Kind.Parser.spaces idx$0) code$1))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ($Parser.many1 Kind.Parser.letter f0 f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.value f3 f4 ($List.fold f5 String.nil String.cons)))))))))))
(define Kind.Parser.name1 (lambda (idx$0) (lambda (code$1) ($Kind.Parser.name1 idx$0 code$1))))
(define ($Kind.Parser.text text$0 idx$1 code$2) (let ((self0 ((Kind.Parser.spaces idx$1) code$2))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.text text$0 f0 f1))))))
(define Kind.Parser.text (lambda (text$0) (lambda (idx$1) (lambda (code$2) ($Kind.Parser.text text$0 idx$1 code$2)))))
(define ($Parser.until1 cond$1 parser$2 idx$3 code$4) (let ((self0 ((parser$2 idx$3) code$4))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ((($Parser.until cond$1 parser$2) f0) f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.value f3 f4 ($List.cons f2 f5)))))))))))
(define Parser.until1 (lambda (cond$1) (lambda (parser$2) (lambda (idx$3) (lambda (code$4) ($Parser.until1 cond$1 parser$2 idx$3 code$4))))))
(define ($Parser.maybe parse$1 idx$2 code$3) (let ((self0 ((parse$1 idx$2) code$3))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.value idx$2 code$3 Maybe.none))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.value f0 f1 ($Maybe.some f2)))))))
(define Parser.maybe (lambda (parse$1) (lambda (idx$2) (lambda (code$3) ($Parser.maybe parse$1 idx$2 code$3)))))
(define ($Kind.Parser.item parser$1 idx$2 code$3) (let ((self0 ((Kind.Parser.spaces idx$2) code$3))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ((parser$1 f0) f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (let ((self6 ($Parser.maybe (Kind.Parser.text ",") f3 f4))) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Parser.Reply.error f6 f7 f8))) ('Parser.Reply.value (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Parser.Reply.value f6 f7 f5))))))))))))))
(define Kind.Parser.item (lambda (parser$1) (lambda (idx$2) (lambda (code$3) ($Kind.Parser.item parser$1 idx$2 code$3)))))
(define ($Kind.Parser.name idx$0 code$1) (let ((self0 ((Kind.Parser.spaces idx$0) code$1))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ((($Parser.many Kind.Parser.letter) f0) f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.value f3 f4 ($List.fold f5 String.nil String.cons)))))))))))
(define Kind.Parser.name (lambda (idx$0) (lambda (code$1) ($Kind.Parser.name idx$0 code$1))))
(define ($Kind.Term.all eras$0 self$1 name$2 xtyp$3 body$4) (vector 'Kind.Term.all eras$0 self$1 name$2 xtyp$3 body$4))
(define Kind.Term.all (lambda (eras$0) (lambda (self$1) (lambda (name$2) (lambda (xtyp$3) (lambda (body$4) ($Kind.Term.all eras$0 self$1 name$2 xtyp$3 body$4)))))))
(define ($Pair.new fst$2 snd$3) (vector 'Pair.new fst$2 snd$3))
(define Pair.new (lambda (fst$2) (lambda (snd$3) ($Pair.new fst$2 snd$3))))
(define ($Kind.Parser.stop from$0 idx$1 code$2) (let ((self0 ($Parser.get_index idx$1 code$2))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((orig$6 ($Pair.new from$0 f2))) ($Parser.Reply.value f0 f1 orig$6)))))))
(define Kind.Parser.stop (lambda (from$0) (lambda (idx$1) (lambda (code$2) ($Kind.Parser.stop from$0 idx$1 code$2)))))
(define ($Kind.Term.ori orig$0 expr$1) (vector 'Kind.Term.ori orig$0 expr$1))
(define Kind.Term.ori (lambda (orig$0) (lambda (expr$1) ($Kind.Term.ori orig$0 expr$1))))
(define ($Kind.Parser.forall idx$0 code$1) (let ((self0 ($Kind.Parser.init idx$0 code$1))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ($Kind.Parser.name f0 f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (let ((self6 ($Kind.Parser.binder ":" f3 f4))) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Parser.Reply.error f6 f7 f8))) ('Parser.Reply.value (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) (let ((self9 ($Parser.maybe (Kind.Parser.text "->") f6 f7))) (case (get self9 0) ('Parser.Reply.error (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) ($Parser.Reply.error f9 f10 f11))) ('Parser.Reply.value (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) (let ((self12 ($Kind.Parser.term f9 f10))) (case (get self12 0) ('Parser.Reply.error (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) ($Parser.Reply.error f12 f13 f14))) ('Parser.Reply.value (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) (let ((term$17 ($List.fold f8 f14 (lambda (x$17) (lambda (t$18) (let ((self17 x$17)) (case (get self17 0) ('Kind.Binder.new (let ((f17 (get self17 1))(f18 (get self17 2))(f19 (get self17 3))) ($Kind.Term.all f17 "" f18 f19 (lambda (s$22) (lambda (x$23) t$18)))))))))))) (let ((self16 ($Kind.Parser.stop f2 f12 f13))) (case (get self16 0) ('Parser.Reply.error (let ((f16 (get self16 1))(f17 (get self16 2))(f18 (get self16 3))) ($Parser.Reply.error f16 f17 f18))) ('Parser.Reply.value (let ((f16 (get self16 1))(f17 (get self16 2))(f18 (get self16 3))) ($Parser.Reply.value f16 f17 (let ((self19 term$17)) (case (get self19 0) ('Kind.Term.var (let ((f19 (get self19 1))(f20 (get self19 2))) term$17)) ('Kind.Term.ref (let ((f19 (get self19 1))) term$17)) ('Kind.Term.typ (let () term$17)) ('Kind.Term.all (let ((f19 (get self19 1))(f20 (get self19 2))(f21 (get self19 3))(f22 (get self19 4))(f23 (get self19 5))) ($Kind.Term.ori f18 ($Kind.Term.all f19 f5 f21 f22 f23)))) ('Kind.Term.lam (let ((f19 (get self19 1))(f20 (get self19 2))) term$17)) ('Kind.Term.app (let ((f19 (get self19 1))(f20 (get self19 2))) term$17)) ('Kind.Term.let (let ((f19 (get self19 1))(f20 (get self19 2))(f21 (get self19 3))) term$17)) ('Kind.Term.def (let ((f19 (get self19 1))(f20 (get self19 2))(f21 (get self19 3))) term$17)) ('Kind.Term.ann (let ((f19 (get self19 1))(f20 (get self19 2))(f21 (get self19 3))) term$17)) ('Kind.Term.gol (let ((f19 (get self19 1))(f20 (get self19 2))(f21 (get self19 3))) term$17)) ('Kind.Term.hol (let ((f19 (get self19 1))) term$17)) ('Kind.Term.nat (let ((f19 (get self19 1))) term$17)) ('Kind.Term.chr (let ((f19 (get self19 1))) term$17)) ('Kind.Term.str (let ((f19 (get self19 1))) term$17)) ('Kind.Term.cse (let ((f19 (get self19 1))(f20 (get self19 2))(f21 (get self19 3))(f22 (get self19 4))(f23 (get self19 5))(f24 (get self19 6))) term$17)) ('Kind.Term.ori (let ((f19 (get self19 1))(f20 (get self19 2))) term$17)))))))))))))))))))))))))))))))
(define Kind.Parser.forall (lambda (idx$0) (lambda (code$1) ($Kind.Parser.forall idx$0 code$1))))
(define ($Kind.Term.lam name$0 body$1) (vector 'Kind.Term.lam name$0 body$1))
(define Kind.Term.lam (lambda (name$0) (lambda (body$1) ($Kind.Term.lam name$0 body$1))))
(define ($Kind.Parser.make_lambda names$0 body$1) (let ((self0 names$0)) (case (get self0 0) ('List.nil (let () body$1)) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) ($Kind.Term.lam f0 (lambda (x$4) ($Kind.Parser.make_lambda f1 body$1))))))))
(define Kind.Parser.make_lambda (lambda (names$0) (lambda (body$1) ($Kind.Parser.make_lambda names$0 body$1))))
(define ($Kind.Parser.lambda idx$0 code$1) (let ((self0 ($Kind.Parser.init idx$0 code$1))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ($Kind.Parser.text "(" f0 f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (let ((self6 ($Parser.until1 (Kind.Parser.text ")") (Kind.Parser.item Kind.Parser.name1) f3 f4))) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Parser.Reply.error f6 f7 f8))) ('Parser.Reply.value (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) (let ((self9 ($Kind.Parser.term f6 f7))) (case (get self9 0) ('Parser.Reply.error (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) ($Parser.Reply.error f9 f10 f11))) ('Parser.Reply.value (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) (let ((self12 ($Kind.Parser.stop f2 f9 f10))) (case (get self12 0) ('Parser.Reply.error (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) ($Parser.Reply.error f12 f13 f14))) ('Parser.Reply.value (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) (let ((expr$17 ($Kind.Parser.make_lambda f8 f11))) ($Parser.Reply.value f12 f13 ($Kind.Term.ori f14 expr$17))))))))))))))))))))))))
(define Kind.Parser.lambda (lambda (idx$0) (lambda (code$1) ($Kind.Parser.lambda idx$0 code$1))))
(define ($Kind.Parser.lambda.erased idx$0 code$1) (let ((self0 ($Kind.Parser.init idx$0 code$1))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ($Kind.Parser.text "<" f0 f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (let ((self6 ($Parser.until1 (Kind.Parser.text ">") (Kind.Parser.item Kind.Parser.name1) f3 f4))) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Parser.Reply.error f6 f7 f8))) ('Parser.Reply.value (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) (let ((self9 ($Kind.Parser.term f6 f7))) (case (get self9 0) ('Parser.Reply.error (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) ($Parser.Reply.error f9 f10 f11))) ('Parser.Reply.value (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) (let ((self12 ($Kind.Parser.stop f2 f9 f10))) (case (get self12 0) ('Parser.Reply.error (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) ($Parser.Reply.error f12 f13 f14))) ('Parser.Reply.value (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) (let ((expr$17 ($Kind.Parser.make_lambda f8 f11))) ($Parser.Reply.value f12 f13 ($Kind.Term.ori f14 expr$17))))))))))))))))))))))))
(define Kind.Parser.lambda.erased (lambda (idx$0) (lambda (code$1) ($Kind.Parser.lambda.erased idx$0 code$1))))
(define ($Kind.Parser.lambda.nameless idx$0 code$1) (let ((self0 ($Kind.Parser.init idx$0 code$1))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ($Kind.Parser.text "()" f0 f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (let ((self6 ($Kind.Parser.term f3 f4))) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Parser.Reply.error f6 f7 f8))) ('Parser.Reply.value (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) (let ((self9 ($Kind.Parser.stop f2 f6 f7))) (case (get self9 0) ('Parser.Reply.error (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) ($Parser.Reply.error f9 f10 f11))) ('Parser.Reply.value (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) (let ((expr$14 ($Kind.Term.lam "" (lambda (x$14) f8)))) ($Parser.Reply.value f9 f10 ($Kind.Term.ori f11 expr$14))))))))))))))))))))
(define Kind.Parser.lambda.nameless (lambda (idx$0) (lambda (code$1) ($Kind.Parser.lambda.nameless idx$0 code$1))))
(define ($Kind.Parser.parenthesis idx$0 code$1) (let ((self0 ($Kind.Parser.init idx$0 code$1))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ($Kind.Parser.text "(" f0 f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (let ((self6 ($Kind.Parser.term f3 f4))) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Parser.Reply.error f6 f7 f8))) ('Parser.Reply.value (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) (let ((self9 ($Kind.Parser.text ")" f6 f7))) (case (get self9 0) ('Parser.Reply.error (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) ($Parser.Reply.error f9 f10 f11))) ('Parser.Reply.value (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) (let ((self12 ($Kind.Parser.stop f2 f9 f10))) (case (get self12 0) ('Parser.Reply.error (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) ($Parser.Reply.error f12 f13 f14))) ('Parser.Reply.value (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) ($Parser.Reply.value f12 f13 ($Kind.Term.ori f14 f8)))))))))))))))))))))))
(define Kind.Parser.parenthesis (lambda (idx$0) (lambda (code$1) ($Kind.Parser.parenthesis idx$0 code$1))))
(define ($Kind.Term.ref name$0) (vector 'Kind.Term.ref name$0))
(define Kind.Term.ref (lambda (name$0) ($Kind.Term.ref name$0)))
(define ($Kind.Term.app func$0 argm$1) (vector 'Kind.Term.app func$0 argm$1))
(define Kind.Term.app (lambda (func$0) (lambda (argm$1) ($Kind.Term.app func$0 argm$1))))
(define ($Kind.Term.hol path$0) (vector 'Kind.Term.hol path$0))
(define Kind.Term.hol (lambda (path$0) ($Kind.Term.hol path$0)))
(define ($Bits.e) (vector 'Bits.e))
(define Bits.e ($Bits.e))
(define ($Kind.Term.let name$0 expr$1 body$2) (vector 'Kind.Term.let name$0 expr$1 body$2))
(define Kind.Term.let (lambda (name$0) (lambda (expr$1) (lambda (body$2) ($Kind.Term.let name$0 expr$1 body$2)))))
(define ($Kind.Parser.letforrange.u32 idx$0 code$1) (let ((self0 ($Kind.Parser.init idx$0 code$1))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ($Kind.Parser.text "let " f0 f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (let ((self6 ($Kind.Parser.name1 f3 f4))) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Parser.Reply.error f6 f7 f8))) ('Parser.Reply.value (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) (let ((self9 ($Kind.Parser.text "=" f6 f7))) (case (get self9 0) ('Parser.Reply.error (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) ($Parser.Reply.error f9 f10 f11))) ('Parser.Reply.value (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) (let ((self12 ($Kind.Parser.text "for " f9 f10))) (case (get self12 0) ('Parser.Reply.error (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) ($Parser.Reply.error f12 f13 f14))) ('Parser.Reply.value (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) (let ((self15 ($Kind.Parser.name1 f12 f13))) (case (get self15 0) ('Parser.Reply.error (let ((f15 (get self15 1))(f16 (get self15 2))(f17 (get self15 3))) ($Parser.Reply.error f15 f16 f17))) ('Parser.Reply.value (let ((f15 (get self15 1))(f16 (get self15 2))(f17 (get self15 3))) (let ((self18 ($Kind.Parser.text ":" f15 f16))) (case (get self18 0) ('Parser.Reply.error (let ((f18 (get self18 1))(f19 (get self18 2))(f20 (get self18 3))) ($Parser.Reply.error f18 f19 f20))) ('Parser.Reply.value (let ((f18 (get self18 1))(f19 (get self18 2))(f20 (get self18 3))) (let ((self21 ($Kind.Parser.text "U32" f18 f19))) (case (get self21 0) ('Parser.Reply.error (let ((f21 (get self21 1))(f22 (get self21 2))(f23 (get self21 3))) ($Parser.Reply.error f21 f22 f23))) ('Parser.Reply.value (let ((f21 (get self21 1))(f22 (get self21 2))(f23 (get self21 3))) (let ((self24 ($Kind.Parser.text "from" f21 f22))) (case (get self24 0) ('Parser.Reply.error (let ((f24 (get self24 1))(f25 (get self24 2))(f26 (get self24 3))) ($Parser.Reply.error f24 f25 f26))) ('Parser.Reply.value (let ((f24 (get self24 1))(f25 (get self24 2))(f26 (get self24 3))) (let ((self27 ($Kind.Parser.term f24 f25))) (case (get self27 0) ('Parser.Reply.error (let ((f27 (get self27 1))(f28 (get self27 2))(f29 (get self27 3))) ($Parser.Reply.error f27 f28 f29))) ('Parser.Reply.value (let ((f27 (get self27 1))(f28 (get self27 2))(f29 (get self27 3))) (let ((self30 ($Kind.Parser.text "to" f27 f28))) (case (get self30 0) ('Parser.Reply.error (let ((f30 (get self30 1))(f31 (get self30 2))(f32 (get self30 3))) ($Parser.Reply.error f30 f31 f32))) ('Parser.Reply.value (let ((f30 (get self30 1))(f31 (get self30 2))(f32 (get self30 3))) (let ((self33 ($Kind.Parser.term f30 f31))) (case (get self33 0) ('Parser.Reply.error (let ((f33 (get self33 1))(f34 (get self33 2))(f35 (get self33 3))) ($Parser.Reply.error f33 f34 f35))) ('Parser.Reply.value (let ((f33 (get self33 1))(f34 (get self33 2))(f35 (get self33 3))) (let ((self36 ($Kind.Parser.text ":" f33 f34))) (case (get self36 0) ('Parser.Reply.error (let ((f36 (get self36 1))(f37 (get self36 2))(f38 (get self36 3))) ($Parser.Reply.error f36 f37 f38))) ('Parser.Reply.value (let ((f36 (get self36 1))(f37 (get self36 2))(f38 (get self36 3))) (let ((self39 ($Kind.Parser.term f36 f37))) (case (get self39 0) ('Parser.Reply.error (let ((f39 (get self39 1))(f40 (get self39 2))(f41 (get self39 3))) ($Parser.Reply.error f39 f40 f41))) ('Parser.Reply.value (let ((f39 (get self39 1))(f40 (get self39 2))(f41 (get self39 3))) (let ((self42 ($Parser.maybe (Kind.Parser.text ";") f39 f40))) (case (get self42 0) ('Parser.Reply.error (let ((f42 (get self42 1))(f43 (get self42 2))(f44 (get self42 3))) ($Parser.Reply.error f42 f43 f44))) ('Parser.Reply.value (let ((f42 (get self42 1))(f43 (get self42 2))(f44 (get self42 3))) (let ((self45 ($Kind.Parser.term f42 f43))) (case (get self45 0) ('Parser.Reply.error (let ((f45 (get self45 1))(f46 (get self45 2))(f47 (get self45 3))) ($Parser.Reply.error f45 f46 f47))) ('Parser.Reply.value (let ((f45 (get self45 1))(f46 (get self45 2))(f47 (get self45 3))) (let ((self48 ($Kind.Parser.stop f2 f45 f46))) (case (get self48 0) ('Parser.Reply.error (let ((f48 (get self48 1))(f49 (get self48 2))(f50 (get self48 3))) ($Parser.Reply.error f48 f49 f50))) ('Parser.Reply.value (let ((f48 (get self48 1))(f49 (get self48 2))(f50 (get self48 3))) (let ((term$53 ($Kind.Term.ref "U32.for"))) (let ((term$54 ($Kind.Term.app term$53 ($Kind.Term.hol Bits.e)))) (let ((term$55 ($Kind.Term.app term$54 ($Kind.Term.ref f8)))) (let ((term$56 ($Kind.Term.app term$55 f29))) (let ((term$57 ($Kind.Term.app term$56 f35))) (let ((lamb$58 ($Kind.Term.lam f17 (lambda (e$58) ($Kind.Term.lam f8 (lambda (s$59) f41)))))) (let ((term$59 ($Kind.Term.app term$57 lamb$58))) (let ((term$60 ($Kind.Term.let f8 term$59 (lambda (x$60) f47)))) ($Parser.Reply.value f48 f49 ($Kind.Term.ori f50 term$60)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.letforrange.u32 (lambda (idx$0) (lambda (code$1) ($Kind.Parser.letforrange.u32 idx$0 code$1))))
(define ($Kind.Parser.letforrange.u32.with idx$0 code$1) (let ((self0 ($Kind.Parser.init idx$0 code$1))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ($Kind.Parser.text "for " f0 f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (let ((self6 ($Kind.Parser.name1 f3 f4))) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Parser.Reply.error f6 f7 f8))) ('Parser.Reply.value (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) (let ((self9 ($Kind.Parser.text ":" f6 f7))) (case (get self9 0) ('Parser.Reply.error (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) ($Parser.Reply.error f9 f10 f11))) ('Parser.Reply.value (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) (let ((self12 ($Kind.Parser.text "U32" f9 f10))) (case (get self12 0) ('Parser.Reply.error (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) ($Parser.Reply.error f12 f13 f14))) ('Parser.Reply.value (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) (let ((self15 ($Kind.Parser.text "from" f12 f13))) (case (get self15 0) ('Parser.Reply.error (let ((f15 (get self15 1))(f16 (get self15 2))(f17 (get self15 3))) ($Parser.Reply.error f15 f16 f17))) ('Parser.Reply.value (let ((f15 (get self15 1))(f16 (get self15 2))(f17 (get self15 3))) (let ((self18 ($Kind.Parser.term f15 f16))) (case (get self18 0) ('Parser.Reply.error (let ((f18 (get self18 1))(f19 (get self18 2))(f20 (get self18 3))) ($Parser.Reply.error f18 f19 f20))) ('Parser.Reply.value (let ((f18 (get self18 1))(f19 (get self18 2))(f20 (get self18 3))) (let ((self21 ($Kind.Parser.text "to" f18 f19))) (case (get self21 0) ('Parser.Reply.error (let ((f21 (get self21 1))(f22 (get self21 2))(f23 (get self21 3))) ($Parser.Reply.error f21 f22 f23))) ('Parser.Reply.value (let ((f21 (get self21 1))(f22 (get self21 2))(f23 (get self21 3))) (let ((self24 ($Kind.Parser.term f21 f22))) (case (get self24 0) ('Parser.Reply.error (let ((f24 (get self24 1))(f25 (get self24 2))(f26 (get self24 3))) ($Parser.Reply.error f24 f25 f26))) ('Parser.Reply.value (let ((f24 (get self24 1))(f25 (get self24 2))(f26 (get self24 3))) (let ((self27 ($Kind.Parser.text "with " f24 f25))) (case (get self27 0) ('Parser.Reply.error (let ((f27 (get self27 1))(f28 (get self27 2))(f29 (get self27 3))) ($Parser.Reply.error f27 f28 f29))) ('Parser.Reply.value (let ((f27 (get self27 1))(f28 (get self27 2))(f29 (get self27 3))) (let ((self30 ($Kind.Parser.name1 f27 f28))) (case (get self30 0) ('Parser.Reply.error (let ((f30 (get self30 1))(f31 (get self30 2))(f32 (get self30 3))) ($Parser.Reply.error f30 f31 f32))) ('Parser.Reply.value (let ((f30 (get self30 1))(f31 (get self30 2))(f32 (get self30 3))) (let ((self33 ($Kind.Parser.text ":" f30 f31))) (case (get self33 0) ('Parser.Reply.error (let ((f33 (get self33 1))(f34 (get self33 2))(f35 (get self33 3))) ($Parser.Reply.error f33 f34 f35))) ('Parser.Reply.value (let ((f33 (get self33 1))(f34 (get self33 2))(f35 (get self33 3))) (let ((self36 ($Kind.Parser.term f33 f34))) (case (get self36 0) ('Parser.Reply.error (let ((f36 (get self36 1))(f37 (get self36 2))(f38 (get self36 3))) ($Parser.Reply.error f36 f37 f38))) ('Parser.Reply.value (let ((f36 (get self36 1))(f37 (get self36 2))(f38 (get self36 3))) (let ((self39 ($Parser.maybe (Kind.Parser.text ";") f36 f37))) (case (get self39 0) ('Parser.Reply.error (let ((f39 (get self39 1))(f40 (get self39 2))(f41 (get self39 3))) ($Parser.Reply.error f39 f40 f41))) ('Parser.Reply.value (let ((f39 (get self39 1))(f40 (get self39 2))(f41 (get self39 3))) (let ((self42 ($Kind.Parser.term f39 f40))) (case (get self42 0) ('Parser.Reply.error (let ((f42 (get self42 1))(f43 (get self42 2))(f44 (get self42 3))) ($Parser.Reply.error f42 f43 f44))) ('Parser.Reply.value (let ((f42 (get self42 1))(f43 (get self42 2))(f44 (get self42 3))) (let ((self45 ($Kind.Parser.stop f2 f42 f43))) (case (get self45 0) ('Parser.Reply.error (let ((f45 (get self45 1))(f46 (get self45 2))(f47 (get self45 3))) ($Parser.Reply.error f45 f46 f47))) ('Parser.Reply.value (let ((f45 (get self45 1))(f46 (get self45 2))(f47 (get self45 3))) (let ((term$50 ($Kind.Term.ref "U32.for"))) (let ((term$51 ($Kind.Term.app term$50 ($Kind.Term.hol Bits.e)))) (let ((term$52 ($Kind.Term.app term$51 ($Kind.Term.ref f32)))) (let ((term$53 ($Kind.Term.app term$52 f20))) (let ((term$54 ($Kind.Term.app term$53 f26))) (let ((lamb$55 ($Kind.Term.lam f8 (lambda (e$55) ($Kind.Term.lam f32 (lambda (s$56) f38)))))) (let ((term$56 ($Kind.Term.app term$54 lamb$55))) (let ((term$57 ($Kind.Term.let f32 term$56 (lambda (x$57) f44)))) ($Parser.Reply.value f45 f46 ($Kind.Term.ori f47 term$57)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.letforrange.u32.with (lambda (idx$0) (lambda (code$1) ($Kind.Parser.letforrange.u32.with idx$0 code$1))))
(define ($Kind.Parser.letforrange.nat idx$0 code$1) (let ((self0 ($Kind.Parser.init idx$0 code$1))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ($Kind.Parser.text "let " f0 f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (let ((self6 ($Kind.Parser.name1 f3 f4))) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Parser.Reply.error f6 f7 f8))) ('Parser.Reply.value (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) (let ((self9 ($Kind.Parser.text "=" f6 f7))) (case (get self9 0) ('Parser.Reply.error (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) ($Parser.Reply.error f9 f10 f11))) ('Parser.Reply.value (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) (let ((self12 ($Kind.Parser.text "for " f9 f10))) (case (get self12 0) ('Parser.Reply.error (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) ($Parser.Reply.error f12 f13 f14))) ('Parser.Reply.value (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) (let ((self15 ($Kind.Parser.name1 f12 f13))) (case (get self15 0) ('Parser.Reply.error (let ((f15 (get self15 1))(f16 (get self15 2))(f17 (get self15 3))) ($Parser.Reply.error f15 f16 f17))) ('Parser.Reply.value (let ((f15 (get self15 1))(f16 (get self15 2))(f17 (get self15 3))) (let ((self18 ($Kind.Parser.text "from" f15 f16))) (case (get self18 0) ('Parser.Reply.error (let ((f18 (get self18 1))(f19 (get self18 2))(f20 (get self18 3))) ($Parser.Reply.error f18 f19 f20))) ('Parser.Reply.value (let ((f18 (get self18 1))(f19 (get self18 2))(f20 (get self18 3))) (let ((self21 ($Kind.Parser.term f18 f19))) (case (get self21 0) ('Parser.Reply.error (let ((f21 (get self21 1))(f22 (get self21 2))(f23 (get self21 3))) ($Parser.Reply.error f21 f22 f23))) ('Parser.Reply.value (let ((f21 (get self21 1))(f22 (get self21 2))(f23 (get self21 3))) (let ((self24 ($Kind.Parser.text "to" f21 f22))) (case (get self24 0) ('Parser.Reply.error (let ((f24 (get self24 1))(f25 (get self24 2))(f26 (get self24 3))) ($Parser.Reply.error f24 f25 f26))) ('Parser.Reply.value (let ((f24 (get self24 1))(f25 (get self24 2))(f26 (get self24 3))) (let ((self27 ($Kind.Parser.term f24 f25))) (case (get self27 0) ('Parser.Reply.error (let ((f27 (get self27 1))(f28 (get self27 2))(f29 (get self27 3))) ($Parser.Reply.error f27 f28 f29))) ('Parser.Reply.value (let ((f27 (get self27 1))(f28 (get self27 2))(f29 (get self27 3))) (let ((self30 ($Kind.Parser.text ":" f27 f28))) (case (get self30 0) ('Parser.Reply.error (let ((f30 (get self30 1))(f31 (get self30 2))(f32 (get self30 3))) ($Parser.Reply.error f30 f31 f32))) ('Parser.Reply.value (let ((f30 (get self30 1))(f31 (get self30 2))(f32 (get self30 3))) (let ((self33 ($Kind.Parser.term f30 f31))) (case (get self33 0) ('Parser.Reply.error (let ((f33 (get self33 1))(f34 (get self33 2))(f35 (get self33 3))) ($Parser.Reply.error f33 f34 f35))) ('Parser.Reply.value (let ((f33 (get self33 1))(f34 (get self33 2))(f35 (get self33 3))) (let ((self36 ($Parser.maybe (Kind.Parser.text ";") f33 f34))) (case (get self36 0) ('Parser.Reply.error (let ((f36 (get self36 1))(f37 (get self36 2))(f38 (get self36 3))) ($Parser.Reply.error f36 f37 f38))) ('Parser.Reply.value (let ((f36 (get self36 1))(f37 (get self36 2))(f38 (get self36 3))) (let ((self39 ($Kind.Parser.term f36 f37))) (case (get self39 0) ('Parser.Reply.error (let ((f39 (get self39 1))(f40 (get self39 2))(f41 (get self39 3))) ($Parser.Reply.error f39 f40 f41))) ('Parser.Reply.value (let ((f39 (get self39 1))(f40 (get self39 2))(f41 (get self39 3))) (let ((self42 ($Kind.Parser.stop f2 f39 f40))) (case (get self42 0) ('Parser.Reply.error (let ((f42 (get self42 1))(f43 (get self42 2))(f44 (get self42 3))) ($Parser.Reply.error f42 f43 f44))) ('Parser.Reply.value (let ((f42 (get self42 1))(f43 (get self42 2))(f44 (get self42 3))) (let ((term$47 ($Kind.Term.ref "Nat.for"))) (let ((term$48 ($Kind.Term.app term$47 ($Kind.Term.hol Bits.e)))) (let ((term$49 ($Kind.Term.app term$48 ($Kind.Term.ref f8)))) (let ((term$50 ($Kind.Term.app term$49 f23))) (let ((term$51 ($Kind.Term.app term$50 f29))) (let ((lamb$52 ($Kind.Term.lam f17 (lambda (e$52) ($Kind.Term.lam f8 (lambda (s$53) f35)))))) (let ((term$53 ($Kind.Term.app term$51 lamb$52))) (let ((term$54 ($Kind.Term.let f8 term$53 (lambda (x$54) f41)))) ($Parser.Reply.value f42 f43 ($Kind.Term.ori f44 term$54)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.letforrange.nat (lambda (idx$0) (lambda (code$1) ($Kind.Parser.letforrange.nat idx$0 code$1))))
(define ($Kind.Parser.letforrange.nat.with idx$0 code$1) (let ((self0 ($Kind.Parser.init idx$0 code$1))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ($Kind.Parser.text "for " f0 f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (let ((self6 ($Kind.Parser.name1 f3 f4))) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Parser.Reply.error f6 f7 f8))) ('Parser.Reply.value (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) (let ((self9 ($Kind.Parser.text "from" f6 f7))) (case (get self9 0) ('Parser.Reply.error (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) ($Parser.Reply.error f9 f10 f11))) ('Parser.Reply.value (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) (let ((self12 ($Kind.Parser.term f9 f10))) (case (get self12 0) ('Parser.Reply.error (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) ($Parser.Reply.error f12 f13 f14))) ('Parser.Reply.value (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) (let ((self15 ($Kind.Parser.text "to" f12 f13))) (case (get self15 0) ('Parser.Reply.error (let ((f15 (get self15 1))(f16 (get self15 2))(f17 (get self15 3))) ($Parser.Reply.error f15 f16 f17))) ('Parser.Reply.value (let ((f15 (get self15 1))(f16 (get self15 2))(f17 (get self15 3))) (let ((self18 ($Kind.Parser.term f15 f16))) (case (get self18 0) ('Parser.Reply.error (let ((f18 (get self18 1))(f19 (get self18 2))(f20 (get self18 3))) ($Parser.Reply.error f18 f19 f20))) ('Parser.Reply.value (let ((f18 (get self18 1))(f19 (get self18 2))(f20 (get self18 3))) (let ((self21 ($Kind.Parser.text "with " f18 f19))) (case (get self21 0) ('Parser.Reply.error (let ((f21 (get self21 1))(f22 (get self21 2))(f23 (get self21 3))) ($Parser.Reply.error f21 f22 f23))) ('Parser.Reply.value (let ((f21 (get self21 1))(f22 (get self21 2))(f23 (get self21 3))) (let ((self24 ($Kind.Parser.name1 f21 f22))) (case (get self24 0) ('Parser.Reply.error (let ((f24 (get self24 1))(f25 (get self24 2))(f26 (get self24 3))) ($Parser.Reply.error f24 f25 f26))) ('Parser.Reply.value (let ((f24 (get self24 1))(f25 (get self24 2))(f26 (get self24 3))) (let ((self27 ($Kind.Parser.text ":" f24 f25))) (case (get self27 0) ('Parser.Reply.error (let ((f27 (get self27 1))(f28 (get self27 2))(f29 (get self27 3))) ($Parser.Reply.error f27 f28 f29))) ('Parser.Reply.value (let ((f27 (get self27 1))(f28 (get self27 2))(f29 (get self27 3))) (let ((self30 ($Kind.Parser.term f27 f28))) (case (get self30 0) ('Parser.Reply.error (let ((f30 (get self30 1))(f31 (get self30 2))(f32 (get self30 3))) ($Parser.Reply.error f30 f31 f32))) ('Parser.Reply.value (let ((f30 (get self30 1))(f31 (get self30 2))(f32 (get self30 3))) (let ((self33 ($Parser.maybe (Kind.Parser.text ";") f30 f31))) (case (get self33 0) ('Parser.Reply.error (let ((f33 (get self33 1))(f34 (get self33 2))(f35 (get self33 3))) ($Parser.Reply.error f33 f34 f35))) ('Parser.Reply.value (let ((f33 (get self33 1))(f34 (get self33 2))(f35 (get self33 3))) (let ((self36 ($Kind.Parser.term f33 f34))) (case (get self36 0) ('Parser.Reply.error (let ((f36 (get self36 1))(f37 (get self36 2))(f38 (get self36 3))) ($Parser.Reply.error f36 f37 f38))) ('Parser.Reply.value (let ((f36 (get self36 1))(f37 (get self36 2))(f38 (get self36 3))) (let ((self39 ($Kind.Parser.stop f2 f36 f37))) (case (get self39 0) ('Parser.Reply.error (let ((f39 (get self39 1))(f40 (get self39 2))(f41 (get self39 3))) ($Parser.Reply.error f39 f40 f41))) ('Parser.Reply.value (let ((f39 (get self39 1))(f40 (get self39 2))(f41 (get self39 3))) (let ((term$44 ($Kind.Term.ref "Nat.for"))) (let ((term$45 ($Kind.Term.app term$44 ($Kind.Term.hol Bits.e)))) (let ((term$46 ($Kind.Term.app term$45 ($Kind.Term.ref f26)))) (let ((term$47 ($Kind.Term.app term$46 f14))) (let ((term$48 ($Kind.Term.app term$47 f20))) (let ((lamb$49 ($Kind.Term.lam f8 (lambda (e$49) ($Kind.Term.lam f26 (lambda (s$50) f32)))))) (let ((term$50 ($Kind.Term.app term$48 lamb$49))) (let ((term$51 ($Kind.Term.let f26 term$50 (lambda (x$51) f38)))) ($Parser.Reply.value f39 f40 ($Kind.Term.ori f41 term$51)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.letforrange.nat.with (lambda (idx$0) (lambda (code$1) ($Kind.Parser.letforrange.nat.with idx$0 code$1))))
(define ($Kind.Parser.letforin idx$0 code$1) (let ((self0 ($Kind.Parser.init idx$0 code$1))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ($Kind.Parser.text "let " f0 f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (let ((self6 ($Kind.Parser.name1 f3 f4))) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Parser.Reply.error f6 f7 f8))) ('Parser.Reply.value (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) (let ((self9 ($Kind.Parser.text "=" f6 f7))) (case (get self9 0) ('Parser.Reply.error (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) ($Parser.Reply.error f9 f10 f11))) ('Parser.Reply.value (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) (let ((self12 ($Kind.Parser.text "for " f9 f10))) (case (get self12 0) ('Parser.Reply.error (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) ($Parser.Reply.error f12 f13 f14))) ('Parser.Reply.value (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) (let ((self15 ($Kind.Parser.name1 f12 f13))) (case (get self15 0) ('Parser.Reply.error (let ((f15 (get self15 1))(f16 (get self15 2))(f17 (get self15 3))) ($Parser.Reply.error f15 f16 f17))) ('Parser.Reply.value (let ((f15 (get self15 1))(f16 (get self15 2))(f17 (get self15 3))) (let ((self18 ($Kind.Parser.text "in" f15 f16))) (case (get self18 0) ('Parser.Reply.error (let ((f18 (get self18 1))(f19 (get self18 2))(f20 (get self18 3))) ($Parser.Reply.error f18 f19 f20))) ('Parser.Reply.value (let ((f18 (get self18 1))(f19 (get self18 2))(f20 (get self18 3))) (let ((self21 ($Kind.Parser.term f18 f19))) (case (get self21 0) ('Parser.Reply.error (let ((f21 (get self21 1))(f22 (get self21 2))(f23 (get self21 3))) ($Parser.Reply.error f21 f22 f23))) ('Parser.Reply.value (let ((f21 (get self21 1))(f22 (get self21 2))(f23 (get self21 3))) (let ((self24 ($Kind.Parser.text ":" f21 f22))) (case (get self24 0) ('Parser.Reply.error (let ((f24 (get self24 1))(f25 (get self24 2))(f26 (get self24 3))) ($Parser.Reply.error f24 f25 f26))) ('Parser.Reply.value (let ((f24 (get self24 1))(f25 (get self24 2))(f26 (get self24 3))) (let ((self27 ($Kind.Parser.term f24 f25))) (case (get self27 0) ('Parser.Reply.error (let ((f27 (get self27 1))(f28 (get self27 2))(f29 (get self27 3))) ($Parser.Reply.error f27 f28 f29))) ('Parser.Reply.value (let ((f27 (get self27 1))(f28 (get self27 2))(f29 (get self27 3))) (let ((self30 ($Parser.maybe (Kind.Parser.text ";") f27 f28))) (case (get self30 0) ('Parser.Reply.error (let ((f30 (get self30 1))(f31 (get self30 2))(f32 (get self30 3))) ($Parser.Reply.error f30 f31 f32))) ('Parser.Reply.value (let ((f30 (get self30 1))(f31 (get self30 2))(f32 (get self30 3))) (let ((self33 ($Kind.Parser.term f30 f31))) (case (get self33 0) ('Parser.Reply.error (let ((f33 (get self33 1))(f34 (get self33 2))(f35 (get self33 3))) ($Parser.Reply.error f33 f34 f35))) ('Parser.Reply.value (let ((f33 (get self33 1))(f34 (get self33 2))(f35 (get self33 3))) (let ((self36 ($Kind.Parser.stop f2 f33 f34))) (case (get self36 0) ('Parser.Reply.error (let ((f36 (get self36 1))(f37 (get self36 2))(f38 (get self36 3))) ($Parser.Reply.error f36 f37 f38))) ('Parser.Reply.value (let ((f36 (get self36 1))(f37 (get self36 2))(f38 (get self36 3))) (let ((term$41 ($Kind.Term.ref "List.for"))) (let ((term$42 ($Kind.Term.app term$41 ($Kind.Term.hol Bits.e)))) (let ((term$43 ($Kind.Term.app term$42 f23))) (let ((term$44 ($Kind.Term.app term$43 ($Kind.Term.hol Bits.e)))) (let ((term$45 ($Kind.Term.app term$44 ($Kind.Term.ref f8)))) (let ((lamb$46 ($Kind.Term.lam f17 (lambda (i$46) ($Kind.Term.lam f8 (lambda (x$47) f29)))))) (let ((term$47 ($Kind.Term.app term$45 lamb$46))) (let ((term$48 ($Kind.Term.let f8 term$47 (lambda (x$48) f35)))) ($Parser.Reply.value f36 f37 ($Kind.Term.ori f38 term$48)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.letforin (lambda (idx$0) (lambda (code$1) ($Kind.Parser.letforin idx$0 code$1))))
(define ($Kind.Parser.letforin.with idx$0 code$1) (let ((self0 ($Kind.Parser.init idx$0 code$1))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ($Kind.Parser.text "for " f0 f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (let ((self6 ($Kind.Parser.name1 f3 f4))) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Parser.Reply.error f6 f7 f8))) ('Parser.Reply.value (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) (let ((self9 ($Kind.Parser.text "in" f6 f7))) (case (get self9 0) ('Parser.Reply.error (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) ($Parser.Reply.error f9 f10 f11))) ('Parser.Reply.value (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) (let ((self12 ($Kind.Parser.term f9 f10))) (case (get self12 0) ('Parser.Reply.error (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) ($Parser.Reply.error f12 f13 f14))) ('Parser.Reply.value (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) (let ((self15 ($Kind.Parser.text "with " f12 f13))) (case (get self15 0) ('Parser.Reply.error (let ((f15 (get self15 1))(f16 (get self15 2))(f17 (get self15 3))) ($Parser.Reply.error f15 f16 f17))) ('Parser.Reply.value (let ((f15 (get self15 1))(f16 (get self15 2))(f17 (get self15 3))) (let ((self18 ($Kind.Parser.name1 f15 f16))) (case (get self18 0) ('Parser.Reply.error (let ((f18 (get self18 1))(f19 (get self18 2))(f20 (get self18 3))) ($Parser.Reply.error f18 f19 f20))) ('Parser.Reply.value (let ((f18 (get self18 1))(f19 (get self18 2))(f20 (get self18 3))) (let ((self21 ($Kind.Parser.text ":" f18 f19))) (case (get self21 0) ('Parser.Reply.error (let ((f21 (get self21 1))(f22 (get self21 2))(f23 (get self21 3))) ($Parser.Reply.error f21 f22 f23))) ('Parser.Reply.value (let ((f21 (get self21 1))(f22 (get self21 2))(f23 (get self21 3))) (let ((self24 ($Kind.Parser.term f21 f22))) (case (get self24 0) ('Parser.Reply.error (let ((f24 (get self24 1))(f25 (get self24 2))(f26 (get self24 3))) ($Parser.Reply.error f24 f25 f26))) ('Parser.Reply.value (let ((f24 (get self24 1))(f25 (get self24 2))(f26 (get self24 3))) (let ((self27 ($Parser.maybe (Kind.Parser.text ";") f24 f25))) (case (get self27 0) ('Parser.Reply.error (let ((f27 (get self27 1))(f28 (get self27 2))(f29 (get self27 3))) ($Parser.Reply.error f27 f28 f29))) ('Parser.Reply.value (let ((f27 (get self27 1))(f28 (get self27 2))(f29 (get self27 3))) (let ((self30 ($Kind.Parser.term f27 f28))) (case (get self30 0) ('Parser.Reply.error (let ((f30 (get self30 1))(f31 (get self30 2))(f32 (get self30 3))) ($Parser.Reply.error f30 f31 f32))) ('Parser.Reply.value (let ((f30 (get self30 1))(f31 (get self30 2))(f32 (get self30 3))) (let ((self33 ($Kind.Parser.stop f2 f30 f31))) (case (get self33 0) ('Parser.Reply.error (let ((f33 (get self33 1))(f34 (get self33 2))(f35 (get self33 3))) ($Parser.Reply.error f33 f34 f35))) ('Parser.Reply.value (let ((f33 (get self33 1))(f34 (get self33 2))(f35 (get self33 3))) (let ((term$38 ($Kind.Term.ref "List.for"))) (let ((term$39 ($Kind.Term.app term$38 ($Kind.Term.hol Bits.e)))) (let ((term$40 ($Kind.Term.app term$39 f14))) (let ((term$41 ($Kind.Term.app term$40 ($Kind.Term.hol Bits.e)))) (let ((term$42 ($Kind.Term.app term$41 ($Kind.Term.ref f20)))) (let ((lamb$43 ($Kind.Term.lam f8 (lambda (i$43) ($Kind.Term.lam f20 (lambda (x$44) f26)))))) (let ((term$44 ($Kind.Term.app term$42 lamb$43))) (let ((term$45 ($Kind.Term.let f20 term$44 (lambda (x$45) f32)))) ($Parser.Reply.value f33 f34 ($Kind.Term.ori f35 term$45)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.letforin.with (lambda (idx$0) (lambda (code$1) ($Kind.Parser.letforin.with idx$0 code$1))))
(define ($Kind.Parser.letwhile idx$0 code$1) (let ((self0 ($Kind.Parser.init idx$0 code$1))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ($Kind.Parser.text "let " f0 f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (let ((self6 ($Kind.Parser.name1 f3 f4))) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Parser.Reply.error f6 f7 f8))) ('Parser.Reply.value (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) (let ((self9 ($Kind.Parser.text "=" f6 f7))) (case (get self9 0) ('Parser.Reply.error (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) ($Parser.Reply.error f9 f10 f11))) ('Parser.Reply.value (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) (let ((self12 ($Kind.Parser.text "while " f9 f10))) (case (get self12 0) ('Parser.Reply.error (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) ($Parser.Reply.error f12 f13 f14))) ('Parser.Reply.value (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) (let ((self15 ($Kind.Parser.term f12 f13))) (case (get self15 0) ('Parser.Reply.error (let ((f15 (get self15 1))(f16 (get self15 2))(f17 (get self15 3))) ($Parser.Reply.error f15 f16 f17))) ('Parser.Reply.value (let ((f15 (get self15 1))(f16 (get self15 2))(f17 (get self15 3))) (let ((self18 ($Kind.Parser.text ":" f15 f16))) (case (get self18 0) ('Parser.Reply.error (let ((f18 (get self18 1))(f19 (get self18 2))(f20 (get self18 3))) ($Parser.Reply.error f18 f19 f20))) ('Parser.Reply.value (let ((f18 (get self18 1))(f19 (get self18 2))(f20 (get self18 3))) (let ((self21 ($Kind.Parser.term f18 f19))) (case (get self21 0) ('Parser.Reply.error (let ((f21 (get self21 1))(f22 (get self21 2))(f23 (get self21 3))) ($Parser.Reply.error f21 f22 f23))) ('Parser.Reply.value (let ((f21 (get self21 1))(f22 (get self21 2))(f23 (get self21 3))) (let ((self24 ($Parser.maybe (Kind.Parser.text ";") f21 f22))) (case (get self24 0) ('Parser.Reply.error (let ((f24 (get self24 1))(f25 (get self24 2))(f26 (get self24 3))) ($Parser.Reply.error f24 f25 f26))) ('Parser.Reply.value (let ((f24 (get self24 1))(f25 (get self24 2))(f26 (get self24 3))) (let ((self27 ($Kind.Parser.term f24 f25))) (case (get self27 0) ('Parser.Reply.error (let ((f27 (get self27 1))(f28 (get self27 2))(f29 (get self27 3))) ($Parser.Reply.error f27 f28 f29))) ('Parser.Reply.value (let ((f27 (get self27 1))(f28 (get self27 2))(f29 (get self27 3))) (let ((self30 ($Kind.Parser.stop f2 f27 f28))) (case (get self30 0) ('Parser.Reply.error (let ((f30 (get self30 1))(f31 (get self30 2))(f32 (get self30 3))) ($Parser.Reply.error f30 f31 f32))) ('Parser.Reply.value (let ((f30 (get self30 1))(f31 (get self30 2))(f32 (get self30 3))) (let ((term$35 ($Kind.Term.ref "Function.while"))) (let ((term$36 ($Kind.Term.app term$35 ($Kind.Term.hol Bits.e)))) (let ((term$37 ($Kind.Term.app term$36 ($Kind.Term.ref f8)))) (let ((term$38 ($Kind.Term.app term$37 ($Kind.Term.lam f8 (lambda (s$38) f17))))) (let ((term$39 ($Kind.Term.app term$38 ($Kind.Term.lam f8 (lambda (s$39) f23))))) (let ((term$40 ($Kind.Term.let f8 term$39 (lambda (x$40) f29)))) ($Parser.Reply.value f30 f31 ($Kind.Term.ori f32 term$40)))))))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.letwhile (lambda (idx$0) (lambda (code$1) ($Kind.Parser.letwhile idx$0 code$1))))
(define ($Kind.Parser.letwhile.with idx$0 code$1) (let ((self0 ($Kind.Parser.init idx$0 code$1))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ($Kind.Parser.text "while " f0 f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (let ((self6 ($Kind.Parser.term f3 f4))) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Parser.Reply.error f6 f7 f8))) ('Parser.Reply.value (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) (let ((self9 ($Kind.Parser.text "with " f6 f7))) (case (get self9 0) ('Parser.Reply.error (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) ($Parser.Reply.error f9 f10 f11))) ('Parser.Reply.value (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) (let ((self12 ($Kind.Parser.name1 f9 f10))) (case (get self12 0) ('Parser.Reply.error (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) ($Parser.Reply.error f12 f13 f14))) ('Parser.Reply.value (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) (let ((self15 ($Kind.Parser.text ":" f12 f13))) (case (get self15 0) ('Parser.Reply.error (let ((f15 (get self15 1))(f16 (get self15 2))(f17 (get self15 3))) ($Parser.Reply.error f15 f16 f17))) ('Parser.Reply.value (let ((f15 (get self15 1))(f16 (get self15 2))(f17 (get self15 3))) (let ((self18 ($Kind.Parser.term f15 f16))) (case (get self18 0) ('Parser.Reply.error (let ((f18 (get self18 1))(f19 (get self18 2))(f20 (get self18 3))) ($Parser.Reply.error f18 f19 f20))) ('Parser.Reply.value (let ((f18 (get self18 1))(f19 (get self18 2))(f20 (get self18 3))) (let ((self21 ($Parser.maybe (Kind.Parser.text ";") f18 f19))) (case (get self21 0) ('Parser.Reply.error (let ((f21 (get self21 1))(f22 (get self21 2))(f23 (get self21 3))) ($Parser.Reply.error f21 f22 f23))) ('Parser.Reply.value (let ((f21 (get self21 1))(f22 (get self21 2))(f23 (get self21 3))) (let ((self24 ($Kind.Parser.term f21 f22))) (case (get self24 0) ('Parser.Reply.error (let ((f24 (get self24 1))(f25 (get self24 2))(f26 (get self24 3))) ($Parser.Reply.error f24 f25 f26))) ('Parser.Reply.value (let ((f24 (get self24 1))(f25 (get self24 2))(f26 (get self24 3))) (let ((self27 ($Kind.Parser.stop f2 f24 f25))) (case (get self27 0) ('Parser.Reply.error (let ((f27 (get self27 1))(f28 (get self27 2))(f29 (get self27 3))) ($Parser.Reply.error f27 f28 f29))) ('Parser.Reply.value (let ((f27 (get self27 1))(f28 (get self27 2))(f29 (get self27 3))) (let ((term$32 ($Kind.Term.ref "Function.while"))) (let ((term$33 ($Kind.Term.app term$32 ($Kind.Term.hol Bits.e)))) (let ((term$34 ($Kind.Term.app term$33 ($Kind.Term.ref f14)))) (let ((term$35 ($Kind.Term.app term$34 ($Kind.Term.lam f14 (lambda (s$35) f8))))) (let ((term$36 ($Kind.Term.app term$35 ($Kind.Term.lam f14 (lambda (s$36) f20))))) (let ((term$37 ($Kind.Term.let f14 term$36 (lambda (x$37) f26)))) ($Parser.Reply.value f27 f28 ($Kind.Term.ori f29 term$37)))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.letwhile.with (lambda (idx$0) (lambda (code$1) ($Kind.Parser.letwhile.with idx$0 code$1))))
(define ($Kind.Parser.let idx$0 code$1) (let ((self0 ($Kind.Parser.init idx$0 code$1))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ($Kind.Parser.text "let " f0 f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (let ((self6 ($Kind.Parser.name f3 f4))) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Parser.Reply.error f6 f7 f8))) ('Parser.Reply.value (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) (let ((self9 ($Kind.Parser.text "=" f6 f7))) (case (get self9 0) ('Parser.Reply.error (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) ($Parser.Reply.error f9 f10 f11))) ('Parser.Reply.value (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) (let ((self12 ($Kind.Parser.term f9 f10))) (case (get self12 0) ('Parser.Reply.error (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) ($Parser.Reply.error f12 f13 f14))) ('Parser.Reply.value (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) (let ((self15 ($Parser.maybe (Kind.Parser.text ";") f12 f13))) (case (get self15 0) ('Parser.Reply.error (let ((f15 (get self15 1))(f16 (get self15 2))(f17 (get self15 3))) ($Parser.Reply.error f15 f16 f17))) ('Parser.Reply.value (let ((f15 (get self15 1))(f16 (get self15 2))(f17 (get self15 3))) (let ((self18 ($Kind.Parser.term f15 f16))) (case (get self18 0) ('Parser.Reply.error (let ((f18 (get self18 1))(f19 (get self18 2))(f20 (get self18 3))) ($Parser.Reply.error f18 f19 f20))) ('Parser.Reply.value (let ((f18 (get self18 1))(f19 (get self18 2))(f20 (get self18 3))) (let ((self21 ($Kind.Parser.stop f2 f18 f19))) (case (get self21 0) ('Parser.Reply.error (let ((f21 (get self21 1))(f22 (get self21 2))(f23 (get self21 3))) ($Parser.Reply.error f21 f22 f23))) ('Parser.Reply.value (let ((f21 (get self21 1))(f22 (get self21 2))(f23 (get self21 3))) ($Parser.Reply.value f21 f22 ($Kind.Term.ori f23 ($Kind.Term.let f8 f14 (lambda (x$26) f20)))))))))))))))))))))))))))))))))))))
(define Kind.Parser.let (lambda (idx$0) (lambda (code$1) ($Kind.Parser.let idx$0 code$1))))
(define ($Kind.Parser.let.omit idx$0 code$1) (let ((self0 ($Kind.Parser.init idx$0 code$1))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ($Kind.Parser.name f0 f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (let ((self6 ($Kind.Parser.text "= " f3 f4))) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Parser.Reply.error f6 f7 f8))) ('Parser.Reply.value (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) (let ((self9 ($Kind.Parser.term f6 f7))) (case (get self9 0) ('Parser.Reply.error (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) ($Parser.Reply.error f9 f10 f11))) ('Parser.Reply.value (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) (let ((self12 ($Parser.maybe (Kind.Parser.text ";") f9 f10))) (case (get self12 0) ('Parser.Reply.error (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) ($Parser.Reply.error f12 f13 f14))) ('Parser.Reply.value (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) (let ((self15 ($Kind.Parser.term f12 f13))) (case (get self15 0) ('Parser.Reply.error (let ((f15 (get self15 1))(f16 (get self15 2))(f17 (get self15 3))) ($Parser.Reply.error f15 f16 f17))) ('Parser.Reply.value (let ((f15 (get self15 1))(f16 (get self15 2))(f17 (get self15 3))) (let ((self18 ($Kind.Parser.stop f2 f15 f16))) (case (get self18 0) ('Parser.Reply.error (let ((f18 (get self18 1))(f19 (get self18 2))(f20 (get self18 3))) ($Parser.Reply.error f18 f19 f20))) ('Parser.Reply.value (let ((f18 (get self18 1))(f19 (get self18 2))(f20 (get self18 3))) ($Parser.Reply.value f18 f19 ($Kind.Term.ori f20 ($Kind.Term.let f5 f11 (lambda (x$23) f17)))))))))))))))))))))))))))))))))
(define Kind.Parser.let.omit (lambda (idx$0) (lambda (code$1) ($Kind.Parser.let.omit idx$0 code$1))))
(define ($Kind.Parser.getwhile idx$0 code$1) (let ((self0 ($Kind.Parser.init idx$0 code$1))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ($Parser.maybe (Kind.Parser.text "let ") f0 f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (let ((self6 ($Kind.Parser.text "{" f3 f4))) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Parser.Reply.error f6 f7 f8))) ('Parser.Reply.value (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) (let ((self9 ($Kind.Parser.name f6 f7))) (case (get self9 0) ('Parser.Reply.error (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) ($Parser.Reply.error f9 f10 f11))) ('Parser.Reply.value (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) (let ((self12 ($Kind.Parser.text "," f9 f10))) (case (get self12 0) ('Parser.Reply.error (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) ($Parser.Reply.error f12 f13 f14))) ('Parser.Reply.value (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) (let ((self15 ($Kind.Parser.name f12 f13))) (case (get self15 0) ('Parser.Reply.error (let ((f15 (get self15 1))(f16 (get self15 2))(f17 (get self15 3))) ($Parser.Reply.error f15 f16 f17))) ('Parser.Reply.value (let ((f15 (get self15 1))(f16 (get self15 2))(f17 (get self15 3))) (let ((self18 ($Kind.Parser.text "}" f15 f16))) (case (get self18 0) ('Parser.Reply.error (let ((f18 (get self18 1))(f19 (get self18 2))(f20 (get self18 3))) ($Parser.Reply.error f18 f19 f20))) ('Parser.Reply.value (let ((f18 (get self18 1))(f19 (get self18 2))(f20 (get self18 3))) (let ((self21 ($Kind.Parser.text "=" f18 f19))) (case (get self21 0) ('Parser.Reply.error (let ((f21 (get self21 1))(f22 (get self21 2))(f23 (get self21 3))) ($Parser.Reply.error f21 f22 f23))) ('Parser.Reply.value (let ((f21 (get self21 1))(f22 (get self21 2))(f23 (get self21 3))) (let ((self24 ($Kind.Parser.text "while " f21 f22))) (case (get self24 0) ('Parser.Reply.error (let ((f24 (get self24 1))(f25 (get self24 2))(f26 (get self24 3))) ($Parser.Reply.error f24 f25 f26))) ('Parser.Reply.value (let ((f24 (get self24 1))(f25 (get self24 2))(f26 (get self24 3))) (let ((self27 ($Kind.Parser.term f24 f25))) (case (get self27 0) ('Parser.Reply.error (let ((f27 (get self27 1))(f28 (get self27 2))(f29 (get self27 3))) ($Parser.Reply.error f27 f28 f29))) ('Parser.Reply.value (let ((f27 (get self27 1))(f28 (get self27 2))(f29 (get self27 3))) (let ((self30 ($Kind.Parser.text ":" f27 f28))) (case (get self30 0) ('Parser.Reply.error (let ((f30 (get self30 1))(f31 (get self30 2))(f32 (get self30 3))) ($Parser.Reply.error f30 f31 f32))) ('Parser.Reply.value (let ((f30 (get self30 1))(f31 (get self30 2))(f32 (get self30 3))) (let ((self33 ($Kind.Parser.term f30 f31))) (case (get self33 0) ('Parser.Reply.error (let ((f33 (get self33 1))(f34 (get self33 2))(f35 (get self33 3))) ($Parser.Reply.error f33 f34 f35))) ('Parser.Reply.value (let ((f33 (get self33 1))(f34 (get self33 2))(f35 (get self33 3))) (let ((self36 ($Parser.maybe (Kind.Parser.text ";") f33 f34))) (case (get self36 0) ('Parser.Reply.error (let ((f36 (get self36 1))(f37 (get self36 2))(f38 (get self36 3))) ($Parser.Reply.error f36 f37 f38))) ('Parser.Reply.value (let ((f36 (get self36 1))(f37 (get self36 2))(f38 (get self36 3))) (let ((self39 ($Kind.Parser.term f36 f37))) (case (get self39 0) ('Parser.Reply.error (let ((f39 (get self39 1))(f40 (get self39 2))(f41 (get self39 3))) ($Parser.Reply.error f39 f40 f41))) ('Parser.Reply.value (let ((f39 (get self39 1))(f40 (get self39 2))(f41 (get self39 3))) (let ((self42 ($Kind.Parser.stop f2 f39 f40))) (case (get self42 0) ('Parser.Reply.error (let ((f42 (get self42 1))(f43 (get self42 2))(f44 (get self42 3))) ($Parser.Reply.error f42 f43 f44))) ('Parser.Reply.value (let ((f42 (get self42 1))(f43 (get self42 2))(f44 (get self42 3))) (let ((moti$47 ($Kind.Term.lam "" (lambda (x$47) ($Kind.Term.hol Bits.e))))) (let ((term$48 ($Kind.Term.ref "Function.while"))) (let ((term$49 ($Kind.Term.app term$48 ($Kind.Term.hol Bits.e)))) (let ((init$50 ($Kind.Term.ref "Pair.new"))) (let ((init$51 ($Kind.Term.app init$50 ($Kind.Term.hol Bits.e)))) (let ((init$52 ($Kind.Term.app init$51 ($Kind.Term.hol Bits.e)))) (let ((init$53 ($Kind.Term.app init$52 ($Kind.Term.ref f11)))) (let ((init$54 ($Kind.Term.app init$53 ($Kind.Term.ref f17)))) (let ((term$55 ($Kind.Term.app term$49 init$54))) (let ((term$56 ($Kind.Term.app term$55 ($Kind.Term.lam "s" (lambda (s$56) ($Kind.Term.app ($Kind.Term.app s$56 moti$47) ($Kind.Term.lam f11 (lambda (x$57) ($Kind.Term.lam f17 (lambda (y$58) f29)))))))))) (let ((term$57 ($Kind.Term.app term$56 ($Kind.Term.lam "s" (lambda (s$57) ($Kind.Term.app ($Kind.Term.app s$57 moti$47) ($Kind.Term.lam f11 (lambda (x$58) ($Kind.Term.lam f17 (lambda (y$59) f35)))))))))) (let ((term$58 ($Kind.Term.app ($Kind.Term.app term$57 moti$47) ($Kind.Term.lam f11 (lambda (x$58) ($Kind.Term.lam f17 (lambda (y$59) f41))))))) ($Parser.Reply.value f42 f43 ($Kind.Term.ori f44 term$58)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.getwhile (lambda (idx$0) (lambda (code$1) ($Kind.Parser.getwhile idx$0 code$1))))
(define ($Kind.Parser.getwhile.with idx$0 code$1) (let ((self0 ($Kind.Parser.init idx$0 code$1))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ($Kind.Parser.text "while " f0 f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (let ((self6 ($Kind.Parser.term f3 f4))) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Parser.Reply.error f6 f7 f8))) ('Parser.Reply.value (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) (let ((self9 ($Kind.Parser.text "with " f6 f7))) (case (get self9 0) ('Parser.Reply.error (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) ($Parser.Reply.error f9 f10 f11))) ('Parser.Reply.value (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) (let ((self12 ($Kind.Parser.text "{" f9 f10))) (case (get self12 0) ('Parser.Reply.error (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) ($Parser.Reply.error f12 f13 f14))) ('Parser.Reply.value (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) (let ((self15 ($Kind.Parser.name f12 f13))) (case (get self15 0) ('Parser.Reply.error (let ((f15 (get self15 1))(f16 (get self15 2))(f17 (get self15 3))) ($Parser.Reply.error f15 f16 f17))) ('Parser.Reply.value (let ((f15 (get self15 1))(f16 (get self15 2))(f17 (get self15 3))) (let ((self18 ($Kind.Parser.text "," f15 f16))) (case (get self18 0) ('Parser.Reply.error (let ((f18 (get self18 1))(f19 (get self18 2))(f20 (get self18 3))) ($Parser.Reply.error f18 f19 f20))) ('Parser.Reply.value (let ((f18 (get self18 1))(f19 (get self18 2))(f20 (get self18 3))) (let ((self21 ($Kind.Parser.name f18 f19))) (case (get self21 0) ('Parser.Reply.error (let ((f21 (get self21 1))(f22 (get self21 2))(f23 (get self21 3))) ($Parser.Reply.error f21 f22 f23))) ('Parser.Reply.value (let ((f21 (get self21 1))(f22 (get self21 2))(f23 (get self21 3))) (let ((self24 ($Kind.Parser.text "}" f21 f22))) (case (get self24 0) ('Parser.Reply.error (let ((f24 (get self24 1))(f25 (get self24 2))(f26 (get self24 3))) ($Parser.Reply.error f24 f25 f26))) ('Parser.Reply.value (let ((f24 (get self24 1))(f25 (get self24 2))(f26 (get self24 3))) (let ((self27 ($Kind.Parser.text ":" f24 f25))) (case (get self27 0) ('Parser.Reply.error (let ((f27 (get self27 1))(f28 (get self27 2))(f29 (get self27 3))) ($Parser.Reply.error f27 f28 f29))) ('Parser.Reply.value (let ((f27 (get self27 1))(f28 (get self27 2))(f29 (get self27 3))) (let ((self30 ($Kind.Parser.term f27 f28))) (case (get self30 0) ('Parser.Reply.error (let ((f30 (get self30 1))(f31 (get self30 2))(f32 (get self30 3))) ($Parser.Reply.error f30 f31 f32))) ('Parser.Reply.value (let ((f30 (get self30 1))(f31 (get self30 2))(f32 (get self30 3))) (let ((self33 ($Parser.maybe (Kind.Parser.text ";") f30 f31))) (case (get self33 0) ('Parser.Reply.error (let ((f33 (get self33 1))(f34 (get self33 2))(f35 (get self33 3))) ($Parser.Reply.error f33 f34 f35))) ('Parser.Reply.value (let ((f33 (get self33 1))(f34 (get self33 2))(f35 (get self33 3))) (let ((self36 ($Kind.Parser.term f33 f34))) (case (get self36 0) ('Parser.Reply.error (let ((f36 (get self36 1))(f37 (get self36 2))(f38 (get self36 3))) ($Parser.Reply.error f36 f37 f38))) ('Parser.Reply.value (let ((f36 (get self36 1))(f37 (get self36 2))(f38 (get self36 3))) (let ((self39 ($Kind.Parser.stop f2 f36 f37))) (case (get self39 0) ('Parser.Reply.error (let ((f39 (get self39 1))(f40 (get self39 2))(f41 (get self39 3))) ($Parser.Reply.error f39 f40 f41))) ('Parser.Reply.value (let ((f39 (get self39 1))(f40 (get self39 2))(f41 (get self39 3))) (let ((moti$44 ($Kind.Term.lam "" (lambda (x$44) ($Kind.Term.hol Bits.e))))) (let ((term$45 ($Kind.Term.ref "Function.while"))) (let ((term$46 ($Kind.Term.app term$45 ($Kind.Term.hol Bits.e)))) (let ((init$47 ($Kind.Term.ref "Pair.new"))) (let ((init$48 ($Kind.Term.app init$47 ($Kind.Term.hol Bits.e)))) (let ((init$49 ($Kind.Term.app init$48 ($Kind.Term.hol Bits.e)))) (let ((init$50 ($Kind.Term.app init$49 ($Kind.Term.ref f17)))) (let ((init$51 ($Kind.Term.app init$50 ($Kind.Term.ref f23)))) (let ((term$52 ($Kind.Term.app term$46 init$51))) (let ((term$53 ($Kind.Term.app term$52 ($Kind.Term.lam "s" (lambda (s$53) ($Kind.Term.app ($Kind.Term.app s$53 moti$44) ($Kind.Term.lam f17 (lambda (x$54) ($Kind.Term.lam f23 (lambda (y$55) f8)))))))))) (let ((term$54 ($Kind.Term.app term$53 ($Kind.Term.lam "s" (lambda (s$54) ($Kind.Term.app ($Kind.Term.app s$54 moti$44) ($Kind.Term.lam f17 (lambda (x$55) ($Kind.Term.lam f23 (lambda (y$56) f32)))))))))) (let ((term$55 ($Kind.Term.app ($Kind.Term.app term$54 moti$44) ($Kind.Term.lam f17 (lambda (x$55) ($Kind.Term.lam f23 (lambda (y$56) f38))))))) ($Parser.Reply.value f39 f40 ($Kind.Term.ori f41 term$55)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.getwhile.with (lambda (idx$0) (lambda (code$1) ($Kind.Parser.getwhile.with idx$0 code$1))))
(define ($Kind.Parser.get idx$0 code$1) (let ((self0 ($Kind.Parser.init idx$0 code$1))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ($Kind.Parser.text "let " f0 f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (let ((self6 ($Kind.Parser.text "{" f3 f4))) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Parser.Reply.error f6 f7 f8))) ('Parser.Reply.value (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) (let ((self9 ($Kind.Parser.name f6 f7))) (case (get self9 0) ('Parser.Reply.error (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) ($Parser.Reply.error f9 f10 f11))) ('Parser.Reply.value (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) (let ((self12 ($Kind.Parser.text "," f9 f10))) (case (get self12 0) ('Parser.Reply.error (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) ($Parser.Reply.error f12 f13 f14))) ('Parser.Reply.value (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) (let ((self15 ($Kind.Parser.name f12 f13))) (case (get self15 0) ('Parser.Reply.error (let ((f15 (get self15 1))(f16 (get self15 2))(f17 (get self15 3))) ($Parser.Reply.error f15 f16 f17))) ('Parser.Reply.value (let ((f15 (get self15 1))(f16 (get self15 2))(f17 (get self15 3))) (let ((self18 ($Kind.Parser.text "}" f15 f16))) (case (get self18 0) ('Parser.Reply.error (let ((f18 (get self18 1))(f19 (get self18 2))(f20 (get self18 3))) ($Parser.Reply.error f18 f19 f20))) ('Parser.Reply.value (let ((f18 (get self18 1))(f19 (get self18 2))(f20 (get self18 3))) (let ((self21 ($Kind.Parser.text "=" f18 f19))) (case (get self21 0) ('Parser.Reply.error (let ((f21 (get self21 1))(f22 (get self21 2))(f23 (get self21 3))) ($Parser.Reply.error f21 f22 f23))) ('Parser.Reply.value (let ((f21 (get self21 1))(f22 (get self21 2))(f23 (get self21 3))) (let ((self24 ($Kind.Parser.term f21 f22))) (case (get self24 0) ('Parser.Reply.error (let ((f24 (get self24 1))(f25 (get self24 2))(f26 (get self24 3))) ($Parser.Reply.error f24 f25 f26))) ('Parser.Reply.value (let ((f24 (get self24 1))(f25 (get self24 2))(f26 (get self24 3))) (let ((self27 ($Parser.maybe (Kind.Parser.text ";") f24 f25))) (case (get self27 0) ('Parser.Reply.error (let ((f27 (get self27 1))(f28 (get self27 2))(f29 (get self27 3))) ($Parser.Reply.error f27 f28 f29))) ('Parser.Reply.value (let ((f27 (get self27 1))(f28 (get self27 2))(f29 (get self27 3))) (let ((self30 ($Kind.Parser.term f27 f28))) (case (get self30 0) ('Parser.Reply.error (let ((f30 (get self30 1))(f31 (get self30 2))(f32 (get self30 3))) ($Parser.Reply.error f30 f31 f32))) ('Parser.Reply.value (let ((f30 (get self30 1))(f31 (get self30 2))(f32 (get self30 3))) (let ((self33 ($Kind.Parser.stop f2 f30 f31))) (case (get self33 0) ('Parser.Reply.error (let ((f33 (get self33 1))(f34 (get self33 2))(f35 (get self33 3))) ($Parser.Reply.error f33 f34 f35))) ('Parser.Reply.value (let ((f33 (get self33 1))(f34 (get self33 2))(f35 (get self33 3))) (let ((term$38 f26)) (let ((term$39 ($Kind.Term.app term$38 ($Kind.Term.lam "" (lambda (x$39) ($Kind.Term.hol Bits.e)))))) (let ((term$40 ($Kind.Term.app term$39 ($Kind.Term.lam f11 (lambda (x$40) ($Kind.Term.lam f17 (lambda (y$41) f32))))))) ($Parser.Reply.value f33 f34 ($Kind.Term.ori f35 term$40))))))))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.get (lambda (idx$0) (lambda (code$1) ($Kind.Parser.get idx$0 code$1))))
(define ($Kind.Parser.get.omit idx$0 code$1) (let ((self0 ($Kind.Parser.init idx$0 code$1))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ($Kind.Parser.text "{" f0 f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (let ((self6 ($Kind.Parser.name f3 f4))) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Parser.Reply.error f6 f7 f8))) ('Parser.Reply.value (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) (let ((self9 ($Kind.Parser.text "," f6 f7))) (case (get self9 0) ('Parser.Reply.error (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) ($Parser.Reply.error f9 f10 f11))) ('Parser.Reply.value (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) (let ((self12 ($Kind.Parser.name f9 f10))) (case (get self12 0) ('Parser.Reply.error (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) ($Parser.Reply.error f12 f13 f14))) ('Parser.Reply.value (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) (let ((self15 ($Kind.Parser.text "}" f12 f13))) (case (get self15 0) ('Parser.Reply.error (let ((f15 (get self15 1))(f16 (get self15 2))(f17 (get self15 3))) ($Parser.Reply.error f15 f16 f17))) ('Parser.Reply.value (let ((f15 (get self15 1))(f16 (get self15 2))(f17 (get self15 3))) (let ((self18 ($Kind.Parser.text "= " f15 f16))) (case (get self18 0) ('Parser.Reply.error (let ((f18 (get self18 1))(f19 (get self18 2))(f20 (get self18 3))) ($Parser.Reply.error f18 f19 f20))) ('Parser.Reply.value (let ((f18 (get self18 1))(f19 (get self18 2))(f20 (get self18 3))) (let ((self21 ($Kind.Parser.term f18 f19))) (case (get self21 0) ('Parser.Reply.error (let ((f21 (get self21 1))(f22 (get self21 2))(f23 (get self21 3))) ($Parser.Reply.error f21 f22 f23))) ('Parser.Reply.value (let ((f21 (get self21 1))(f22 (get self21 2))(f23 (get self21 3))) (let ((self24 ($Parser.maybe (Kind.Parser.text ";") f21 f22))) (case (get self24 0) ('Parser.Reply.error (let ((f24 (get self24 1))(f25 (get self24 2))(f26 (get self24 3))) ($Parser.Reply.error f24 f25 f26))) ('Parser.Reply.value (let ((f24 (get self24 1))(f25 (get self24 2))(f26 (get self24 3))) (let ((self27 ($Kind.Parser.term f24 f25))) (case (get self27 0) ('Parser.Reply.error (let ((f27 (get self27 1))(f28 (get self27 2))(f29 (get self27 3))) ($Parser.Reply.error f27 f28 f29))) ('Parser.Reply.value (let ((f27 (get self27 1))(f28 (get self27 2))(f29 (get self27 3))) (let ((self30 ($Kind.Parser.stop f2 f27 f28))) (case (get self30 0) ('Parser.Reply.error (let ((f30 (get self30 1))(f31 (get self30 2))(f32 (get self30 3))) ($Parser.Reply.error f30 f31 f32))) ('Parser.Reply.value (let ((f30 (get self30 1))(f31 (get self30 2))(f32 (get self30 3))) (let ((term$35 f23)) (let ((term$36 ($Kind.Term.app term$35 ($Kind.Term.lam "" (lambda (x$36) ($Kind.Term.hol Bits.e)))))) (let ((term$37 ($Kind.Term.app term$36 ($Kind.Term.lam f8 (lambda (x$37) ($Kind.Term.lam f14 (lambda (y$38) f29))))))) ($Parser.Reply.value f30 f31 ($Kind.Term.ori f32 term$37))))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.get.omit (lambda (idx$0) (lambda (code$1) ($Kind.Parser.get.omit idx$0 code$1))))
(define ($Kind.Term.def name$0 expr$1 body$2) (vector 'Kind.Term.def name$0 expr$1 body$2))
(define Kind.Term.def (lambda (name$0) (lambda (expr$1) (lambda (body$2) ($Kind.Term.def name$0 expr$1 body$2)))))
(define ($Kind.Parser.def idx$0 code$1) (let ((self0 ($Kind.Parser.init idx$0 code$1))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ($Kind.Parser.text "def " f0 f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (let ((self6 ($Kind.Parser.name f3 f4))) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Parser.Reply.error f6 f7 f8))) ('Parser.Reply.value (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) (let ((self9 ($Kind.Parser.text "=" f6 f7))) (case (get self9 0) ('Parser.Reply.error (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) ($Parser.Reply.error f9 f10 f11))) ('Parser.Reply.value (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) (let ((self12 ($Kind.Parser.term f9 f10))) (case (get self12 0) ('Parser.Reply.error (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) ($Parser.Reply.error f12 f13 f14))) ('Parser.Reply.value (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) (let ((self15 ($Parser.maybe (Kind.Parser.text ";") f12 f13))) (case (get self15 0) ('Parser.Reply.error (let ((f15 (get self15 1))(f16 (get self15 2))(f17 (get self15 3))) ($Parser.Reply.error f15 f16 f17))) ('Parser.Reply.value (let ((f15 (get self15 1))(f16 (get self15 2))(f17 (get self15 3))) (let ((self18 ($Kind.Parser.term f15 f16))) (case (get self18 0) ('Parser.Reply.error (let ((f18 (get self18 1))(f19 (get self18 2))(f20 (get self18 3))) ($Parser.Reply.error f18 f19 f20))) ('Parser.Reply.value (let ((f18 (get self18 1))(f19 (get self18 2))(f20 (get self18 3))) (let ((self21 ($Kind.Parser.stop f2 f18 f19))) (case (get self21 0) ('Parser.Reply.error (let ((f21 (get self21 1))(f22 (get self21 2))(f23 (get self21 3))) ($Parser.Reply.error f21 f22 f23))) ('Parser.Reply.value (let ((f21 (get self21 1))(f22 (get self21 2))(f23 (get self21 3))) ($Parser.Reply.value f21 f22 ($Kind.Term.ori f23 ($Kind.Term.def f8 f14 (lambda (x$26) f20)))))))))))))))))))))))))))))))))))))
(define Kind.Parser.def (lambda (idx$0) (lambda (code$1) ($Kind.Parser.def idx$0 code$1))))
(define ($Kind.Parser.goal_rewrite idx$0 code$1) (let ((self0 ($Kind.Parser.init idx$0 code$1))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ($Kind.Parser.text "rewrite " f0 f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (let ((self6 ($Kind.Parser.name1 f3 f4))) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Parser.Reply.error f6 f7 f8))) ('Parser.Reply.value (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) (let ((self9 ($Kind.Parser.text "in" f6 f7))) (case (get self9 0) ('Parser.Reply.error (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) ($Parser.Reply.error f9 f10 f11))) ('Parser.Reply.value (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) (let ((self12 ($Kind.Parser.term f9 f10))) (case (get self12 0) ('Parser.Reply.error (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) ($Parser.Reply.error f12 f13 f14))) ('Parser.Reply.value (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) (let ((self15 ($Kind.Parser.text "with" f12 f13))) (case (get self15 0) ('Parser.Reply.error (let ((f15 (get self15 1))(f16 (get self15 2))(f17 (get self15 3))) ($Parser.Reply.error f15 f16 f17))) ('Parser.Reply.value (let ((f15 (get self15 1))(f16 (get self15 2))(f17 (get self15 3))) (let ((self18 ($Kind.Parser.term f15 f16))) (case (get self18 0) ('Parser.Reply.error (let ((f18 (get self18 1))(f19 (get self18 2))(f20 (get self18 3))) ($Parser.Reply.error f18 f19 f20))) ('Parser.Reply.value (let ((f18 (get self18 1))(f19 (get self18 2))(f20 (get self18 3))) (let ((self21 ($Kind.Parser.term f18 f19))) (case (get self21 0) ('Parser.Reply.error (let ((f21 (get self21 1))(f22 (get self21 2))(f23 (get self21 3))) ($Parser.Reply.error f21 f22 f23))) ('Parser.Reply.value (let ((f21 (get self21 1))(f22 (get self21 2))(f23 (get self21 3))) (let ((self24 ($Kind.Parser.stop f2 f21 f22))) (case (get self24 0) ('Parser.Reply.error (let ((f24 (get self24 1))(f25 (get self24 2))(f26 (get self24 3))) ($Parser.Reply.error f24 f25 f26))) ('Parser.Reply.value (let ((f24 (get self24 1))(f25 (get self24 2))(f26 (get self24 3))) (let ((moti$29 ($Kind.Term.lam f8 (lambda (s$29) ($Kind.Term.lam "" (lambda (x$30) f14)))))) (let ((term$30 ($Kind.Term.ref "Equal.mirror"))) (let ((term$31 ($Kind.Term.app term$30 ($Kind.Term.hol Bits.e)))) (let ((term$32 ($Kind.Term.app term$31 ($Kind.Term.hol Bits.e)))) (let ((term$33 ($Kind.Term.app term$32 ($Kind.Term.hol Bits.e)))) (let ((term$34 ($Kind.Term.app term$33 f20))) (let ((term$35 ($Kind.Term.app term$34 moti$29))) (let ((term$36 ($Kind.Term.app term$35 f23))) ($Parser.Reply.value f24 f25 ($Kind.Term.ori f26 term$36)))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.goal_rewrite (lambda (idx$0) (lambda (code$1) ($Kind.Parser.goal_rewrite idx$0 code$1))))
(define ($Kind.Parser.if idx$0 code$1) (let ((self0 ($Kind.Parser.init idx$0 code$1))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ($Kind.Parser.text "if " f0 f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (let ((self6 ($Kind.Parser.term f3 f4))) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Parser.Reply.error f6 f7 f8))) ('Parser.Reply.value (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) (let ((self9 ($Kind.Parser.text "then" f6 f7))) (case (get self9 0) ('Parser.Reply.error (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) ($Parser.Reply.error f9 f10 f11))) ('Parser.Reply.value (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) (let ((self12 ($Kind.Parser.term f9 f10))) (case (get self12 0) ('Parser.Reply.error (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) ($Parser.Reply.error f12 f13 f14))) ('Parser.Reply.value (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) (let ((self15 ($Kind.Parser.text "else" f12 f13))) (case (get self15 0) ('Parser.Reply.error (let ((f15 (get self15 1))(f16 (get self15 2))(f17 (get self15 3))) ($Parser.Reply.error f15 f16 f17))) ('Parser.Reply.value (let ((f15 (get self15 1))(f16 (get self15 2))(f17 (get self15 3))) (let ((self18 ($Kind.Parser.term f15 f16))) (case (get self18 0) ('Parser.Reply.error (let ((f18 (get self18 1))(f19 (get self18 2))(f20 (get self18 3))) ($Parser.Reply.error f18 f19 f20))) ('Parser.Reply.value (let ((f18 (get self18 1))(f19 (get self18 2))(f20 (get self18 3))) (let ((self21 ($Kind.Parser.stop f2 f18 f19))) (case (get self21 0) ('Parser.Reply.error (let ((f21 (get self21 1))(f22 (get self21 2))(f23 (get self21 3))) ($Parser.Reply.error f21 f22 f23))) ('Parser.Reply.value (let ((f21 (get self21 1))(f22 (get self21 2))(f23 (get self21 3))) (let ((term$26 f8)) (let ((term$27 ($Kind.Term.app term$26 ($Kind.Term.lam "" (lambda (x$27) ($Kind.Term.hol Bits.e)))))) (let ((term$28 ($Kind.Term.app term$27 f14))) (let ((term$29 ($Kind.Term.app term$28 f20))) ($Parser.Reply.value f21 f22 ($Kind.Term.ori f23 term$29)))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.if (lambda (idx$0) (lambda (code$1) ($Kind.Parser.if idx$0 code$1))))
(define ($List.mapped as$1 f$3) (let ((self0 as$1)) (case (get self0 0) ('List.nil (let () List.nil)) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) ($List.cons (f$3 f0) ($List.mapped f1 f$3)))))))
(define List.mapped (lambda (as$1) (lambda (f$3) ($List.mapped as$1 f$3))))
(define ($U16.new value$0) (word-to-u16 value$0))
(define U16.new (lambda (value$0) ($U16.new value$0)))
(define ($Nat.apply n$1 f$2 x$3) (let ((self0 n$1)) (case (= self0 0) (#t (let () x$3)) (#f (let ((f0 (- self0 1))) ($Nat.apply f0 f$2 (f$2 x$3)))))))
(define Nat.apply (lambda (n$1) (lambda (f$2) (lambda (x$3) ($Nat.apply n$1 f$2 x$3)))))
(define ($Word.e) (vector 'Word.e))
(define Word.e ($Word.e))
(define ($Word.i pred$1) (vector 'Word.i pred$1))
(define Word.i (lambda (pred$1) ($Word.i pred$1)))
(define ($Word.o pred$1) (vector 'Word.o pred$1))
(define Word.o (lambda (pred$1) ($Word.o pred$1)))
(define ($Word.inc word$1) (let ((self0 word$1)) (case (get self0 0) ('Word.e (let () Word.e)) ('Word.o (let ((f0 (get self0 1))) ($Word.i f0))) ('Word.i (let ((f0 (get self0 1))) ($Word.o ($Word.inc f0)))))))
(define Word.inc (lambda (word$1) ($Word.inc word$1)))
(define ($Word.zero size$0) (let ((self0 size$0)) (case (= self0 0) (#t (let () Word.e)) (#f (let ((f0 (- self0 1))) ($Word.o ($Word.zero f0)))))))
(define Word.zero (lambda (size$0) ($Word.zero size$0)))
(define ($Nat.to_word size$0 n$1) ($Nat.apply n$1 Word.inc ($Word.zero size$0)))
(define Nat.to_word (lambda (size$0) (lambda (n$1) ($Nat.to_word size$0 n$1))))
(define ($Nat.zero) 0)
(define Nat.zero ($Nat.zero))
(define ($Nat.to_u16 n$0) n$0)
(define Nat.to_u16 (lambda (n$0) ($Nat.to_u16 n$0)))
(define ($Kind.Code.backslash) ($Nat.to_u16 92))
(define Kind.Code.backslash ($Kind.Code.backslash))
(define ($Kind.Code.escapes) ($List.cons ($Pair.new "\\b" 8) ($List.cons ($Pair.new "\\f" 12) ($List.cons ($Pair.new "\\n" 10) ($List.cons ($Pair.new "\\r" 13) ($List.cons ($Pair.new "\\t" 9) ($List.cons ($Pair.new "\\v" 11) ($List.cons ($Pair.new ($String.cons Kind.Code.backslash ($String.cons Kind.Code.backslash String.nil)) Kind.Code.backslash) ($List.cons ($Pair.new "\\\"" 34) ($List.cons ($Pair.new "\\0" 0) ($List.cons ($Pair.new "\\'" 39) List.nil)))))))))))
(define Kind.Code.escapes ($Kind.Code.escapes))
(define ($Kind.Parser.char.single) ($Parser.first_of ($List.cons ($Parser.first_of ($List.mapped Kind.Code.escapes (lambda (esc$0) (let ((self1 esc$0)) (case (get self1 0) ('Pair.new (let ((f1 (get self1 1))(f2 (get self1 2))) (lambda (idx$3) (lambda (code$4) (let ((self5 ($Parser.text f1 idx$3 code$4))) (case (get self5 0) ('Parser.Reply.error (let ((f5 (get self5 1))(f6 (get self5 2))(f7 (get self5 3))) ($Parser.Reply.error f5 f6 f7))) ('Parser.Reply.value (let ((f5 (get self5 1))(f6 (get self5 2))(f7 (get self5 3))) ($Parser.Reply.value f5 f6 f2)))))))))))))) ($List.cons Parser.one List.nil))))
(define Kind.Parser.char.single ($Kind.Parser.char.single))
(define ($Kind.Term.chr chrx$0) (vector 'Kind.Term.chr chrx$0))
(define Kind.Term.chr (lambda (chrx$0) ($Kind.Term.chr chrx$0)))
(define ($Kind.Parser.char idx$0 code$1) (let ((self0 ($Kind.Parser.init idx$0 code$1))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ($Kind.Parser.text "'" f0 f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (let ((self6 ((Kind.Parser.char.single f3) f4))) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Parser.Reply.error f6 f7 f8))) ('Parser.Reply.value (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) (let ((self9 ($Parser.text "'" f6 f7))) (case (get self9 0) ('Parser.Reply.error (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) ($Parser.Reply.error f9 f10 f11))) ('Parser.Reply.value (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) (let ((self12 ($Kind.Parser.stop f2 f9 f10))) (case (get self12 0) ('Parser.Reply.error (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) ($Parser.Reply.error f12 f13 f14))) ('Parser.Reply.value (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) ($Parser.Reply.value f12 f13 ($Kind.Term.ori f14 ($Kind.Term.chr f8))))))))))))))))))))))))
(define Kind.Parser.char (lambda (idx$0) (lambda (code$1) ($Kind.Parser.char idx$0 code$1))))
(define ($String.reverse.go xs$0 res$1) (let ((self0 xs$0)) (case (= (string-length self0) 0) (#t (let () res$1)) (#f (let ((f0 (char->integer (string-ref self0 0)))(f1 (let ((_str_ self0)) (substring _str_ 1 (string-length _str_))))) ($String.reverse.go f1 ($String.cons f0 res$1)))))))
(define String.reverse.go (lambda (xs$0) (lambda (res$1) ($String.reverse.go xs$0 res$1))))
(define ($String.reverse xs$0) ($String.reverse.go xs$0 String.nil))
(define String.reverse (lambda (xs$0) ($String.reverse xs$0)))
(define ($Kind.Parser.string.go delim$0 str$1 idx$2 code$3) (let ((self0 code$3)) (case (= (string-length self0) 0) (#t (let () ($Parser.Reply.error idx$2 code$3 "Non-terminating string."))) (#f (let ((f0 (char->integer (string-ref self0 0)))(f1 (let ((_str_ self0)) (substring _str_ 1 (string-length _str_))))) (let ((self2 ($U16.eql f0 delim$0))) (case self2 (#t (let () ($Parser.Reply.value ($Nat.succ idx$2) f1 ($String.reverse str$1)))) (#f (let () (let ((self2 ((Kind.Parser.char.single idx$2) code$3))) (case (get self2 0) ('Parser.Reply.error (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))) ($Parser.Reply.error f2 f3 f4))) ('Parser.Reply.value (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))) ($Kind.Parser.string.go delim$0 ($String.cons f4 str$1) f2 f3))))))))))))))
(define Kind.Parser.string.go (lambda (delim$0) (lambda (str$1) (lambda (idx$2) (lambda (code$3) ($Kind.Parser.string.go delim$0 str$1 idx$2 code$3))))))
(define ($Kind.Term.str strx$0) (vector 'Kind.Term.str strx$0))
(define Kind.Term.str (lambda (strx$0) ($Kind.Term.str strx$0)))
(define ($Kind.Parser.string delim$0 idx$1 code$2) (let ((self0 ($Kind.Parser.init idx$1 code$2))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ($Kind.Parser.text ($String.cons delim$0 String.nil) f0 f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (let ((self6 ($Kind.Parser.string.go delim$0 "" f3 f4))) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Parser.Reply.error f6 f7 f8))) ('Parser.Reply.value (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) (let ((self9 ($Kind.Parser.stop f2 f6 f7))) (case (get self9 0) ('Parser.Reply.error (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) ($Parser.Reply.error f9 f10 f11))) ('Parser.Reply.value (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) ($Parser.Reply.value f9 f10 ($Kind.Term.ori f11 ($Kind.Term.str f8))))))))))))))))))))
(define Kind.Parser.string (lambda (delim$0) (lambda (idx$1) (lambda (code$2) ($Kind.Parser.string delim$0 idx$1 code$2)))))
(define ($Kind.Parser.pair idx$0 code$1) (let ((self0 ($Kind.Parser.init idx$0 code$1))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ($Kind.Parser.text "{" f0 f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (let ((self6 ($Kind.Parser.term f3 f4))) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Parser.Reply.error f6 f7 f8))) ('Parser.Reply.value (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) (let ((self9 ($Parser.maybe (Kind.Parser.text ",") f6 f7))) (case (get self9 0) ('Parser.Reply.error (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) ($Parser.Reply.error f9 f10 f11))) ('Parser.Reply.value (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) (let ((self12 ($Kind.Parser.term f9 f10))) (case (get self12 0) ('Parser.Reply.error (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) ($Parser.Reply.error f12 f13 f14))) ('Parser.Reply.value (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) (let ((self15 ($Parser.maybe (Kind.Parser.text ",") f12 f13))) (case (get self15 0) ('Parser.Reply.error (let ((f15 (get self15 1))(f16 (get self15 2))(f17 (get self15 3))) ($Parser.Reply.error f15 f16 f17))) ('Parser.Reply.value (let ((f15 (get self15 1))(f16 (get self15 2))(f17 (get self15 3))) (let ((self18 ($Kind.Parser.text "}" f15 f16))) (case (get self18 0) ('Parser.Reply.error (let ((f18 (get self18 1))(f19 (get self18 2))(f20 (get self18 3))) ($Parser.Reply.error f18 f19 f20))) ('Parser.Reply.value (let ((f18 (get self18 1))(f19 (get self18 2))(f20 (get self18 3))) (let ((self21 ($Kind.Parser.stop f2 f18 f19))) (case (get self21 0) ('Parser.Reply.error (let ((f21 (get self21 1))(f22 (get self21 2))(f23 (get self21 3))) ($Parser.Reply.error f21 f22 f23))) ('Parser.Reply.value (let ((f21 (get self21 1))(f22 (get self21 2))(f23 (get self21 3))) (let ((term$26 ($Kind.Term.ref "Pair.new"))) (let ((term$27 ($Kind.Term.app term$26 ($Kind.Term.hol Bits.e)))) (let ((term$28 ($Kind.Term.app term$27 ($Kind.Term.hol Bits.e)))) (let ((term$29 ($Kind.Term.app term$28 f8))) (let ((term$30 ($Kind.Term.app term$29 f14))) ($Parser.Reply.value f21 f22 ($Kind.Term.ori f23 term$30))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.pair (lambda (idx$0) (lambda (code$1) ($Kind.Parser.pair idx$0 code$1))))
(define ($Kind.Parser.sigma.type idx$0 code$1) (let ((self0 ($Kind.Parser.init idx$0 code$1))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ($Kind.Parser.text "[" f0 f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (let ((self6 ($Kind.Parser.name1 f3 f4))) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Parser.Reply.error f6 f7 f8))) ('Parser.Reply.value (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) (let ((self9 ($Kind.Parser.text ":" f6 f7))) (case (get self9 0) ('Parser.Reply.error (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) ($Parser.Reply.error f9 f10 f11))) ('Parser.Reply.value (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) (let ((self12 ($Kind.Parser.term f9 f10))) (case (get self12 0) ('Parser.Reply.error (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) ($Parser.Reply.error f12 f13 f14))) ('Parser.Reply.value (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) (let ((self15 ($Kind.Parser.text "]" f12 f13))) (case (get self15 0) ('Parser.Reply.error (let ((f15 (get self15 1))(f16 (get self15 2))(f17 (get self15 3))) ($Parser.Reply.error f15 f16 f17))) ('Parser.Reply.value (let ((f15 (get self15 1))(f16 (get self15 2))(f17 (get self15 3))) (let ((self18 ($Kind.Parser.term f15 f16))) (case (get self18 0) ('Parser.Reply.error (let ((f18 (get self18 1))(f19 (get self18 2))(f20 (get self18 3))) ($Parser.Reply.error f18 f19 f20))) ('Parser.Reply.value (let ((f18 (get self18 1))(f19 (get self18 2))(f20 (get self18 3))) (let ((self21 ($Kind.Parser.stop f2 f18 f19))) (case (get self21 0) ('Parser.Reply.error (let ((f21 (get self21 1))(f22 (get self21 2))(f23 (get self21 3))) ($Parser.Reply.error f21 f22 f23))) ('Parser.Reply.value (let ((f21 (get self21 1))(f22 (get self21 2))(f23 (get self21 3))) (let ((term$26 ($Kind.Term.ref "Sigma"))) (let ((term$27 ($Kind.Term.app term$26 f14))) (let ((term$28 ($Kind.Term.app term$27 ($Kind.Term.lam f8 (lambda (x$28) f20))))) ($Parser.Reply.value f21 f22 ($Kind.Term.ori f23 term$28))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.sigma.type (lambda (idx$0) (lambda (code$1) ($Kind.Parser.sigma.type idx$0 code$1))))
(define ($Kind.Parser.some idx$0 code$1) (let ((self0 ($Kind.Parser.init idx$0 code$1))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ($Kind.Parser.text "some(" f0 f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (let ((self6 ($Kind.Parser.term f3 f4))) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Parser.Reply.error f6 f7 f8))) ('Parser.Reply.value (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) (let ((self9 ($Kind.Parser.text ")" f6 f7))) (case (get self9 0) ('Parser.Reply.error (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) ($Parser.Reply.error f9 f10 f11))) ('Parser.Reply.value (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) (let ((self12 ($Kind.Parser.stop f2 f9 f10))) (case (get self12 0) ('Parser.Reply.error (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) ($Parser.Reply.error f12 f13 f14))) ('Parser.Reply.value (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) (let ((term$17 ($Kind.Term.ref "Maybe.some"))) (let ((term$18 ($Kind.Term.app term$17 ($Kind.Term.hol Bits.e)))) (let ((term$19 ($Kind.Term.app term$18 f8))) ($Parser.Reply.value f12 f13 ($Kind.Term.ori f14 term$19))))))))))))))))))))))))))
(define Kind.Parser.some (lambda (idx$0) (lambda (code$1) ($Kind.Parser.some idx$0 code$1))))
(define ($Kind.Parser.not idx$0 code$1) (let ((self0 ($Kind.Parser.init idx$0 code$1))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ($Kind.Parser.text "not(" f0 f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (let ((self6 ($Kind.Parser.term f3 f4))) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Parser.Reply.error f6 f7 f8))) ('Parser.Reply.value (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) (let ((self9 ($Kind.Parser.text ")" f6 f7))) (case (get self9 0) ('Parser.Reply.error (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) ($Parser.Reply.error f9 f10 f11))) ('Parser.Reply.value (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) (let ((self12 ($Kind.Parser.stop f2 f9 f10))) (case (get self12 0) ('Parser.Reply.error (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) ($Parser.Reply.error f12 f13 f14))) ('Parser.Reply.value (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) (let ((term$17 ($Kind.Term.ref "Bool.not"))) (let ((term$18 ($Kind.Term.app term$17 f8))) ($Parser.Reply.value f12 f13 ($Kind.Term.ori f14 term$18)))))))))))))))))))))))))
(define Kind.Parser.not (lambda (idx$0) (lambda (code$1) ($Kind.Parser.not idx$0 code$1))))
(define ($Kind.Parser.left idx$0 code$1) (let ((self0 ($Kind.Parser.init idx$0 code$1))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ($Kind.Parser.text "left(" f0 f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (let ((self6 ($Kind.Parser.term f3 f4))) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Parser.Reply.error f6 f7 f8))) ('Parser.Reply.value (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) (let ((self9 ($Kind.Parser.text ")" f6 f7))) (case (get self9 0) ('Parser.Reply.error (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) ($Parser.Reply.error f9 f10 f11))) ('Parser.Reply.value (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) (let ((self12 ($Kind.Parser.stop f2 f9 f10))) (case (get self12 0) ('Parser.Reply.error (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) ($Parser.Reply.error f12 f13 f14))) ('Parser.Reply.value (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) (let ((term$17 ($Kind.Term.ref "Either.left"))) (let ((term$18 ($Kind.Term.app term$17 ($Kind.Term.hol Bits.e)))) (let ((term$19 ($Kind.Term.app term$18 ($Kind.Term.hol Bits.e)))) (let ((term$20 ($Kind.Term.app term$19 f8))) ($Parser.Reply.value f12 f13 ($Kind.Term.ori f14 term$20)))))))))))))))))))))))))))
(define Kind.Parser.left (lambda (idx$0) (lambda (code$1) ($Kind.Parser.left idx$0 code$1))))
(define ($Kind.Parser.right idx$0 code$1) (let ((self0 ($Kind.Parser.init idx$0 code$1))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ($Kind.Parser.text "right(" f0 f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (let ((self6 ($Kind.Parser.term f3 f4))) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Parser.Reply.error f6 f7 f8))) ('Parser.Reply.value (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) (let ((self9 ($Kind.Parser.text ")" f6 f7))) (case (get self9 0) ('Parser.Reply.error (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) ($Parser.Reply.error f9 f10 f11))) ('Parser.Reply.value (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) (let ((self12 ($Kind.Parser.stop f2 f9 f10))) (case (get self12 0) ('Parser.Reply.error (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) ($Parser.Reply.error f12 f13 f14))) ('Parser.Reply.value (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) (let ((term$17 ($Kind.Term.ref "Either.right"))) (let ((term$18 ($Kind.Term.app term$17 ($Kind.Term.hol Bits.e)))) (let ((term$19 ($Kind.Term.app term$18 ($Kind.Term.hol Bits.e)))) (let ((term$20 ($Kind.Term.app term$19 f8))) ($Parser.Reply.value f12 f13 ($Kind.Term.ori f14 term$20)))))))))))))))))))))))))))
(define Kind.Parser.right (lambda (idx$0) (lambda (code$1) ($Kind.Parser.right idx$0 code$1))))
(define ($Kind.Parser.apply idx$0 code$1) (let ((self0 ($Kind.Parser.init idx$0 code$1))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ($Kind.Parser.text "apply(" f0 f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (let ((self6 ($Kind.Parser.term f3 f4))) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Parser.Reply.error f6 f7 f8))) ('Parser.Reply.value (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) (let ((self9 ($Kind.Parser.text "," f6 f7))) (case (get self9 0) ('Parser.Reply.error (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) ($Parser.Reply.error f9 f10 f11))) ('Parser.Reply.value (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) (let ((self12 ($Kind.Parser.term f9 f10))) (case (get self12 0) ('Parser.Reply.error (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) ($Parser.Reply.error f12 f13 f14))) ('Parser.Reply.value (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) (let ((self15 ($Kind.Parser.text ")" f12 f13))) (case (get self15 0) ('Parser.Reply.error (let ((f15 (get self15 1))(f16 (get self15 2))(f17 (get self15 3))) ($Parser.Reply.error f15 f16 f17))) ('Parser.Reply.value (let ((f15 (get self15 1))(f16 (get self15 2))(f17 (get self15 3))) (let ((self18 ($Kind.Parser.stop f2 f15 f16))) (case (get self18 0) ('Parser.Reply.error (let ((f18 (get self18 1))(f19 (get self18 2))(f20 (get self18 3))) ($Parser.Reply.error f18 f19 f20))) ('Parser.Reply.value (let ((f18 (get self18 1))(f19 (get self18 2))(f20 (get self18 3))) (let ((term$23 ($Kind.Term.ref "Equal.apply"))) (let ((term$24 ($Kind.Term.app term$23 ($Kind.Term.hol Bits.e)))) (let ((term$25 ($Kind.Term.app term$24 ($Kind.Term.hol Bits.e)))) (let ((term$26 ($Kind.Term.app term$25 ($Kind.Term.hol Bits.e)))) (let ((term$27 ($Kind.Term.app term$26 ($Kind.Term.hol Bits.e)))) (let ((term$28 ($Kind.Term.app term$27 f8))) (let ((term$29 ($Kind.Term.app term$28 f14))) ($Parser.Reply.value f18 f19 ($Kind.Term.ori f20 term$29))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.apply (lambda (idx$0) (lambda (code$1) ($Kind.Parser.apply idx$0 code$1))))
(define ($Kind.Parser.chain idx$0 code$1) (let ((self0 ($Kind.Parser.init idx$0 code$1))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ($Kind.Parser.text "chain(" f0 f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (let ((self6 ($Kind.Parser.term f3 f4))) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Parser.Reply.error f6 f7 f8))) ('Parser.Reply.value (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) (let ((self9 ($Kind.Parser.text "," f6 f7))) (case (get self9 0) ('Parser.Reply.error (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) ($Parser.Reply.error f9 f10 f11))) ('Parser.Reply.value (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) (let ((self12 ($Kind.Parser.term f9 f10))) (case (get self12 0) ('Parser.Reply.error (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) ($Parser.Reply.error f12 f13 f14))) ('Parser.Reply.value (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) (let ((self15 ($Kind.Parser.text ")" f12 f13))) (case (get self15 0) ('Parser.Reply.error (let ((f15 (get self15 1))(f16 (get self15 2))(f17 (get self15 3))) ($Parser.Reply.error f15 f16 f17))) ('Parser.Reply.value (let ((f15 (get self15 1))(f16 (get self15 2))(f17 (get self15 3))) (let ((self18 ($Kind.Parser.stop f2 f15 f16))) (case (get self18 0) ('Parser.Reply.error (let ((f18 (get self18 1))(f19 (get self18 2))(f20 (get self18 3))) ($Parser.Reply.error f18 f19 f20))) ('Parser.Reply.value (let ((f18 (get self18 1))(f19 (get self18 2))(f20 (get self18 3))) (let ((term$23 ($Kind.Term.ref "Equal.chain"))) (let ((term$24 ($Kind.Term.app term$23 ($Kind.Term.hol Bits.e)))) (let ((term$25 ($Kind.Term.app term$24 ($Kind.Term.hol Bits.e)))) (let ((term$26 ($Kind.Term.app term$25 ($Kind.Term.hol Bits.e)))) (let ((term$27 ($Kind.Term.app term$26 ($Kind.Term.hol Bits.e)))) (let ((term$28 ($Kind.Term.app term$27 f8))) (let ((term$29 ($Kind.Term.app term$28 f14))) ($Parser.Reply.value f18 f19 ($Kind.Term.ori f20 term$29))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.chain (lambda (idx$0) (lambda (code$1) ($Kind.Parser.chain idx$0 code$1))))
(define ($Kind.Parser.mirror idx$0 code$1) (let ((self0 ($Kind.Parser.init idx$0 code$1))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ($Kind.Parser.text "mirror(" f0 f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (let ((self6 ($Kind.Parser.term f3 f4))) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Parser.Reply.error f6 f7 f8))) ('Parser.Reply.value (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) (let ((self9 ($Kind.Parser.text ")" f6 f7))) (case (get self9 0) ('Parser.Reply.error (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) ($Parser.Reply.error f9 f10 f11))) ('Parser.Reply.value (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) (let ((self12 ($Kind.Parser.stop f2 f9 f10))) (case (get self12 0) ('Parser.Reply.error (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) ($Parser.Reply.error f12 f13 f14))) ('Parser.Reply.value (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) (let ((term$17 ($Kind.Term.ref "Equal.mirror"))) (let ((term$18 ($Kind.Term.app term$17 ($Kind.Term.hol Bits.e)))) (let ((term$19 ($Kind.Term.app term$18 ($Kind.Term.hol Bits.e)))) (let ((term$20 ($Kind.Term.app term$19 ($Kind.Term.hol Bits.e)))) (let ((term$21 ($Kind.Term.app term$20 f8))) ($Parser.Reply.value f12 f13 ($Kind.Term.ori f14 term$21))))))))))))))))))))))))))))
(define Kind.Parser.mirror (lambda (idx$0) (lambda (code$1) ($Kind.Parser.mirror idx$0 code$1))))
(define ($Kind.Name.read str$0) str$0)
(define Kind.Name.read (lambda (str$0) ($Kind.Name.read str$0)))
(define ($Kind.Parser.list idx$0 code$1) (let ((self0 ($Kind.Parser.init idx$0 code$1))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ($Kind.Parser.text "[" f0 f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (let ((self6 ((($Parser.until (Kind.Parser.text "]") (Kind.Parser.item Kind.Parser.term)) f3) f4))) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Parser.Reply.error f6 f7 f8))) ('Parser.Reply.value (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) (let ((self9 ($Kind.Parser.stop f2 f6 f7))) (case (get self9 0) ('Parser.Reply.error (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) ($Parser.Reply.error f9 f10 f11))) ('Parser.Reply.value (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) ($Parser.Reply.value f9 f10 ($List.fold f8 ($Kind.Term.ori f11 ($Kind.Term.app ($Kind.Term.ref ($Kind.Name.read "List.nil")) ($Kind.Term.hol Bits.e))) (lambda (x$14) (lambda (xs$15) (let ((term$16 ($Kind.Term.ref ($Kind.Name.read "List.cons")))) (let ((term$17 ($Kind.Term.app term$16 ($Kind.Term.hol Bits.e)))) (let ((term$18 ($Kind.Term.app term$17 x$14))) (let ((term$19 ($Kind.Term.app term$18 xs$15))) ($Kind.Term.ori f11 term$19))))))))))))))))))))))))))
(define Kind.Parser.list (lambda (idx$0) (lambda (code$1) ($Kind.Parser.list idx$0 code$1))))
(define ($Kind.Parser.map idx$0 code$1) (let ((self0 ($Kind.Parser.init idx$0 code$1))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ($Kind.Parser.text "{" f0 f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (let ((self6 ((($Parser.until (Kind.Parser.text "}") (Kind.Parser.item (lambda (idx$8) (lambda (code$9) (let ((self8 ($Kind.Parser.term idx$8 code$9))) (case (get self8 0) ('Parser.Reply.error (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))) ($Parser.Reply.error f8 f9 f10))) ('Parser.Reply.value (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))) (let ((self11 ($Kind.Parser.text ":" f8 f9))) (case (get self11 0) ('Parser.Reply.error (let ((f11 (get self11 1))(f12 (get self11 2))(f13 (get self11 3))) ($Parser.Reply.error f11 f12 f13))) ('Parser.Reply.value (let ((f11 (get self11 1))(f12 (get self11 2))(f13 (get self11 3))) (let ((self14 ($Kind.Parser.term f11 f12))) (case (get self14 0) ('Parser.Reply.error (let ((f14 (get self14 1))(f15 (get self14 2))(f16 (get self14 3))) ($Parser.Reply.error f14 f15 f16))) ('Parser.Reply.value (let ((f14 (get self14 1))(f15 (get self14 2))(f16 (get self14 3))) ($Parser.Reply.value f14 f15 ($Pair.new f10 f16)))))))))))))))))) f3) f4))) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Parser.Reply.error f6 f7 f8))) ('Parser.Reply.value (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) (let ((self9 ($Kind.Parser.stop f2 f6 f7))) (case (get self9 0) ('Parser.Reply.error (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) ($Parser.Reply.error f9 f10 f11))) ('Parser.Reply.value (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) (let ((list$14 ($List.fold f8 ($Kind.Term.ori f11 ($Kind.Term.app ($Kind.Term.ref "List.nil") ($Kind.Term.hol Bits.e))) (lambda (kv$14) (lambda (xs$15) (let ((self14 kv$14)) (case (get self14 0) ('Pair.new (let ((f14 (get self14 1))(f15 (get self14 2))) (let ((pair$18 ($Kind.Term.ref "Pair.new"))) (let ((pair$19 ($Kind.Term.app pair$18 ($Kind.Term.hol Bits.e)))) (let ((pair$20 ($Kind.Term.app pair$19 ($Kind.Term.hol Bits.e)))) (let ((pair$21 ($Kind.Term.app pair$20 f14))) (let ((pair$22 ($Kind.Term.app pair$21 f15))) (let ((term$23 ($Kind.Term.ref "List.cons"))) (let ((term$24 ($Kind.Term.app term$23 ($Kind.Term.hol Bits.e)))) (let ((term$25 ($Kind.Term.app term$24 pair$22))) (let ((term$26 ($Kind.Term.app term$25 xs$15))) ($Kind.Term.ori f11 term$26))))))))))))))))))) (let ((term$15 ($Kind.Term.ref "Map.from_list"))) (let ((term$16 ($Kind.Term.app term$15 ($Kind.Term.hol Bits.e)))) (let ((term$17 ($Kind.Term.app term$16 list$14))) ($Parser.Reply.value f9 f10 ($Kind.Term.ori f11 term$17)))))))))))))))))))))))
(define Kind.Parser.map (lambda (idx$0) (lambda (code$1) ($Kind.Parser.map idx$0 code$1))))
(define ($Kind.Parser.log idx$0 code$1) (let ((self0 ($Kind.Parser.init idx$0 code$1))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ($Kind.Parser.text "log(" f0 f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (let ((self6 ((($Parser.until (Kind.Parser.text ")") (Kind.Parser.item Kind.Parser.term)) f3) f4))) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Parser.Reply.error f6 f7 f8))) ('Parser.Reply.value (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) (let ((self9 ($Kind.Parser.term f6 f7))) (case (get self9 0) ('Parser.Reply.error (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) ($Parser.Reply.error f9 f10 f11))) ('Parser.Reply.value (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) (let ((term$14 ($Kind.Term.ref "Debug.log"))) (let ((term$15 ($Kind.Term.app term$14 ($Kind.Term.hol Bits.e)))) (let ((args$16 ($List.fold f8 ($Kind.Term.ref "String.nil") (lambda (x$16) (lambda (xs$17) (let ((arg$18 ($Kind.Term.ref "String.concat"))) (let ((arg$19 ($Kind.Term.app arg$18 x$16))) (let ((arg$20 ($Kind.Term.app arg$19 xs$17))) arg$20)))))))) (let ((term$17 ($Kind.Term.app term$15 args$16))) (let ((term$18 ($Kind.Term.app term$17 ($Kind.Term.lam "" (lambda (x$18) f11))))) (let ((self17 ($Kind.Parser.stop f2 f9 f10))) (case (get self17 0) ('Parser.Reply.error (let ((f17 (get self17 1))(f18 (get self17 2))(f19 (get self17 3))) ($Parser.Reply.error f17 f18 f19))) ('Parser.Reply.value (let ((f17 (get self17 1))(f18 (get self17 2))(f19 (get self17 3))) ($Parser.Reply.value f17 f18 ($Kind.Term.ori f19 term$18))))))))))))))))))))))))))))
(define Kind.Parser.log (lambda (idx$0) (lambda (code$1) ($Kind.Parser.log idx$0 code$1))))
(define ($Kind.Parser.do.statements monad_name$0) ($Parser.first_of ($List.cons (lambda (idx$1) (lambda (code$2) (let ((self2 ($Kind.Parser.init idx$1 code$2))) (case (get self2 0) ('Parser.Reply.error (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))) ($Parser.Reply.error f2 f3 f4))) ('Parser.Reply.value (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))) (let ((self5 ((($Parser.first_of ($List.cons (Kind.Parser.text "var ") ($List.cons (Kind.Parser.text "get ") List.nil))) f2) f3))) (case (get self5 0) ('Parser.Reply.error (let ((f5 (get self5 1))(f6 (get self5 2))(f7 (get self5 3))) ($Parser.Reply.error f5 f6 f7))) ('Parser.Reply.value (let ((f5 (get self5 1))(f6 (get self5 2))(f7 (get self5 3))) (let ((self8 ($Kind.Parser.name1 f5 f6))) (case (get self8 0) ('Parser.Reply.error (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))) ($Parser.Reply.error f8 f9 f10))) ('Parser.Reply.value (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))) (let ((self11 ($Kind.Parser.text "=" f8 f9))) (case (get self11 0) ('Parser.Reply.error (let ((f11 (get self11 1))(f12 (get self11 2))(f13 (get self11 3))) ($Parser.Reply.error f11 f12 f13))) ('Parser.Reply.value (let ((f11 (get self11 1))(f12 (get self11 2))(f13 (get self11 3))) (let ((self14 ($Kind.Parser.term f11 f12))) (case (get self14 0) ('Parser.Reply.error (let ((f14 (get self14 1))(f15 (get self14 2))(f16 (get self14 3))) ($Parser.Reply.error f14 f15 f16))) ('Parser.Reply.value (let ((f14 (get self14 1))(f15 (get self14 2))(f16 (get self14 3))) (let ((self17 ($Parser.maybe (Kind.Parser.text ";") f14 f15))) (case (get self17 0) ('Parser.Reply.error (let ((f17 (get self17 1))(f18 (get self17 2))(f19 (get self17 3))) ($Parser.Reply.error f17 f18 f19))) ('Parser.Reply.value (let ((f17 (get self17 1))(f18 (get self17 2))(f19 (get self17 3))) (let ((self20 ((($Kind.Parser.do.statements monad_name$0) f17) f18))) (case (get self20 0) ('Parser.Reply.error (let ((f20 (get self20 1))(f21 (get self20 2))(f22 (get self20 3))) ($Parser.Reply.error f20 f21 f22))) ('Parser.Reply.value (let ((f20 (get self20 1))(f21 (get self20 2))(f22 (get self20 3))) (let ((self23 ($Kind.Parser.stop f4 f20 f21))) (case (get self23 0) ('Parser.Reply.error (let ((f23 (get self23 1))(f24 (get self23 2))(f25 (get self23 3))) ($Parser.Reply.error f23 f24 f25))) ('Parser.Reply.value (let ((f23 (get self23 1))(f24 (get self23 2))(f25 (get self23 3))) (let ((term$27 ($Kind.Term.app ($Kind.Term.ref "Monad.bind") ($Kind.Term.ref monad_name$0)))) (let ((term$28 ($Kind.Term.app term$27 ($Kind.Term.ref ($String.concat monad_name$0 ".monad"))))) (let ((term$29 ($Kind.Term.app term$28 ($Kind.Term.hol Bits.e)))) (let ((term$30 ($Kind.Term.app term$29 ($Kind.Term.hol Bits.e)))) (let ((term$31 ($Kind.Term.app term$30 f16))) (let ((term$32 ($Kind.Term.app term$31 ($Kind.Term.lam f10 (lambda (x$32) f22))))) ($Parser.Reply.value f23 f24 ($Kind.Term.ori f25 term$32)))))))))))))))))))))))))))))))))))))))))) ($List.cons (lambda (idx$1) (lambda (code$2) (let ((self2 ($Kind.Parser.init idx$1 code$2))) (case (get self2 0) ('Parser.Reply.error (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))) ($Parser.Reply.error f2 f3 f4))) ('Parser.Reply.value (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))) (let ((self5 ($Kind.Parser.text "let " f2 f3))) (case (get self5 0) ('Parser.Reply.error (let ((f5 (get self5 1))(f6 (get self5 2))(f7 (get self5 3))) ($Parser.Reply.error f5 f6 f7))) ('Parser.Reply.value (let ((f5 (get self5 1))(f6 (get self5 2))(f7 (get self5 3))) (let ((self8 ($Kind.Parser.name1 f5 f6))) (case (get self8 0) ('Parser.Reply.error (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))) ($Parser.Reply.error f8 f9 f10))) ('Parser.Reply.value (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))) (let ((self11 ($Kind.Parser.text "=" f8 f9))) (case (get self11 0) ('Parser.Reply.error (let ((f11 (get self11 1))(f12 (get self11 2))(f13 (get self11 3))) ($Parser.Reply.error f11 f12 f13))) ('Parser.Reply.value (let ((f11 (get self11 1))(f12 (get self11 2))(f13 (get self11 3))) (let ((self14 ($Kind.Parser.term f11 f12))) (case (get self14 0) ('Parser.Reply.error (let ((f14 (get self14 1))(f15 (get self14 2))(f16 (get self14 3))) ($Parser.Reply.error f14 f15 f16))) ('Parser.Reply.value (let ((f14 (get self14 1))(f15 (get self14 2))(f16 (get self14 3))) (let ((self17 ($Parser.maybe (Kind.Parser.text ";") f14 f15))) (case (get self17 0) ('Parser.Reply.error (let ((f17 (get self17 1))(f18 (get self17 2))(f19 (get self17 3))) ($Parser.Reply.error f17 f18 f19))) ('Parser.Reply.value (let ((f17 (get self17 1))(f18 (get self17 2))(f19 (get self17 3))) (let ((self20 ((($Kind.Parser.do.statements monad_name$0) f17) f18))) (case (get self20 0) ('Parser.Reply.error (let ((f20 (get self20 1))(f21 (get self20 2))(f22 (get self20 3))) ($Parser.Reply.error f20 f21 f22))) ('Parser.Reply.value (let ((f20 (get self20 1))(f21 (get self20 2))(f22 (get self20 3))) (let ((self23 ($Kind.Parser.stop f4 f20 f21))) (case (get self23 0) ('Parser.Reply.error (let ((f23 (get self23 1))(f24 (get self23 2))(f25 (get self23 3))) ($Parser.Reply.error f23 f24 f25))) ('Parser.Reply.value (let ((f23 (get self23 1))(f24 (get self23 2))(f25 (get self23 3))) ($Parser.Reply.value f23 f24 ($Kind.Term.ori f25 ($Kind.Term.let f10 f16 (lambda (x$27) f22)))))))))))))))))))))))))))))))))))))) ($List.cons (lambda (idx$1) (lambda (code$2) (let ((self2 ($Kind.Parser.init idx$1 code$2))) (case (get self2 0) ('Parser.Reply.error (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))) ($Parser.Reply.error f2 f3 f4))) ('Parser.Reply.value (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))) (let ((self5 ($Kind.Parser.text "return " f2 f3))) (case (get self5 0) ('Parser.Reply.error (let ((f5 (get self5 1))(f6 (get self5 2))(f7 (get self5 3))) ($Parser.Reply.error f5 f6 f7))) ('Parser.Reply.value (let ((f5 (get self5 1))(f6 (get self5 2))(f7 (get self5 3))) (let ((self8 ($Kind.Parser.term f5 f6))) (case (get self8 0) ('Parser.Reply.error (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))) ($Parser.Reply.error f8 f9 f10))) ('Parser.Reply.value (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))) (let ((self11 ($Parser.maybe (Kind.Parser.text ";") f8 f9))) (case (get self11 0) ('Parser.Reply.error (let ((f11 (get self11 1))(f12 (get self11 2))(f13 (get self11 3))) ($Parser.Reply.error f11 f12 f13))) ('Parser.Reply.value (let ((f11 (get self11 1))(f12 (get self11 2))(f13 (get self11 3))) (let ((self14 ($Kind.Parser.stop f4 f11 f12))) (case (get self14 0) ('Parser.Reply.error (let ((f14 (get self14 1))(f15 (get self14 2))(f16 (get self14 3))) ($Parser.Reply.error f14 f15 f16))) ('Parser.Reply.value (let ((f14 (get self14 1))(f15 (get self14 2))(f16 (get self14 3))) (let ((term$18 ($Kind.Term.app ($Kind.Term.ref "Monad.pure") ($Kind.Term.ref monad_name$0)))) (let ((term$19 ($Kind.Term.app term$18 ($Kind.Term.ref ($String.concat monad_name$0 ".monad"))))) (let ((term$20 ($Kind.Term.app term$19 ($Kind.Term.hol Bits.e)))) (let ((term$21 ($Kind.Term.app term$20 f10))) ($Parser.Reply.value f14 f15 ($Kind.Term.ori f16 term$21)))))))))))))))))))))))))))) ($List.cons (lambda (idx$1) (lambda (code$2) (let ((self2 ($Kind.Parser.init idx$1 code$2))) (case (get self2 0) ('Parser.Reply.error (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))) ($Parser.Reply.error f2 f3 f4))) ('Parser.Reply.value (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))) (let ((self5 ($Kind.Parser.term f2 f3))) (case (get self5 0) ('Parser.Reply.error (let ((f5 (get self5 1))(f6 (get self5 2))(f7 (get self5 3))) ($Parser.Reply.error f5 f6 f7))) ('Parser.Reply.value (let ((f5 (get self5 1))(f6 (get self5 2))(f7 (get self5 3))) (let ((self8 ($Parser.maybe (Kind.Parser.text ";") f5 f6))) (case (get self8 0) ('Parser.Reply.error (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))) ($Parser.Reply.error f8 f9 f10))) ('Parser.Reply.value (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))) (let ((self11 ((($Kind.Parser.do.statements monad_name$0) f8) f9))) (case (get self11 0) ('Parser.Reply.error (let ((f11 (get self11 1))(f12 (get self11 2))(f13 (get self11 3))) ($Parser.Reply.error f11 f12 f13))) ('Parser.Reply.value (let ((f11 (get self11 1))(f12 (get self11 2))(f13 (get self11 3))) (let ((self14 ($Kind.Parser.stop f4 f11 f12))) (case (get self14 0) ('Parser.Reply.error (let ((f14 (get self14 1))(f15 (get self14 2))(f16 (get self14 3))) ($Parser.Reply.error f14 f15 f16))) ('Parser.Reply.value (let ((f14 (get self14 1))(f15 (get self14 2))(f16 (get self14 3))) (let ((term$18 ($Kind.Term.app ($Kind.Term.ref "Monad.bind") ($Kind.Term.ref monad_name$0)))) (let ((term$19 ($Kind.Term.app term$18 ($Kind.Term.ref ($String.concat monad_name$0 ".monad"))))) (let ((term$20 ($Kind.Term.app term$19 ($Kind.Term.hol Bits.e)))) (let ((term$21 ($Kind.Term.app term$20 ($Kind.Term.hol Bits.e)))) (let ((term$22 ($Kind.Term.app term$21 f7))) (let ((term$23 ($Kind.Term.app term$22 ($Kind.Term.lam "" (lambda (x$23) f13))))) ($Parser.Reply.value f14 f15 ($Kind.Term.ori f16 term$23)))))))))))))))))))))))))))))) ($List.cons (lambda (idx$1) (lambda (code$2) (let ((self2 ($Kind.Parser.term idx$1 code$2))) (case (get self2 0) ('Parser.Reply.error (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))) ($Parser.Reply.error f2 f3 f4))) ('Parser.Reply.value (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))) (let ((self5 ($Parser.maybe (Kind.Parser.text ";") f2 f3))) (case (get self5 0) ('Parser.Reply.error (let ((f5 (get self5 1))(f6 (get self5 2))(f7 (get self5 3))) ($Parser.Reply.error f5 f6 f7))) ('Parser.Reply.value (let ((f5 (get self5 1))(f6 (get self5 2))(f7 (get self5 3))) ($Parser.Reply.value f5 f6 f4))))))))))) List.nil)))))))
(define Kind.Parser.do.statements (lambda (monad_name$0) ($Kind.Parser.do.statements monad_name$0)))
(define ($Kind.Parser.do idx$0 code$1) (let ((self0 ($Parser.maybe (Kind.Parser.text "do ") idx$0 code$1))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ($Kind.Parser.name1 f0 f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (let ((self6 ($Parser.text " {" f3 f4))) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Parser.Reply.error f6 f7 f8))) ('Parser.Reply.value (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) (let ((self9 ((($Kind.Parser.do.statements f5) f6) f7))) (case (get self9 0) ('Parser.Reply.error (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) ($Parser.Reply.error f9 f10 f11))) ('Parser.Reply.value (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) (let ((self12 ($Kind.Parser.text "}" f9 f10))) (case (get self12 0) ('Parser.Reply.error (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) ($Parser.Reply.error f12 f13 f14))) ('Parser.Reply.value (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) ($Parser.Reply.value f12 f13 f11))))))))))))))))))))))
(define Kind.Parser.do (lambda (idx$0) (lambda (code$1) ($Kind.Parser.do idx$0 code$1))))
(define ($Parser.try parse$1 idx$2 code$3) (let ((self0 ((parse$1 idx$2) code$3))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.value idx$2 code$3 Bool.false))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.value idx$2 code$3 Bool.true))))))
(define Parser.try (lambda (parse$1) (lambda (idx$2) (lambda (code$3) ($Parser.try parse$1 idx$2 code$3)))))
(define ($Parser.fail error$1 idx$2 code$3) ($Parser.Reply.error idx$2 code$3 error$1))
(define Parser.fail (lambda (error$1) (lambda (idx$2) (lambda (code$3) ($Parser.fail error$1 idx$2 code$3)))))
(define ($Parser.avoiding test$1 parse$2 idx$3 code$4) (let ((self0 ($Parser.try test$1 idx$3 code$4))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (((let ((self3 f2)) (case self3 (#t (let () (Parser.fail "Avoided."))) (#f (let () parse$2)))) f0) f1))))))
(define Parser.avoiding (lambda (test$1) (lambda (parse$2) (lambda (idx$3) (lambda (code$4) ($Parser.avoiding test$1 parse$2 idx$3 code$4))))))
(define ($Maybe.default m$1 a$2) (let ((self0 m$1)) (case (get self0 0) ('Maybe.none (let () a$2)) ('Maybe.some (let ((f0 (get self0 1))) f0)))))
(define Maybe.default (lambda (m$1) (lambda (a$2) ($Maybe.default m$1 a$2))))
(define ($BitsMap.get bits$1 map$2) (let ((self0 bits$1)) (case (get self0 0) ('Bits.e (let () (let ((self0 map$2)) (case (get self0 0) ('BitsMap.new (let () Maybe.none)) ('BitsMap.tie (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) f0)))))) ('Bits.o (let ((f0 (get self0 1))) (let ((self1 map$2)) (case (get self1 0) ('BitsMap.new (let () Maybe.none)) ('BitsMap.tie (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))) ($BitsMap.get f0 f2))))))) ('Bits.i (let ((f0 (get self0 1))) (let ((self1 map$2)) (case (get self1 0) ('BitsMap.new (let () Maybe.none)) ('BitsMap.tie (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))) ($BitsMap.get f0 f3))))))))))
(define BitsMap.get (lambda (bits$1) (lambda (map$2) ($BitsMap.get bits$1 map$2))))
(define ($Bits.o pred$0) (vector 'Bits.o pred$0))
(define Bits.o (lambda (pred$0) ($Bits.o pred$0)))
(define ($Bits.i pred$0) (vector 'Bits.i pred$0))
(define Bits.i (lambda (pred$0) ($Bits.i pred$0)))
(define ($Cmp.as_ltn cmp$0) (let ((self0 cmp$0)) (case (get self0 0) ('Cmp.ltn (let () Bool.true)) ('Cmp.eql (let () Bool.false)) ('Cmp.gtn (let () Bool.false)))))
(define Cmp.as_ltn (lambda (cmp$0) ($Cmp.as_ltn cmp$0)))
(define ($Word.ltn a$1 b$2) ($Cmp.as_ltn ($Word.cmp a$1 b$2)))
(define Word.ltn (lambda (a$1) (lambda (b$2) ($Word.ltn a$1 b$2))))
(define ($U16.ltn a$0 b$1) (< a$0 b$1))
(define U16.ltn (lambda (a$0) (lambda (b$1) ($U16.ltn a$0 b$1))))
(define ($Kind.Name.to_bits name$0) (let ((self0 name$0)) (case (= (string-length self0) 0) (#t (let () Bits.e)) (#f (let ((f0 (char->integer (string-ref self0 0)))(f1 (let ((_str_ self0)) (substring _str_ 1 (string-length _str_))))) (let ((x$3 f0)) (let ((O$4 Bits.o)) (let ((I$5 Bits.i)) (let ((self5 ($U16.ltn x$3 ($Nat.to_u16 47)))) (case self5 (#t (let () (I$5 (I$5 (I$5 (I$5 (I$5 (O$4 ($Kind.Name.to_bits f1))))))))) (#f (let () (let ((self5 ($U16.ltn x$3 ($Nat.to_u16 58)))) (case self5 (#t (let () (let ((self5 ($U16.ltn x$3 ($Nat.to_u16 53)))) (case self5 (#t (let () (let ((self5 ($U16.ltn x$3 ($Nat.to_u16 50)))) (case self5 (#t (let () (let ((self5 ($U16.ltn x$3 ($Nat.to_u16 49)))) (case self5 (#t (let () (I$5 (I$5 (O$4 (I$5 (O$4 (O$4 ($Kind.Name.to_bits f1))))))))) (#f (let () (I$5 (I$5 (O$4 (I$5 (O$4 (I$5 ($Kind.Name.to_bits f1))))))))))))) (#f (let () (let ((self5 ($U16.ltn x$3 ($Nat.to_u16 51)))) (case self5 (#t (let () (I$5 (I$5 (O$4 (I$5 (I$5 (O$4 ($Kind.Name.to_bits f1))))))))) (#f (let () (let ((self5 ($U16.ltn x$3 ($Nat.to_u16 52)))) (case self5 (#t (let () (I$5 (I$5 (O$4 (I$5 (I$5 (I$5 ($Kind.Name.to_bits f1))))))))) (#f (let () (I$5 (I$5 (I$5 (O$4 (O$4 (O$4 ($Kind.Name.to_bits f1))))))))))))))))))))) (#f (let () (let ((self5 ($U16.ltn x$3 ($Nat.to_u16 55)))) (case self5 (#t (let () (let ((self5 ($U16.ltn x$3 ($Nat.to_u16 54)))) (case self5 (#t (let () (I$5 (I$5 (I$5 (O$4 (O$4 (I$5 ($Kind.Name.to_bits f1))))))))) (#f (let () (I$5 (I$5 (I$5 (O$4 (I$5 (O$4 ($Kind.Name.to_bits f1))))))))))))) (#f (let () (let ((self5 ($U16.ltn x$3 ($Nat.to_u16 56)))) (case self5 (#t (let () (I$5 (I$5 (I$5 (O$4 (I$5 (I$5 ($Kind.Name.to_bits f1))))))))) (#f (let () (let ((self5 ($U16.ltn x$3 ($Nat.to_u16 57)))) (case self5 (#t (let () (I$5 (I$5 (I$5 (I$5 (O$4 (O$4 ($Kind.Name.to_bits f1))))))))) (#f (let () (I$5 (I$5 (I$5 (I$5 (O$4 (I$5 ($Kind.Name.to_bits f1))))))))))))))))))))))))) (#f (let () (let ((self5 ($U16.ltn x$3 ($Nat.to_u16 91)))) (case self5 (#t (let () (let ((self5 ($U16.ltn x$3 ($Nat.to_u16 78)))) (case self5 (#t (let () (let ((self5 ($U16.ltn x$3 ($Nat.to_u16 71)))) (case self5 (#t (let () (let ((self5 ($U16.ltn x$3 ($Nat.to_u16 68)))) (case self5 (#t (let () (let ((self5 ($U16.ltn x$3 ($Nat.to_u16 66)))) (case self5 (#t (let () (O$4 (O$4 (O$4 (O$4 (O$4 (O$4 ($Kind.Name.to_bits f1))))))))) (#f (let () (let ((self5 ($U16.ltn x$3 ($Nat.to_u16 67)))) (case self5 (#t (let () (O$4 (O$4 (O$4 (O$4 (O$4 (I$5 ($Kind.Name.to_bits f1))))))))) (#f (let () (O$4 (O$4 (O$4 (O$4 (I$5 (O$4 ($Kind.Name.to_bits f1))))))))))))))))) (#f (let () (let ((self5 ($U16.ltn x$3 ($Nat.to_u16 69)))) (case self5 (#t (let () (O$4 (O$4 (O$4 (O$4 (I$5 (I$5 ($Kind.Name.to_bits f1))))))))) (#f (let () (let ((self5 ($U16.ltn x$3 ($Nat.to_u16 70)))) (case self5 (#t (let () (O$4 (O$4 (O$4 (I$5 (O$4 (O$4 ($Kind.Name.to_bits f1))))))))) (#f (let () (O$4 (O$4 (O$4 (I$5 (O$4 (I$5 ($Kind.Name.to_bits f1))))))))))))))))))))) (#f (let () (let ((self5 ($U16.ltn x$3 ($Nat.to_u16 74)))) (case self5 (#t (let () (let ((self5 ($U16.ltn x$3 ($Nat.to_u16 72)))) (case self5 (#t (let () (O$4 (O$4 (O$4 (I$5 (I$5 (O$4 ($Kind.Name.to_bits f1))))))))) (#f (let () (let ((self5 ($U16.ltn x$3 ($Nat.to_u16 73)))) (case self5 (#t (let () (O$4 (O$4 (O$4 (I$5 (I$5 (I$5 ($Kind.Name.to_bits f1))))))))) (#f (let () (O$4 (O$4 (I$5 (O$4 (O$4 (O$4 ($Kind.Name.to_bits f1))))))))))))))))) (#f (let () (let ((self5 ($U16.ltn x$3 ($Nat.to_u16 76)))) (case self5 (#t (let () (let ((self5 ($U16.ltn x$3 ($Nat.to_u16 75)))) (case self5 (#t (let () (O$4 (O$4 (I$5 (O$4 (O$4 (I$5 ($Kind.Name.to_bits f1))))))))) (#f (let () (O$4 (O$4 (I$5 (O$4 (I$5 (O$4 ($Kind.Name.to_bits f1))))))))))))) (#f (let () (let ((self5 ($U16.ltn x$3 ($Nat.to_u16 77)))) (case self5 (#t (let () (O$4 (O$4 (I$5 (O$4 (I$5 (I$5 ($Kind.Name.to_bits f1))))))))) (#f (let () (O$4 (O$4 (I$5 (I$5 (O$4 (O$4 ($Kind.Name.to_bits f1))))))))))))))))))))))))) (#f (let () (let ((self5 ($U16.ltn x$3 ($Nat.to_u16 84)))) (case self5 (#t (let () (let ((self5 ($U16.ltn x$3 ($Nat.to_u16 81)))) (case self5 (#t (let () (let ((self5 ($U16.ltn x$3 ($Nat.to_u16 79)))) (case self5 (#t (let () (O$4 (O$4 (I$5 (I$5 (O$4 (I$5 ($Kind.Name.to_bits f1))))))))) (#f (let () (let ((self5 ($U16.ltn x$3 ($Nat.to_u16 80)))) (case self5 (#t (let () (O$4 (O$4 (I$5 (I$5 (I$5 (O$4 ($Kind.Name.to_bits f1))))))))) (#f (let () (O$4 (O$4 (I$5 (I$5 (I$5 (I$5 ($Kind.Name.to_bits f1))))))))))))))))) (#f (let () (let ((self5 ($U16.ltn x$3 ($Nat.to_u16 82)))) (case self5 (#t (let () (O$4 (I$5 (O$4 (O$4 (O$4 (O$4 ($Kind.Name.to_bits f1))))))))) (#f (let () (let ((self5 ($U16.ltn x$3 ($Nat.to_u16 83)))) (case self5 (#t (let () (O$4 (I$5 (O$4 (O$4 (O$4 (I$5 ($Kind.Name.to_bits f1))))))))) (#f (let () (O$4 (I$5 (O$4 (O$4 (I$5 (O$4 ($Kind.Name.to_bits f1))))))))))))))))))))) (#f (let () (let ((self5 ($U16.ltn x$3 ($Nat.to_u16 87)))) (case self5 (#t (let () (let ((self5 ($U16.ltn x$3 ($Nat.to_u16 85)))) (case self5 (#t (let () (O$4 (I$5 (O$4 (O$4 (I$5 (I$5 ($Kind.Name.to_bits f1))))))))) (#f (let () (let ((self5 ($U16.ltn x$3 ($Nat.to_u16 86)))) (case self5 (#t (let () (O$4 (I$5 (O$4 (I$5 (O$4 (O$4 ($Kind.Name.to_bits f1))))))))) (#f (let () (O$4 (I$5 (O$4 (I$5 (O$4 (I$5 ($Kind.Name.to_bits f1))))))))))))))))) (#f (let () (let ((self5 ($U16.ltn x$3 ($Nat.to_u16 89)))) (case self5 (#t (let () (let ((self5 ($U16.ltn x$3 ($Nat.to_u16 88)))) (case self5 (#t (let () (O$4 (I$5 (O$4 (I$5 (I$5 (O$4 ($Kind.Name.to_bits f1))))))))) (#f (let () (O$4 (I$5 (O$4 (I$5 (I$5 (I$5 ($Kind.Name.to_bits f1))))))))))))) (#f (let () (let ((self5 ($U16.ltn x$3 ($Nat.to_u16 90)))) (case self5 (#t (let () (O$4 (I$5 (I$5 (O$4 (O$4 (O$4 ($Kind.Name.to_bits f1))))))))) (#f (let () (O$4 (I$5 (I$5 (O$4 (O$4 (I$5 ($Kind.Name.to_bits f1))))))))))))))))))))))))))))) (#f (let () (let ((self5 ($U16.ltn x$3 ($Nat.to_u16 96)))) (case self5 (#t (let () (I$5 (I$5 (I$5 (I$5 (I$5 (I$5 ($Kind.Name.to_bits f1))))))))) (#f (let () (let ((self5 ($U16.ltn x$3 ($Nat.to_u16 110)))) (case self5 (#t (let () (let ((self5 ($U16.ltn x$3 ($Nat.to_u16 103)))) (case self5 (#t (let () (let ((self5 ($U16.ltn x$3 ($Nat.to_u16 100)))) (case self5 (#t (let () (let ((self5 ($U16.ltn x$3 ($Nat.to_u16 98)))) (case self5 (#t (let () (O$4 (I$5 (I$5 (O$4 (I$5 (O$4 ($Kind.Name.to_bits f1))))))))) (#f (let () (let ((self5 ($U16.ltn x$3 ($Nat.to_u16 99)))) (case self5 (#t (let () (O$4 (I$5 (I$5 (O$4 (I$5 (I$5 ($Kind.Name.to_bits f1))))))))) (#f (let () (O$4 (I$5 (I$5 (I$5 (O$4 (O$4 ($Kind.Name.to_bits f1))))))))))))))))) (#f (let () (let ((self5 ($U16.ltn x$3 ($Nat.to_u16 101)))) (case self5 (#t (let () (O$4 (I$5 (I$5 (I$5 (O$4 (I$5 ($Kind.Name.to_bits f1))))))))) (#f (let () (let ((self5 ($U16.ltn x$3 ($Nat.to_u16 102)))) (case self5 (#t (let () (O$4 (I$5 (I$5 (I$5 (I$5 (O$4 ($Kind.Name.to_bits f1))))))))) (#f (let () (O$4 (I$5 (I$5 (I$5 (I$5 (I$5 ($Kind.Name.to_bits f1))))))))))))))))))))) (#f (let () (let ((self5 ($U16.ltn x$3 ($Nat.to_u16 106)))) (case self5 (#t (let () (let ((self5 ($U16.ltn x$3 ($Nat.to_u16 104)))) (case self5 (#t (let () (I$5 (O$4 (O$4 (O$4 (O$4 (O$4 ($Kind.Name.to_bits f1))))))))) (#f (let () (let ((self5 ($U16.ltn x$3 ($Nat.to_u16 105)))) (case self5 (#t (let () (I$5 (O$4 (O$4 (O$4 (O$4 (I$5 ($Kind.Name.to_bits f1))))))))) (#f (let () (I$5 (O$4 (O$4 (O$4 (I$5 (O$4 ($Kind.Name.to_bits f1))))))))))))))))) (#f (let () (let ((self5 ($U16.ltn x$3 ($Nat.to_u16 108)))) (case self5 (#t (let () (let ((self5 ($U16.ltn x$3 ($Nat.to_u16 107)))) (case self5 (#t (let () (I$5 (O$4 (O$4 (O$4 (I$5 (I$5 ($Kind.Name.to_bits f1))))))))) (#f (let () (I$5 (O$4 (O$4 (I$5 (O$4 (O$4 ($Kind.Name.to_bits f1))))))))))))) (#f (let () (let ((self5 ($U16.ltn x$3 ($Nat.to_u16 109)))) (case self5 (#t (let () (I$5 (O$4 (O$4 (I$5 (O$4 (I$5 ($Kind.Name.to_bits f1))))))))) (#f (let () (I$5 (O$4 (O$4 (I$5 (I$5 (O$4 ($Kind.Name.to_bits f1))))))))))))))))))))))))) (#f (let () (let ((self5 ($U16.ltn x$3 ($Nat.to_u16 116)))) (case self5 (#t (let () (let ((self5 ($U16.ltn x$3 ($Nat.to_u16 113)))) (case self5 (#t (let () (let ((self5 ($U16.ltn x$3 ($Nat.to_u16 111)))) (case self5 (#t (let () (I$5 (O$4 (O$4 (I$5 (I$5 (I$5 ($Kind.Name.to_bits f1))))))))) (#f (let () (let ((self5 ($U16.ltn x$3 ($Nat.to_u16 112)))) (case self5 (#t (let () (I$5 (O$4 (I$5 (O$4 (O$4 (O$4 ($Kind.Name.to_bits f1))))))))) (#f (let () (I$5 (O$4 (I$5 (O$4 (O$4 (I$5 ($Kind.Name.to_bits f1))))))))))))))))) (#f (let () (let ((self5 ($U16.ltn x$3 ($Nat.to_u16 114)))) (case self5 (#t (let () (I$5 (O$4 (I$5 (O$4 (I$5 (O$4 ($Kind.Name.to_bits f1))))))))) (#f (let () (let ((self5 ($U16.ltn x$3 ($Nat.to_u16 115)))) (case self5 (#t (let () (I$5 (O$4 (I$5 (O$4 (I$5 (I$5 ($Kind.Name.to_bits f1))))))))) (#f (let () (I$5 (O$4 (I$5 (I$5 (O$4 (O$4 ($Kind.Name.to_bits f1))))))))))))))))))))) (#f (let () (let ((self5 ($U16.ltn x$3 ($Nat.to_u16 119)))) (case self5 (#t (let () (let ((self5 ($U16.ltn x$3 ($Nat.to_u16 117)))) (case self5 (#t (let () (I$5 (O$4 (I$5 (I$5 (O$4 (I$5 ($Kind.Name.to_bits f1))))))))) (#f (let () (let ((self5 ($U16.ltn x$3 ($Nat.to_u16 118)))) (case self5 (#t (let () (I$5 (O$4 (I$5 (I$5 (I$5 (O$4 ($Kind.Name.to_bits f1))))))))) (#f (let () (I$5 (O$4 (I$5 (I$5 (I$5 (I$5 ($Kind.Name.to_bits f1))))))))))))))))) (#f (let () (let ((self5 ($U16.ltn x$3 ($Nat.to_u16 121)))) (case self5 (#t (let () (let ((self5 ($U16.ltn x$3 ($Nat.to_u16 120)))) (case self5 (#t (let () (I$5 (I$5 (O$4 (O$4 (O$4 (O$4 ($Kind.Name.to_bits f1))))))))) (#f (let () (I$5 (I$5 (O$4 (O$4 (O$4 (I$5 ($Kind.Name.to_bits f1))))))))))))) (#f (let () (let ((self5 ($U16.ltn x$3 ($Nat.to_u16 122)))) (case self5 (#t (let () (I$5 (I$5 (O$4 (O$4 (I$5 (O$4 ($Kind.Name.to_bits f1))))))))) (#f (let () (I$5 (I$5 (O$4 (O$4 (I$5 (I$5 ($Kind.Name.to_bits f1)))))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Name.to_bits (lambda (name$0) ($Kind.Name.to_bits name$0)))
(define ($Kind.Map.get name$1 map$2) ($BitsMap.get ($Kind.Name.to_bits name$1) map$2))
(define Kind.Map.get (lambda (name$1) (lambda (map$2) ($Kind.Map.get name$1 map$2))))
(define ($Kind.Term.nat natx$0) (vector 'Kind.Term.nat natx$0))
(define Kind.Term.nat (lambda (natx$0) ($Kind.Term.nat natx$0)))
(define ($Kind.Term.unroll_nat natx$0) (let ((self0 natx$0)) (case (= self0 0) (#t (let () ($Kind.Term.ref ($Kind.Name.read "Nat.zero")))) (#f (let ((f0 (- self0 1))) (let ((func$2 ($Kind.Term.ref ($Kind.Name.read "Nat.succ")))) (let ((argm$3 ($Kind.Term.nat f0))) ($Kind.Term.app func$2 argm$3))))))))
(define Kind.Term.unroll_nat (lambda (natx$0) ($Kind.Term.unroll_nat natx$0)))
(define ($Word.to_bits a$1) (let ((self0 a$1)) (case (get self0 0) ('Word.e (let () Bits.e)) ('Word.o (let ((f0 (get self0 1))) ($Bits.o ($Word.to_bits f0)))) ('Word.i (let ((f0 (get self0 1))) ($Bits.i ($Word.to_bits f0)))))))
(define Word.to_bits (lambda (a$1) ($Word.to_bits a$1)))
(define ($U16.to_bits a$0) (let ((self0 a$0)) (case #t (#t (let ((f0 (u16-to-word self0))) ($Word.to_bits f0))))))
(define U16.to_bits (lambda (a$0) ($U16.to_bits a$0)))
(define ($Kind.Term.unroll_chr.bits bits$0) (let ((self0 bits$0)) (case (get self0 0) ('Bits.e (let () ($Kind.Term.ref ($Kind.Name.read "Bits.e")))) ('Bits.o (let ((f0 (get self0 1))) ($Kind.Term.app ($Kind.Term.ref ($Kind.Name.read "Bits.o")) ($Kind.Term.unroll_chr.bits f0)))) ('Bits.i (let ((f0 (get self0 1))) ($Kind.Term.app ($Kind.Term.ref ($Kind.Name.read "Bits.i")) ($Kind.Term.unroll_chr.bits f0)))))))
(define Kind.Term.unroll_chr.bits (lambda (bits$0) ($Kind.Term.unroll_chr.bits bits$0)))
(define ($Kind.Term.unroll_chr chrx$0) (let ((bits$1 ($U16.to_bits chrx$0))) (let ((term$2 ($Kind.Term.ref ($Kind.Name.read "Word.from_bits")))) (let ((term$3 ($Kind.Term.app term$2 ($Kind.Term.nat 16)))) (let ((term$4 ($Kind.Term.app term$3 ($Kind.Term.unroll_chr.bits bits$1)))) (let ((term$5 ($Kind.Term.app ($Kind.Term.ref ($Kind.Name.read "U16.new")) term$4))) term$5))))))
(define Kind.Term.unroll_chr (lambda (chrx$0) ($Kind.Term.unroll_chr chrx$0)))
(define ($Kind.Term.unroll_str strx$0) (let ((self0 strx$0)) (case (= (string-length self0) 0) (#t (let () ($Kind.Term.ref ($Kind.Name.read "String.nil")))) (#f (let ((f0 (char->integer (string-ref self0 0)))(f1 (let ((_str_ self0)) (substring _str_ 1 (string-length _str_))))) (let ((char$3 ($Kind.Term.chr f0))) (let ((term$4 ($Kind.Term.ref ($Kind.Name.read "String.cons")))) (let ((term$5 ($Kind.Term.app term$4 char$3))) (let ((term$6 ($Kind.Term.app term$5 ($Kind.Term.str f1)))) term$6)))))))))
(define Kind.Term.unroll_str (lambda (strx$0) ($Kind.Term.unroll_str strx$0)))
(define ($Kind.Term.reduce term$0 defs$1) (let ((self0 term$0)) (case (get self0 0) ('Kind.Term.var (let ((f0 (get self0 1))(f1 (get self0 2))) term$0)) ('Kind.Term.ref (let ((f0 (get self0 1))) (let ((self1 ($Kind.Map.get f0 defs$1))) (case (get self1 0) ('Maybe.none (let () ($Kind.Term.ref f0))) ('Maybe.some (let ((f1 (get self1 1))) (let ((self2 f1)) (case (get self2 0) ('Kind.Def.new (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))(f5 (get self2 4))(f6 (get self2 5))(f7 (get self2 6))(f8 (get self2 7))(f9 (get self2 8))(f10 (get self2 9))) ($Kind.Term.reduce f6 defs$1))))))))))) ('Kind.Term.typ (let () term$0)) ('Kind.Term.all (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))) term$0)) ('Kind.Term.lam (let ((f0 (get self0 1))(f1 (get self0 2))) term$0)) ('Kind.Term.app (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((func$4 ($Kind.Term.reduce f0 defs$1))) (let ((self3 func$4)) (case (get self3 0) ('Kind.Term.var (let ((f3 (get self3 1))(f4 (get self3 2))) term$0)) ('Kind.Term.ref (let ((f3 (get self3 1))) term$0)) ('Kind.Term.typ (let () term$0)) ('Kind.Term.all (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))(f6 (get self3 4))(f7 (get self3 5))) term$0)) ('Kind.Term.lam (let ((f3 (get self3 1))(f4 (get self3 2))) ($Kind.Term.reduce (f4 f1) defs$1))) ('Kind.Term.app (let ((f3 (get self3 1))(f4 (get self3 2))) term$0)) ('Kind.Term.let (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) term$0)) ('Kind.Term.def (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) term$0)) ('Kind.Term.ann (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) term$0)) ('Kind.Term.gol (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) term$0)) ('Kind.Term.hol (let ((f3 (get self3 1))) term$0)) ('Kind.Term.nat (let ((f3 (get self3 1))) term$0)) ('Kind.Term.chr (let ((f3 (get self3 1))) term$0)) ('Kind.Term.str (let ((f3 (get self3 1))) term$0)) ('Kind.Term.cse (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))(f6 (get self3 4))(f7 (get self3 5))(f8 (get self3 6))) term$0)) ('Kind.Term.ori (let ((f3 (get self3 1))(f4 (get self3 2))) term$0))))))) ('Kind.Term.let (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Kind.Term.reduce (f2 f1) defs$1))) ('Kind.Term.def (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Kind.Term.reduce (f2 f1) defs$1))) ('Kind.Term.ann (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Kind.Term.reduce f1 defs$1))) ('Kind.Term.gol (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) term$0)) ('Kind.Term.hol (let ((f0 (get self0 1))) term$0)) ('Kind.Term.nat (let ((f0 (get self0 1))) ($Kind.Term.reduce ($Kind.Term.unroll_nat f0) defs$1))) ('Kind.Term.chr (let ((f0 (get self0 1))) ($Kind.Term.reduce ($Kind.Term.unroll_chr f0) defs$1))) ('Kind.Term.str (let ((f0 (get self0 1))) ($Kind.Term.reduce ($Kind.Term.unroll_str f0) defs$1))) ('Kind.Term.cse (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))(f5 (get self0 6))) term$0)) ('Kind.Term.ori (let ((f0 (get self0 1))(f1 (get self0 2))) ($Kind.Term.reduce f1 defs$1))))))
(define Kind.Term.reduce (lambda (term$0) (lambda (defs$1) ($Kind.Term.reduce term$0 defs$1))))
(define ($BitsMap.new) (vector 'BitsMap.new))
(define BitsMap.new ($BitsMap.new))
(define ($Kind.Map.new) BitsMap.new)
(define Kind.Map.new ($Kind.Map.new))
(define ($Kind.Term.extract_name term$0) (let ((term$1 ($Kind.Term.reduce term$0 Kind.Map.new))) (let ((self1 term$1)) (case (get self1 0) ('Kind.Term.var (let ((f1 (get self1 1))(f2 (get self1 2))) f1)) ('Kind.Term.ref (let ((f1 (get self1 1))) f1)) ('Kind.Term.typ (let () "self")) ('Kind.Term.all (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))(f4 (get self1 4))(f5 (get self1 5))) "self")) ('Kind.Term.lam (let ((f1 (get self1 1))(f2 (get self1 2))) "self")) ('Kind.Term.app (let ((f1 (get self1 1))(f2 (get self1 2))) "self")) ('Kind.Term.let (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))) "self")) ('Kind.Term.def (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))) "self")) ('Kind.Term.ann (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))) "self")) ('Kind.Term.gol (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))) "self")) ('Kind.Term.hol (let ((f1 (get self1 1))) "self")) ('Kind.Term.nat (let ((f1 (get self1 1))) "self")) ('Kind.Term.chr (let ((f1 (get self1 1))) "self")) ('Kind.Term.str (let ((f1 (get self1 1))) "self")) ('Kind.Term.cse (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))(f4 (get self1 4))(f5 (get self1 5))(f6 (get self1 6))) "self")) ('Kind.Term.ori (let ((f1 (get self1 1))(f2 (get self1 2))) "self"))))))
(define Kind.Term.extract_name (lambda (term$0) ($Kind.Term.extract_name term$0)))
(define ($Kind.Ann.new name$0 term$1 type$2) (vector 'Kind.Ann.new name$0 term$1 type$2))
(define Kind.Ann.new (lambda (name$0) (lambda (term$1) (lambda (type$2) ($Kind.Ann.new name$0 term$1 type$2)))))
(define ($Kind.Parser.case.with) ($Parser.first_of ($List.cons (lambda (idx$0) (lambda (code$1) (let ((self2 ($Kind.Parser.text "with " idx$0 code$1))) (case (get self2 0) ('Parser.Reply.error (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))) ($Parser.Reply.error f2 f3 f4))) ('Parser.Reply.value (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))) ((($Parser.many (lambda (idx$5) (lambda (code$6) (let ((self7 ($Kind.Parser.name1 idx$5 code$6))) (case (get self7 0) ('Parser.Reply.error (let ((f7 (get self7 1))(f8 (get self7 2))(f9 (get self7 3))) ($Parser.Reply.error f7 f8 f9))) ('Parser.Reply.value (let ((f7 (get self7 1))(f8 (get self7 2))(f9 (get self7 3))) (let ((self10 ($Parser.maybe (lambda (idx$10) (lambda (code$11) (let ((self12 ($Kind.Parser.text ":" idx$10 code$11))) (case (get self12 0) ('Parser.Reply.error (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) ($Parser.Reply.error f12 f13 f14))) ('Parser.Reply.value (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) (let ((self15 ($Kind.Parser.term f12 f13))) (case (get self15 0) ('Parser.Reply.error (let ((f15 (get self15 1))(f16 (get self15 2))(f17 (get self15 3))) ($Parser.Reply.error f15 f16 f17))) ('Parser.Reply.value (let ((f15 (get self15 1))(f16 (get self15 2))(f17 (get self15 3))) (let ((self18 ($Parser.maybe (Kind.Parser.text ";") f15 f16))) (case (get self18 0) ('Parser.Reply.error (let ((f18 (get self18 1))(f19 (get self18 2))(f20 (get self18 3))) ($Parser.Reply.error f18 f19 f20))) ('Parser.Reply.value (let ((f18 (get self18 1))(f19 (get self18 2))(f20 (get self18 3))) ($Parser.Reply.value f18 f19 f17))))))))))))))) f7 f8))) (case (get self10 0) ('Parser.Reply.error (let ((f10 (get self10 1))(f11 (get self10 2))(f12 (get self10 3))) ($Parser.Reply.error f10 f11 f12))) ('Parser.Reply.value (let ((f10 (get self10 1))(f11 (get self10 2))(f12 (get self10 3))) ($Parser.Reply.value f10 f11 ($Kind.Ann.new f9 ($Kind.Term.ref f9) f12))))))))))))) f2) f3))))))) ($List.cons (lambda (idx$0) (lambda (code$1) ($Parser.Reply.value idx$0 code$1 List.nil))) List.nil))))
(define Kind.Parser.case.with ($Kind.Parser.case.with))
(define ($Kind.Parser.case.case idx$0 code$1) (let ((self0 ((($Parser.until (Kind.Parser.text ":") Kind.Parser.name1) idx$0) code$1))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ($Kind.Parser.term f0 f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (let ((self6 ($Parser.maybe (Kind.Parser.text ",") f3 f4))) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Parser.Reply.error f6 f7 f8))) ('Parser.Reply.value (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Parser.Reply.value f6 f7 ($Pair.new f2 f5)))))))))))))))
(define Kind.Parser.case.case (lambda (idx$0) (lambda (code$1) ($Kind.Parser.case.case idx$0 code$1))))
(define ($Debug.log s$1 x$2) (x$2 Unit.new))
(define Debug.log (lambda (s$1) (lambda (x$2) ($Debug.log s$1 x$2))))
(define ($Pair.snd pair$2) (let ((self0 pair$2)) (case (get self0 0) ('Pair.new (let ((f0 (get self0 1))(f1 (get self0 2))) f1)))))
(define Pair.snd (lambda (pair$2) ($Pair.snd pair$2)))
(define ($BitsMap.tie val$1 lft$2 rgt$3) (vector 'BitsMap.tie val$1 lft$2 rgt$3))
(define BitsMap.tie (lambda (val$1) (lambda (lft$2) (lambda (rgt$3) ($BitsMap.tie val$1 lft$2 rgt$3)))))
(define ($BitsMap.set bits$1 val$2 map$3) (let ((self0 bits$1)) (case (get self0 0) ('Bits.e (let () (let ((self0 map$3)) (case (get self0 0) ('BitsMap.new (let () ($BitsMap.tie ($Maybe.some val$2) BitsMap.new BitsMap.new))) ('BitsMap.tie (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($BitsMap.tie ($Maybe.some val$2) f1 f2))))))) ('Bits.o (let ((f0 (get self0 1))) (let ((self1 map$3)) (case (get self1 0) ('BitsMap.new (let () ($BitsMap.tie Maybe.none ($BitsMap.set f0 val$2 BitsMap.new) BitsMap.new))) ('BitsMap.tie (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))) ($BitsMap.tie f1 ($BitsMap.set f0 val$2 f2) f3))))))) ('Bits.i (let ((f0 (get self0 1))) (let ((self1 map$3)) (case (get self1 0) ('BitsMap.new (let () ($BitsMap.tie Maybe.none BitsMap.new ($BitsMap.set f0 val$2 BitsMap.new)))) ('BitsMap.tie (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))) ($BitsMap.tie f1 f2 ($BitsMap.set f0 val$2 f3)))))))))))
(define BitsMap.set (lambda (bits$1) (lambda (val$2) (lambda (map$3) ($BitsMap.set bits$1 val$2 map$3)))))
(define ($Kind.Map.set name$1 val$2 map$3) ($BitsMap.set ($Kind.Name.to_bits name$1) val$2 map$3))
(define Kind.Map.set (lambda (name$1) (lambda (val$2) (lambda (map$3) ($Kind.Map.set name$1 val$2 map$3)))))
(define ($Kind.Parser.case.group dflt$0 cses$1) (let ((self0 cses$1)) (case (get self0 0) ('List.nil (let () (let ((self0 dflt$0)) (case (get self0 0) ('Maybe.none (let () Kind.Map.new)) ('Maybe.some (let ((f0 (get self0 1))) ($Kind.Map.set "_" ($List.cons ($Pair.new List.nil f0) List.nil) Kind.Map.new))))))) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((map$4 ($Kind.Parser.case.group dflt$0 f1))) (let ((self3 f0)) (case (get self3 0) ('Pair.new (let ((f3 (get self3 1))(f4 (get self3 2))) (let ((self5 f3)) (case (get self5 0) ('List.nil (let () map$4)) ('List.cons (let ((f5 (get self5 1))(f6 (get self5 2))) (let ((rest$9 ($Maybe.default ($Kind.Map.get f5 map$4) List.nil))) ($Kind.Map.set f5 ($List.cons ($Pair.new f6 f4) rest$9) map$4))))))))))))))))
(define Kind.Parser.case.group (lambda (dflt$0) (lambda (cses$1) ($Kind.Parser.case.group dflt$0 cses$1))))
(define ($Pair.fst pair$2) (let ((self0 pair$2)) (case (get self0 0) ('Pair.new (let ((f0 (get self0 1))(f1 (get self0 2))) f0)))))
(define Pair.fst (lambda (pair$2) ($Pair.fst pair$2)))
(define ($BitsMap.map fn$2 map$3) (let ((self0 map$3)) (case (get self0 0) ('BitsMap.new (let () BitsMap.new)) ('BitsMap.tie (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((val$7 (let ((self3 f0)) (case (get self3 0) ('Maybe.none (let () Maybe.none)) ('Maybe.some (let ((f3 (get self3 1))) ($Maybe.some (fn$2 f3)))))))) (let ((lft$8 ($BitsMap.map fn$2 f1))) (let ((rgt$9 ($BitsMap.map fn$2 f2))) ($BitsMap.tie val$7 lft$8 rgt$9)))))))))
(define BitsMap.map (lambda (fn$2) (lambda (map$3) ($BitsMap.map fn$2 map$3))))
(define ($Kind.Map.map fn$2 map$3) ($BitsMap.map fn$2 map$3))
(define Kind.Map.map (lambda (fn$2) (lambda (map$3) ($Kind.Map.map fn$2 map$3))))
(define ($Kind.Term.cse path$0 expr$1 name$2 with$3 cses$4 moti$5) (vector 'Kind.Term.cse path$0 expr$1 name$2 with$3 cses$4 moti$5))
(define Kind.Term.cse (lambda (path$0) (lambda (expr$1) (lambda (name$2) (lambda (with$3) (lambda (cses$4) (lambda (moti$5) ($Kind.Term.cse path$0 expr$1 name$2 with$3 cses$4 moti$5))))))))
(define ($Kind.Parser.case.build vals$0 wyth$1 cses$2 dflt$3 moti$4 orig$5) (let ((self0 vals$0)) (case (get self0 0) ('List.nil (let () (let ((self0 cses$2)) (case (get self0 0) ('List.nil (let () ($Debug.log ($String.concat "MISSING CASE" String.nil) (lambda ($6) ($Kind.Term.ref "missing_case"))))) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) ($Pair.snd f0))))))) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((group$8 ($Kind.Parser.case.group dflt$3 cses$2))) (let ((name$9 ($Pair.fst f0))) (let ((expr$10 ($Pair.snd f0))) (let ((cses$11 ($Kind.Map.map (lambda (cses$11) ($Kind.Parser.case.build f1 wyth$1 cses$11 dflt$3 moti$4 orig$5)) group$8))) ($Kind.Term.ori orig$5 ($Kind.Term.cse Bits.e expr$10 name$9 wyth$1 cses$11 moti$4)))))))))))
(define Kind.Parser.case.build (lambda (vals$0) (lambda (wyth$1) (lambda (cses$2) (lambda (dflt$3) (lambda (moti$4) (lambda (orig$5) ($Kind.Parser.case.build vals$0 wyth$1 cses$2 dflt$3 moti$4 orig$5))))))))
(define ($Kind.Parser.case idx$0 code$1) (let ((self0 ($Kind.Parser.init idx$0 code$1))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ($Kind.Parser.text "case " f0 f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (let ((self6 ($Parser.many1 (lambda (idx$8) (lambda (code$9) (let ((self8 ($Parser.avoiding (Kind.Parser.text "{") Kind.Parser.term idx$8 code$9))) (case (get self8 0) ('Parser.Reply.error (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))) ($Parser.Reply.error f8 f9 f10))) ('Parser.Reply.value (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))) (let ((self11 ($Parser.maybe (lambda (idx$13) (lambda (code$14) (let ((self13 ($Kind.Parser.text "as" idx$13 code$14))) (case (get self13 0) ('Parser.Reply.error (let ((f13 (get self13 1))(f14 (get self13 2))(f15 (get self13 3))) ($Parser.Reply.error f13 f14 f15))) ('Parser.Reply.value (let ((f13 (get self13 1))(f14 (get self13 2))(f15 (get self13 3))) (let ((self16 ($Kind.Parser.name1 f13 f14))) (case (get self16 0) ('Parser.Reply.error (let ((f16 (get self16 1))(f17 (get self16 2))(f18 (get self16 3))) ($Parser.Reply.error f16 f17 f18))) ('Parser.Reply.value (let ((f16 (get self16 1))(f17 (get self16 2))(f18 (get self16 3))) (let ((self19 ($Parser.maybe (Kind.Parser.text ";") f16 f17))) (case (get self19 0) ('Parser.Reply.error (let ((f19 (get self19 1))(f20 (get self19 2))(f21 (get self19 3))) ($Parser.Reply.error f19 f20 f21))) ('Parser.Reply.value (let ((f19 (get self19 1))(f20 (get self19 2))(f21 (get self19 3))) ($Parser.Reply.value f19 f20 f18))))))))))))))) f8 f9))) (case (get self11 0) ('Parser.Reply.error (let ((f11 (get self11 1))(f12 (get self11 2))(f13 (get self11 3))) ($Parser.Reply.error f11 f12 f13))) ('Parser.Reply.value (let ((f11 (get self11 1))(f12 (get self11 2))(f13 (get self11 3))) (let ((name$16 ($Maybe.default f13 ($Kind.Term.extract_name f10)))) ($Parser.Reply.value f11 f12 ($Pair.new name$16 f10))))))))))))) f3 f4))) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Parser.Reply.error f6 f7 f8))) ('Parser.Reply.value (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) (let ((self9 ((Kind.Parser.case.with f6) f7))) (case (get self9 0) ('Parser.Reply.error (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) ($Parser.Reply.error f9 f10 f11))) ('Parser.Reply.value (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) (let ((self12 ($Kind.Parser.text "{" f9 f10))) (case (get self12 0) ('Parser.Reply.error (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) ($Parser.Reply.error f12 f13 f14))) ('Parser.Reply.value (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) (let ((self15 ((($Parser.until (Kind.Parser.text "}") Kind.Parser.case.case) f12) f13))) (case (get self15 0) ('Parser.Reply.error (let ((f15 (get self15 1))(f16 (get self15 2))(f17 (get self15 3))) ($Parser.Reply.error f15 f16 f17))) ('Parser.Reply.value (let ((f15 (get self15 1))(f16 (get self15 2))(f17 (get self15 3))) (let ((self18 ($Parser.maybe (Kind.Parser.text "!") f15 f16))) (case (get self18 0) ('Parser.Reply.error (let ((f18 (get self18 1))(f19 (get self18 2))(f20 (get self18 3))) ($Parser.Reply.error f18 f19 f20))) ('Parser.Reply.value (let ((f18 (get self18 1))(f19 (get self18 2))(f20 (get self18 3))) (let ((self21 ($Parser.maybe (lambda (idx$23) (lambda (code$24) (let ((self23 ($Kind.Parser.text "default" idx$23 code$24))) (case (get self23 0) ('Parser.Reply.error (let ((f23 (get self23 1))(f24 (get self23 2))(f25 (get self23 3))) ($Parser.Reply.error f23 f24 f25))) ('Parser.Reply.value (let ((f23 (get self23 1))(f24 (get self23 2))(f25 (get self23 3))) (let ((self26 ($Kind.Parser.term f23 f24))) (case (get self26 0) ('Parser.Reply.error (let ((f26 (get self26 1))(f27 (get self26 2))(f28 (get self26 3))) ($Parser.Reply.error f26 f27 f28))) ('Parser.Reply.value (let ((f26 (get self26 1))(f27 (get self26 2))(f28 (get self26 3))) ($Parser.Reply.value f26 f27 f28))))))))))) f18 f19))) (case (get self21 0) ('Parser.Reply.error (let ((f21 (get self21 1))(f22 (get self21 2))(f23 (get self21 3))) ($Parser.Reply.error f21 f22 f23))) ('Parser.Reply.value (let ((f21 (get self21 1))(f22 (get self21 2))(f23 (get self21 3))) (let ((self24 ($Parser.maybe (lambda (idx$26) (lambda (code$27) (let ((self26 ($Kind.Parser.text ":" idx$26 code$27))) (case (get self26 0) ('Parser.Reply.error (let ((f26 (get self26 1))(f27 (get self26 2))(f28 (get self26 3))) ($Parser.Reply.error f26 f27 f28))) ('Parser.Reply.value (let ((f26 (get self26 1))(f27 (get self26 2))(f28 (get self26 3))) ($Kind.Parser.term f26 f27))))))) f21 f22))) (case (get self24 0) ('Parser.Reply.error (let ((f24 (get self24 1))(f25 (get self24 2))(f26 (get self24 3))) ($Parser.Reply.error f24 f25 f26))) ('Parser.Reply.value (let ((f24 (get self24 1))(f25 (get self24 2))(f26 (get self24 3))) (let ((moti$29 (let ((self27 f26)) (case (get self27 0) ('Maybe.none (let () (let ((self27 f20)) (case (get self27 0) ('Maybe.none (let () ($Maybe.some ($Kind.Term.hol Bits.e)))) ('Maybe.some (let ((f27 (get self27 1))) Maybe.none)))))) ('Maybe.some (let ((f27 (get self27 1))) ($Maybe.some f27))))))) (let ((self28 ($Kind.Parser.stop f2 f24 f25))) (case (get self28 0) ('Parser.Reply.error (let ((f28 (get self28 1))(f29 (get self28 2))(f30 (get self28 3))) ($Parser.Reply.error f28 f29 f30))) ('Parser.Reply.value (let ((f28 (get self28 1))(f29 (get self28 2))(f30 (get self28 3))) ($Parser.Reply.value f28 f29 ($Kind.Parser.case.build f8 f11 f17 f23 moti$29 f30))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.case (lambda (idx$0) (lambda (code$1) ($Kind.Parser.case idx$0 code$1))))
(define ($Kind.Parser.open idx$0 code$1) (let ((self0 ($Kind.Parser.init idx$0 code$1))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ($Kind.Parser.text "open " f0 f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (let ((self6 ((Kind.Parser.spaces f3) f4))) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Parser.Reply.error f6 f7 f8))) ('Parser.Reply.value (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) (let ((self9 ($Kind.Parser.term f6 f7))) (case (get self9 0) ('Parser.Reply.error (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) ($Parser.Reply.error f9 f10 f11))) ('Parser.Reply.value (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) (let ((self12 ($Parser.maybe (lambda (idx$14) (lambda (code$15) (let ((self14 ($Kind.Parser.text "as" idx$14 code$15))) (case (get self14 0) ('Parser.Reply.error (let ((f14 (get self14 1))(f15 (get self14 2))(f16 (get self14 3))) ($Parser.Reply.error f14 f15 f16))) ('Parser.Reply.value (let ((f14 (get self14 1))(f15 (get self14 2))(f16 (get self14 3))) ($Kind.Parser.name1 f14 f15))))))) f9 f10))) (case (get self12 0) ('Parser.Reply.error (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) ($Parser.Reply.error f12 f13 f14))) ('Parser.Reply.value (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) (let ((self15 ($Parser.maybe (Kind.Parser.text ";") f12 f13))) (case (get self15 0) ('Parser.Reply.error (let ((f15 (get self15 1))(f16 (get self15 2))(f17 (get self15 3))) ($Parser.Reply.error f15 f16 f17))) ('Parser.Reply.value (let ((f15 (get self15 1))(f16 (get self15 2))(f17 (get self15 3))) (let ((name$20 (let ((self18 f14)) (case (get self18 0) ('Maybe.none (let () (let ((self18 ($Kind.Term.reduce f11 Kind.Map.new))) (case (get self18 0) ('Kind.Term.var (let ((f18 (get self18 1))(f19 (get self18 2))) f18)) ('Kind.Term.ref (let ((f18 (get self18 1))) f18)) ('Kind.Term.typ (let () ($Kind.Name.read "self"))) ('Kind.Term.all (let ((f18 (get self18 1))(f19 (get self18 2))(f20 (get self18 3))(f21 (get self18 4))(f22 (get self18 5))) ($Kind.Name.read "self"))) ('Kind.Term.lam (let ((f18 (get self18 1))(f19 (get self18 2))) ($Kind.Name.read "self"))) ('Kind.Term.app (let ((f18 (get self18 1))(f19 (get self18 2))) ($Kind.Name.read "self"))) ('Kind.Term.let (let ((f18 (get self18 1))(f19 (get self18 2))(f20 (get self18 3))) ($Kind.Name.read "self"))) ('Kind.Term.def (let ((f18 (get self18 1))(f19 (get self18 2))(f20 (get self18 3))) ($Kind.Name.read "self"))) ('Kind.Term.ann (let ((f18 (get self18 1))(f19 (get self18 2))(f20 (get self18 3))) ($Kind.Name.read "self"))) ('Kind.Term.gol (let ((f18 (get self18 1))(f19 (get self18 2))(f20 (get self18 3))) ($Kind.Name.read "self"))) ('Kind.Term.hol (let ((f18 (get self18 1))) ($Kind.Name.read "self"))) ('Kind.Term.nat (let ((f18 (get self18 1))) ($Kind.Name.read "self"))) ('Kind.Term.chr (let ((f18 (get self18 1))) ($Kind.Name.read "self"))) ('Kind.Term.str (let ((f18 (get self18 1))) ($Kind.Name.read "self"))) ('Kind.Term.cse (let ((f18 (get self18 1))(f19 (get self18 2))(f20 (get self18 3))(f21 (get self18 4))(f22 (get self18 5))(f23 (get self18 6))) ($Kind.Name.read "self"))) ('Kind.Term.ori (let ((f18 (get self18 1))(f19 (get self18 2))) ($Kind.Name.read "self"))))))) ('Maybe.some (let ((f18 (get self18 1))) f18)))))) (let ((wyth$21 List.nil)) (let ((self20 ($Kind.Parser.term f15 f16))) (case (get self20 0) ('Parser.Reply.error (let ((f20 (get self20 1))(f21 (get self20 2))(f22 (get self20 3))) ($Parser.Reply.error f20 f21 f22))) ('Parser.Reply.value (let ((f20 (get self20 1))(f21 (get self20 2))(f22 (get self20 3))) (let ((cses$25 ($Kind.Map.set "_" f22 Kind.Map.new))) (let ((moti$26 ($Maybe.some ($Kind.Term.hol Bits.e)))) (let ((self25 ($Kind.Parser.stop f2 f20 f21))) (case (get self25 0) ('Parser.Reply.error (let ((f25 (get self25 1))(f26 (get self25 2))(f27 (get self25 3))) ($Parser.Reply.error f25 f26 f27))) ('Parser.Reply.value (let ((f25 (get self25 1))(f26 (get self25 2))(f27 (get self25 3))) ($Parser.Reply.value f25 f26 ($Kind.Term.ori f27 ($Kind.Term.cse Bits.e f11 name$20 wyth$21 cses$25 moti$26))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.open (lambda (idx$0) (lambda (code$1) ($Kind.Parser.open idx$0 code$1))))
(define ($Kind.Parser.without idx$0 code$1) (let ((self0 ($Kind.Parser.init idx$0 code$1))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ($Kind.Parser.text "without " f0 f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (let ((self6 ($Kind.Parser.name1 f3 f4))) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Parser.Reply.error f6 f7 f8))) ('Parser.Reply.value (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) (let ((self9 ($Kind.Parser.text ":" f6 f7))) (case (get self9 0) ('Parser.Reply.error (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) ($Parser.Reply.error f9 f10 f11))) ('Parser.Reply.value (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) (let ((self12 ($Kind.Parser.term f9 f10))) (case (get self12 0) ('Parser.Reply.error (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) ($Parser.Reply.error f12 f13 f14))) ('Parser.Reply.value (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) (let ((self15 ($Kind.Parser.term f12 f13))) (case (get self15 0) ('Parser.Reply.error (let ((f15 (get self15 1))(f16 (get self15 2))(f17 (get self15 3))) ($Parser.Reply.error f15 f16 f17))) ('Parser.Reply.value (let ((f15 (get self15 1))(f16 (get self15 2))(f17 (get self15 3))) (let ((self18 ($Kind.Parser.stop f2 f15 f16))) (case (get self18 0) ('Parser.Reply.error (let ((f18 (get self18 1))(f19 (get self18 2))(f20 (get self18 3))) ($Parser.Reply.error f18 f19 f20))) ('Parser.Reply.value (let ((f18 (get self18 1))(f19 (get self18 2))(f20 (get self18 3))) (let ((term$23 ($Kind.Term.ref f8))) (let ((term$24 ($Kind.Term.app term$23 ($Kind.Term.lam "" (lambda (x$24) ($Kind.Term.hol Bits.e)))))) (let ((term$25 ($Kind.Term.app term$24 f14))) (let ((term$26 ($Kind.Term.app term$25 ($Kind.Term.lam f8 (lambda (x$26) f17))))) ($Parser.Reply.value f18 f19 ($Kind.Term.ori f20 term$26)))))))))))))))))))))))))))))))))))
(define Kind.Parser.without (lambda (idx$0) (lambda (code$1) ($Kind.Parser.without idx$0 code$1))))
(define ($Kind.Parser.switch.case idx$0 code$1) (let ((self0 ($Kind.Parser.term idx$0 code$1))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ($Kind.Parser.text ":" f0 f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (let ((self6 ($Kind.Parser.term f3 f4))) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Parser.Reply.error f6 f7 f8))) ('Parser.Reply.value (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Parser.Reply.value f6 f7 ($Pair.new f2 f8)))))))))))))))
(define Kind.Parser.switch.case (lambda (idx$0) (lambda (code$1) ($Kind.Parser.switch.case idx$0 code$1))))
(define ($Kind.Parser.switch idx$0 code$1) (let ((self0 ($Kind.Parser.init idx$0 code$1))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ($Kind.Parser.text "switch " f0 f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (let ((self6 ($Kind.Parser.term f3 f4))) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Parser.Reply.error f6 f7 f8))) ('Parser.Reply.value (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) (let ((self9 ($Kind.Parser.text "{" f6 f7))) (case (get self9 0) ('Parser.Reply.error (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) ($Parser.Reply.error f9 f10 f11))) ('Parser.Reply.value (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) (let ((self12 ((($Parser.until (Kind.Parser.text "}") Kind.Parser.switch.case) f9) f10))) (case (get self12 0) ('Parser.Reply.error (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) ($Parser.Reply.error f12 f13 f14))) ('Parser.Reply.value (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) (let ((self15 ($Kind.Parser.text "default " f12 f13))) (case (get self15 0) ('Parser.Reply.error (let ((f15 (get self15 1))(f16 (get self15 2))(f17 (get self15 3))) ($Parser.Reply.error f15 f16 f17))) ('Parser.Reply.value (let ((f15 (get self15 1))(f16 (get self15 2))(f17 (get self15 3))) (let ((self18 ($Kind.Parser.term f15 f16))) (case (get self18 0) ('Parser.Reply.error (let ((f18 (get self18 1))(f19 (get self18 2))(f20 (get self18 3))) ($Parser.Reply.error f18 f19 f20))) ('Parser.Reply.value (let ((f18 (get self18 1))(f19 (get self18 2))(f20 (get self18 3))) (let ((self21 ($Kind.Parser.stop f2 f18 f19))) (case (get self21 0) ('Parser.Reply.error (let ((f21 (get self21 1))(f22 (get self21 2))(f23 (get self21 3))) ($Parser.Reply.error f21 f22 f23))) ('Parser.Reply.value (let ((f21 (get self21 1))(f22 (get self21 2))(f23 (get self21 3))) (let ((term$26 ($List.fold f14 f20 (lambda (cse$26) (lambda (rest$27) (let ((self26 cse$26)) (case (get self26 0) ('Pair.new (let ((f26 (get self26 1))(f27 (get self26 2))) (let ((term$30 ($Kind.Term.app f8 f26))) (let ((term$31 ($Kind.Term.app term$30 ($Kind.Term.lam "" (lambda (x$31) ($Kind.Term.hol Bits.e)))))) (let ((term$32 ($Kind.Term.app term$31 f27))) (let ((term$33 ($Kind.Term.app term$32 rest$27))) term$33))))))))))))) ($Parser.Reply.value f21 f22 ($Kind.Term.ori f23 term$26))))))))))))))))))))))))))))))))))))
(define Kind.Parser.switch (lambda (idx$0) (lambda (code$1) ($Kind.Parser.switch idx$0 code$1))))
(define ($Parser.digit idx$0 code$1) (let ((self0 code$1)) (case (= (string-length self0) 0) (#t (let () ($Parser.Reply.error idx$0 code$1 "Not a digit."))) (#f (let ((f0 (char->integer (string-ref self0 0)))(f1 (let ((_str_ self0)) (substring _str_ 1 (string-length _str_))))) (let ((sidx$4 ($Nat.succ idx$0))) (let ((self3 ($U16.eql f0 48))) (case self3 (#t (let () ($Parser.Reply.value sidx$4 f1 0))) (#f (let () (let ((self3 ($U16.eql f0 49))) (case self3 (#t (let () ($Parser.Reply.value sidx$4 f1 1))) (#f (let () (let ((self3 ($U16.eql f0 50))) (case self3 (#t (let () ($Parser.Reply.value sidx$4 f1 2))) (#f (let () (let ((self3 ($U16.eql f0 51))) (case self3 (#t (let () ($Parser.Reply.value sidx$4 f1 3))) (#f (let () (let ((self3 ($U16.eql f0 52))) (case self3 (#t (let () ($Parser.Reply.value sidx$4 f1 4))) (#f (let () (let ((self3 ($U16.eql f0 53))) (case self3 (#t (let () ($Parser.Reply.value sidx$4 f1 5))) (#f (let () (let ((self3 ($U16.eql f0 54))) (case self3 (#t (let () ($Parser.Reply.value sidx$4 f1 6))) (#f (let () (let ((self3 ($U16.eql f0 55))) (case self3 (#t (let () ($Parser.Reply.value sidx$4 f1 7))) (#f (let () (let ((self3 ($U16.eql f0 56))) (case self3 (#t (let () ($Parser.Reply.value sidx$4 f1 8))) (#f (let () (let ((self3 ($U16.eql f0 57))) (case self3 (#t (let () ($Parser.Reply.value sidx$4 f1 9))) (#f (let () ($Parser.Reply.error idx$0 code$1 "Not a digit.")))))))))))))))))))))))))))))))))))))))))))))))
(define Parser.digit (lambda (idx$0) (lambda (code$1) ($Parser.digit idx$0 code$1))))
(define ($Nat.add n$0 m$1) (+ n$0 m$1))
(define Nat.add (lambda (n$0) (lambda (m$1) ($Nat.add n$0 m$1))))
(define ($Nat.mul n$0 m$1) (* n$0 m$1))
(define Nat.mul (lambda (n$0) (lambda (m$1) ($Nat.mul n$0 m$1))))
(define ($Nat.from_base.go b$0 ds$1 p$2 res$3) (let ((self0 ds$1)) (case (get self0 0) ('List.nil (let () res$3)) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) ($Nat.from_base.go b$0 f1 ($Nat.mul b$0 p$2) ($Nat.add ($Nat.mul f0 p$2) res$3)))))))
(define Nat.from_base.go (lambda (b$0) (lambda (ds$1) (lambda (p$2) (lambda (res$3) ($Nat.from_base.go b$0 ds$1 p$2 res$3))))))
(define ($Nat.from_base base$0 ds$1) ($Nat.from_base.go base$0 ($List.reverse ds$1) 1 0))
(define Nat.from_base (lambda (base$0) (lambda (ds$1) ($Nat.from_base base$0 ds$1))))
(define ($Parser.nat idx$0 code$1) (let ((self0 ($Parser.many1 Parser.digit idx$0 code$1))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.value f0 f1 ($Nat.from_base 10 f2)))))))
(define Parser.nat (lambda (idx$0) (lambda (code$1) ($Parser.nat idx$0 code$1))))
(define ($Bits.reverse.tco a$0 r$1) (let ((self0 a$0)) (case (get self0 0) ('Bits.e (let () r$1)) ('Bits.o (let ((f0 (get self0 1))) ($Bits.reverse.tco f0 ($Bits.o r$1)))) ('Bits.i (let ((f0 (get self0 1))) ($Bits.reverse.tco f0 ($Bits.i r$1)))))))
(define Bits.reverse.tco (lambda (a$0) (lambda (r$1) ($Bits.reverse.tco a$0 r$1))))
(define ($Bits.reverse a$0) ($Bits.reverse.tco a$0 Bits.e))
(define Bits.reverse (lambda (a$0) ($Bits.reverse a$0)))
(define ($Bits.tail a$0) (let ((self0 a$0)) (case (get self0 0) ('Bits.e (let () Bits.e)) ('Bits.o (let ((f0 (get self0 1))) f0)) ('Bits.i (let ((f0 (get self0 1))) f0)))))
(define Bits.tail (lambda (a$0) ($Bits.tail a$0)))
(define ($Bits.inc a$0) (let ((self0 a$0)) (case (get self0 0) ('Bits.e (let () ($Bits.i Bits.e))) ('Bits.o (let ((f0 (get self0 1))) ($Bits.i f0))) ('Bits.i (let ((f0 (get self0 1))) ($Bits.o ($Bits.inc f0)))))))
(define Bits.inc (lambda (a$0) ($Bits.inc a$0)))
(define ($Nat.to_bits n$0) (let ((self0 n$0)) (case (= self0 0) (#t (let () ($Bits.o Bits.e))) (#f (let ((f0 (- self0 1))) ($Bits.inc ($Nat.to_bits f0)))))))
(define Nat.to_bits (lambda (n$0) ($Nat.to_bits n$0)))
(define ($Maybe.is_some m$1) (let ((self0 m$1)) (case (get self0 0) ('Maybe.none (let () Bool.false)) ('Maybe.some (let ((f0 (get self0 1))) Bool.true)))))
(define Maybe.is_some (lambda (m$1) ($Maybe.is_some m$1)))
(define ($Kind.Term.gol name$0 dref$1 verb$2) (vector 'Kind.Term.gol name$0 dref$1 verb$2))
(define Kind.Term.gol (lambda (name$0) (lambda (dref$1) (lambda (verb$2) ($Kind.Term.gol name$0 dref$1 verb$2)))))
(define ($Kind.Parser.goal idx$0 code$1) (let ((self0 ($Kind.Parser.init idx$0 code$1))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ($Kind.Parser.text "?" f0 f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (let ((self6 ($Kind.Parser.name f3 f4))) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Parser.Reply.error f6 f7 f8))) ('Parser.Reply.value (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) (let ((self9 ((($Parser.many (lambda (idx$11) (lambda (code$12) (let ((self11 ($Kind.Parser.text "-" idx$11 code$12))) (case (get self11 0) ('Parser.Reply.error (let ((f11 (get self11 1))(f12 (get self11 2))(f13 (get self11 3))) ($Parser.Reply.error f11 f12 f13))) ('Parser.Reply.value (let ((f11 (get self11 1))(f12 (get self11 2))(f13 (get self11 3))) (let ((self14 ($Parser.nat f11 f12))) (case (get self14 0) ('Parser.Reply.error (let ((f14 (get self14 1))(f15 (get self14 2))(f16 (get self14 3))) ($Parser.Reply.error f14 f15 f16))) ('Parser.Reply.value (let ((f14 (get self14 1))(f15 (get self14 2))(f16 (get self14 3))) (let ((bits$19 ($Bits.reverse ($Bits.tail ($Bits.reverse ($Nat.to_bits f16)))))) ($Parser.Reply.value f14 f15 bits$19))))))))))))) f6) f7))) (case (get self9 0) ('Parser.Reply.error (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) ($Parser.Reply.error f9 f10 f11))) ('Parser.Reply.value (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) (let ((self12 (let ((self12 ($Parser.maybe (Parser.text "-") f9 f10))) (case (get self12 0) ('Parser.Reply.error (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) ($Parser.Reply.error f12 f13 f14))) ('Parser.Reply.value (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) ($Parser.Reply.value f12 f13 ($Maybe.is_some f14)))))))) (case (get self12 0) ('Parser.Reply.error (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) ($Parser.Reply.error f12 f13 f14))) ('Parser.Reply.value (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) (let ((self15 ($Kind.Parser.stop f2 f12 f13))) (case (get self15 0) ('Parser.Reply.error (let ((f15 (get self15 1))(f16 (get self15 2))(f17 (get self15 3))) ($Parser.Reply.error f15 f16 f17))) ('Parser.Reply.value (let ((f15 (get self15 1))(f16 (get self15 2))(f17 (get self15 3))) ($Parser.Reply.value f15 f16 ($Kind.Term.ori f17 ($Kind.Term.gol f8 f11 f14))))))))))))))))))))))))))))
(define Kind.Parser.goal (lambda (idx$0) (lambda (code$1) ($Kind.Parser.goal idx$0 code$1))))
(define ($Kind.Parser.hole idx$0 code$1) (let ((self0 ($Kind.Parser.init idx$0 code$1))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ($Kind.Parser.text "_" f0 f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (let ((self6 ($Kind.Parser.stop f2 f3 f4))) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Parser.Reply.error f6 f7 f8))) ('Parser.Reply.value (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Parser.Reply.value f6 f7 ($Kind.Term.ori f8 ($Kind.Term.hol Bits.e))))))))))))))))
(define Kind.Parser.hole (lambda (idx$0) (lambda (code$1) ($Kind.Parser.hole idx$0 code$1))))
(define ($Bool.or a$0 b$1) (or a$0 b$1))
(define Bool.or (lambda (a$0) (lambda (b$1) ($Bool.or a$0 b$1))))
(define ($Kind.Parser.float.sign idx$0 code$1) (let ((self0 code$1)) (case (= (string-length self0) 0) (#t (let () ($Parser.Reply.error idx$0 code$1 "Expected '+' or '-'."))) (#f (let ((f0 (char->integer (string-ref self0 0)))(f1 (let ((_str_ self0)) (substring _str_ 1 (string-length _str_))))) (let ((sidx$4 ($Nat.succ idx$0))) (let ((self3 ($Bool.or ($U16.eql f0 43) ($U16.eql f0 45)))) (case self3 (#t (let () ($Parser.Reply.value sidx$4 f1 f0))) (#f (let () ($Parser.Reply.error idx$0 code$1 "Expected '+' ou '-'.")))))))))))
(define Kind.Parser.float.sign (lambda (idx$0) (lambda (code$1) ($Kind.Parser.float.sign idx$0 code$1))))
(define ($List.any cond$1 list$2) (let ((self0 list$2)) (case (get self0 0) ('List.nil (let () Bool.false)) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 (cond$1 f0))) (case self2 (#t (let () Bool.true)) (#f (let () ($List.any cond$1 f1))))))))))
(define List.any (lambda (cond$1) (lambda (list$2) ($List.any cond$1 list$2))))
(define ($Kind.Parser.float.str_digit idx$0 code$1) (let ((self0 code$1)) (case (= (string-length self0) 0) (#t (let () ($Parser.Reply.error idx$0 code$1 "Not a digit."))) (#f (let ((f0 (char->integer (string-ref self0 0)))(f1 (let ((_str_ self0)) (substring _str_ 1 (string-length _str_))))) (let ((sidx$4 ($Nat.succ idx$0))) (let ((digits$5 ($List.cons 48 ($List.cons 49 ($List.cons 50 ($List.cons 51 ($List.cons 52 ($List.cons 52 ($List.cons 53 ($List.cons 54 ($List.cons 55 ($List.cons 56 ($List.cons 57 List.nil))))))))))))) (let ((self4 ($List.any (U16.eql f0) digits$5))) (case self4 (#t (let () ($Parser.Reply.value sidx$4 f1 f0))) (#f (let () ($Parser.Reply.error idx$0 code$1 "Not a digit."))))))))))))
(define Kind.Parser.float.str_digit (lambda (idx$0) (lambda (code$1) ($Kind.Parser.float.str_digit idx$0 code$1))))
(define ($String.from_list xs$0) (let ((self0 xs$0)) (case (get self0 0) ('List.nil (let () String.nil)) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) ($String.cons f0 ($String.from_list f1)))))))
(define String.from_list (lambda (xs$0) ($String.from_list xs$0)))
(define ($Kind.Parser.float.64 idx$0 code$1) (let ((self0 ($Kind.Parser.init idx$0 code$1))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ($Parser.maybe Kind.Parser.float.sign f0 f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (let ((sign$8 ($Maybe.default f5 43))) (let ((self7 ($Parser.many1 Kind.Parser.float.str_digit f3 f4))) (case (get self7 0) ('Parser.Reply.error (let ((f7 (get self7 1))(f8 (get self7 2))(f9 (get self7 3))) ($Parser.Reply.error f7 f8 f9))) ('Parser.Reply.value (let ((f7 (get self7 1))(f8 (get self7 2))(f9 (get self7 3))) (let ((self10 ($Parser.text "." f7 f8))) (case (get self10 0) ('Parser.Reply.error (let ((f10 (get self10 1))(f11 (get self10 2))(f12 (get self10 3))) ($Parser.Reply.error f10 f11 f12))) ('Parser.Reply.value (let ((f10 (get self10 1))(f11 (get self10 2))(f12 (get self10 3))) (let ((self13 ($Parser.many1 Kind.Parser.float.str_digit f10 f11))) (case (get self13 0) ('Parser.Reply.error (let ((f13 (get self13 1))(f14 (get self13 2))(f15 (get self13 3))) ($Parser.Reply.error f13 f14 f15))) ('Parser.Reply.value (let ((f13 (get self13 1))(f14 (get self13 2))(f15 (get self13 3))) (let ((self16 ($Parser.text "#64" f13 f14))) (case (get self16 0) ('Parser.Reply.error (let ((f16 (get self16 1))(f17 (get self16 2))(f18 (get self16 3))) ($Parser.Reply.error f16 f17 f18))) ('Parser.Reply.value (let ((f16 (get self16 1))(f17 (get self16 2))(f18 (get self16 3))) (let ((float_str$21 ($Kind.Term.str ($String.concat ($String.cons sign$8 ($String.from_list f9)) ($String.concat "." ($String.from_list f15)))))) (let ((conv$22 ($Kind.Term.ref "F64.parse"))) (let ((term$23 ($Kind.Term.app conv$22 float_str$21))) (let ((self22 ($Kind.Parser.stop f2 f16 f17))) (case (get self22 0) ('Parser.Reply.error (let ((f22 (get self22 1))(f23 (get self22 2))(f24 (get self22 3))) ($Parser.Reply.error f22 f23 f24))) ('Parser.Reply.value (let ((f22 (get self22 1))(f23 (get self22 2))(f24 (get self22 3))) ($Parser.Reply.value f22 f23 ($Kind.Term.ori f24 term$23)))))))))))))))))))))))))))))))))))
(define Kind.Parser.float.64 (lambda (idx$0) (lambda (code$1) ($Kind.Parser.float.64 idx$0 code$1))))
(define ($Kind.Parser.float.32 idx$0 code$1) (let ((self0 ($Kind.Parser.init idx$0 code$1))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ($Parser.maybe Kind.Parser.float.sign f0 f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (let ((sign$8 ($Maybe.default f5 43))) (let ((self7 ($Parser.many1 Kind.Parser.float.str_digit f3 f4))) (case (get self7 0) ('Parser.Reply.error (let ((f7 (get self7 1))(f8 (get self7 2))(f9 (get self7 3))) ($Parser.Reply.error f7 f8 f9))) ('Parser.Reply.value (let ((f7 (get self7 1))(f8 (get self7 2))(f9 (get self7 3))) (let ((self10 ($Parser.text "." f7 f8))) (case (get self10 0) ('Parser.Reply.error (let ((f10 (get self10 1))(f11 (get self10 2))(f12 (get self10 3))) ($Parser.Reply.error f10 f11 f12))) ('Parser.Reply.value (let ((f10 (get self10 1))(f11 (get self10 2))(f12 (get self10 3))) (let ((self13 ($Parser.many1 Kind.Parser.float.str_digit f10 f11))) (case (get self13 0) ('Parser.Reply.error (let ((f13 (get self13 1))(f14 (get self13 2))(f15 (get self13 3))) ($Parser.Reply.error f13 f14 f15))) ('Parser.Reply.value (let ((f13 (get self13 1))(f14 (get self13 2))(f15 (get self13 3))) (let ((self16 ($Parser.text "#32" f13 f14))) (case (get self16 0) ('Parser.Reply.error (let ((f16 (get self16 1))(f17 (get self16 2))(f18 (get self16 3))) ($Parser.Reply.error f16 f17 f18))) ('Parser.Reply.value (let ((f16 (get self16 1))(f17 (get self16 2))(f18 (get self16 3))) (let ((float_str$21 ($Kind.Term.str ($String.concat ($String.cons sign$8 ($String.from_list f9)) ($String.concat "." ($String.from_list f15)))))) (let ((conv$22 ($Kind.Term.ref "F32.parse"))) (let ((term$23 ($Kind.Term.app conv$22 float_str$21))) (let ((self22 ($Kind.Parser.stop f2 f16 f17))) (case (get self22 0) ('Parser.Reply.error (let ((f22 (get self22 1))(f23 (get self22 2))(f24 (get self22 3))) ($Parser.Reply.error f22 f23 f24))) ('Parser.Reply.value (let ((f22 (get self22 1))(f23 (get self22 2))(f24 (get self22 3))) ($Parser.Reply.value f22 f23 ($Kind.Term.ori f24 term$23)))))))))))))))))))))))))))))))))))
(define Kind.Parser.float.32 (lambda (idx$0) (lambda (code$1) ($Kind.Parser.float.32 idx$0 code$1))))
(define ($Either.left value$2) (vector 'Either.left value$2))
(define Either.left (lambda (value$2) ($Either.left value$2)))
(define ($Either.right value$2) (vector 'Either.right value$2))
(define Either.right (lambda (value$2) ($Either.right value$2)))
(define ($Nat.sub_rem n$0 m$1) (let ((self0 m$1)) (case (= self0 0) (#t (let () ($Either.left n$0))) (#f (let ((f0 (- self0 1))) (let ((self1 n$0)) (case (= self1 0) (#t (let () ($Either.right ($Nat.succ f0)))) (#f (let ((f1 (- self1 1))) ($Nat.sub_rem f1 f0))))))))))
(define Nat.sub_rem (lambda (n$0) (lambda (m$1) ($Nat.sub_rem n$0 m$1))))
(define ($Nat.div_mod.go n$0 m$1 d$2) (let ((self0 ($Nat.sub_rem n$0 m$1))) (case (get self0 0) ('Either.left (let ((f0 (get self0 1))) ($Nat.div_mod.go f0 m$1 ($Nat.succ d$2)))) ('Either.right (let ((f0 (get self0 1))) ($Pair.new d$2 n$0))))))
(define Nat.div_mod.go (lambda (n$0) (lambda (m$1) (lambda (d$2) ($Nat.div_mod.go n$0 m$1 d$2)))))
(define ($Nat.div_mod n$0 m$1) ($Nat.div_mod.go n$0 m$1 Nat.zero))
(define Nat.div_mod (lambda (n$0) (lambda (m$1) ($Nat.div_mod n$0 m$1))))
(define ($Nat.to_base.go base$0 nat$1 res$2) (let ((self0 ($Nat.div_mod nat$1 base$0))) (case (get self0 0) ('Pair.new (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 f0)) (case (= self2 0) (#t (let () ($List.cons f1 res$2))) (#f (let ((f2 (- self2 1))) ($Nat.to_base.go base$0 f0 ($List.cons f1 res$2)))))))))))
(define Nat.to_base.go (lambda (base$0) (lambda (nat$1) (lambda (res$2) ($Nat.to_base.go base$0 nat$1 res$2)))))
(define ($Nat.to_base base$0 nat$1) ($Nat.to_base.go base$0 nat$1 List.nil))
(define Nat.to_base (lambda (base$0) (lambda (nat$1) ($Nat.to_base base$0 nat$1))))
(define ($Nat.mod.go n$0 m$1 r$2) (let ((self0 m$1)) (case (= self0 0) (#t (let () ($Nat.mod.go n$0 r$2 m$1))) (#f (let ((f0 (- self0 1))) (let ((self1 n$0)) (case (= self1 0) (#t (let () r$2)) (#f (let ((f1 (- self1 1))) ($Nat.mod.go f1 f0 ($Nat.succ r$2)))))))))))
(define Nat.mod.go (lambda (n$0) (lambda (m$1) (lambda (r$2) ($Nat.mod.go n$0 m$1 r$2)))))
(define ($Nat.mod n$0 m$1) (mod n$0 m$1))
(define Nat.mod (lambda (n$0) (lambda (m$1) ($Nat.mod n$0 m$1))))
(define ($Nat.lte n$0 m$1) (<= n$0 m$1))
(define Nat.lte (lambda (n$0) (lambda (m$1) ($Nat.lte n$0 m$1))))
(define ($List.at index$1 list$2) (let ((self0 list$2)) (case (get self0 0) ('List.nil (let () Maybe.none)) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 index$1)) (case (= self2 0) (#t (let () ($Maybe.some f0))) (#f (let ((f2 (- self2 1))) ($List.at f2 f1))))))))))
(define List.at (lambda (index$1) (lambda (list$2) ($List.at index$1 list$2))))
(define ($Nat.show_digit base$0 n$1) (let ((m$2 ($Nat.mod n$1 base$0))) (let ((base64$3 ($List.cons 48 ($List.cons 49 ($List.cons 50 ($List.cons 51 ($List.cons 52 ($List.cons 53 ($List.cons 54 ($List.cons 55 ($List.cons 56 ($List.cons 57 ($List.cons 65 ($List.cons 66 ($List.cons 67 ($List.cons 68 ($List.cons 69 ($List.cons 70 ($List.cons 71 ($List.cons 72 ($List.cons 73 ($List.cons 74 ($List.cons 75 ($List.cons 76 ($List.cons 77 ($List.cons 78 ($List.cons 79 ($List.cons 80 ($List.cons 81 ($List.cons 82 ($List.cons 83 ($List.cons 84 ($List.cons 85 ($List.cons 86 ($List.cons 87 ($List.cons 88 ($List.cons 89 ($List.cons 90 ($List.cons 97 ($List.cons 98 ($List.cons 99 ($List.cons 100 ($List.cons 101 ($List.cons 102 ($List.cons 103 ($List.cons 104 ($List.cons 105 ($List.cons 106 ($List.cons 107 ($List.cons 108 ($List.cons 109 ($List.cons 110 ($List.cons 111 ($List.cons 112 ($List.cons 113 ($List.cons 114 ($List.cons 115 ($List.cons 116 ($List.cons 117 ($List.cons 118 ($List.cons 119 ($List.cons 120 ($List.cons 121 ($List.cons 122 ($List.cons 43 ($List.cons 47 List.nil)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) (let ((self2 ($Bool.and ($Nat.gtn base$0 0) ($Nat.lte base$0 64)))) (case self2 (#t (let () (let ((self2 ($List.at m$2 base64$3))) (case (get self2 0) ('Maybe.none (let () 35)) ('Maybe.some (let ((f2 (get self2 1))) f2)))))) (#f (let () 35)))))))
(define Nat.show_digit (lambda (base$0) (lambda (n$1) ($Nat.show_digit base$0 n$1))))
(define ($Nat.to_string_base base$0 nat$1) ($List.fold ($Nat.to_base base$0 nat$1) String.nil (lambda (n$2) (lambda (str$3) ($String.cons ($Nat.show_digit base$0 n$2) str$3)))))
(define Nat.to_string_base (lambda (base$0) (lambda (nat$1) ($Nat.to_string_base base$0 nat$1))))
(define ($Nat.show n$0) (number->string n$0))
(define Nat.show (lambda (n$0) ($Nat.show n$0)))
(define ($Kind.Parser.int_pos idx$0 code$1) (let ((self0 ($Parser.text "+" idx$0 code$1))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ($Parser.many1 Parser.digit f0 f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.value f3 f4 ($Pair.new Bool.true ($Nat.from_base 10 f5))))))))))))
(define Kind.Parser.int_pos (lambda (idx$0) (lambda (code$1) ($Kind.Parser.int_pos idx$0 code$1))))
(define ($Kind.Parser.int_neg idx$0 code$1) (let ((self0 ($Parser.text "-" idx$0 code$1))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ($Parser.many1 Parser.digit f0 f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.value f3 f4 ($Pair.new Bool.false ($Nat.from_base 10 f5))))))))))))
(define Kind.Parser.int_neg (lambda (idx$0) (lambda (code$1) ($Kind.Parser.int_neg idx$0 code$1))))
(define ($Kind.Parser.int idx$0 code$1) (let ((self0 ($Kind.Parser.init idx$0 code$1))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ((Kind.Parser.spaces f0) f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (let ((self6 ((($Parser.first_of ($List.cons Kind.Parser.int_pos ($List.cons Kind.Parser.int_neg List.nil))) f3) f4))) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Parser.Reply.error f6 f7 f8))) ('Parser.Reply.value (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) (let ((term$11 (let ((self9 f8)) (case (get self9 0) ('Pair.new (let ((f9 (get self9 1))(f10 (get self9 2))) (let ((ret$13 ($Kind.Term.ref "Int.from_nat"))) (let ((ret$14 ($Kind.Term.app ret$13 ($Kind.Term.nat f10)))) (let ((self13 f9)) (case self13 (#t (let () ret$14)) (#f (let () (let ((inv$15 ($Kind.Term.ref "Int.neg"))) ($Kind.Term.app inv$15 ret$14)))))))))))))) (let ((self10 ($Kind.Parser.stop f2 f6 f7))) (case (get self10 0) ('Parser.Reply.error (let ((f10 (get self10 1))(f11 (get self10 2))(f12 (get self10 3))) ($Parser.Reply.error f10 f11 f12))) ('Parser.Reply.value (let ((f10 (get self10 1))(f11 (get self10 2))(f12 (get self10 3))) ($Parser.Reply.value f10 f11 ($Kind.Term.ori f12 term$11))))))))))))))))))))
(define Kind.Parser.int (lambda (idx$0) (lambda (code$1) ($Kind.Parser.int idx$0 code$1))))
(define ($Kind.Parser.machine_integer.signed size$0) (let ((size_str$1 ($Nat.show size$0))) (lambda (idx$2) (lambda (code$3) (let ((self3 ($Kind.Parser.init idx$2 code$3))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (let ((self6 ((Kind.Parser.spaces f3) f4))) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Parser.Reply.error f6 f7 f8))) ('Parser.Reply.value (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) (let ((self9 ($Kind.Parser.int f6 f7))) (case (get self9 0) ('Parser.Reply.error (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) ($Parser.Reply.error f9 f10 f11))) ('Parser.Reply.value (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) (let ((self12 ($Parser.text ($String.concat "#" size_str$1) f9 f10))) (case (get self12 0) ('Parser.Reply.error (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) ($Parser.Reply.error f12 f13 f14))) ('Parser.Reply.value (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) (let ((term$16 ($Kind.Term.ref ($String.concat "Int.to_i" size_str$1)))) (let ((term$17 ($Kind.Term.app term$16 f11))) (let ((self17 ($Kind.Parser.stop f5 f12 f13))) (case (get self17 0) ('Parser.Reply.error (let ((f17 (get self17 1))(f18 (get self17 2))(f19 (get self17 3))) ($Parser.Reply.error f17 f18 f19))) ('Parser.Reply.value (let ((f17 (get self17 1))(f18 (get self17 2))(f19 (get self17 3))) ($Parser.Reply.value f17 f18 ($Kind.Term.ori f19 term$17))))))))))))))))))))))))))))
(define Kind.Parser.machine_integer.signed (lambda (size$0) ($Kind.Parser.machine_integer.signed size$0)))
(define ($Parser.hex_digit idx$0 code$1) (let ((self0 code$1)) (case (= (string-length self0) 0) (#t (let () ($Parser.Reply.error idx$0 code$1 "Not a digit."))) (#f (let ((f0 (char->integer (string-ref self0 0)))(f1 (let ((_str_ self0)) (substring _str_ 1 (string-length _str_))))) (let ((sidx$4 ($Nat.succ idx$0))) (let ((self3 ($U16.eql f0 48))) (case self3 (#t (let () ($Parser.Reply.value sidx$4 f1 0))) (#f (let () (let ((self3 ($U16.eql f0 49))) (case self3 (#t (let () ($Parser.Reply.value sidx$4 f1 1))) (#f (let () (let ((self3 ($U16.eql f0 50))) (case self3 (#t (let () ($Parser.Reply.value sidx$4 f1 2))) (#f (let () (let ((self3 ($U16.eql f0 51))) (case self3 (#t (let () ($Parser.Reply.value sidx$4 f1 3))) (#f (let () (let ((self3 ($U16.eql f0 52))) (case self3 (#t (let () ($Parser.Reply.value sidx$4 f1 4))) (#f (let () (let ((self3 ($U16.eql f0 53))) (case self3 (#t (let () ($Parser.Reply.value sidx$4 f1 5))) (#f (let () (let ((self3 ($U16.eql f0 54))) (case self3 (#t (let () ($Parser.Reply.value sidx$4 f1 6))) (#f (let () (let ((self3 ($U16.eql f0 55))) (case self3 (#t (let () ($Parser.Reply.value sidx$4 f1 7))) (#f (let () (let ((self3 ($U16.eql f0 56))) (case self3 (#t (let () ($Parser.Reply.value sidx$4 f1 8))) (#f (let () (let ((self3 ($U16.eql f0 57))) (case self3 (#t (let () ($Parser.Reply.value sidx$4 f1 9))) (#f (let () (let ((self3 ($U16.eql f0 97))) (case self3 (#t (let () ($Parser.Reply.value sidx$4 f1 10))) (#f (let () (let ((self3 ($U16.eql f0 98))) (case self3 (#t (let () ($Parser.Reply.value sidx$4 f1 11))) (#f (let () (let ((self3 ($U16.eql f0 99))) (case self3 (#t (let () ($Parser.Reply.value sidx$4 f1 12))) (#f (let () (let ((self3 ($U16.eql f0 100))) (case self3 (#t (let () ($Parser.Reply.value sidx$4 f1 13))) (#f (let () (let ((self3 ($U16.eql f0 101))) (case self3 (#t (let () ($Parser.Reply.value sidx$4 f1 14))) (#f (let () (let ((self3 ($U16.eql f0 102))) (case self3 (#t (let () ($Parser.Reply.value sidx$4 f1 15))) (#f (let () (let ((self3 ($U16.eql f0 65))) (case self3 (#t (let () ($Parser.Reply.value sidx$4 f1 10))) (#f (let () (let ((self3 ($U16.eql f0 66))) (case self3 (#t (let () ($Parser.Reply.value sidx$4 f1 11))) (#f (let () (let ((self3 ($U16.eql f0 67))) (case self3 (#t (let () ($Parser.Reply.value sidx$4 f1 12))) (#f (let () (let ((self3 ($U16.eql f0 68))) (case self3 (#t (let () ($Parser.Reply.value sidx$4 f1 13))) (#f (let () (let ((self3 ($U16.eql f0 69))) (case self3 (#t (let () ($Parser.Reply.value sidx$4 f1 14))) (#f (let () (let ((self3 ($U16.eql f0 70))) (case self3 (#t (let () ($Parser.Reply.value sidx$4 f1 15))) (#f (let () ($Parser.Reply.error idx$0 code$1 "Not a digit.")))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(define Parser.hex_digit (lambda (idx$0) (lambda (code$1) ($Parser.hex_digit idx$0 code$1))))
(define ($Parser.hex_nat idx$0 code$1) (let ((self0 ($Parser.text "0x" idx$0 code$1))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ($Parser.many1 Parser.hex_digit f0 f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.value f3 f4 ($Nat.from_base 16 f5)))))))))))
(define Parser.hex_nat (lambda (idx$0) (lambda (code$1) ($Parser.hex_nat idx$0 code$1))))
(define ($Kind.Parser.nat idx$0 code$1) (let ((self0 ($Kind.Parser.init idx$0 code$1))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ((Kind.Parser.spaces f0) f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (let ((self6 ((($Parser.first_of ($List.cons Parser.hex_nat ($List.cons Parser.nat List.nil))) f3) f4))) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Parser.Reply.error f6 f7 f8))) ('Parser.Reply.value (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) (let ((self9 ($Kind.Parser.stop f2 f6 f7))) (case (get self9 0) ('Parser.Reply.error (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) ($Parser.Reply.error f9 f10 f11))) ('Parser.Reply.value (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) ($Parser.Reply.value f9 f10 ($Kind.Term.ori f11 ($Kind.Term.nat f8))))))))))))))))))))
(define Kind.Parser.nat (lambda (idx$0) (lambda (code$1) ($Kind.Parser.nat idx$0 code$1))))
(define ($Kind.Parser.machine_integer.unsigned size$0) (let ((size_str$1 ($Nat.show size$0))) (lambda (idx$2) (lambda (code$3) (let ((self3 ($Kind.Parser.init idx$2 code$3))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (let ((self6 ((Kind.Parser.spaces f3) f4))) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Parser.Reply.error f6 f7 f8))) ('Parser.Reply.value (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) (let ((self9 ($Kind.Parser.nat f6 f7))) (case (get self9 0) ('Parser.Reply.error (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) ($Parser.Reply.error f9 f10 f11))) ('Parser.Reply.value (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) (let ((self12 ($Parser.text ($String.concat "#" ($Nat.show size$0)) f9 f10))) (case (get self12 0) ('Parser.Reply.error (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) ($Parser.Reply.error f12 f13 f14))) ('Parser.Reply.value (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) (let ((term$16 ($Kind.Term.ref ($String.concat "Nat.to_u" ($Nat.show size$0))))) (let ((term$17 ($Kind.Term.app term$16 f11))) (let ((self17 ($Kind.Parser.stop f5 f12 f13))) (case (get self17 0) ('Parser.Reply.error (let ((f17 (get self17 1))(f18 (get self17 2))(f19 (get self17 3))) ($Parser.Reply.error f17 f18 f19))) ('Parser.Reply.value (let ((f17 (get self17 1))(f18 (get self17 2))(f19 (get self17 3))) ($Parser.Reply.value f17 f18 ($Kind.Term.ori f19 term$17))))))))))))))))))))))))))))
(define Kind.Parser.machine_integer.unsigned (lambda (size$0) ($Kind.Parser.machine_integer.unsigned size$0)))
(define ($Kind.Parser.u64 idx$0 code$1) (let ((self0 ($Kind.Parser.init idx$0 code$1))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ((Kind.Parser.spaces f0) f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (let ((self6 ($Parser.nat f3 f4))) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Parser.Reply.error f6 f7 f8))) ('Parser.Reply.value (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) (let ((self9 ($Parser.text "l" f6 f7))) (case (get self9 0) ('Parser.Reply.error (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) ($Parser.Reply.error f9 f10 f11))) ('Parser.Reply.value (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) (let ((term$14 ($Kind.Term.ref "Nat.to_u64"))) (let ((term$15 ($Kind.Term.app term$14 ($Kind.Term.nat f8)))) (let ((self14 ($Kind.Parser.stop f2 f9 f10))) (case (get self14 0) ('Parser.Reply.error (let ((f14 (get self14 1))(f15 (get self14 2))(f16 (get self14 3))) ($Parser.Reply.error f14 f15 f16))) ('Parser.Reply.value (let ((f14 (get self14 1))(f15 (get self14 2))(f16 (get self14 3))) ($Parser.Reply.value f14 f15 ($Kind.Term.ori f16 term$15)))))))))))))))))))))))))
(define Kind.Parser.u64 (lambda (idx$0) (lambda (code$1) ($Kind.Parser.u64 idx$0 code$1))))
(define ($Kind.Parser.u32 idx$0 code$1) (let ((self0 ($Kind.Parser.init idx$0 code$1))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ((Kind.Parser.spaces f0) f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (let ((self6 ($Parser.nat f3 f4))) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Parser.Reply.error f6 f7 f8))) ('Parser.Reply.value (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) (let ((self9 ($Parser.text "u" f6 f7))) (case (get self9 0) ('Parser.Reply.error (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) ($Parser.Reply.error f9 f10 f11))) ('Parser.Reply.value (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) (let ((term$14 ($Kind.Term.ref "Nat.to_u32"))) (let ((term$15 ($Kind.Term.app term$14 ($Kind.Term.nat f8)))) (let ((self14 ($Kind.Parser.stop f2 f9 f10))) (case (get self14 0) ('Parser.Reply.error (let ((f14 (get self14 1))(f15 (get self14 2))(f16 (get self14 3))) ($Parser.Reply.error f14 f15 f16))) ('Parser.Reply.value (let ((f14 (get self14 1))(f15 (get self14 2))(f16 (get self14 3))) ($Parser.Reply.value f14 f15 ($Kind.Term.ori f16 term$15)))))))))))))))))))))))))
(define Kind.Parser.u32 (lambda (idx$0) (lambda (code$1) ($Kind.Parser.u32 idx$0 code$1))))
(define ($Kind.Parser.u16 idx$0 code$1) (let ((self0 ($Kind.Parser.init idx$0 code$1))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ((Kind.Parser.spaces f0) f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (let ((self6 ($Parser.nat f3 f4))) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Parser.Reply.error f6 f7 f8))) ('Parser.Reply.value (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) (let ((self9 ($Parser.text "s" f6 f7))) (case (get self9 0) ('Parser.Reply.error (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) ($Parser.Reply.error f9 f10 f11))) ('Parser.Reply.value (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) (let ((term$14 ($Kind.Term.ref "Nat.to_u16"))) (let ((term$15 ($Kind.Term.app term$14 ($Kind.Term.nat f8)))) (let ((self14 ($Kind.Parser.stop f2 f9 f10))) (case (get self14 0) ('Parser.Reply.error (let ((f14 (get self14 1))(f15 (get self14 2))(f16 (get self14 3))) ($Parser.Reply.error f14 f15 f16))) ('Parser.Reply.value (let ((f14 (get self14 1))(f15 (get self14 2))(f16 (get self14 3))) ($Parser.Reply.value f14 f15 ($Kind.Term.ori f16 term$15)))))))))))))))))))))))))
(define Kind.Parser.u16 (lambda (idx$0) (lambda (code$1) ($Kind.Parser.u16 idx$0 code$1))))
(define ($Kind.Parser.u8 idx$0 code$1) (let ((self0 ($Kind.Parser.init idx$0 code$1))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ((Kind.Parser.spaces f0) f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (let ((self6 ($Parser.nat f3 f4))) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Parser.Reply.error f6 f7 f8))) ('Parser.Reply.value (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) (let ((self9 ($Parser.text "b" f6 f7))) (case (get self9 0) ('Parser.Reply.error (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) ($Parser.Reply.error f9 f10 f11))) ('Parser.Reply.value (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) (let ((term$14 ($Kind.Term.ref "Nat.to_u8"))) (let ((term$15 ($Kind.Term.app term$14 ($Kind.Term.nat f8)))) (let ((self14 ($Kind.Parser.stop f2 f9 f10))) (case (get self14 0) ('Parser.Reply.error (let ((f14 (get self14 1))(f15 (get self14 2))(f16 (get self14 3))) ($Parser.Reply.error f14 f15 f16))) ('Parser.Reply.value (let ((f14 (get self14 1))(f15 (get self14 2))(f16 (get self14 3))) ($Parser.Reply.value f14 f15 ($Kind.Term.ori f16 term$15)))))))))))))))))))))))))
(define Kind.Parser.u8 (lambda (idx$0) (lambda (code$1) ($Kind.Parser.u8 idx$0 code$1))))
(define ($String.eql a$0 b$1) (string=? a$0 b$1))
(define String.eql (lambda (a$0) (lambda (b$1) ($String.eql a$0 b$1))))
(define ($Kind.Term.typ) (vector 'Kind.Term.typ))
(define Kind.Term.typ ($Kind.Term.typ))
(define ($Kind.Parser.reference idx$0 code$1) (let ((self0 ($Kind.Parser.init idx$0 code$1))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ($Kind.Parser.name1 f0 f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (let ((self6 ($Kind.Parser.stop f2 f3 f4))) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Parser.Reply.error f6 f7 f8))) ('Parser.Reply.value (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) (((let ((self9 ($String.eql f5 "case"))) (case self9 (#t (let () (Parser.fail "Reserved keyword."))) (#f (let () (let ((self9 ($String.eql f5 "do"))) (case self9 (#t (let () (Parser.fail "Reserved keyword."))) (#f (let () (let ((self9 ($String.eql f5 "if"))) (case self9 (#t (let () (Parser.fail "Reserved keyword."))) (#f (let () (let ((self9 ($String.eql f5 "with"))) (case self9 (#t (let () (Parser.fail "Reserved keyword."))) (#f (let () (let ((self9 ($String.eql f5 "let"))) (case self9 (#t (let () (Parser.fail "Reserved keyword."))) (#f (let () (let ((self9 ($String.eql f5 "def"))) (case self9 (#t (let () (Parser.fail "Reserved keyword."))) (#f (let () (let ((self9 ($String.eql f5 "Type"))) (case self9 (#t (let () (lambda (idx$11) (lambda (code$12) ($Parser.Reply.value idx$11 code$12 ($Kind.Term.ori f8 Kind.Term.typ)))))) (#f (let () (let ((self9 ($String.eql f5 "true"))) (case self9 (#t (let () (lambda (idx$11) (lambda (code$12) ($Parser.Reply.value idx$11 code$12 ($Kind.Term.ori f8 ($Kind.Term.ref "Bool.true"))))))) (#f (let () (let ((self9 ($String.eql f5 "false"))) (case self9 (#t (let () (lambda (idx$11) (lambda (code$12) ($Parser.Reply.value idx$11 code$12 ($Kind.Term.ori f8 ($Kind.Term.ref "Bool.false"))))))) (#f (let () (let ((self9 ($String.eql f5 "unit"))) (case self9 (#t (let () (lambda (idx$11) (lambda (code$12) ($Parser.Reply.value idx$11 code$12 ($Kind.Term.ori f8 ($Kind.Term.ref "Unit.new"))))))) (#f (let () (let ((self9 ($String.eql f5 "none"))) (case self9 (#t (let () (let ((term$11 ($Kind.Term.ref "Maybe.none"))) (let ((term$12 ($Kind.Term.app term$11 ($Kind.Term.hol Bits.e)))) (lambda (idx$13) (lambda (code$14) ($Parser.Reply.value idx$13 code$14 ($Kind.Term.ori f8 term$12)))))))) (#f (let () (let ((self9 ($String.eql f5 "refl"))) (case self9 (#t (let () (let ((term$11 ($Kind.Term.ref "Equal.refl"))) (let ((term$12 ($Kind.Term.app term$11 ($Kind.Term.hol Bits.e)))) (let ((term$13 ($Kind.Term.app term$12 ($Kind.Term.hol Bits.e)))) (lambda (idx$14) (lambda (code$15) ($Parser.Reply.value idx$14 code$15 ($Kind.Term.ori f8 term$13))))))))) (#f (let () (lambda (idx$11) (lambda (code$12) ($Parser.Reply.value idx$11 code$12 ($Kind.Term.ori f8 ($Kind.Term.ref f5))))))))))))))))))))))))))))))))))))))))))))))))))))) f6) f7))))))))))))))
(define Kind.Parser.reference (lambda (idx$0) (lambda (code$1) ($Kind.Parser.reference idx$0 code$1))))
(define ($List.for xs$1 b$3 f$4) (let ((self0 xs$1)) (case (get self0 0) ('List.nil (let () b$3)) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) ($List.for f1 ((f$4 f0) b$3) f$4))))))
(define List.for (lambda (xs$1) (lambda (b$3) (lambda (f$4) ($List.for xs$1 b$3 f$4)))))
(define ($Kind.Parser.application init$0 func$1 idx$2 code$3) (let ((self0 ($Parser.text "(" idx$2 code$3))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ($Parser.until1 (Kind.Parser.text ")") (Kind.Parser.item Kind.Parser.term) f0 f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (let ((self6 ($Kind.Parser.stop init$0 f3 f4))) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Parser.Reply.error f6 f7 f8))) ('Parser.Reply.value (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) (let ((expr$13 ($List.for f5 func$1 (lambda (x$13) (lambda (f$14) ($Kind.Term.app f$14 x$13)))))) ($Parser.Reply.value f6 f7 ($Kind.Term.ori f8 expr$13))))))))))))))))
(define Kind.Parser.application (lambda (init$0) (lambda (func$1) (lambda (idx$2) (lambda (code$3) ($Kind.Parser.application init$0 func$1 idx$2 code$3))))))
(define ($Parser.spaces) ($Parser.many ($Parser.first_of ($List.cons (Parser.text " ") ($List.cons (Parser.text "\xA;") List.nil)))))
(define Parser.spaces ($Parser.spaces))
(define ($Parser.spaces_text text$0 idx$1 code$2) (let ((self0 ((Parser.spaces idx$1) code$2))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.text text$0 f0 f1))))))
(define Parser.spaces_text (lambda (text$0) (lambda (idx$1) (lambda (code$2) ($Parser.spaces_text text$0 idx$1 code$2)))))
(define ($Kind.Parser.application.erased init$0 func$1 idx$2 code$3) (let ((self0 ($Parser.get_index idx$2 code$3))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ($Parser.text "<" f0 f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (let ((self6 ($Parser.until1 (Parser.spaces_text ">") (Kind.Parser.item Kind.Parser.term) f3 f4))) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Parser.Reply.error f6 f7 f8))) ('Parser.Reply.value (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) (let ((self9 ($Kind.Parser.stop f2 f6 f7))) (case (get self9 0) ('Parser.Reply.error (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) ($Parser.Reply.error f9 f10 f11))) ('Parser.Reply.value (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) (let ((expr$16 ($List.for f8 func$1 (lambda (x$16) (lambda (f$17) ($Kind.Term.app f$17 x$16)))))) ($Parser.Reply.value f9 f10 ($Kind.Term.ori f11 expr$16))))))))))))))))))))
(define Kind.Parser.application.erased (lambda (init$0) (lambda (func$1) (lambda (idx$2) (lambda (code$3) ($Kind.Parser.application.erased init$0 func$1 idx$2 code$3))))))
(define ($Kind.Parser.list_set init$0 list$1 idx$2 code$3) (let ((self0 ($Parser.text "[" idx$2 code$3))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ($Kind.Parser.term f0 f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (let ((self6 ($Kind.Parser.text "]" f3 f4))) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Parser.Reply.error f6 f7 f8))) ('Parser.Reply.value (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) (let ((self9 ($Kind.Parser.text "<-" f6 f7))) (case (get self9 0) ('Parser.Reply.error (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) ($Parser.Reply.error f9 f10 f11))) ('Parser.Reply.value (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) (let ((self12 ($Kind.Parser.term f9 f10))) (case (get self12 0) ('Parser.Reply.error (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) ($Parser.Reply.error f12 f13 f14))) ('Parser.Reply.value (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) (let ((self15 ($Kind.Parser.stop init$0 f12 f13))) (case (get self15 0) ('Parser.Reply.error (let ((f15 (get self15 1))(f16 (get self15 2))(f17 (get self15 3))) ($Parser.Reply.error f15 f16 f17))) ('Parser.Reply.value (let ((f15 (get self15 1))(f16 (get self15 2))(f17 (get self15 3))) (let ((term$22 ($Kind.Term.ref "List.set"))) (let ((term$23 ($Kind.Term.app term$22 ($Kind.Term.hol Bits.e)))) (let ((term$24 ($Kind.Term.app term$23 f5))) (let ((term$25 ($Kind.Term.app term$24 f14))) (let ((term$26 ($Kind.Term.app term$25 list$1))) ($Parser.Reply.value f15 f16 ($Kind.Term.ori f17 term$26))))))))))))))))))))))))))))))))
(define Kind.Parser.list_set (lambda (init$0) (lambda (list$1) (lambda (idx$2) (lambda (code$3) ($Kind.Parser.list_set init$0 list$1 idx$2 code$3))))))
(define ($Kind.Parser.list_get init$0 list$1 idx$2 code$3) (let ((self0 ($Parser.text "[" idx$2 code$3))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ($Kind.Parser.term f0 f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (let ((self6 ($Kind.Parser.text "]" f3 f4))) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Parser.Reply.error f6 f7 f8))) ('Parser.Reply.value (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) (let ((self9 ($Kind.Parser.stop init$0 f6 f7))) (case (get self9 0) ('Parser.Reply.error (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) ($Parser.Reply.error f9 f10 f11))) ('Parser.Reply.value (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) (let ((term$16 ($Kind.Term.ref "List.get"))) (let ((term$17 ($Kind.Term.app term$16 ($Kind.Term.hol Bits.e)))) (let ((term$18 ($Kind.Term.app term$17 f5))) (let ((term$19 ($Kind.Term.app term$18 list$1))) ($Parser.Reply.value f9 f10 ($Kind.Term.ori f11 term$19)))))))))))))))))))))))
(define Kind.Parser.list_get (lambda (init$0) (lambda (list$1) (lambda (idx$2) (lambda (code$3) ($Kind.Parser.list_get init$0 list$1 idx$2 code$3))))))
(define ($Kind.Parser.map_set init$0 map$1 idx$2 code$3) (let ((self0 ($Parser.text "{" idx$2 code$3))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ($Kind.Parser.term f0 f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (let ((self6 ($Kind.Parser.text "}" f3 f4))) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Parser.Reply.error f6 f7 f8))) ('Parser.Reply.value (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) (let ((self9 ($Kind.Parser.text "<-" f6 f7))) (case (get self9 0) ('Parser.Reply.error (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) ($Parser.Reply.error f9 f10 f11))) ('Parser.Reply.value (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) (let ((self12 ($Kind.Parser.term f9 f10))) (case (get self12 0) ('Parser.Reply.error (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) ($Parser.Reply.error f12 f13 f14))) ('Parser.Reply.value (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) (let ((self15 ($Kind.Parser.stop init$0 f12 f13))) (case (get self15 0) ('Parser.Reply.error (let ((f15 (get self15 1))(f16 (get self15 2))(f17 (get self15 3))) ($Parser.Reply.error f15 f16 f17))) ('Parser.Reply.value (let ((f15 (get self15 1))(f16 (get self15 2))(f17 (get self15 3))) (let ((term$22 ($Kind.Term.ref "Map.set"))) (let ((term$23 ($Kind.Term.app term$22 ($Kind.Term.hol Bits.e)))) (let ((term$24 ($Kind.Term.app term$23 f5))) (let ((term$25 ($Kind.Term.app term$24 f14))) (let ((term$26 ($Kind.Term.app term$25 map$1))) ($Parser.Reply.value f15 f16 ($Kind.Term.ori f17 term$26))))))))))))))))))))))))))))))))
(define Kind.Parser.map_set (lambda (init$0) (lambda (map$1) (lambda (idx$2) (lambda (code$3) ($Kind.Parser.map_set init$0 map$1 idx$2 code$3))))))
(define ($Kind.Parser.map_get init$0 map$1 idx$2 code$3) (let ((self0 ($Parser.text "{" idx$2 code$3))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ($Kind.Parser.term f0 f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (let ((self6 ($Kind.Parser.text "}" f3 f4))) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Parser.Reply.error f6 f7 f8))) ('Parser.Reply.value (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) (let ((self9 ($Kind.Parser.stop init$0 f6 f7))) (case (get self9 0) ('Parser.Reply.error (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) ($Parser.Reply.error f9 f10 f11))) ('Parser.Reply.value (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) (let ((term$16 ($Kind.Term.ref "Map.get"))) (let ((term$17 ($Kind.Term.app term$16 ($Kind.Term.hol Bits.e)))) (let ((term$18 ($Kind.Term.app term$17 f5))) (let ((term$19 ($Kind.Term.app term$18 map$1))) ($Parser.Reply.value f9 f10 ($Kind.Term.ori f11 term$19)))))))))))))))))))))))
(define Kind.Parser.map_get (lambda (init$0) (lambda (map$1) (lambda (idx$2) (lambda (code$3) ($Kind.Parser.map_get init$0 map$1 idx$2 code$3))))))
(define ($Kind.Parser.arrow init$0 xtyp$1 idx$2 code$3) (let ((self0 ($Kind.Parser.text "->" idx$2 code$3))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ($Kind.Parser.term f0 f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (let ((self6 ($Kind.Parser.stop init$0 f3 f4))) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Parser.Reply.error f6 f7 f8))) ('Parser.Reply.value (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Parser.Reply.value f6 f7 ($Kind.Term.ori f8 ($Kind.Term.all Bool.false "" "" xtyp$1 (lambda (s$13) (lambda (x$14) f5))))))))))))))))))
(define Kind.Parser.arrow (lambda (init$0) (lambda (xtyp$1) (lambda (idx$2) (lambda (code$3) ($Kind.Parser.arrow init$0 xtyp$1 idx$2 code$3))))))
(define ($Kind.Parser.op sym$0 ref$1 init$2 val0$3 idx$4 code$5) (let ((self0 ($Kind.Parser.text sym$0 idx$4 code$5))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ($Parser.text " " f0 f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (let ((self6 ($Kind.Parser.term f3 f4))) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Parser.Reply.error f6 f7 f8))) ('Parser.Reply.value (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) (let ((self9 ($Kind.Parser.stop init$2 f6 f7))) (case (get self9 0) ('Parser.Reply.error (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) ($Parser.Reply.error f9 f10 f11))) ('Parser.Reply.value (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) (let ((term$18 ($Kind.Term.ref ref$1))) (let ((term$19 ($Kind.Term.app term$18 val0$3))) (let ((term$20 ($Kind.Term.app term$19 f8))) ($Parser.Reply.value f9 f10 ($Kind.Term.ori f11 term$20))))))))))))))))))))))
(define Kind.Parser.op (lambda (sym$0) (lambda (ref$1) (lambda (init$2) (lambda (val0$3) (lambda (idx$4) (lambda (code$5) ($Kind.Parser.op sym$0 ref$1 init$2 val0$3 idx$4 code$5))))))))
(define ($Kind.Parser.add) ((Kind.Parser.op "+") "Nat.add"))
(define Kind.Parser.add ($Kind.Parser.add))
(define ($Kind.Parser.sub) ((Kind.Parser.op "-") "Nat.sub"))
(define Kind.Parser.sub ($Kind.Parser.sub))
(define ($Kind.Parser.mul) ((Kind.Parser.op "*") "Nat.mul"))
(define Kind.Parser.mul ($Kind.Parser.mul))
(define ($Kind.Parser.div) ((Kind.Parser.op "/") "Nat.div"))
(define Kind.Parser.div ($Kind.Parser.div))
(define ($Kind.Parser.mod) ((Kind.Parser.op "%") "Nat.mod"))
(define Kind.Parser.mod ($Kind.Parser.mod))
(define ($Kind.Parser.ltn) ((Kind.Parser.op "<?") "Nat.ltn"))
(define Kind.Parser.ltn ($Kind.Parser.ltn))
(define ($Kind.Parser.lte) ((Kind.Parser.op "<=?") "Nat.lte"))
(define Kind.Parser.lte ($Kind.Parser.lte))
(define ($Kind.Parser.eql) ((Kind.Parser.op "=?") "Nat.eql"))
(define Kind.Parser.eql ($Kind.Parser.eql))
(define ($Kind.Parser.gte) ((Kind.Parser.op ">=?") "Nat.gte"))
(define Kind.Parser.gte ($Kind.Parser.gte))
(define ($Kind.Parser.gtn) ((Kind.Parser.op ">?") "Nat.gtn"))
(define Kind.Parser.gtn ($Kind.Parser.gtn))
(define ($Kind.Parser.and) ((Kind.Parser.op "&&") "Bool.and"))
(define Kind.Parser.and ($Kind.Parser.and))
(define ($Kind.Parser.or) ((Kind.Parser.op "||") "Bool.or"))
(define Kind.Parser.or ($Kind.Parser.or))
(define ($Kind.Parser.default init$0 val0$1 idx$2 code$3) (let ((self0 ($Kind.Parser.text "<>" idx$2 code$3))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ($Kind.Parser.term f0 f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (let ((self6 ($Kind.Parser.stop init$0 f3 f4))) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Parser.Reply.error f6 f7 f8))) ('Parser.Reply.value (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) (let ((term$13 ($Kind.Term.ref "Maybe.default"))) (let ((term$14 ($Kind.Term.app term$13 ($Kind.Term.hol Bits.e)))) (let ((term$15 ($Kind.Term.app term$14 val0$1))) (let ((term$16 ($Kind.Term.app term$15 f5))) ($Parser.Reply.value f6 f7 ($Kind.Term.ori f8 term$16)))))))))))))))))))
(define Kind.Parser.default (lambda (init$0) (lambda (val0$1) (lambda (idx$2) (lambda (code$3) ($Kind.Parser.default init$0 val0$1 idx$2 code$3))))))
(define ($Kind.Parser.cons init$0 head$1 idx$2 code$3) (let ((self0 ($Kind.Parser.text "&" idx$2 code$3))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ($Kind.Parser.term f0 f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (let ((self6 ($Kind.Parser.stop init$0 f3 f4))) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Parser.Reply.error f6 f7 f8))) ('Parser.Reply.value (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) (let ((term$13 ($Kind.Term.ref "List.cons"))) (let ((term$14 ($Kind.Term.app term$13 ($Kind.Term.hol Bits.e)))) (let ((term$15 ($Kind.Term.app term$14 head$1))) (let ((term$16 ($Kind.Term.app term$15 f5))) (let ((self13 ($Kind.Parser.stop init$0 f6 f7))) (case (get self13 0) ('Parser.Reply.error (let ((f13 (get self13 1))(f14 (get self13 2))(f15 (get self13 3))) ($Parser.Reply.error f13 f14 f15))) ('Parser.Reply.value (let ((f13 (get self13 1))(f14 (get self13 2))(f15 (get self13 3))) ($Parser.Reply.value f13 f14 ($Kind.Term.ori f15 term$16)))))))))))))))))))))))
(define Kind.Parser.cons (lambda (init$0) (lambda (head$1) (lambda (idx$2) (lambda (code$3) ($Kind.Parser.cons init$0 head$1 idx$2 code$3))))))
(define ($Kind.Parser.concat init$0 lst0$1 idx$2 code$3) (let ((self0 ($Kind.Parser.text "++" idx$2 code$3))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ($Kind.Parser.term f0 f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (let ((self6 ($Kind.Parser.stop init$0 f3 f4))) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Parser.Reply.error f6 f7 f8))) ('Parser.Reply.value (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) (let ((term$13 ($Kind.Term.ref "List.concat"))) (let ((term$14 ($Kind.Term.app term$13 ($Kind.Term.hol Bits.e)))) (let ((term$15 ($Kind.Term.app term$14 lst0$1))) (let ((term$16 ($Kind.Term.app term$15 f5))) (let ((self13 ($Kind.Parser.stop init$0 f6 f7))) (case (get self13 0) ('Parser.Reply.error (let ((f13 (get self13 1))(f14 (get self13 2))(f15 (get self13 3))) ($Parser.Reply.error f13 f14 f15))) ('Parser.Reply.value (let ((f13 (get self13 1))(f14 (get self13 2))(f15 (get self13 3))) ($Parser.Reply.value f13 f14 ($Kind.Term.ori f15 term$16)))))))))))))))))))))))
(define Kind.Parser.concat (lambda (init$0) (lambda (lst0$1) (lambda (idx$2) (lambda (code$3) ($Kind.Parser.concat init$0 lst0$1 idx$2 code$3))))))
(define ($Kind.Parser.string_concat init$0 str0$1 idx$2 code$3) (let ((self0 ($Kind.Parser.text "|" idx$2 code$3))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ($Kind.Parser.term f0 f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (let ((self6 ($Kind.Parser.stop init$0 f3 f4))) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Parser.Reply.error f6 f7 f8))) ('Parser.Reply.value (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) (let ((term$13 ($Kind.Term.ref "String.concat"))) (let ((term$14 ($Kind.Term.app term$13 str0$1))) (let ((term$15 ($Kind.Term.app term$14 f5))) (let ((self12 ($Kind.Parser.stop init$0 f6 f7))) (case (get self12 0) ('Parser.Reply.error (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) ($Parser.Reply.error f12 f13 f14))) ('Parser.Reply.value (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) ($Parser.Reply.value f12 f13 ($Kind.Term.ori f14 term$15))))))))))))))))))))))
(define Kind.Parser.string_concat (lambda (init$0) (lambda (str0$1) (lambda (idx$2) (lambda (code$3) ($Kind.Parser.string_concat init$0 str0$1 idx$2 code$3))))))
(define ($Kind.Parser.sigma init$0 val0$1 idx$2 code$3) (let ((self0 ($Kind.Parser.text "~" idx$2 code$3))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ($Kind.Parser.term f0 f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (let ((self6 ($Kind.Parser.stop init$0 f3 f4))) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Parser.Reply.error f6 f7 f8))) ('Parser.Reply.value (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) (let ((term$13 ($Kind.Term.ref "Sigma.new"))) (let ((term$14 ($Kind.Term.app term$13 ($Kind.Term.hol Bits.e)))) (let ((term$15 ($Kind.Term.app term$14 ($Kind.Term.hol Bits.e)))) (let ((term$16 ($Kind.Term.app term$15 val0$1))) (let ((term$17 ($Kind.Term.app term$16 f5))) ($Parser.Reply.value f6 f7 ($Kind.Term.ori f8 term$17))))))))))))))))))))
(define Kind.Parser.sigma (lambda (init$0) (lambda (val0$1) (lambda (idx$2) (lambda (code$3) ($Kind.Parser.sigma init$0 val0$1 idx$2 code$3))))))
(define ($Kind.Parser.equality init$0 val0$1 idx$2 code$3) (let ((self0 ($Kind.Parser.text "==" idx$2 code$3))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ($Kind.Parser.term f0 f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (let ((self6 ($Kind.Parser.stop init$0 f3 f4))) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Parser.Reply.error f6 f7 f8))) ('Parser.Reply.value (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) (let ((term$13 ($Kind.Term.ref "Equal"))) (let ((term$14 ($Kind.Term.app term$13 ($Kind.Term.hol Bits.e)))) (let ((term$15 ($Kind.Term.app term$14 val0$1))) (let ((term$16 ($Kind.Term.app term$15 f5))) ($Parser.Reply.value f6 f7 ($Kind.Term.ori f8 term$16)))))))))))))))))))
(define Kind.Parser.equality (lambda (init$0) (lambda (val0$1) (lambda (idx$2) (lambda (code$3) ($Kind.Parser.equality init$0 val0$1 idx$2 code$3))))))
(define ($Kind.Parser.inequality init$0 val0$1 idx$2 code$3) (let ((self0 ($Kind.Parser.text "!=" idx$2 code$3))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ($Kind.Parser.term f0 f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (let ((self6 ($Kind.Parser.stop init$0 f3 f4))) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Parser.Reply.error f6 f7 f8))) ('Parser.Reply.value (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) (let ((term$13 ($Kind.Term.ref "Equal"))) (let ((term$14 ($Kind.Term.app term$13 ($Kind.Term.hol Bits.e)))) (let ((term$15 ($Kind.Term.app term$14 val0$1))) (let ((term$16 ($Kind.Term.app term$15 f5))) (let ((term$17 ($Kind.Term.app ($Kind.Term.ref "Not") term$16))) ($Parser.Reply.value f6 f7 ($Kind.Term.ori f8 term$17))))))))))))))))))))
(define Kind.Parser.inequality (lambda (init$0) (lambda (val0$1) (lambda (idx$2) (lambda (code$3) ($Kind.Parser.inequality init$0 val0$1 idx$2 code$3))))))
(define ($Kind.Parser.rewrite init$0 subt$1 idx$2 code$3) (let ((self0 ($Kind.Parser.text "::" idx$2 code$3))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ($Kind.Parser.text "rewrite" f0 f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (let ((self6 ($Kind.Parser.name1 f3 f4))) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Parser.Reply.error f6 f7 f8))) ('Parser.Reply.value (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) (let ((self9 ($Kind.Parser.text "in" f6 f7))) (case (get self9 0) ('Parser.Reply.error (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) ($Parser.Reply.error f9 f10 f11))) ('Parser.Reply.value (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) (let ((self12 ($Kind.Parser.term f9 f10))) (case (get self12 0) ('Parser.Reply.error (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) ($Parser.Reply.error f12 f13 f14))) ('Parser.Reply.value (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) (let ((self15 ($Kind.Parser.text "with" f12 f13))) (case (get self15 0) ('Parser.Reply.error (let ((f15 (get self15 1))(f16 (get self15 2))(f17 (get self15 3))) ($Parser.Reply.error f15 f16 f17))) ('Parser.Reply.value (let ((f15 (get self15 1))(f16 (get self15 2))(f17 (get self15 3))) (let ((self18 ($Kind.Parser.term f15 f16))) (case (get self18 0) ('Parser.Reply.error (let ((f18 (get self18 1))(f19 (get self18 2))(f20 (get self18 3))) ($Parser.Reply.error f18 f19 f20))) ('Parser.Reply.value (let ((f18 (get self18 1))(f19 (get self18 2))(f20 (get self18 3))) (let ((self21 ($Kind.Parser.stop init$0 f18 f19))) (case (get self21 0) ('Parser.Reply.error (let ((f21 (get self21 1))(f22 (get self21 2))(f23 (get self21 3))) ($Parser.Reply.error f21 f22 f23))) ('Parser.Reply.value (let ((f21 (get self21 1))(f22 (get self21 2))(f23 (get self21 3))) (let ((term$28 ($Kind.Term.ref "Equal.rewrite"))) (let ((term$29 ($Kind.Term.app term$28 ($Kind.Term.hol Bits.e)))) (let ((term$30 ($Kind.Term.app term$29 ($Kind.Term.hol Bits.e)))) (let ((term$31 ($Kind.Term.app term$30 ($Kind.Term.hol Bits.e)))) (let ((term$32 ($Kind.Term.app term$31 f20))) (let ((term$33 ($Kind.Term.app term$32 ($Kind.Term.lam f8 (lambda (x$33) f14))))) (let ((term$34 ($Kind.Term.app term$33 subt$1))) ($Parser.Reply.value f21 f22 ($Kind.Term.ori f23 term$34))))))))))))))))))))))))))))))))))))))))))
(define Kind.Parser.rewrite (lambda (init$0) (lambda (subt$1) (lambda (idx$2) (lambda (code$3) ($Kind.Parser.rewrite init$0 subt$1 idx$2 code$3))))))
(define ($Kind.Term.ann done$0 term$1 type$2) (vector 'Kind.Term.ann done$0 term$1 type$2))
(define Kind.Term.ann (lambda (done$0) (lambda (term$1) (lambda (type$2) ($Kind.Term.ann done$0 term$1 type$2)))))
(define ($Kind.Parser.annotation init$0 term$1 idx$2 code$3) (let ((self0 ($Kind.Parser.text "::" idx$2 code$3))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ($Kind.Parser.term f0 f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (let ((self6 ($Kind.Parser.stop init$0 f3 f4))) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Parser.Reply.error f6 f7 f8))) ('Parser.Reply.value (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Parser.Reply.value f6 f7 ($Kind.Term.ori f8 ($Kind.Term.ann Bool.false term$1 f5))))))))))))))))
(define Kind.Parser.annotation (lambda (init$0) (lambda (term$1) (lambda (idx$2) (lambda (code$3) ($Kind.Parser.annotation init$0 term$1 idx$2 code$3))))))
(define ($Kind.Parser.application.hole init$0 term$1 idx$2 code$3) (let ((self0 ($Kind.Parser.text "!" idx$2 code$3))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ($Kind.Parser.stop init$0 f0 f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.value f3 f4 ($Kind.Term.ori f5 ($Kind.Term.app term$1 ($Kind.Term.hol Bits.e)))))))))))))
(define Kind.Parser.application.hole (lambda (init$0) (lambda (term$1) (lambda (idx$2) (lambda (code$3) ($Kind.Parser.application.hole init$0 term$1 idx$2 code$3))))))
(define ($Kind.Parser.suffix init$0 term$1 idx$2 code$3) (let ((suffix_parser$4 ($Parser.first_of ($List.cons ((Kind.Parser.application init$0) term$1) ($List.cons ((Kind.Parser.application.erased init$0) term$1) ($List.cons ((Kind.Parser.list_set init$0) term$1) ($List.cons ((Kind.Parser.list_get init$0) term$1) ($List.cons ((Kind.Parser.map_set init$0) term$1) ($List.cons ((Kind.Parser.map_get init$0) term$1) ($List.cons ((Kind.Parser.arrow init$0) term$1) ($List.cons ((Kind.Parser.add init$0) term$1) ($List.cons ((Kind.Parser.sub init$0) term$1) ($List.cons ((Kind.Parser.mul init$0) term$1) ($List.cons ((Kind.Parser.div init$0) term$1) ($List.cons ((Kind.Parser.mod init$0) term$1) ($List.cons ((Kind.Parser.ltn init$0) term$1) ($List.cons ((Kind.Parser.lte init$0) term$1) ($List.cons ((Kind.Parser.eql init$0) term$1) ($List.cons ((Kind.Parser.gte init$0) term$1) ($List.cons ((Kind.Parser.gtn init$0) term$1) ($List.cons ((Kind.Parser.and init$0) term$1) ($List.cons ((Kind.Parser.or init$0) term$1) ($List.cons ((Kind.Parser.default init$0) term$1) ($List.cons ((Kind.Parser.cons init$0) term$1) ($List.cons ((Kind.Parser.concat init$0) term$1) ($List.cons ((Kind.Parser.string_concat init$0) term$1) ($List.cons ((Kind.Parser.sigma init$0) term$1) ($List.cons ((Kind.Parser.equality init$0) term$1) ($List.cons ((Kind.Parser.inequality init$0) term$1) ($List.cons ((Kind.Parser.rewrite init$0) term$1) ($List.cons ((Kind.Parser.annotation init$0) term$1) ($List.cons ((Kind.Parser.application.hole init$0) term$1) List.nil)))))))))))))))))))))))))))))))) (let ((self1 ((suffix_parser$4 idx$2) code$3))) (case (get self1 0) ('Parser.Reply.error (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))) ($Parser.Reply.value idx$2 code$3 term$1))) ('Parser.Reply.value (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))) ($Kind.Parser.suffix init$0 f3 f1 f2)))))))
(define Kind.Parser.suffix (lambda (init$0) (lambda (term$1) (lambda (idx$2) (lambda (code$3) ($Kind.Parser.suffix init$0 term$1 idx$2 code$3))))))
(define ($Kind.Parser.term idx$0 code$1) (let ((self0 ($Kind.Parser.init idx$0 code$1))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ((($Parser.first_of ($List.cons Kind.Parser.forall ($List.cons Kind.Parser.lambda ($List.cons Kind.Parser.lambda.erased ($List.cons Kind.Parser.lambda.nameless ($List.cons Kind.Parser.parenthesis ($List.cons Kind.Parser.letforrange.u32 ($List.cons Kind.Parser.letforrange.u32.with ($List.cons Kind.Parser.letforrange.nat ($List.cons Kind.Parser.letforrange.nat.with ($List.cons Kind.Parser.letforin ($List.cons Kind.Parser.letforin.with ($List.cons Kind.Parser.letwhile ($List.cons Kind.Parser.letwhile.with ($List.cons Kind.Parser.let ($List.cons Kind.Parser.let.omit ($List.cons Kind.Parser.getwhile ($List.cons Kind.Parser.getwhile.with ($List.cons Kind.Parser.get ($List.cons Kind.Parser.get.omit ($List.cons Kind.Parser.def ($List.cons Kind.Parser.goal_rewrite ($List.cons Kind.Parser.if ($List.cons Kind.Parser.char ($List.cons (Kind.Parser.string 34) ($List.cons (Kind.Parser.string 96) ($List.cons Kind.Parser.pair ($List.cons Kind.Parser.sigma.type ($List.cons Kind.Parser.some ($List.cons Kind.Parser.not ($List.cons Kind.Parser.left ($List.cons Kind.Parser.right ($List.cons Kind.Parser.apply ($List.cons Kind.Parser.chain ($List.cons Kind.Parser.mirror ($List.cons Kind.Parser.list ($List.cons Kind.Parser.map ($List.cons Kind.Parser.log ($List.cons Kind.Parser.do ($List.cons Kind.Parser.case ($List.cons Kind.Parser.open ($List.cons Kind.Parser.without ($List.cons Kind.Parser.switch ($List.cons Kind.Parser.goal ($List.cons Kind.Parser.hole ($List.cons Kind.Parser.float.64 ($List.cons Kind.Parser.float.32 ($List.cons ($Kind.Parser.machine_integer.signed 256) ($List.cons ($Kind.Parser.machine_integer.signed 128) ($List.cons ($Kind.Parser.machine_integer.signed 64) ($List.cons ($Kind.Parser.machine_integer.signed 32) ($List.cons ($Kind.Parser.machine_integer.signed 16) ($List.cons ($Kind.Parser.machine_integer.signed 8) ($List.cons Kind.Parser.int ($List.cons ($Kind.Parser.machine_integer.unsigned 256) ($List.cons ($Kind.Parser.machine_integer.unsigned 128) ($List.cons ($Kind.Parser.machine_integer.unsigned 64) ($List.cons ($Kind.Parser.machine_integer.unsigned 32) ($List.cons ($Kind.Parser.machine_integer.unsigned 16) ($List.cons ($Kind.Parser.machine_integer.unsigned 8) ($List.cons Kind.Parser.u64 ($List.cons Kind.Parser.u32 ($List.cons Kind.Parser.u16 ($List.cons Kind.Parser.u8 ($List.cons Kind.Parser.nat ($List.cons Kind.Parser.reference List.nil)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) f0) f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Kind.Parser.suffix f2 f5 f3 f4))))))))))
(define Kind.Parser.term (lambda (idx$0) (lambda (code$1) ($Kind.Parser.term idx$0 code$1))))
(define ($Kind.Parser.name_term sep$0 idx$1 code$2) (let ((self0 ($Kind.Parser.name idx$1 code$2))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ($Kind.Parser.text sep$0 f0 f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (let ((self6 ($Kind.Parser.term f3 f4))) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Parser.Reply.error f6 f7 f8))) ('Parser.Reply.value (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Parser.Reply.value f6 f7 ($Pair.new f2 f8)))))))))))))))
(define Kind.Parser.name_term (lambda (sep$0) (lambda (idx$1) (lambda (code$2) ($Kind.Parser.name_term sep$0 idx$1 code$2)))))
(define ($Kind.Binder.new eras$0 name$1 term$2) (vector 'Kind.Binder.new eras$0 name$1 term$2))
(define Kind.Binder.new (lambda (eras$0) (lambda (name$1) (lambda (term$2) ($Kind.Binder.new eras$0 name$1 term$2)))))
(define ($Kind.Parser.binder.homo sep$0 eras$1 idx$2 code$3) (let ((self0 ($Kind.Parser.text (let ((self0 eras$1)) (case self0 (#t (let () "<")) (#f (let () "(")))) idx$2 code$3))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ($Parser.until1 (Kind.Parser.text (let ((self3 eras$1)) (case self3 (#t (let () ">")) (#f (let () ")"))))) (Kind.Parser.item (Kind.Parser.name_term sep$0)) f0 f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.value f3 f4 ($List.mapped f5 (lambda (pair$10) (let ((self7 pair$10)) (case (get self7 0) ('Pair.new (let ((f7 (get self7 1))(f8 (get self7 2))) ($Kind.Binder.new eras$1 f7 f8)))))))))))))))))
(define Kind.Parser.binder.homo (lambda (sep$0) (lambda (eras$1) (lambda (idx$2) (lambda (code$3) ($Kind.Parser.binder.homo sep$0 eras$1 idx$2 code$3))))))
(define ($List.concat as$1 bs$2) (let ((self0 as$1)) (case (get self0 0) ('List.nil (let () bs$2)) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) ($List.cons f0 ($List.concat f1 bs$2)))))))
(define List.concat (lambda (as$1) (lambda (bs$2) ($List.concat as$1 bs$2))))
(define ($List.flatten xs$1) (let ((self0 xs$1)) (case (get self0 0) ('List.nil (let () List.nil)) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) ($List.concat f0 ($List.flatten f1)))))))
(define List.flatten (lambda (xs$1) ($List.flatten xs$1)))
(define ($Kind.Parser.binder sep$0 idx$1 code$2) (let ((self0 ($Parser.many1 ($Parser.first_of ($List.cons ((Kind.Parser.binder.homo sep$0) Bool.true) ($List.cons ((Kind.Parser.binder.homo sep$0) Bool.false) List.nil))) idx$1 code$2))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.value f0 f1 ($List.flatten f2)))))))
(define Kind.Parser.binder (lambda (sep$0) (lambda (idx$1) (lambda (code$2) ($Kind.Parser.binder sep$0 idx$1 code$2)))))
(define ($List.length xs$1) (let ((self0 xs$1)) (case (get self0 0) ('List.nil (let () 0)) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) ($Nat.succ ($List.length f1)))))))
(define List.length (lambda (xs$1) ($List.length xs$1)))
(define ($Kind.Parser.make_forall binds$0 body$1) (let ((self0 binds$0)) (case (get self0 0) ('List.nil (let () body$1)) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 f0)) (case (get self2 0) ('Kind.Binder.new (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))) ($Kind.Term.all f2 "" f3 f4 (lambda (s$7) (lambda (x$8) ($Kind.Parser.make_forall f1 body$1)))))))))))))
(define Kind.Parser.make_forall (lambda (binds$0) (lambda (body$1) ($Kind.Parser.make_forall binds$0 body$1))))
(define ($List.at_last index$1 list$2) ($List.at index$1 ($List.reverse list$2)))
(define List.at_last (lambda (index$1) (lambda (list$2) ($List.at_last index$1 list$2))))
(define ($Kind.Term.var name$0 indx$1) (vector 'Kind.Term.var name$0 indx$1))
(define Kind.Term.var (lambda (name$0) (lambda (indx$1) ($Kind.Term.var name$0 indx$1))))
(define ($Kind.Context.get_name_skips name$0) (let ((self0 name$0)) (case (= (string-length self0) 0) (#t (let () ($Pair.new "" 0))) (#f (let ((f0 (char->integer (string-ref self0 0)))(f1 (let ((_str_ self0)) (substring _str_ 1 (string-length _str_))))) (let ((name_skips$3 ($Kind.Context.get_name_skips f1))) (let ((self3 name_skips$3)) (case (get self3 0) ('Pair.new (let ((f3 (get self3 1))(f4 (get self3 2))) (let ((self5 ($U16.eql f0 94))) (case self5 (#t (let () ($Pair.new f3 ($Nat.succ f4)))) (#f (let () ($Pair.new ($String.cons f0 f3) f4)))))))))))))))
(define Kind.Context.get_name_skips (lambda (name$0) ($Kind.Context.get_name_skips name$0)))
(define ($Kind.Name.eql a$0 b$1) ($String.eql a$0 b$1))
(define Kind.Name.eql (lambda (a$0) (lambda (b$1) ($Kind.Name.eql a$0 b$1))))
(define ($Kind.Context.find.go name$0 skip$1 ctx$2) (let ((self0 ctx$2)) (case (get self0 0) ('List.nil (let () Maybe.none)) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 f0)) (case (get self2 0) ('Pair.new (let ((f2 (get self2 1))(f3 (get self2 2))) (let ((self4 ($Kind.Name.eql name$0 f2))) (case self4 (#t (let () (let ((self4 skip$1)) (case (= self4 0) (#t (let () ($Maybe.some f3))) (#f (let ((f4 (- self4 1))) ($Kind.Context.find.go name$0 f4 f1))))))) (#f (let () ($Kind.Context.find.go name$0 skip$1 f1))))))))))))))
(define Kind.Context.find.go (lambda (name$0) (lambda (skip$1) (lambda (ctx$2) ($Kind.Context.find.go name$0 skip$1 ctx$2)))))
(define ($Kind.Context.find name$0 ctx$1) (let ((self0 ($Kind.Context.get_name_skips name$0))) (case (get self0 0) ('Pair.new (let ((f0 (get self0 1))(f1 (get self0 2))) ($Kind.Context.find.go f0 f1 ctx$1))))))
(define Kind.Context.find (lambda (name$0) (lambda (ctx$1) ($Kind.Context.find name$0 ctx$1))))
(define ($Kind.Path.o path$0 x$1) (path$0 ($Bits.o x$1)))
(define Kind.Path.o (lambda (path$0) (lambda (x$1) ($Kind.Path.o path$0 x$1))))
(define ($Kind.Path.i path$0 x$1) (path$0 ($Bits.i x$1)))
(define Kind.Path.i (lambda (path$0) (lambda (x$1) ($Kind.Path.i path$0 x$1))))
(define ($Kind.Path.to_bits path$0) (path$0 Bits.e))
(define Kind.Path.to_bits (lambda (path$0) ($Kind.Path.to_bits path$0)))
(define ($Kind.Term.bind vars$0 path$1 term$2) (let ((self0 term$2)) (case (get self0 0) ('Kind.Term.var (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 ($List.at_last f1 vars$0))) (case (get self2 0) ('Maybe.none (let () ($Kind.Term.var f0 f1))) ('Maybe.some (let ((f2 (get self2 1))) ($Pair.snd f2))))))) ('Kind.Term.ref (let ((f0 (get self0 1))) (let ((self1 ($Kind.Context.find f0 vars$0))) (case (get self1 0) ('Maybe.none (let () ($Kind.Term.ref f0))) ('Maybe.some (let ((f1 (get self1 1))) f1)))))) ('Kind.Term.typ (let () Kind.Term.typ)) ('Kind.Term.all (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))) (let ((vlen$8 ($List.length vars$0))) ($Kind.Term.all f0 f1 f2 ($Kind.Term.bind vars$0 (Kind.Path.o path$1) f3) (lambda (s$9) (lambda (x$10) ($Kind.Term.bind ($List.cons ($Pair.new f2 x$10) ($List.cons ($Pair.new f1 s$9) vars$0)) (Kind.Path.i path$1) ((f4 ($Kind.Term.var f1 vlen$8)) ($Kind.Term.var f2 ($Nat.succ vlen$8)))))))))) ('Kind.Term.lam (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((vlen$5 ($List.length vars$0))) ($Kind.Term.lam f0 (lambda (x$6) ($Kind.Term.bind ($List.cons ($Pair.new f0 x$6) vars$0) (Kind.Path.o path$1) (f1 ($Kind.Term.var f0 vlen$5)))))))) ('Kind.Term.app (let ((f0 (get self0 1))(f1 (get self0 2))) ($Kind.Term.app ($Kind.Term.bind vars$0 (Kind.Path.o path$1) f0) ($Kind.Term.bind vars$0 (Kind.Path.i path$1) f1)))) ('Kind.Term.let (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((vlen$6 ($List.length vars$0))) ($Kind.Term.let f0 ($Kind.Term.bind vars$0 (Kind.Path.o path$1) f1) (lambda (x$7) ($Kind.Term.bind ($List.cons ($Pair.new f0 x$7) vars$0) (Kind.Path.i path$1) (f2 ($Kind.Term.var f0 vlen$6)))))))) ('Kind.Term.def (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((vlen$6 ($List.length vars$0))) ($Kind.Term.def f0 ($Kind.Term.bind vars$0 (Kind.Path.o path$1) f1) (lambda (x$7) ($Kind.Term.bind ($List.cons ($Pair.new f0 x$7) vars$0) (Kind.Path.i path$1) (f2 ($Kind.Term.var f0 vlen$6)))))))) ('Kind.Term.ann (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Kind.Term.ann f0 ($Kind.Term.bind vars$0 (Kind.Path.o path$1) f1) ($Kind.Term.bind vars$0 (Kind.Path.i path$1) f2)))) ('Kind.Term.gol (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Kind.Term.gol f0 f1 f2))) ('Kind.Term.hol (let ((f0 (get self0 1))) ($Kind.Term.hol ($Kind.Path.to_bits path$1)))) ('Kind.Term.nat (let ((f0 (get self0 1))) ($Kind.Term.nat f0))) ('Kind.Term.chr (let ((f0 (get self0 1))) ($Kind.Term.chr f0))) ('Kind.Term.str (let ((f0 (get self0 1))) ($Kind.Term.str f0))) ('Kind.Term.cse (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))(f5 (get self0 6))) (let ((expr$9 ($Kind.Term.bind vars$0 (Kind.Path.o path$1) f1))) (let ((name$10 f2)) (let ((wyth$11 ($List.mapped f3 (lambda (with_var$11) (let ((self9 with_var$11)) (case (get self9 0) ('Kind.Ann.new (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) (let ((with_var_term$15 ($Kind.Term.bind vars$0 path$1 f10))) (let ((with_var_type$16 (let ((self13 f11)) (case (get self13 0) ('Maybe.none (let () Maybe.none)) ('Maybe.some (let ((f13 (get self13 1))) ($Maybe.some ($Kind.Term.bind vars$0 path$1 f13)))))))) ($Kind.Ann.new f9 with_var_term$15 with_var_type$16))))))))))) (let ((cses$12 f4)) (let ((moti$13 f5)) ($Kind.Term.cse ($Kind.Path.to_bits path$1) expr$9 name$10 wyth$11 cses$12 moti$13)))))))) ('Kind.Term.ori (let ((f0 (get self0 1))(f1 (get self0 2))) ($Kind.Term.ori f0 ($Kind.Term.bind vars$0 path$1 f1)))))))
(define Kind.Term.bind (lambda (vars$0) (lambda (path$1) (lambda (term$2) ($Kind.Term.bind vars$0 path$1 term$2)))))
(define ($Kind.Def.new file$0 code$1 orig$2 name$3 term$4 type$5 isct$6 arit$7 stat$8) (vector 'Kind.Def.new file$0 code$1 orig$2 name$3 term$4 type$5 isct$6 arit$7 stat$8))
(define Kind.Def.new (lambda (file$0) (lambda (code$1) (lambda (orig$2) (lambda (name$3) (lambda (term$4) (lambda (type$5) (lambda (isct$6) (lambda (arit$7) (lambda (stat$8) ($Kind.Def.new file$0 code$1 orig$2 name$3 term$4 type$5 isct$6 arit$7 stat$8)))))))))))
(define ($Kind.Status.done cached$0) (vector 'Kind.Status.done cached$0))
(define Kind.Status.done (lambda (cached$0) ($Kind.Status.done cached$0)))
(define ($Trampoline.call t$1) (let ((self0 t$1)) (case (get self0 0) ('Trampoline.done (let ((f0 (get self0 1))) f0)) ('Trampoline.wrap (let ((f0 (get self0 1))) ($Trampoline.call (f0 Unit.new)))))))
(define Trampoline.call (lambda (t$1) ($Trampoline.call t$1)))
(define ($Trampoline.wrap value$1) (vector 'Trampoline.wrap value$1))
(define Trampoline.wrap (lambda (value$1) ($Trampoline.wrap value$1)))
(define ($BitsMap.set_if_empty.cps.go bits$1 val$2 map$3 cont$4) (let ((self0 bits$1)) (case (get self0 0) ('Bits.e (let () (let ((self0 map$3)) (case (get self0 0) ('BitsMap.new (let () (cont$4 ($BitsMap.tie ($Maybe.some val$2) BitsMap.new BitsMap.new)))) ('BitsMap.tie (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (cont$4 ($BitsMap.tie (let ((self3 f0)) (case (get self3 0) ('Maybe.none (let () ($Maybe.some val$2))) ('Maybe.some (let ((f3 (get self3 1))) ($Maybe.some f3))))) f1 f2)))))))) ('Bits.o (let ((f0 (get self0 1))) (let ((self1 map$3)) (case (get self1 0) ('BitsMap.new (let () ($BitsMap.set_if_empty.cps.go f0 val$2 BitsMap.new (lambda (lft$6) ($Trampoline.wrap (lambda ($7) (cont$4 ($BitsMap.tie Maybe.none lft$6 BitsMap.new)))))))) ('BitsMap.tie (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))) ($BitsMap.set_if_empty.cps.go f0 val$2 f2 (lambda (lft$9) ($Trampoline.wrap (lambda ($10) (cont$4 ($BitsMap.tie f1 lft$9 f3)))))))))))) ('Bits.i (let ((f0 (get self0 1))) (let ((self1 map$3)) (case (get self1 0) ('BitsMap.new (let () ($BitsMap.set_if_empty.cps.go f0 val$2 BitsMap.new (lambda (rgt$6) ($Trampoline.wrap (lambda ($7) (cont$4 ($BitsMap.tie Maybe.none BitsMap.new rgt$6)))))))) ('BitsMap.tie (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))) ($BitsMap.set_if_empty.cps.go f0 val$2 f3 (lambda (rgt$9) ($Trampoline.wrap (lambda ($10) (cont$4 ($BitsMap.tie f1 f2 rgt$9)))))))))))))))
(define BitsMap.set_if_empty.cps.go (lambda (bits$1) (lambda (val$2) (lambda (map$3) (lambda (cont$4) ($BitsMap.set_if_empty.cps.go bits$1 val$2 map$3 cont$4))))))
(define ($Trampoline.done value$1) (vector 'Trampoline.done value$1))
(define Trampoline.done (lambda (value$1) ($Trampoline.done value$1)))
(define ($BitsMap.set_if_empty.cps bits$1 val$2 map$3) ($Trampoline.call ($BitsMap.set_if_empty.cps.go bits$1 val$2 map$3 Trampoline.done)))
(define BitsMap.set_if_empty.cps (lambda (bits$1) (lambda (val$2) (lambda (map$3) ($BitsMap.set_if_empty.cps bits$1 val$2 map$3)))))
(define ($BitsMap.set_if_empty bits$1 val$2 map$3) ($BitsMap.set_if_empty.cps bits$1 val$2 map$3))
(define BitsMap.set_if_empty (lambda (bits$1) (lambda (val$2) (lambda (map$3) ($BitsMap.set_if_empty bits$1 val$2 map$3)))))
(define ($Kind.Map.set_if_empty name$1 val$2 map$3) ($BitsMap.set_if_empty ($Kind.Name.to_bits name$1) val$2 map$3))
(define Kind.Map.set_if_empty (lambda (name$1) (lambda (val$2) (lambda (map$3) ($Kind.Map.set_if_empty name$1 val$2 map$3)))))
(define ($Kind.Status.init) (vector 'Kind.Status.init))
(define Kind.Status.init ($Kind.Status.init))
(define ($Kind.Map.def file$0 code$1 orig$2 name$3 term$4 type$5 isct$6 arit$7 done$8 defs$9) (let ((defn$10 ((((((((Kind.Def.new file$0) code$1) orig$2) name$3) term$4) type$5) isct$6) arit$7))) (let ((self1 done$8)) (case self1 (#t (let () ($Kind.Map.set name$3 (defn$10 ($Kind.Status.done Bool.false)) defs$9))) (#f (let () ($Kind.Map.set_if_empty name$3 (defn$10 Kind.Status.init) defs$9)))))))
(define Kind.Map.def (lambda (file$0) (lambda (code$1) (lambda (orig$2) (lambda (name$3) (lambda (term$4) (lambda (type$5) (lambda (isct$6) (lambda (arit$7) (lambda (done$8) (lambda (defs$9) ($Kind.Map.def file$0 code$1 orig$2 name$3 term$4 type$5 isct$6 arit$7 done$8 defs$9))))))))))))
(define ($Kind.Parser.file.def file$0 code$1 defs$2 idx$3 code$4) (let ((self0 ($Kind.Parser.init idx$3 code$4))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ($Kind.Parser.name1 f0 f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (let ((self6 ((($Parser.many (Kind.Parser.binder ":")) f3) f4))) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Parser.Reply.error f6 f7 f8))) ('Parser.Reply.value (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) (let ((args$14 ($List.flatten f8))) (let ((self10 ($Kind.Parser.text ":" f6 f7))) (case (get self10 0) ('Parser.Reply.error (let ((f10 (get self10 1))(f11 (get self10 2))(f12 (get self10 3))) ($Parser.Reply.error f10 f11 f12))) ('Parser.Reply.value (let ((f10 (get self10 1))(f11 (get self10 2))(f12 (get self10 3))) (let ((self13 ($Kind.Parser.term f10 f11))) (case (get self13 0) ('Parser.Reply.error (let ((f13 (get self13 1))(f14 (get self13 2))(f15 (get self13 3))) ($Parser.Reply.error f13 f14 f15))) ('Parser.Reply.value (let ((f13 (get self13 1))(f14 (get self13 2))(f15 (get self13 3))) (let ((self16 ($Kind.Parser.term f13 f14))) (case (get self16 0) ('Parser.Reply.error (let ((f16 (get self16 1))(f17 (get self16 2))(f18 (get self16 3))) ($Parser.Reply.error f16 f17 f18))) ('Parser.Reply.value (let ((f16 (get self16 1))(f17 (get self16 2))(f18 (get self16 3))) (let ((self19 ($Kind.Parser.stop f2 f16 f17))) (case (get self19 0) ('Parser.Reply.error (let ((f19 (get self19 1))(f20 (get self19 2))(f21 (get self19 3))) ($Parser.Reply.error f19 f20 f21))) ('Parser.Reply.value (let ((f19 (get self19 1))(f20 (get self19 2))(f21 (get self19 3))) (let ((arit$27 ($List.length args$14))) (let ((type$28 ($Kind.Parser.make_forall args$14 f15))) (let ((term$29 ($Kind.Parser.make_lambda ($List.mapped args$14 (lambda (x$29) (let ((self25 x$29)) (case (get self25 0) ('Kind.Binder.new (let ((f25 (get self25 1))(f26 (get self25 2))(f27 (get self25 3))) f26)))))) f18))) (let ((type$30 ($Kind.Term.bind List.nil (lambda (x$30) ($Bits.i x$30)) type$28))) (let ((term$31 ($Kind.Term.bind List.nil (lambda (x$31) ($Bits.o x$31)) term$29))) (let ((defs$32 ($Kind.Map.def file$0 code$1 f21 f5 term$31 type$30 Bool.false arit$27 Bool.false defs$2))) ($Parser.Reply.value f19 f20 defs$32)))))))))))))))))))))))))))))))))))))
(define Kind.Parser.file.def (lambda (file$0) (lambda (code$1) (lambda (defs$2) (lambda (idx$3) (lambda (code$4) ($Kind.Parser.file.def file$0 code$1 defs$2 idx$3 code$4)))))))
(define ($Kind.Constructor.new name$0 args$1 inds$2) (vector 'Kind.Constructor.new name$0 args$1 inds$2))
(define Kind.Constructor.new (lambda (name$0) (lambda (args$1) (lambda (inds$2) ($Kind.Constructor.new name$0 args$1 inds$2)))))
(define ($Kind.Parser.constructor namespace$0 idx$1 code$2) (let ((self0 ($Kind.Parser.name1 idx$1 code$2))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ($Parser.maybe (Kind.Parser.binder ":") f0 f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (let ((self6 ($Parser.maybe (lambda (idx$9) (lambda (code$10) (let ((self8 ($Kind.Parser.text "~" idx$9 code$10))) (case (get self8 0) ('Parser.Reply.error (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))) ($Parser.Reply.error f8 f9 f10))) ('Parser.Reply.value (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))) ($Kind.Parser.binder "=" f8 f9))))))) f3 f4))) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Parser.Reply.error f6 f7 f8))) ('Parser.Reply.value (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) (let ((args$12 ($Maybe.default f5 List.nil))) (let ((inds$13 ($Maybe.default f8 List.nil))) ($Parser.Reply.value f6 f7 ($Kind.Constructor.new f2 args$12 inds$13)))))))))))))))))
(define Kind.Parser.constructor (lambda (namespace$0) (lambda (idx$1) (lambda (code$2) ($Kind.Parser.constructor namespace$0 idx$1 code$2)))))
(define ($Kind.Datatype.new name$0 pars$1 inds$2 ctrs$3) (vector 'Kind.Datatype.new name$0 pars$1 inds$2 ctrs$3))
(define Kind.Datatype.new (lambda (name$0) (lambda (pars$1) (lambda (inds$2) (lambda (ctrs$3) ($Kind.Datatype.new name$0 pars$1 inds$2 ctrs$3))))))
(define ($Kind.Parser.datatype idx$0 code$1) (let ((self0 ($Kind.Parser.text "type " idx$0 code$1))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ($Kind.Parser.name1 f0 f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (let ((self6 ($Parser.maybe (Kind.Parser.binder ":") f3 f4))) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Parser.Reply.error f6 f7 f8))) ('Parser.Reply.value (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) (let ((self9 ($Parser.maybe (lambda (idx$11) (lambda (code$12) (let ((self11 ($Kind.Parser.text "~" idx$11 code$12))) (case (get self11 0) ('Parser.Reply.error (let ((f11 (get self11 1))(f12 (get self11 2))(f13 (get self11 3))) ($Parser.Reply.error f11 f12 f13))) ('Parser.Reply.value (let ((f11 (get self11 1))(f12 (get self11 2))(f13 (get self11 3))) ($Kind.Parser.binder ":" f11 f12))))))) f6 f7))) (case (get self9 0) ('Parser.Reply.error (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) ($Parser.Reply.error f9 f10 f11))) ('Parser.Reply.value (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) (let ((pars$14 ($Maybe.default f8 List.nil))) (let ((inds$15 ($Maybe.default f11 List.nil))) (let ((self14 ($Kind.Parser.text "{" f9 f10))) (case (get self14 0) ('Parser.Reply.error (let ((f14 (get self14 1))(f15 (get self14 2))(f16 (get self14 3))) ($Parser.Reply.error f14 f15 f16))) ('Parser.Reply.value (let ((f14 (get self14 1))(f15 (get self14 2))(f16 (get self14 3))) (let ((self17 ((($Parser.until (Kind.Parser.text "}") (Kind.Parser.item (Kind.Parser.constructor f5))) f14) f15))) (case (get self17 0) ('Parser.Reply.error (let ((f17 (get self17 1))(f18 (get self17 2))(f19 (get self17 3))) ($Parser.Reply.error f17 f18 f19))) ('Parser.Reply.value (let ((f17 (get self17 1))(f18 (get self17 2))(f19 (get self17 3))) ($Parser.Reply.value f17 f18 ($Kind.Datatype.new f5 pars$14 inds$15 f19)))))))))))))))))))))))))))))
(define Kind.Parser.datatype (lambda (idx$0) (lambda (code$1) ($Kind.Parser.datatype idx$0 code$1))))
(define ($Kind.Datatype.build_term.motive.go type$0 name$1 inds$2) (let ((self0 inds$2)) (case (get self0 0) ('List.nil (let () (let ((self0 type$0)) (case (get self0 0) ('Kind.Datatype.new (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))) (let ((slf$7 ($Kind.Term.ref name$1))) (let ((slf$8 ($List.for f1 slf$7 (lambda (v$8) (lambda (slf$9) ($Kind.Term.app slf$9 ($Kind.Term.ref (let ((self7 v$8)) (case (get self7 0) ('Kind.Binder.new (let ((f7 (get self7 1))(f8 (get self7 2))(f9 (get self7 3))) f8))))))))))) (let ((slf$9 ($List.for f2 slf$8 (lambda (v$9) (lambda (slf$10) ($Kind.Term.app slf$10 ($Kind.Term.ref (let ((self8 v$9)) (case (get self8 0) ('Kind.Binder.new (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))) f9))))))))))) ($Kind.Term.all Bool.false "" "" slf$9 (lambda (s$10) (lambda (x$11) Kind.Term.typ)))))))))))) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 f0)) (case (get self2 0) ('Kind.Binder.new (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))) ($Kind.Term.all f2 "" f3 f4 (lambda (s$8) (lambda (x$9) ($Kind.Datatype.build_term.motive.go type$0 name$1 f1)))))))))))))
(define Kind.Datatype.build_term.motive.go (lambda (type$0) (lambda (name$1) (lambda (inds$2) ($Kind.Datatype.build_term.motive.go type$0 name$1 inds$2)))))
(define ($Kind.Datatype.build_term.motive type$0) (let ((self0 type$0)) (case (get self0 0) ('Kind.Datatype.new (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))) ($Kind.Datatype.build_term.motive.go type$0 f0 f2))))))
(define Kind.Datatype.build_term.motive (lambda (type$0) ($Kind.Datatype.build_term.motive type$0)))
(define ($Kind.Datatype.build_term.constructor.go type$0 ctor$1 args$2) (let ((self0 args$2)) (case (get self0 0) ('List.nil (let () (let ((self0 type$0)) (case (get self0 0) ('Kind.Datatype.new (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))) (let ((self4 ctor$1)) (case (get self4 0) ('Kind.Constructor.new (let ((f4 (get self4 1))(f5 (get self4 2))(f6 (get self4 3))) (let ((ret$10 ($Kind.Term.ref ($Kind.Name.read "P")))) (let ((ret$11 ($List.for f6 ret$10 (lambda (v$11) (lambda (ret$12) ($Kind.Term.app ret$12 (let ((self10 v$11)) (case (get self10 0) ('Kind.Binder.new (let ((f10 (get self10 1))(f11 (get self10 2))(f12 (get self10 3))) f12)))))))))) (let ((ctr$12 ($String.flatten ($List.cons f0 ($List.cons ($Kind.Name.read ".") ($List.cons f4 List.nil)))))) (let ((slf$13 ($Kind.Term.ref ctr$12))) (let ((slf$14 ($List.for f1 slf$13 (lambda (v$14) (lambda (slf$15) ($Kind.Term.app slf$15 ($Kind.Term.ref (let ((self13 v$14)) (case (get self13 0) ('Kind.Binder.new (let ((f13 (get self13 1))(f14 (get self13 2))(f15 (get self13 3))) f14))))))))))) (let ((slf$15 ($List.for f5 slf$14 (lambda (v$15) (lambda (slf$16) ($Kind.Term.app slf$16 ($Kind.Term.ref (let ((self14 v$15)) (case (get self14 0) ('Kind.Binder.new (let ((f14 (get self14 1))(f15 (get self14 2))(f16 (get self14 3))) f15))))))))))) ($Kind.Term.app ret$11 slf$15))))))))))))))))) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 f0)) (case (get self2 0) ('Kind.Binder.new (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))) (let ((eras$8 f2)) (let ((name$9 f3)) (let ((xtyp$10 f4)) (let ((body$11 ($Kind.Datatype.build_term.constructor.go type$0 ctor$1 f1))) ($Kind.Term.all eras$8 "" name$9 xtyp$10 (lambda (s$12) (lambda (x$13) body$11))))))))))))))))
(define Kind.Datatype.build_term.constructor.go (lambda (type$0) (lambda (ctor$1) (lambda (args$2) ($Kind.Datatype.build_term.constructor.go type$0 ctor$1 args$2)))))
(define ($Kind.Datatype.build_term.constructor type$0 ctor$1) (let ((self0 ctor$1)) (case (get self0 0) ('Kind.Constructor.new (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Kind.Datatype.build_term.constructor.go type$0 ctor$1 f1))))))
(define Kind.Datatype.build_term.constructor (lambda (type$0) (lambda (ctor$1) ($Kind.Datatype.build_term.constructor type$0 ctor$1))))
(define ($Kind.Datatype.build_term.constructors.go type$0 name$1 ctrs$2) (let ((self0 ctrs$2)) (case (get self0 0) ('List.nil (let () (let ((self0 type$0)) (case (get self0 0) ('Kind.Datatype.new (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))) (let ((ret$7 ($Kind.Term.ref ($Kind.Name.read "P")))) (let ((ret$8 ($List.for f2 ret$7 (lambda (v$8) (lambda (ret$9) ($Kind.Term.app ret$9 ($Kind.Term.ref (let ((self7 v$8)) (case (get self7 0) ('Kind.Binder.new (let ((f7 (get self7 1))(f8 (get self7 2))(f9 (get self7 3))) f8))))))))))) ($Kind.Term.app ret$8 ($Kind.Term.ref ($String.concat name$1 ".Self"))))))))))) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 f0)) (case (get self2 0) ('Kind.Constructor.new (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))) ($Kind.Term.all Bool.false "" f2 ($Kind.Datatype.build_term.constructor type$0 f0) (lambda (s$8) (lambda (x$9) ($Kind.Datatype.build_term.constructors.go type$0 name$1 f1)))))))))))))
(define Kind.Datatype.build_term.constructors.go (lambda (type$0) (lambda (name$1) (lambda (ctrs$2) ($Kind.Datatype.build_term.constructors.go type$0 name$1 ctrs$2)))))
(define ($Kind.Datatype.build_term.constructors type$0) (let ((self0 type$0)) (case (get self0 0) ('Kind.Datatype.new (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))) ($Kind.Datatype.build_term.constructors.go type$0 f0 f3))))))
(define Kind.Datatype.build_term.constructors (lambda (type$0) ($Kind.Datatype.build_term.constructors type$0)))
(define ($Kind.Datatype.build_term.go type$0 name$1 pars$2 inds$3) (let ((self0 pars$2)) (case (get self0 0) ('List.nil (let () (let ((self0 inds$3)) (case (get self0 0) ('List.nil (let () ($Kind.Term.all Bool.true ($String.concat name$1 ".Self") ($Kind.Name.read "P") ($Kind.Datatype.build_term.motive type$0) (lambda (s$4) (lambda (x$5) ($Kind.Datatype.build_term.constructors type$0)))))) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 f0)) (case (get self2 0) ('Kind.Binder.new (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))) ($Kind.Term.lam f3 (lambda (x$9) ($Kind.Datatype.build_term.go type$0 name$1 pars$2 f1))))))))))))) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 f0)) (case (get self2 0) ('Kind.Binder.new (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))) ($Kind.Term.lam f3 (lambda (x$9) ($Kind.Datatype.build_term.go type$0 name$1 f1 inds$3))))))))))))
(define Kind.Datatype.build_term.go (lambda (type$0) (lambda (name$1) (lambda (pars$2) (lambda (inds$3) ($Kind.Datatype.build_term.go type$0 name$1 pars$2 inds$3))))))
(define ($Kind.Datatype.build_term type$0) (let ((self0 type$0)) (case (get self0 0) ('Kind.Datatype.new (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))) ($Kind.Datatype.build_term.go type$0 f0 f1 f2))))))
(define Kind.Datatype.build_term (lambda (type$0) ($Kind.Datatype.build_term type$0)))
(define ($Kind.Datatype.build_type.go type$0 name$1 pars$2 inds$3) (let ((self0 pars$2)) (case (get self0 0) ('List.nil (let () (let ((self0 inds$3)) (case (get self0 0) ('List.nil (let () Kind.Term.typ)) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 f0)) (case (get self2 0) ('Kind.Binder.new (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))) ($Kind.Term.all Bool.false "" f3 f4 (lambda (s$9) (lambda (x$10) ($Kind.Datatype.build_type.go type$0 name$1 pars$2 f1)))))))))))))) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 f0)) (case (get self2 0) ('Kind.Binder.new (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))) ($Kind.Term.all Bool.false "" f3 f4 (lambda (s$9) (lambda (x$10) ($Kind.Datatype.build_type.go type$0 name$1 f1 inds$3)))))))))))))
(define Kind.Datatype.build_type.go (lambda (type$0) (lambda (name$1) (lambda (pars$2) (lambda (inds$3) ($Kind.Datatype.build_type.go type$0 name$1 pars$2 inds$3))))))
(define ($Kind.Datatype.build_type type$0) (let ((self0 type$0)) (case (get self0 0) ('Kind.Datatype.new (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))) ($Kind.Datatype.build_type.go type$0 f0 f1 f2))))))
(define Kind.Datatype.build_type (lambda (type$0) ($Kind.Datatype.build_type type$0)))
(define ($Kind.Constructor.build_term.opt.go type$0 ctor$1 ctrs$2) (let ((self0 ctrs$2)) (case (get self0 0) ('List.nil (let () (let ((self0 ctor$1)) (case (get self0 0) ('Kind.Constructor.new (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((ret$6 ($Kind.Term.ref f0))) (let ((ret$7 ($List.for f1 ret$6 (lambda (arg$7) (lambda (ret$8) ($Kind.Term.app ret$8 ($Kind.Term.ref (let ((self6 arg$7)) (case (get self6 0) ('Kind.Binder.new (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) f7))))))))))) ret$7)))))))) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 f0)) (case (get self2 0) ('Kind.Constructor.new (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))) ($Kind.Term.lam f2 (lambda (x$8) ($Kind.Constructor.build_term.opt.go type$0 ctor$1 f1))))))))))))
(define Kind.Constructor.build_term.opt.go (lambda (type$0) (lambda (ctor$1) (lambda (ctrs$2) ($Kind.Constructor.build_term.opt.go type$0 ctor$1 ctrs$2)))))
(define ($Kind.Constructor.build_term.opt type$0 ctor$1) (let ((self0 type$0)) (case (get self0 0) ('Kind.Datatype.new (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))) ($Kind.Constructor.build_term.opt.go type$0 ctor$1 f3))))))
(define Kind.Constructor.build_term.opt (lambda (type$0) (lambda (ctor$1) ($Kind.Constructor.build_term.opt type$0 ctor$1))))
(define ($Kind.Constructor.build_term.go type$0 ctor$1 name$2 pars$3 args$4) (let ((self0 pars$3)) (case (get self0 0) ('List.nil (let () (let ((self0 args$4)) (case (get self0 0) ('List.nil (let () ($Kind.Term.lam ($Kind.Name.read "P") (lambda (x$5) ($Kind.Constructor.build_term.opt type$0 ctor$1))))) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 f0)) (case (get self2 0) ('Kind.Binder.new (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))) ($Kind.Term.lam f3 (lambda (x$10) ($Kind.Constructor.build_term.go type$0 ctor$1 name$2 pars$3 f1))))))))))))) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 f0)) (case (get self2 0) ('Kind.Binder.new (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))) ($Kind.Term.lam f3 (lambda (x$10) ($Kind.Constructor.build_term.go type$0 ctor$1 name$2 f1 args$4))))))))))))
(define Kind.Constructor.build_term.go (lambda (type$0) (lambda (ctor$1) (lambda (name$2) (lambda (pars$3) (lambda (args$4) ($Kind.Constructor.build_term.go type$0 ctor$1 name$2 pars$3 args$4)))))))
(define ($Kind.Constructor.build_term type$0 ctor$1) (let ((self0 type$0)) (case (get self0 0) ('Kind.Datatype.new (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))) (let ((self4 ctor$1)) (case (get self4 0) ('Kind.Constructor.new (let ((f4 (get self4 1))(f5 (get self4 2))(f6 (get self4 3))) ($Kind.Constructor.build_term.go type$0 ctor$1 f0 f1 f5))))))))))
(define Kind.Constructor.build_term (lambda (type$0) (lambda (ctor$1) ($Kind.Constructor.build_term type$0 ctor$1))))
(define ($Kind.Constructor.build_type.go type$0 ctor$1 name$2 pars$3 args$4) (let ((self0 pars$3)) (case (get self0 0) ('List.nil (let () (let ((self0 args$4)) (case (get self0 0) ('List.nil (let () (let ((self0 type$0)) (case (get self0 0) ('Kind.Datatype.new (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))) (let ((self4 ctor$1)) (case (get self4 0) ('Kind.Constructor.new (let ((f4 (get self4 1))(f5 (get self4 2))(f6 (get self4 3))) (let ((type$12 ($Kind.Term.ref name$2))) (let ((type$13 ($List.for f1 type$12 (lambda (v$13) (lambda (type$14) ($Kind.Term.app type$14 ($Kind.Term.ref (let ((self10 v$13)) (case (get self10 0) ('Kind.Binder.new (let ((f10 (get self10 1))(f11 (get self10 2))(f12 (get self10 3))) f11))))))))))) (let ((type$14 ($List.for f6 type$13 (lambda (v$14) (lambda (type$15) ($Kind.Term.app type$15 (let ((self11 v$14)) (case (get self11 0) ('Kind.Binder.new (let ((f11 (get self11 1))(f12 (get self11 2))(f13 (get self11 3))) f13)))))))))) type$14))))))))))))) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 f0)) (case (get self2 0) ('Kind.Binder.new (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))) ($Kind.Term.all f2 "" f3 f4 (lambda (s$10) (lambda (x$11) ($Kind.Constructor.build_type.go type$0 ctor$1 name$2 pars$3 f1)))))))))))))) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 f0)) (case (get self2 0) ('Kind.Binder.new (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))) ($Kind.Term.all f2 "" f3 f4 (lambda (s$10) (lambda (x$11) ($Kind.Constructor.build_type.go type$0 ctor$1 name$2 f1 args$4)))))))))))))
(define Kind.Constructor.build_type.go (lambda (type$0) (lambda (ctor$1) (lambda (name$2) (lambda (pars$3) (lambda (args$4) ($Kind.Constructor.build_type.go type$0 ctor$1 name$2 pars$3 args$4)))))))
(define ($Kind.Constructor.build_type type$0 ctor$1) (let ((self0 type$0)) (case (get self0 0) ('Kind.Datatype.new (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))) (let ((self4 ctor$1)) (case (get self4 0) ('Kind.Constructor.new (let ((f4 (get self4 1))(f5 (get self4 2))(f6 (get self4 3))) ($Kind.Constructor.build_type.go type$0 ctor$1 f0 f1 f5))))))))))
(define Kind.Constructor.build_type (lambda (type$0) (lambda (ctor$1) ($Kind.Constructor.build_type type$0 ctor$1))))
(define ($Kind.Parser.file.adt file$0 code$1 defs$2 idx$3 code$4) (let ((self0 ($Kind.Parser.init idx$3 code$4))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ($Kind.Parser.datatype f0 f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (let ((self6 ($Kind.Parser.stop f2 f3 f4))) (case (get self6 0) ('Parser.Reply.error (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Parser.Reply.error f6 f7 f8))) ('Parser.Reply.value (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) (((let ((self9 f5)) (case (get self9 0) ('Kind.Datatype.new (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))(f12 (get self9 4))) (let ((term$18 ($Kind.Datatype.build_term f5))) (let ((term$19 ($Kind.Term.bind List.nil (lambda (x$19) ($Bits.i x$19)) term$18))) (let ((type$20 ($Kind.Datatype.build_type f5))) (let ((type$21 ($Kind.Term.bind List.nil (lambda (x$21) ($Bits.o x$21)) type$20))) (let ((arit$22 ($Nat.add ($List.length f10) ($List.length f11)))) (let ((defs$23 ($Kind.Map.def file$0 code$1 f8 f9 term$19 type$21 Bool.false arit$22 Bool.false defs$2))) (let ((defs$24 ($List.fold f12 defs$23 (lambda (ctr$24) (lambda (defs$25) (let ((typ_name$26 f9)) (let ((ctr_arit$27 ($Nat.add arit$22 ($List.length (let ((self22 ctr$24)) (case (get self22 0) ('Kind.Constructor.new (let ((f22 (get self22 1))(f23 (get self22 2))(f24 (get self22 3))) f23)))))))) (let ((ctr_name$28 ($String.flatten ($List.cons typ_name$26 ($List.cons ($Kind.Name.read ".") ($List.cons (let ((self23 ctr$24)) (case (get self23 0) ('Kind.Constructor.new (let ((f23 (get self23 1))(f24 (get self23 2))(f25 (get self23 3))) f23)))) List.nil)))))) (let ((ctr_term$29 ($Kind.Constructor.build_term f5 ctr$24))) (let ((ctr_term$30 ($Kind.Term.bind List.nil (lambda (x$30) ($Bits.i x$30)) ctr_term$29))) (let ((ctr_type$31 ($Kind.Constructor.build_type f5 ctr$24))) (let ((ctr_type$32 ($Kind.Term.bind List.nil (lambda (x$32) ($Bits.o x$32)) ctr_type$31))) ($Kind.Map.def file$0 code$1 f8 ctr_name$28 ctr_term$30 ctr_type$32 Bool.true ctr_arit$27 Bool.false defs$25))))))))))))) (lambda (idx$25) (lambda (code$26) ($Parser.Reply.value idx$25 code$26 defs$24)))))))))))))) f6) f7))))))))))))))
(define Kind.Parser.file.adt (lambda (file$0) (lambda (code$1) (lambda (defs$2) (lambda (idx$3) (lambda (code$4) ($Kind.Parser.file.adt file$0 code$1 defs$2 idx$3 code$4)))))))
(define ($Kind.Parser.file.end file$0 code$1 defs$2 idx$3 code$4) (let ((self0 ((Kind.Parser.spaces idx$3) code$4))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ($Parser.eof f0 f1))) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.error f3 f4 f5))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.value f3 f4 defs$2))))))))))
(define Kind.Parser.file.end (lambda (file$0) (lambda (code$1) (lambda (defs$2) (lambda (idx$3) (lambda (code$4) ($Kind.Parser.file.end file$0 code$1 defs$2 idx$3 code$4)))))))
(define ($Kind.Parser.file file$0 code$1 defs$2 idx$3 code$4) (let ((self0 ($Parser.is_eof idx$3 code$4))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (((let ((self3 f2)) (case self3 (#t (let () (lambda (idx$8) (lambda (code$9) ($Parser.Reply.value idx$8 code$9 defs$2))))) (#f (let () (lambda (idx$8) (lambda (code$9) (let ((self5 ((($Parser.first_of ($List.cons (((Kind.Parser.file.def file$0) code$1) defs$2) ($List.cons (((Kind.Parser.file.adt file$0) code$1) defs$2) ($List.cons (((Kind.Parser.file.end file$0) code$1) defs$2) List.nil)))) idx$8) code$9))) (case (get self5 0) ('Parser.Reply.error (let ((f5 (get self5 1))(f6 (get self5 2))(f7 (get self5 3))) ($Parser.Reply.error f5 f6 f7))) ('Parser.Reply.value (let ((f5 (get self5 1))(f6 (get self5 2))(f7 (get self5 3))) ($Kind.Parser.file file$0 code$1 f7 f5 f6))))))))))) f0) f1))))))
(define Kind.Parser.file (lambda (file$0) (lambda (code$1) (lambda (defs$2) (lambda (idx$3) (lambda (code$4) ($Kind.Parser.file file$0 code$1 defs$2 idx$3 code$4)))))))
(define ($String.join.go sep$0 list$1 fst$2) (let ((self0 list$1)) (case (get self0 0) ('List.nil (let () "")) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) ($String.flatten ($List.cons (let ((self2 fst$2)) (case self2 (#t (let () "")) (#f (let () sep$0)))) ($List.cons f0 ($List.cons ($String.join.go sep$0 f1 Bool.false) List.nil)))))))))
(define String.join.go (lambda (sep$0) (lambda (list$1) (lambda (fst$2) ($String.join.go sep$0 list$1 fst$2)))))
(define ($String.join sep$0 list$1) ($String.join.go sep$0 list$1 Bool.true))
(define String.join (lambda (sep$0) (lambda (list$1) ($String.join sep$0 list$1))))
(define ($Kind.Code.highlight.end col$0 row$1 res$2) ($String.join "\xA;" res$2))
(define Kind.Code.highlight.end (lambda (col$0) (lambda (row$1) (lambda (res$2) ($Kind.Code.highlight.end col$0 row$1 res$2)))))
(define ($Maybe.extract m$1 a$3 f$4) (let ((self0 m$1)) (case (get self0 0) ('Maybe.none (let () a$3)) ('Maybe.some (let ((f0 (get self0 1))) (f$4 f0))))))
(define Maybe.extract (lambda (m$1) (lambda (a$3) (lambda (f$4) ($Maybe.extract m$1 a$3 f$4)))))
(define ($Nat.is_zero n$0) (let ((self0 n$0)) (case (= self0 0) (#t (let () Bool.true)) (#f (let ((f0 (- self0 1))) Bool.false)))))
(define Nat.is_zero (lambda (n$0) ($Nat.is_zero n$0)))
(define ($Nat.double n$0) (let ((self0 n$0)) (case (= self0 0) (#t (let () Nat.zero)) (#f (let ((f0 (- self0 1))) ($Nat.succ ($Nat.succ ($Nat.double f0))))))))
(define Nat.double (lambda (n$0) ($Nat.double n$0)))
(define ($Nat.pred n$0) (let ((self0 n$0)) (case (= self0 0) (#t (let () Nat.zero)) (#f (let ((f0 (- self0 1))) f0)))))
(define Nat.pred (lambda (n$0) ($Nat.pred n$0)))
(define ($String.pad_right size$0 chr$1 str$2) (let ((self0 size$0)) (case (= self0 0) (#t (let () str$2)) (#f (let ((f0 (- self0 1))) (let ((self1 str$2)) (case (= (string-length self1) 0) (#t (let () ($String.cons chr$1 ($String.pad_right f0 chr$1 "")))) (#f (let ((f1 (char->integer (string-ref self1 0)))(f2 (let ((_str_ self1)) (substring _str_ 1 (string-length _str_))))) ($String.cons f1 ($String.pad_right f0 chr$1 f2)))))))))))
(define String.pad_right (lambda (size$0) (lambda (chr$1) (lambda (str$2) ($String.pad_right size$0 chr$1 str$2)))))
(define ($String.pad_left size$0 chr$1 str$2) ($String.reverse ($String.pad_right size$0 chr$1 ($String.reverse str$2))))
(define String.pad_left (lambda (size$0) (lambda (chr$1) (lambda (str$2) ($String.pad_left size$0 chr$1 str$2)))))
(define ($Bool.not a$0) (not a$0))
(define Bool.not (lambda (a$0) ($Bool.not a$0)))
(define ($Kind.Code.color col$0 str$1) ($String.cons ($Nat.to_u16 27) ($String.cons 91 ($String.concat col$0 ($String.cons 109 ($String.concat str$1 ($String.cons ($Nat.to_u16 27) ($String.cons 91 ($String.cons 48 ($String.cons 109 String.nil))))))))))
(define Kind.Code.color (lambda (col$0) (lambda (str$1) ($Kind.Code.color col$0 str$1))))
(define ($Nat.eql n$0 m$1) (= n$0 m$1))
(define Nat.eql (lambda (n$0) (lambda (m$1) ($Nat.eql n$0 m$1))))
(define ($List.take n$1 xs$2) (let ((self0 xs$2)) (case (get self0 0) ('List.nil (let () List.nil)) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 n$1)) (case (= self2 0) (#t (let () List.nil)) (#f (let ((f2 (- self2 1))) ($List.cons f0 ($List.take f2 f1)))))))))))
(define List.take (lambda (n$1) (lambda (xs$2) ($List.take n$1 xs$2))))
(define ($Kind.Code.highlight.go code$0 ix0$1 ix1$2 col$3 row$4 lft$5 lin$6 res$7) (let ((spa$8 3)) (let ((self1 code$0)) (case (= (string-length self1) 0) (#t (let () ($Kind.Code.highlight.end col$3 row$4 ($List.reverse res$7)))) (#f (let ((f1 (char->integer (string-ref self1 0)))(f2 (let ((_str_ self1)) (substring _str_ 1 (string-length _str_))))) (let ((self3 ($U16.eql f1 10))) (case self3 (#t (let () (let ((stp$11 ($Maybe.extract lft$5 Bool.false Nat.is_zero))) (let ((self4 stp$11)) (case self4 (#t (let () ($Kind.Code.highlight.end col$3 row$4 ($List.reverse res$7)))) (#f (let () (let ((siz$12 ($Nat.succ ($Nat.double spa$8)))) (let ((lft$13 (let ((self5 ix1$2)) (case (= self5 0) (#t (let () (let ((self5 lft$5)) (case (get self5 0) ('Maybe.none (let () ($Maybe.some spa$8))) ('Maybe.some (let ((f5 (get self5 1))) ($Maybe.some ($Nat.pred f5)))))))) (#f (let ((f5 (- self5 1))) lft$5)))))) (let ((ix0$14 ($Nat.pred ix0$1))) (let ((ix1$15 ($Nat.pred ix1$2))) (let ((col$16 0)) (let ((row$17 ($Nat.succ row$4))) (let ((res$18 ($List.cons ($String.reverse lin$6) res$7))) (let ((lin$19 ($String.reverse ($String.flatten ($List.cons ($String.pad_left 4 32 ($Nat.show row$17)) ($List.cons " | " List.nil)))))) ($Kind.Code.highlight.go f2 ix0$14 ix1$15 col$16 row$17 lft$13 lin$19 res$18)))))))))))))))) (#f (let () (let ((chr$11 ($String.cons f1 String.nil))) (let ((chr$12 (let ((self4 ($Bool.and ($Nat.is_zero ix0$1) ($Bool.not ($Nat.is_zero ix1$2))))) (case self4 (#t (let () ($String.reverse ($Kind.Code.color "31" ($Kind.Code.color "4" chr$11))))) (#f (let () chr$11)))))) (let ((res$13 (let ((self5 ($Nat.eql ix0$1 1))) (case self5 (#t (let () ($List.take spa$8 res$7))) (#f (let () res$7)))))) (let ((ix0$14 ($Nat.pred ix0$1))) (let ((ix1$15 ($Nat.pred ix1$2))) (let ((col$16 ($Nat.succ col$3))) (let ((lin$17 ($String.flatten ($List.cons chr$12 ($List.cons lin$6 List.nil))))) ($Kind.Code.highlight.go f2 ix0$14 ix1$15 col$16 row$4 lft$5 lin$17 res$13))))))))))))))))))
(define Kind.Code.highlight.go (lambda (code$0) (lambda (ix0$1) (lambda (ix1$2) (lambda (col$3) (lambda (row$4) (lambda (lft$5) (lambda (lin$6) (lambda (res$7) ($Kind.Code.highlight.go code$0 ix0$1 ix1$2 col$3 row$4 lft$5 lin$6 res$7))))))))))
(define ($Kind.Code.highlight code$0 idx0$1 idx1$2) ($Kind.Code.highlight.go code$0 idx0$1 idx1$2 0 1 Maybe.none ($String.reverse "   1 | ") List.nil))
(define Kind.Code.highlight (lambda (code$0) (lambda (idx0$1) (lambda (idx1$2) ($Kind.Code.highlight code$0 idx0$1 idx1$2)))))
(define ($Kind.Defs.read file$0 code$1 defs$2) (let ((self0 ($Kind.Parser.file file$0 code$1 defs$2 0 code$1))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((err$6 f2)) (let ((hig$7 ($Kind.Code.highlight code$1 f0 ($Nat.succ f0)))) (let ((str$8 ($String.flatten ($List.cons err$6 ($List.cons "\xA;" ($List.cons hig$7 List.nil)))))) ($Either.left str$8)))))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Either.right f2))))))
(define Kind.Defs.read (lambda (file$0) (lambda (code$1) (lambda (defs$2) ($Kind.Defs.read file$0 code$1 defs$2)))))
(define ($BitsMap.keys.go xs$1 key$2 list$3) (let ((self0 xs$1)) (case (get self0 0) ('BitsMap.new (let () list$3)) ('BitsMap.tie (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((list0$7 (let ((self3 f0)) (case (get self3 0) ('Maybe.none (let () list$3)) ('Maybe.some (let ((f3 (get self3 1))) ($List.cons ($Bits.reverse key$2) list$3))))))) (let ((list1$8 ($BitsMap.keys.go f1 ($Bits.o key$2) list0$7))) (let ((list2$9 ($BitsMap.keys.go f2 ($Bits.i key$2) list1$8))) list2$9))))))))
(define BitsMap.keys.go (lambda (xs$1) (lambda (key$2) (lambda (list$3) ($BitsMap.keys.go xs$1 key$2 list$3)))))
(define ($BitsMap.keys xs$1) ($List.reverse ($BitsMap.keys.go xs$1 Bits.e List.nil)))
(define BitsMap.keys (lambda (xs$1) ($BitsMap.keys xs$1)))
(define ($Kind.Name.from_bits bs$0) (let ((self0 bs$0)) (case (get self0 0) ('Bits.e (let () String.nil)) ('Bits.o (let ((f0 (get self0 1))) (let ((bs$2 f0)) (let ((self2 bs$2)) (case (get self2 0) ('Bits.e (let () String.nil)) ('Bits.o (let ((f2 (get self2 1))) (let ((bs$4 f2)) (let ((self4 bs$4)) (case (get self4 0) ('Bits.e (let () String.nil)) ('Bits.o (let ((f4 (get self4 1))) (let ((bs$6 f4)) (let ((self6 bs$6)) (case (get self6 0) ('Bits.e (let () String.nil)) ('Bits.o (let ((f6 (get self6 1))) (let ((bs$8 f6)) (let ((self8 bs$8)) (case (get self8 0) ('Bits.e (let () String.nil)) ('Bits.o (let ((f8 (get self8 1))) (let ((bs$10 f8)) (let ((self10 bs$10)) (case (get self10 0) ('Bits.e (let () String.nil)) ('Bits.o (let ((f10 (get self10 1))) (let ((bs$12 f10)) ($String.cons 65 ($Kind.Name.from_bits bs$12))))) ('Bits.i (let ((f10 (get self10 1))) (let ((bs$12 f10)) ($String.cons 66 ($Kind.Name.from_bits bs$12)))))))))) ('Bits.i (let ((f8 (get self8 1))) (let ((bs$10 f8)) (let ((self10 bs$10)) (case (get self10 0) ('Bits.e (let () String.nil)) ('Bits.o (let ((f10 (get self10 1))) (let ((bs$12 f10)) ($String.cons 67 ($Kind.Name.from_bits bs$12))))) ('Bits.i (let ((f10 (get self10 1))) (let ((bs$12 f10)) ($String.cons 68 ($Kind.Name.from_bits bs$12))))))))))))))) ('Bits.i (let ((f6 (get self6 1))) (let ((bs$8 f6)) (let ((self8 bs$8)) (case (get self8 0) ('Bits.e (let () String.nil)) ('Bits.o (let ((f8 (get self8 1))) (let ((bs$10 f8)) (let ((self10 bs$10)) (case (get self10 0) ('Bits.e (let () String.nil)) ('Bits.o (let ((f10 (get self10 1))) (let ((bs$12 f10)) ($String.cons 69 ($Kind.Name.from_bits bs$12))))) ('Bits.i (let ((f10 (get self10 1))) (let ((bs$12 f10)) ($String.cons 70 ($Kind.Name.from_bits bs$12)))))))))) ('Bits.i (let ((f8 (get self8 1))) (let ((bs$10 f8)) (let ((self10 bs$10)) (case (get self10 0) ('Bits.e (let () String.nil)) ('Bits.o (let ((f10 (get self10 1))) (let ((bs$12 f10)) ($String.cons 71 ($Kind.Name.from_bits bs$12))))) ('Bits.i (let ((f10 (get self10 1))) (let ((bs$12 f10)) ($String.cons 72 ($Kind.Name.from_bits bs$12)))))))))))))))))))) ('Bits.i (let ((f4 (get self4 1))) (let ((bs$6 f4)) (let ((self6 bs$6)) (case (get self6 0) ('Bits.e (let () String.nil)) ('Bits.o (let ((f6 (get self6 1))) (let ((bs$8 f6)) (let ((self8 bs$8)) (case (get self8 0) ('Bits.e (let () String.nil)) ('Bits.o (let ((f8 (get self8 1))) (let ((bs$10 f8)) (let ((self10 bs$10)) (case (get self10 0) ('Bits.e (let () String.nil)) ('Bits.o (let ((f10 (get self10 1))) (let ((bs$12 f10)) ($String.cons 73 ($Kind.Name.from_bits bs$12))))) ('Bits.i (let ((f10 (get self10 1))) (let ((bs$12 f10)) ($String.cons 74 ($Kind.Name.from_bits bs$12)))))))))) ('Bits.i (let ((f8 (get self8 1))) (let ((bs$10 f8)) (let ((self10 bs$10)) (case (get self10 0) ('Bits.e (let () String.nil)) ('Bits.o (let ((f10 (get self10 1))) (let ((bs$12 f10)) ($String.cons 75 ($Kind.Name.from_bits bs$12))))) ('Bits.i (let ((f10 (get self10 1))) (let ((bs$12 f10)) ($String.cons 76 ($Kind.Name.from_bits bs$12))))))))))))))) ('Bits.i (let ((f6 (get self6 1))) (let ((bs$8 f6)) (let ((self8 bs$8)) (case (get self8 0) ('Bits.e (let () String.nil)) ('Bits.o (let ((f8 (get self8 1))) (let ((bs$10 f8)) (let ((self10 bs$10)) (case (get self10 0) ('Bits.e (let () String.nil)) ('Bits.o (let ((f10 (get self10 1))) (let ((bs$12 f10)) ($String.cons 77 ($Kind.Name.from_bits bs$12))))) ('Bits.i (let ((f10 (get self10 1))) (let ((bs$12 f10)) ($String.cons 78 ($Kind.Name.from_bits bs$12)))))))))) ('Bits.i (let ((f8 (get self8 1))) (let ((bs$10 f8)) (let ((self10 bs$10)) (case (get self10 0) ('Bits.e (let () String.nil)) ('Bits.o (let ((f10 (get self10 1))) (let ((bs$12 f10)) ($String.cons 79 ($Kind.Name.from_bits bs$12))))) ('Bits.i (let ((f10 (get self10 1))) (let ((bs$12 f10)) ($String.cons 80 ($Kind.Name.from_bits bs$12))))))))))))))))))))))))) ('Bits.i (let ((f2 (get self2 1))) (let ((bs$4 f2)) (let ((self4 bs$4)) (case (get self4 0) ('Bits.e (let () String.nil)) ('Bits.o (let ((f4 (get self4 1))) (let ((bs$6 f4)) (let ((self6 bs$6)) (case (get self6 0) ('Bits.e (let () String.nil)) ('Bits.o (let ((f6 (get self6 1))) (let ((bs$8 f6)) (let ((self8 bs$8)) (case (get self8 0) ('Bits.e (let () String.nil)) ('Bits.o (let ((f8 (get self8 1))) (let ((bs$10 f8)) (let ((self10 bs$10)) (case (get self10 0) ('Bits.e (let () String.nil)) ('Bits.o (let ((f10 (get self10 1))) (let ((bs$12 f10)) ($String.cons 81 ($Kind.Name.from_bits bs$12))))) ('Bits.i (let ((f10 (get self10 1))) (let ((bs$12 f10)) ($String.cons 82 ($Kind.Name.from_bits bs$12)))))))))) ('Bits.i (let ((f8 (get self8 1))) (let ((bs$10 f8)) (let ((self10 bs$10)) (case (get self10 0) ('Bits.e (let () String.nil)) ('Bits.o (let ((f10 (get self10 1))) (let ((bs$12 f10)) ($String.cons 83 ($Kind.Name.from_bits bs$12))))) ('Bits.i (let ((f10 (get self10 1))) (let ((bs$12 f10)) ($String.cons 84 ($Kind.Name.from_bits bs$12))))))))))))))) ('Bits.i (let ((f6 (get self6 1))) (let ((bs$8 f6)) (let ((self8 bs$8)) (case (get self8 0) ('Bits.e (let () String.nil)) ('Bits.o (let ((f8 (get self8 1))) (let ((bs$10 f8)) (let ((self10 bs$10)) (case (get self10 0) ('Bits.e (let () String.nil)) ('Bits.o (let ((f10 (get self10 1))) (let ((bs$12 f10)) ($String.cons 85 ($Kind.Name.from_bits bs$12))))) ('Bits.i (let ((f10 (get self10 1))) (let ((bs$12 f10)) ($String.cons 86 ($Kind.Name.from_bits bs$12)))))))))) ('Bits.i (let ((f8 (get self8 1))) (let ((bs$10 f8)) (let ((self10 bs$10)) (case (get self10 0) ('Bits.e (let () String.nil)) ('Bits.o (let ((f10 (get self10 1))) (let ((bs$12 f10)) ($String.cons 87 ($Kind.Name.from_bits bs$12))))) ('Bits.i (let ((f10 (get self10 1))) (let ((bs$12 f10)) ($String.cons 88 ($Kind.Name.from_bits bs$12)))))))))))))))))))) ('Bits.i (let ((f4 (get self4 1))) (let ((bs$6 f4)) (let ((self6 bs$6)) (case (get self6 0) ('Bits.e (let () String.nil)) ('Bits.o (let ((f6 (get self6 1))) (let ((bs$8 f6)) (let ((self8 bs$8)) (case (get self8 0) ('Bits.e (let () String.nil)) ('Bits.o (let ((f8 (get self8 1))) (let ((bs$10 f8)) (let ((self10 bs$10)) (case (get self10 0) ('Bits.e (let () String.nil)) ('Bits.o (let ((f10 (get self10 1))) (let ((bs$12 f10)) ($String.cons 89 ($Kind.Name.from_bits bs$12))))) ('Bits.i (let ((f10 (get self10 1))) (let ((bs$12 f10)) ($String.cons 90 ($Kind.Name.from_bits bs$12)))))))))) ('Bits.i (let ((f8 (get self8 1))) (let ((bs$10 f8)) (let ((self10 bs$10)) (case (get self10 0) ('Bits.e (let () String.nil)) ('Bits.o (let ((f10 (get self10 1))) (let ((bs$12 f10)) ($String.cons 97 ($Kind.Name.from_bits bs$12))))) ('Bits.i (let ((f10 (get self10 1))) (let ((bs$12 f10)) ($String.cons 98 ($Kind.Name.from_bits bs$12))))))))))))))) ('Bits.i (let ((f6 (get self6 1))) (let ((bs$8 f6)) (let ((self8 bs$8)) (case (get self8 0) ('Bits.e (let () String.nil)) ('Bits.o (let ((f8 (get self8 1))) (let ((bs$10 f8)) (let ((self10 bs$10)) (case (get self10 0) ('Bits.e (let () String.nil)) ('Bits.o (let ((f10 (get self10 1))) (let ((bs$12 f10)) ($String.cons 99 ($Kind.Name.from_bits bs$12))))) ('Bits.i (let ((f10 (get self10 1))) (let ((bs$12 f10)) ($String.cons 100 ($Kind.Name.from_bits bs$12)))))))))) ('Bits.i (let ((f8 (get self8 1))) (let ((bs$10 f8)) (let ((self10 bs$10)) (case (get self10 0) ('Bits.e (let () String.nil)) ('Bits.o (let ((f10 (get self10 1))) (let ((bs$12 f10)) ($String.cons 101 ($Kind.Name.from_bits bs$12))))) ('Bits.i (let ((f10 (get self10 1))) (let ((bs$12 f10)) ($String.cons 102 ($Kind.Name.from_bits bs$12)))))))))))))))))))))))))))))) ('Bits.i (let ((f0 (get self0 1))) (let ((bs$2 f0)) (let ((self2 bs$2)) (case (get self2 0) ('Bits.e (let () String.nil)) ('Bits.o (let ((f2 (get self2 1))) (let ((bs$4 f2)) (let ((self4 bs$4)) (case (get self4 0) ('Bits.e (let () String.nil)) ('Bits.o (let ((f4 (get self4 1))) (let ((bs$6 f4)) (let ((self6 bs$6)) (case (get self6 0) ('Bits.e (let () String.nil)) ('Bits.o (let ((f6 (get self6 1))) (let ((bs$8 f6)) (let ((self8 bs$8)) (case (get self8 0) ('Bits.e (let () String.nil)) ('Bits.o (let ((f8 (get self8 1))) (let ((bs$10 f8)) (let ((self10 bs$10)) (case (get self10 0) ('Bits.e (let () String.nil)) ('Bits.o (let ((f10 (get self10 1))) (let ((bs$12 f10)) ($String.cons 103 ($Kind.Name.from_bits bs$12))))) ('Bits.i (let ((f10 (get self10 1))) (let ((bs$12 f10)) ($String.cons 104 ($Kind.Name.from_bits bs$12)))))))))) ('Bits.i (let ((f8 (get self8 1))) (let ((bs$10 f8)) (let ((self10 bs$10)) (case (get self10 0) ('Bits.e (let () String.nil)) ('Bits.o (let ((f10 (get self10 1))) (let ((bs$12 f10)) ($String.cons 105 ($Kind.Name.from_bits bs$12))))) ('Bits.i (let ((f10 (get self10 1))) (let ((bs$12 f10)) ($String.cons 106 ($Kind.Name.from_bits bs$12))))))))))))))) ('Bits.i (let ((f6 (get self6 1))) (let ((bs$8 f6)) (let ((self8 bs$8)) (case (get self8 0) ('Bits.e (let () String.nil)) ('Bits.o (let ((f8 (get self8 1))) (let ((bs$10 f8)) (let ((self10 bs$10)) (case (get self10 0) ('Bits.e (let () String.nil)) ('Bits.o (let ((f10 (get self10 1))) (let ((bs$12 f10)) ($String.cons 107 ($Kind.Name.from_bits bs$12))))) ('Bits.i (let ((f10 (get self10 1))) (let ((bs$12 f10)) ($String.cons 108 ($Kind.Name.from_bits bs$12)))))))))) ('Bits.i (let ((f8 (get self8 1))) (let ((bs$10 f8)) (let ((self10 bs$10)) (case (get self10 0) ('Bits.e (let () String.nil)) ('Bits.o (let ((f10 (get self10 1))) (let ((bs$12 f10)) ($String.cons 109 ($Kind.Name.from_bits bs$12))))) ('Bits.i (let ((f10 (get self10 1))) (let ((bs$12 f10)) ($String.cons 110 ($Kind.Name.from_bits bs$12)))))))))))))))))))) ('Bits.i (let ((f4 (get self4 1))) (let ((bs$6 f4)) (let ((self6 bs$6)) (case (get self6 0) ('Bits.e (let () String.nil)) ('Bits.o (let ((f6 (get self6 1))) (let ((bs$8 f6)) (let ((self8 bs$8)) (case (get self8 0) ('Bits.e (let () String.nil)) ('Bits.o (let ((f8 (get self8 1))) (let ((bs$10 f8)) (let ((self10 bs$10)) (case (get self10 0) ('Bits.e (let () String.nil)) ('Bits.o (let ((f10 (get self10 1))) (let ((bs$12 f10)) ($String.cons 111 ($Kind.Name.from_bits bs$12))))) ('Bits.i (let ((f10 (get self10 1))) (let ((bs$12 f10)) ($String.cons 112 ($Kind.Name.from_bits bs$12)))))))))) ('Bits.i (let ((f8 (get self8 1))) (let ((bs$10 f8)) (let ((self10 bs$10)) (case (get self10 0) ('Bits.e (let () String.nil)) ('Bits.o (let ((f10 (get self10 1))) (let ((bs$12 f10)) ($String.cons 113 ($Kind.Name.from_bits bs$12))))) ('Bits.i (let ((f10 (get self10 1))) (let ((bs$12 f10)) ($String.cons 114 ($Kind.Name.from_bits bs$12))))))))))))))) ('Bits.i (let ((f6 (get self6 1))) (let ((bs$8 f6)) (let ((self8 bs$8)) (case (get self8 0) ('Bits.e (let () String.nil)) ('Bits.o (let ((f8 (get self8 1))) (let ((bs$10 f8)) (let ((self10 bs$10)) (case (get self10 0) ('Bits.e (let () String.nil)) ('Bits.o (let ((f10 (get self10 1))) (let ((bs$12 f10)) ($String.cons 115 ($Kind.Name.from_bits bs$12))))) ('Bits.i (let ((f10 (get self10 1))) (let ((bs$12 f10)) ($String.cons 116 ($Kind.Name.from_bits bs$12)))))))))) ('Bits.i (let ((f8 (get self8 1))) (let ((bs$10 f8)) (let ((self10 bs$10)) (case (get self10 0) ('Bits.e (let () String.nil)) ('Bits.o (let ((f10 (get self10 1))) (let ((bs$12 f10)) ($String.cons 117 ($Kind.Name.from_bits bs$12))))) ('Bits.i (let ((f10 (get self10 1))) (let ((bs$12 f10)) ($String.cons 118 ($Kind.Name.from_bits bs$12))))))))))))))))))))))))) ('Bits.i (let ((f2 (get self2 1))) (let ((bs$4 f2)) (let ((self4 bs$4)) (case (get self4 0) ('Bits.e (let () String.nil)) ('Bits.o (let ((f4 (get self4 1))) (let ((bs$6 f4)) (let ((self6 bs$6)) (case (get self6 0) ('Bits.e (let () String.nil)) ('Bits.o (let ((f6 (get self6 1))) (let ((bs$8 f6)) (let ((self8 bs$8)) (case (get self8 0) ('Bits.e (let () String.nil)) ('Bits.o (let ((f8 (get self8 1))) (let ((bs$10 f8)) (let ((self10 bs$10)) (case (get self10 0) ('Bits.e (let () String.nil)) ('Bits.o (let ((f10 (get self10 1))) (let ((bs$12 f10)) ($String.cons 119 ($Kind.Name.from_bits bs$12))))) ('Bits.i (let ((f10 (get self10 1))) (let ((bs$12 f10)) ($String.cons 120 ($Kind.Name.from_bits bs$12)))))))))) ('Bits.i (let ((f8 (get self8 1))) (let ((bs$10 f8)) (let ((self10 bs$10)) (case (get self10 0) ('Bits.e (let () String.nil)) ('Bits.o (let ((f10 (get self10 1))) (let ((bs$12 f10)) ($String.cons 121 ($Kind.Name.from_bits bs$12))))) ('Bits.i (let ((f10 (get self10 1))) (let ((bs$12 f10)) ($String.cons 122 ($Kind.Name.from_bits bs$12))))))))))))))) ('Bits.i (let ((f6 (get self6 1))) (let ((bs$8 f6)) (let ((self8 bs$8)) (case (get self8 0) ('Bits.e (let () String.nil)) ('Bits.o (let ((f8 (get self8 1))) (let ((bs$10 f8)) (let ((self10 bs$10)) (case (get self10 0) ('Bits.e (let () String.nil)) ('Bits.o (let ((f10 (get self10 1))) (let ((bs$12 f10)) ($String.cons 48 ($Kind.Name.from_bits bs$12))))) ('Bits.i (let ((f10 (get self10 1))) (let ((bs$12 f10)) ($String.cons 49 ($Kind.Name.from_bits bs$12)))))))))) ('Bits.i (let ((f8 (get self8 1))) (let ((bs$10 f8)) (let ((self10 bs$10)) (case (get self10 0) ('Bits.e (let () String.nil)) ('Bits.o (let ((f10 (get self10 1))) (let ((bs$12 f10)) ($String.cons 50 ($Kind.Name.from_bits bs$12))))) ('Bits.i (let ((f10 (get self10 1))) (let ((bs$12 f10)) ($String.cons 51 ($Kind.Name.from_bits bs$12)))))))))))))))))))) ('Bits.i (let ((f4 (get self4 1))) (let ((bs$6 f4)) (let ((self6 bs$6)) (case (get self6 0) ('Bits.e (let () String.nil)) ('Bits.o (let ((f6 (get self6 1))) (let ((bs$8 f6)) (let ((self8 bs$8)) (case (get self8 0) ('Bits.e (let () String.nil)) ('Bits.o (let ((f8 (get self8 1))) (let ((bs$10 f8)) (let ((self10 bs$10)) (case (get self10 0) ('Bits.e (let () String.nil)) ('Bits.o (let ((f10 (get self10 1))) (let ((bs$12 f10)) ($String.cons 52 ($Kind.Name.from_bits bs$12))))) ('Bits.i (let ((f10 (get self10 1))) (let ((bs$12 f10)) ($String.cons 53 ($Kind.Name.from_bits bs$12)))))))))) ('Bits.i (let ((f8 (get self8 1))) (let ((bs$10 f8)) (let ((self10 bs$10)) (case (get self10 0) ('Bits.e (let () String.nil)) ('Bits.o (let ((f10 (get self10 1))) (let ((bs$12 f10)) ($String.cons 54 ($Kind.Name.from_bits bs$12))))) ('Bits.i (let ((f10 (get self10 1))) (let ((bs$12 f10)) ($String.cons 55 ($Kind.Name.from_bits bs$12))))))))))))))) ('Bits.i (let ((f6 (get self6 1))) (let ((bs$8 f6)) (let ((self8 bs$8)) (case (get self8 0) ('Bits.e (let () String.nil)) ('Bits.o (let ((f8 (get self8 1))) (let ((bs$10 f8)) (let ((self10 bs$10)) (case (get self10 0) ('Bits.e (let () String.nil)) ('Bits.o (let ((f10 (get self10 1))) (let ((bs$12 f10)) ($String.cons 56 ($Kind.Name.from_bits bs$12))))) ('Bits.i (let ((f10 (get self10 1))) (let ((bs$12 f10)) ($String.cons 57 ($Kind.Name.from_bits bs$12)))))))))) ('Bits.i (let ((f8 (get self8 1))) (let ((bs$10 f8)) (let ((self10 bs$10)) (case (get self10 0) ('Bits.e (let () String.nil)) ('Bits.o (let ((f10 (get self10 1))) (let ((bs$12 f10)) ($String.cons 46 ($Kind.Name.from_bits bs$12))))) ('Bits.i (let ((f10 (get self10 1))) (let ((bs$12 f10)) ($String.cons 95 ($Kind.Name.from_bits bs$12)))))))))))))))))))))))))))))))))
(define Kind.Name.from_bits (lambda (bs$0) ($Kind.Name.from_bits bs$0)))
(define ($Nat.read str$0) (let ((p$1 ($Parser.nat 0 str$0))) (let ((self1 p$1)) (case (get self1 0) ('Parser.Reply.error (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))) 0)) ('Parser.Reply.value (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))) f3))))))
(define Nat.read (lambda (str$0) ($Nat.read str$0)))
(define ($IO.get_time) ($IO.ask "get_time" "" (lambda (time$0) ($IO.end ($Nat.read time$0)))))
(define IO.get_time ($IO.get_time))
(define ($Kind.Synth.load.cached.is_loop name$0 defs$1) (let ((self0 ($Kind.Map.get name$0 defs$1))) (case (get self0 0) ('Maybe.none (let () Bool.false)) ('Maybe.some (let ((f0 (get self0 1))) (let ((self1 f0)) (case (get self1 0) ('Kind.Def.new (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))(f4 (get self1 4))(f5 (get self1 5))(f6 (get self1 6))(f7 (get self1 7))(f8 (get self1 8))(f9 (get self1 9))) (let ((self10 f9)) (case (get self10 0) ('Kind.Status.init (let () Bool.false)) ('Kind.Status.wait (let () Bool.false)) ('Kind.Status.done (let ((f10 (get self10 1))) f10)) ('Kind.Status.fail (let ((f10 (get self10 1))) Bool.false)))))))))))))
(define Kind.Synth.load.cached.is_loop (lambda (name$0) (lambda (defs$1) ($Kind.Synth.load.cached.is_loop name$0 defs$1))))
(define ($String.is_empty str$0) (let ((self0 str$0)) (case (= (string-length self0) 0) (#t (let () Bool.true)) (#f (let ((f0 (char->integer (string-ref self0 0)))(f1 (let ((_str_ self0)) (substring _str_ 1 (string-length _str_))))) Bool.false)))))
(define String.is_empty (lambda (str$0) ($String.is_empty str$0)))
(define ($IO.get_file_mtime name$0) ($IO.ask "get_file_mtime" name$0 (lambda (file$1) ($IO.end file$1))))
(define IO.get_file_mtime (lambda (name$0) ($IO.get_file_mtime name$0)))
(define ($Maybe.bind m$2 f$3) (let ((self0 m$2)) (case (get self0 0) ('Maybe.none (let () Maybe.none)) ('Maybe.some (let ((f0 (get self0 1))) (f$3 f0))))))
(define Maybe.bind (lambda (m$2) (lambda (f$3) ($Maybe.bind m$2 f$3))))
(define ($Maybe.monad) (vector 'Monad.new Maybe.bind Maybe.some))
(define Maybe.monad ($Maybe.monad))
(define ($Kind.Core.read.spaces code$0) (let ((self0 code$0)) (case (= (string-length self0) 0) (#t (let () ($Pair.new code$0 Unit.new))) (#f (let ((f0 (char->integer (string-ref self0 0)))(f1 (let ((_str_ self0)) (substring _str_ 1 (string-length _str_))))) (let ((is_space$3 ($Bool.or ($U16.eql f0 32) ($Bool.or ($U16.eql f0 10) ($Bool.or ($U16.eql f0 13) ($Bool.or ($U16.eql f0 9) ($Bool.or ($U16.eql f0 11) ($Bool.or ($U16.eql f0 12) Bool.false)))))))) (let ((self3 is_space$3)) (case self3 (#t (let () ($Kind.Core.read.spaces f1))) (#f (let () ($Pair.new code$0 Unit.new)))))))))))
(define Kind.Core.read.spaces (lambda (code$0) ($Kind.Core.read.spaces code$0)))
(define ($Char.eql a$0 b$1) ($U16.eql a$0 b$1))
(define Char.eql (lambda (a$0) (lambda (b$1) ($Char.eql a$0 b$1))))
(define ($Cmp.as_gte cmp$0) (let ((self0 cmp$0)) (case (get self0 0) ('Cmp.ltn (let () Bool.false)) ('Cmp.eql (let () Bool.true)) ('Cmp.gtn (let () Bool.true)))))
(define Cmp.as_gte (lambda (cmp$0) ($Cmp.as_gte cmp$0)))
(define ($Word.gte a$1 b$2) ($Cmp.as_gte ($Word.cmp a$1 b$2)))
(define Word.gte (lambda (a$1) (lambda (b$2) ($Word.gte a$1 b$2))))
(define ($U16.gte a$0 b$1) (>= a$0 b$1))
(define U16.gte (lambda (a$0) (lambda (b$1) ($U16.gte a$0 b$1))))
(define ($Kind.Core.read.is_name chr$0) ($Bool.or ($Bool.and ($U16.gte chr$0 ($Nat.to_u16 46)) ($U16.lte chr$0 ($Nat.to_u16 47))) ($Bool.or ($Bool.and ($U16.gte chr$0 ($Nat.to_u16 48)) ($U16.ltn chr$0 ($Nat.to_u16 58))) ($Bool.or ($Bool.and ($U16.gte chr$0 ($Nat.to_u16 65)) ($U16.ltn chr$0 ($Nat.to_u16 91))) ($Bool.or ($Bool.and ($U16.gte chr$0 ($Nat.to_u16 95)) ($U16.ltn chr$0 ($Nat.to_u16 96))) ($Bool.or ($Bool.and ($U16.gte chr$0 ($Nat.to_u16 97)) ($U16.ltn chr$0 ($Nat.to_u16 123))) Bool.false))))))
(define Kind.Core.read.is_name (lambda (chr$0) ($Kind.Core.read.is_name chr$0)))
(define ($Kind.Core.read.name code$0) (let ((self0 code$0)) (case (= (string-length self0) 0) (#t (let () ($Pair.new code$0 ""))) (#f (let ((f0 (char->integer (string-ref self0 0)))(f1 (let ((_str_ self0)) (substring _str_ 1 (string-length _str_))))) (let ((self2 ($Kind.Core.read.is_name f0))) (case self2 (#t (let () (let ((self2 ($Kind.Core.read.name f1))) (case (get self2 0) ('Pair.new (let ((f2 (get self2 1))(f3 (get self2 2))) ($Pair.new f2 ($String.cons f0 f3)))))))) (#f (let () ($Pair.new code$0 ""))))))))))
(define Kind.Core.read.name (lambda (code$0) ($Kind.Core.read.name code$0)))
(define ($Kind.Core.read.char code$0 chr$1) (let ((self0 ($Kind.Core.read.spaces code$0))) (case (get self0 0) ('Pair.new (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 f0)) (case (= (string-length self2) 0) (#t (let () ($Pair.new "" Unit.new))) (#f (let ((f2 (char->integer (string-ref self2 0)))(f3 (let ((_str_ self2)) (substring _str_ 1 (string-length _str_))))) (let ((self4 ($U16.eql f2 chr$1))) (case self4 (#t (let () ($Pair.new f3 Unit.new))) (#f (let () ($Pair.new "" Unit.new))))))))))))))
(define Kind.Core.read.char (lambda (code$0) (lambda (chr$1) ($Kind.Core.read.char code$0 chr$1))))
(define ($String.starts_with xs$0 match$1) (let ((self0 match$1)) (case (= (string-length self0) 0) (#t (let () Bool.true)) (#f (let ((f0 (char->integer (string-ref self0 0)))(f1 (let ((_str_ self0)) (substring _str_ 1 (string-length _str_))))) (let ((self2 xs$0)) (case (= (string-length self2) 0) (#t (let () Bool.false)) (#f (let ((f2 (char->integer (string-ref self2 0)))(f3 (let ((_str_ self2)) (substring _str_ 1 (string-length _str_))))) (let ((self4 ($Char.eql f0 f2))) (case self4 (#t (let () ($String.starts_with f3 f1))) (#f (let () Bool.false)))))))))))))
(define String.starts_with (lambda (xs$0) (lambda (match$1) ($String.starts_with xs$0 match$1))))
(define ($String.drop n$0 xs$1) (let ((self0 n$0)) (case (= self0 0) (#t (let () xs$1)) (#f (let ((f0 (- self0 1))) (let ((self1 xs$1)) (case (= (string-length self1) 0) (#t (let () String.nil)) (#f (let ((f1 (char->integer (string-ref self1 0)))(f2 (let ((_str_ self1)) (substring _str_ 1 (string-length _str_))))) ($String.drop f0 f2))))))))))
(define String.drop (lambda (n$0) (lambda (xs$1) ($String.drop n$0 xs$1))))
(define ($Char.is_hex chr$0) ($Bool.or ($Bool.and ($U16.gte chr$0 48) ($U16.lte chr$0 57)) ($Bool.or ($Bool.and ($U16.gte chr$0 97) ($U16.lte chr$0 102)) ($Bool.or ($Bool.and ($U16.gte chr$0 65) ($U16.lte chr$0 70)) Bool.false))))
(define Char.is_hex (lambda (chr$0) ($Char.is_hex chr$0)))
(define ($Word.adder a$1 b$2 c$3) ((let ((self0 a$1)) (case (get self0 0) ('Word.e (let () (lambda (b$4) Word.e))) ('Word.o (let ((f0 (get self0 1))) (lambda (b$6) ((let ((self2 b$6)) (case (get self2 0) ('Word.e (let () (lambda (a.pred$7) Word.e))) ('Word.o (let ((f2 (get self2 1))) (lambda (a.pred$9) (let ((self4 c$3)) (case self4 (#t (let () ($Word.i ($Word.adder a.pred$9 f2 Bool.false)))) (#f (let () ($Word.o ($Word.adder a.pred$9 f2 Bool.false))))))))) ('Word.i (let ((f2 (get self2 1))) (lambda (a.pred$9) (let ((self4 c$3)) (case self4 (#t (let () ($Word.o ($Word.adder a.pred$9 f2 Bool.true)))) (#f (let () ($Word.i ($Word.adder a.pred$9 f2 Bool.false))))))))))) f0)))) ('Word.i (let ((f0 (get self0 1))) (lambda (b$6) ((let ((self2 b$6)) (case (get self2 0) ('Word.e (let () (lambda (a.pred$7) Word.e))) ('Word.o (let ((f2 (get self2 1))) (lambda (a.pred$9) (let ((self4 c$3)) (case self4 (#t (let () ($Word.o ($Word.adder a.pred$9 f2 Bool.true)))) (#f (let () ($Word.i ($Word.adder a.pred$9 f2 Bool.false))))))))) ('Word.i (let ((f2 (get self2 1))) (lambda (a.pred$9) (let ((self4 c$3)) (case self4 (#t (let () ($Word.i ($Word.adder a.pred$9 f2 Bool.true)))) (#f (let () ($Word.o ($Word.adder a.pred$9 f2 Bool.true))))))))))) f0)))))) b$2))
(define Word.adder (lambda (a$1) (lambda (b$2) (lambda (c$3) ($Word.adder a$1 b$2 c$3)))))
(define ($Word.add a$1 b$2) ($Word.adder a$1 b$2 Bool.false))
(define Word.add (lambda (a$1) (lambda (b$2) ($Word.add a$1 b$2))))
(define ($U16.add a$0 b$1) (mod (+ a$0 b$1) 65536))
(define U16.add (lambda (a$0) (lambda (b$1) ($U16.add a$0 b$1))))
(define ($Word.shift_left1.aux word$1 prev$2) (let ((self0 word$1)) (case (get self0 0) ('Word.e (let () Word.e)) ('Word.o (let ((f0 (get self0 1))) (let ((self1 prev$2)) (case self1 (#t (let () ($Word.i ($Word.shift_left1.aux f0 Bool.false)))) (#f (let () ($Word.o ($Word.shift_left1.aux f0 Bool.false)))))))) ('Word.i (let ((f0 (get self0 1))) (let ((self1 prev$2)) (case self1 (#t (let () ($Word.i ($Word.shift_left1.aux f0 Bool.true)))) (#f (let () ($Word.o ($Word.shift_left1.aux f0 Bool.true)))))))))))
(define Word.shift_left1.aux (lambda (word$1) (lambda (prev$2) ($Word.shift_left1.aux word$1 prev$2))))
(define ($Word.shift_left1 word$1) (let ((self0 word$1)) (case (get self0 0) ('Word.e (let () Word.e)) ('Word.o (let ((f0 (get self0 1))) ($Word.o ($Word.shift_left1.aux f0 Bool.false)))) ('Word.i (let ((f0 (get self0 1))) ($Word.o ($Word.shift_left1.aux f0 Bool.true)))))))
(define Word.shift_left1 (lambda (word$1) ($Word.shift_left1 word$1)))
(define ($Word.mul.go a$2 b$3 acc$4) (let ((self0 a$2)) (case (get self0 0) ('Word.e (let () acc$4)) ('Word.o (let ((f0 (get self0 1))) ($Word.mul.go f0 ($Word.shift_left1 b$3) acc$4))) ('Word.i (let ((f0 (get self0 1))) ($Word.mul.go f0 ($Word.shift_left1 b$3) ($Word.add b$3 acc$4)))))))
(define Word.mul.go (lambda (a$2) (lambda (b$3) (lambda (acc$4) ($Word.mul.go a$2 b$3 acc$4)))))
(define ($Word.to_zero word$1) (let ((self0 word$1)) (case (get self0 0) ('Word.e (let () Word.e)) ('Word.o (let ((f0 (get self0 1))) ($Word.o ($Word.to_zero f0)))) ('Word.i (let ((f0 (get self0 1))) ($Word.o ($Word.to_zero f0)))))))
(define Word.to_zero (lambda (word$1) ($Word.to_zero word$1)))
(define ($Word.mul a$1 b$2) ($Word.mul.go a$1 b$2 ($Word.to_zero a$1)))
(define Word.mul (lambda (a$1) (lambda (b$2) ($Word.mul a$1 b$2))))
(define ($U16.mul a$0 b$1) (mod (* a$0 b$1) 65536))
(define U16.mul (lambda (a$0) (lambda (b$1) ($U16.mul a$0 b$1))))
(define ($Word.subber a$1 b$2 c$3) ((let ((self0 a$1)) (case (get self0 0) ('Word.e (let () (lambda (b$4) Word.e))) ('Word.o (let ((f0 (get self0 1))) (lambda (b$6) ((let ((self2 b$6)) (case (get self2 0) ('Word.e (let () (lambda (a.pred$7) Word.e))) ('Word.o (let ((f2 (get self2 1))) (lambda (a.pred$9) (let ((self4 c$3)) (case self4 (#t (let () ($Word.i ($Word.subber a.pred$9 f2 Bool.true)))) (#f (let () ($Word.o ($Word.subber a.pred$9 f2 Bool.false))))))))) ('Word.i (let ((f2 (get self2 1))) (lambda (a.pred$9) (let ((self4 c$3)) (case self4 (#t (let () ($Word.o ($Word.subber a.pred$9 f2 Bool.true)))) (#f (let () ($Word.i ($Word.subber a.pred$9 f2 Bool.true))))))))))) f0)))) ('Word.i (let ((f0 (get self0 1))) (lambda (b$6) ((let ((self2 b$6)) (case (get self2 0) ('Word.e (let () (lambda (a.pred$7) Word.e))) ('Word.o (let ((f2 (get self2 1))) (lambda (a.pred$9) (let ((self4 c$3)) (case self4 (#t (let () ($Word.o ($Word.subber a.pred$9 f2 Bool.false)))) (#f (let () ($Word.i ($Word.subber a.pred$9 f2 Bool.false))))))))) ('Word.i (let ((f2 (get self2 1))) (lambda (a.pred$9) (let ((self4 c$3)) (case self4 (#t (let () ($Word.i ($Word.subber a.pred$9 f2 Bool.true)))) (#f (let () ($Word.o ($Word.subber a.pred$9 f2 Bool.false))))))))))) f0)))))) b$2))
(define Word.subber (lambda (a$1) (lambda (b$2) (lambda (c$3) ($Word.subber a$1 b$2 c$3)))))
(define ($Word.sub a$1 b$2) ($Word.subber a$1 b$2 Bool.false))
(define Word.sub (lambda (a$1) (lambda (b$2) ($Word.sub a$1 b$2))))
(define ($U16.sub a$0 b$1) (mod (- a$0 b$1) 65536))
(define U16.sub (lambda (a$0) (lambda (b$1) ($U16.sub a$0 b$1))))
(define ($U16.inc a$0) (+ a$0 1))
(define U16.inc (lambda (a$0) ($U16.inc a$0)))
(define ($U16.zero) ($U16.new ($Word.zero ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ Nat.zero)))))))))))))))))))
(define U16.zero ($U16.zero))
(define ($Char.hex_value16 chr$0) (let ((self0 ($Bool.and ($U16.gte chr$0 48) ($U16.lte chr$0 57)))) (case self0 (#t (let () ($U16.sub chr$0 48))) (#f (let () (let ((self0 ($Bool.and ($U16.gte chr$0 97) ($U16.lte chr$0 102)))) (case self0 (#t (let () ((lambda (x0$1) ($U16.inc ($U16.inc ($U16.inc ($U16.inc ($U16.inc ($U16.inc ($U16.inc ($U16.inc ($U16.inc ($U16.inc x0$1))))))))))) ($U16.sub chr$0 97)))) (#f (let () (let ((self0 ($Bool.and ($U16.gte chr$0 65) ($U16.lte chr$0 70)))) (case self0 (#t (let () ((lambda (x0$1) ($U16.inc ($U16.inc ($U16.inc ($U16.inc ($U16.inc ($U16.inc ($U16.inc ($U16.inc ($U16.inc ($U16.inc x0$1))))))))))) ($U16.sub chr$0 65)))) (#f (let () U16.zero)))))))))))))
(define Char.hex_value16 (lambda (chr$0) ($Char.hex_value16 chr$0)))
(define ($Kind.Core.read.u16 code$0 u16$1) (let ((self0 code$0)) (case (= (string-length self0) 0) (#t (let () ($Pair.new code$0 u16$1))) (#f (let ((f0 (char->integer (string-ref self0 0)))(f1 (let ((_str_ self0)) (substring _str_ 1 (string-length _str_))))) (let ((self2 ($Char.is_hex f0))) (case self2 (#t (let () (let ((u16$4 ($U16.add ($U16.mul u16$1 ($Nat.to_u16 16)) ($Char.hex_value16 f0)))) ($Kind.Core.read.u16 f1 u16$4)))) (#f (let () ($Pair.new code$0 u16$1))))))))))
(define Kind.Core.read.u16 (lambda (code$0) (lambda (u16$1) ($Kind.Core.read.u16 code$0 u16$1))))
(define ($Kind.Core.read.chrx code$0) (let ((self0 ($String.starts_with code$0 "\\u{"))) (case self0 (#t (let () (let ((code$1 ($String.drop 3 code$0))) (let ((self1 ($Kind.Core.read.u16 code$1 ($Nat.to_u16 0)))) (case (get self1 0) ('Pair.new (let ((f1 (get self1 1))(f2 (get self1 2))) (let ((self3 ($String.starts_with f1 "}"))) (case self3 (#t (let () ($Pair.new ($String.drop 1 f1) f2))) (#f (let () ($Pair.new "" 63)))))))))))) (#f (let () (let ((self0 ($String.starts_with code$0 "\\'"))) (case self0 (#t (let () ($Pair.new ($String.drop 2 code$0) 39))) (#f (let () (let ((self0 ($String.starts_with code$0 "\\\""))) (case self0 (#t (let () ($Pair.new ($String.drop 2 code$0) 34))) (#f (let () (let ((self0 ($String.starts_with code$0 "\\\\"))) (case self0 (#t (let () ($Pair.new ($String.drop 2 code$0) 92))) (#f (let () (let ((self0 code$0)) (case (= (string-length self0) 0) (#t (let () ($Pair.new "" 63))) (#f (let ((f0 (char->integer (string-ref self0 0)))(f1 (let ((_str_ self0)) (substring _str_ 1 (string-length _str_))))) ($Pair.new f1 f0))))))))))))))))))))))
(define Kind.Core.read.chrx (lambda (code$0) ($Kind.Core.read.chrx code$0)))
(define ($Kind.Core.read.strx code$0) (let ((self0 ($String.starts_with code$0 "\""))) (case self0 (#t (let () ($Pair.new code$0 ""))) (#f (let () (let ((self0 ($Kind.Core.read.chrx code$0))) (case (get self0 0) ('Pair.new (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 ($Kind.Core.read.strx f0))) (case (get self2 0) ('Pair.new (let ((f2 (get self2 1))(f3 (get self2 2))) ($Pair.new f2 ($String.cons f1 f3)))))))))))))))
(define Kind.Core.read.strx (lambda (code$0) ($Kind.Core.read.strx code$0)))
(define ($Char.dec_value chr$0) (let ((self0 ($U16.eql chr$0 48))) (case self0 (#t (let () 0)) (#f (let () (let ((self0 ($U16.eql chr$0 49))) (case self0 (#t (let () 1)) (#f (let () (let ((self0 ($U16.eql chr$0 50))) (case self0 (#t (let () 2)) (#f (let () (let ((self0 ($U16.eql chr$0 51))) (case self0 (#t (let () 3)) (#f (let () (let ((self0 ($U16.eql chr$0 52))) (case self0 (#t (let () 4)) (#f (let () (let ((self0 ($U16.eql chr$0 53))) (case self0 (#t (let () 5)) (#f (let () (let ((self0 ($U16.eql chr$0 54))) (case self0 (#t (let () 6)) (#f (let () (let ((self0 ($U16.eql chr$0 55))) (case self0 (#t (let () 7)) (#f (let () (let ((self0 ($U16.eql chr$0 56))) (case self0 (#t (let () 8)) (#f (let () (let ((self0 ($U16.eql chr$0 57))) (case self0 (#t (let () 9)) (#f (let () 0)))))))))))))))))))))))))))))))))))))))))
(define Char.dec_value (lambda (chr$0) ($Char.dec_value chr$0)))
(define ($Kind.Core.read.natx code$0 nat$1) (let ((self0 code$0)) (case (= (string-length self0) 0) (#t (let () ($Pair.new code$0 nat$1))) (#f (let ((f0 (char->integer (string-ref self0 0)))(f1 (let ((_str_ self0)) (substring _str_ 1 (string-length _str_))))) (let ((self2 ($Char.is_hex f0))) (case self2 (#t (let () (let ((nat$4 ($Nat.add ($Nat.mul nat$1 10) ($Char.dec_value f0)))) ($Kind.Core.read.natx f1 nat$4)))) (#f (let () ($Pair.new code$0 nat$1))))))))))
(define Kind.Core.read.natx (lambda (code$0) (lambda (nat$1) ($Kind.Core.read.natx code$0 nat$1))))
(define ($Kind.Core.read.find list$1 cond$2 indx$3 skip$4) (let ((self0 list$1)) (case (get self0 0) ('List.nil (let () Maybe.none)) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 ((cond$2 f0) indx$3))) (case self2 (#t (let () (let ((self2 ($Nat.eql skip$4 0))) (case self2 (#t (let () ($Maybe.some ($Pair.new f0 indx$3)))) (#f (let () ($Kind.Core.read.find f1 cond$2 ($Nat.succ indx$3) ($Nat.pred skip$4)))))))) (#f (let () ($Kind.Core.read.find f1 cond$2 ($Nat.succ indx$3) skip$4))))))))))
(define Kind.Core.read.find (lambda (list$1) (lambda (cond$2) (lambda (indx$3) (lambda (skip$4) ($Kind.Core.read.find list$1 cond$2 indx$3 skip$4))))))
(define ($Kind.Core.read.term code$0) (let ((self0 ($Kind.Core.read.spaces code$0))) (case (get self0 0) ('Pair.new (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 f0)) (case (= (string-length self2) 0) (#t (let () ($Pair.new "" (lambda (ctx$3) ($Kind.Term.ref "error"))))) (#f (let ((f2 (char->integer (string-ref self2 0)))(f3 (let ((_str_ self2)) (substring _str_ 1 (string-length _str_))))) (let ((head$5 f2)) (let ((code$6 f3)) (let ((self6 ($Char.eql head$5 42))) (case self6 (#t (let () ($Pair.new code$6 (lambda (ctx$7) Kind.Term.typ)))) (#f (let () (let ((self6 ($U16.eql head$5 64))) (case self6 (#t (let () (let ((self6 ($Kind.Core.read.name code$6))) (case (get self6 0) ('Pair.new (let ((f6 (get self6 1))(f7 (get self6 2))) (let ((self8 ($Kind.Core.read.char f6 40))) (case (get self8 0) ('Pair.new (let ((f8 (get self8 1))(f9 (get self8 2))) (let ((self10 ($Kind.Core.read.name f8))) (case (get self10 0) ('Pair.new (let ((f10 (get self10 1))(f11 (get self10 2))) (let ((self12 ($Kind.Core.read.char f10 58))) (case (get self12 0) ('Pair.new (let ((f12 (get self12 1))(f13 (get self12 2))) (let ((self14 ($Kind.Core.read.term f12))) (case (get self14 0) ('Pair.new (let ((f14 (get self14 1))(f15 (get self14 2))) (let ((self16 ($Kind.Core.read.char f14 41))) (case (get self16 0) ('Pair.new (let ((f16 (get self16 1))(f17 (get self16 2))) (let ((self18 ($Kind.Core.read.term f16))) (case (get self18 0) ('Pair.new (let ((f18 (get self18 1))(f19 (get self18 2))) ($Pair.new f18 (lambda (ctx$21) ($Kind.Term.all Bool.false f7 f11 (f15 ctx$21) (lambda (s$22) (lambda (x$23) (f19 ($List.cons ($Pair.new f11 x$23) ($List.cons ($Pair.new f7 s$22) ctx$21)))))))))))))))))))))))))))))))))))))) (#f (let () (let ((self6 ($U16.eql head$5 37))) (case self6 (#t (let () (let ((self6 ($Kind.Core.read.name code$6))) (case (get self6 0) ('Pair.new (let ((f6 (get self6 1))(f7 (get self6 2))) (let ((self8 ($Kind.Core.read.char f6 40))) (case (get self8 0) ('Pair.new (let ((f8 (get self8 1))(f9 (get self8 2))) (let ((self10 ($Kind.Core.read.name f8))) (case (get self10 0) ('Pair.new (let ((f10 (get self10 1))(f11 (get self10 2))) (let ((self12 ($Kind.Core.read.char f10 58))) (case (get self12 0) ('Pair.new (let ((f12 (get self12 1))(f13 (get self12 2))) (let ((self14 ($Kind.Core.read.term f12))) (case (get self14 0) ('Pair.new (let ((f14 (get self14 1))(f15 (get self14 2))) (let ((self16 ($Kind.Core.read.char f14 41))) (case (get self16 0) ('Pair.new (let ((f16 (get self16 1))(f17 (get self16 2))) (let ((self18 ($Kind.Core.read.term f16))) (case (get self18 0) ('Pair.new (let ((f18 (get self18 1))(f19 (get self18 2))) ($Pair.new f18 (lambda (ctx$21) ($Kind.Term.all Bool.true f7 f11 (f15 ctx$21) (lambda (s$22) (lambda (x$23) (f19 ($List.cons ($Pair.new f11 x$23) ($List.cons ($Pair.new f7 s$22) ctx$21)))))))))))))))))))))))))))))))))))))) (#f (let () (let ((self6 ($U16.eql head$5 35))) (case self6 (#t (let () (let ((self6 ($Kind.Core.read.name code$6))) (case (get self6 0) ('Pair.new (let ((f6 (get self6 1))(f7 (get self6 2))) (let ((self8 ($Kind.Core.read.term f6))) (case (get self8 0) ('Pair.new (let ((f8 (get self8 1))(f9 (get self8 2))) ($Pair.new f8 (lambda (ctx$11) ($Kind.Term.lam f7 (lambda (x$12) (f9 ($List.cons ($Pair.new f7 x$12) ctx$11)))))))))))))))) (#f (let () (let ((self6 ($U16.eql head$5 40))) (case self6 (#t (let () (let ((self6 ($Kind.Core.read.term code$6))) (case (get self6 0) ('Pair.new (let ((f6 (get self6 1))(f7 (get self6 2))) (let ((self8 ($Kind.Core.read.term f6))) (case (get self8 0) ('Pair.new (let ((f8 (get self8 1))(f9 (get self8 2))) (let ((self10 ($Kind.Core.read.char f8 41))) (case (get self10 0) ('Pair.new (let ((f10 (get self10 1))(f11 (get self10 2))) ($Pair.new f10 (lambda (ctx$13) ($Kind.Term.app (f7 ctx$13) (f9 ctx$13)))))))))))))))))) (#f (let () (let ((self6 ($U16.eql head$5 33))) (case self6 (#t (let () (let ((self6 ($Kind.Core.read.name code$6))) (case (get self6 0) ('Pair.new (let ((f6 (get self6 1))(f7 (get self6 2))) (let ((self8 ($Kind.Core.read.char f6 61))) (case (get self8 0) ('Pair.new (let ((f8 (get self8 1))(f9 (get self8 2))) (let ((self10 ($Kind.Core.read.term f8))) (case (get self10 0) ('Pair.new (let ((f10 (get self10 1))(f11 (get self10 2))) (let ((self12 ($Kind.Core.read.char f10 59))) (case (get self12 0) ('Pair.new (let ((f12 (get self12 1))(f13 (get self12 2))) (let ((self14 ($Kind.Core.read.term f12))) (case (get self14 0) ('Pair.new (let ((f14 (get self14 1))(f15 (get self14 2))) ($Pair.new f14 (lambda (ctx$17) ($Kind.Term.let f7 (f11 ctx$17) (lambda (x$18) (f15 ($List.cons ($Pair.new f7 x$18) ctx$17)))))))))))))))))))))))))))) (#f (let () (let ((self6 ($U16.eql head$5 36))) (case self6 (#t (let () (let ((self6 ($Kind.Core.read.name code$6))) (case (get self6 0) ('Pair.new (let ((f6 (get self6 1))(f7 (get self6 2))) (let ((self8 ($Kind.Core.read.char f6 61))) (case (get self8 0) ('Pair.new (let ((f8 (get self8 1))(f9 (get self8 2))) (let ((self10 ($Kind.Core.read.term f8))) (case (get self10 0) ('Pair.new (let ((f10 (get self10 1))(f11 (get self10 2))) (let ((self12 ($Kind.Core.read.char f10 59))) (case (get self12 0) ('Pair.new (let ((f12 (get self12 1))(f13 (get self12 2))) (let ((self14 ($Kind.Core.read.term f12))) (case (get self14 0) ('Pair.new (let ((f14 (get self14 1))(f15 (get self14 2))) ($Pair.new f14 (lambda (ctx$17) ($Kind.Term.def f7 (f11 ctx$17) (lambda (x$18) (f15 ($List.cons ($Pair.new f7 x$18) ctx$17)))))))))))))))))))))))))))) (#f (let () (let ((self6 ($U16.eql head$5 123))) (case self6 (#t (let () (let ((self6 ($Kind.Core.read.term code$6))) (case (get self6 0) ('Pair.new (let ((f6 (get self6 1))(f7 (get self6 2))) (let ((self8 ($Kind.Core.read.char f6 58))) (case (get self8 0) ('Pair.new (let ((f8 (get self8 1))(f9 (get self8 2))) (let ((self10 ($Kind.Core.read.term f8))) (case (get self10 0) ('Pair.new (let ((f10 (get self10 1))(f11 (get self10 2))) (let ((self12 ($Kind.Core.read.char f10 125))) (case (get self12 0) ('Pair.new (let ((f12 (get self12 1))(f13 (get self12 2))) ($Pair.new f12 (lambda (ctx$15) ($Kind.Term.ann Bool.false (f7 ctx$15) (f11 ctx$15)))))))))))))))))))))) (#f (let () (let ((self6 ($U16.eql head$5 39))) (case self6 (#t (let () (let ((self6 ($Kind.Core.read.chrx code$6))) (case (get self6 0) ('Pair.new (let ((f6 (get self6 1))(f7 (get self6 2))) (let ((self8 ($Kind.Core.read.char f6 39))) (case (get self8 0) ('Pair.new (let ((f8 (get self8 1))(f9 (get self8 2))) ($Pair.new f8 (lambda (ctx$11) ($Kind.Term.chr f7))))))))))))) (#f (let () (let ((self6 ($U16.eql head$5 34))) (case self6 (#t (let () (let ((self6 ($Kind.Core.read.strx code$6))) (case (get self6 0) ('Pair.new (let ((f6 (get self6 1))(f7 (get self6 2))) (let ((self8 ($Kind.Core.read.char f6 34))) (case (get self8 0) ('Pair.new (let ((f8 (get self8 1))(f9 (get self8 2))) ($Pair.new f8 (lambda (ctx$11) ($Kind.Term.str f7))))))))))))) (#f (let () (let ((self6 ($U16.eql head$5 43))) (case self6 (#t (let () (let ((self6 ($Kind.Core.read.natx code$6 0))) (case (get self6 0) ('Pair.new (let ((f6 (get self6 1))(f7 (get self6 2))) ($Pair.new f6 (lambda (ctx$9) ($Kind.Term.nat f7))))))))) (#f (let () (let ((self6 ($Kind.Core.read.is_name head$5))) (case self6 (#t (let () (let ((self6 ($Kind.Core.read.name code$6))) (case (get self6 0) ('Pair.new (let ((f6 (get self6 1))(f7 (get self6 2))) (let ((name$9 ($String.cons head$5 f7))) (let ((self9 (let ((self9 f6)) (case (= (string-length self9) 0) (#t (let () ($Pair.new "" 0))) (#f (let ((f9 (char->integer (string-ref self9 0)))(f10 (let ((_str_ self9)) (substring _str_ 1 (string-length _str_))))) (let ((self11 ($U16.eql f9 94))) (case self11 (#t (let () ($Kind.Core.read.natx f10 0))) (#f (let () ($Pair.new f6 0))))))))))) (case (get self9 0) ('Pair.new (let ((f9 (get self9 1))(f10 (get self9 2))) ($Pair.new f9 (lambda (ctx$12) (let ((got$13 ($Kind.Core.read.find ctx$12 (lambda (x$13) (lambda (i$14) ($String.eql ($Pair.fst x$13) name$9))) 0 f10))) (let ((self13 got$13)) (case (get self13 0) ('Maybe.none (let () ($Kind.Term.ref name$9))) ('Maybe.some (let ((f13 (get self13 1))) ($Pair.snd ($Pair.fst f13)))))))))))))))))))) (#f (let () ($Pair.new "" (lambda (ctx$7) ($Kind.Term.ref "error"))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(define Kind.Core.read.term (lambda (code$0) ($Kind.Core.read.term code$0)))
(define ($Kind.Core.read code$0) (let ((self0 ($Kind.Core.read.term ($String.concat code$0 ";")))) (case (get self0 0) ('Pair.new (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 f0)) (case (= (string-length self2) 0) (#t (let () Maybe.none)) (#f (let ((f2 (char->integer (string-ref self2 0)))(f3 (let ((_str_ self2)) (substring _str_ 1 (string-length _str_))))) ($Maybe.some (f1 List.nil)))))))))))
(define Kind.Core.read (lambda (code$0) ($Kind.Core.read code$0)))
(define ($Bool.read code$0) (let ((self0 ($String.eql code$0 "Bool.true"))) (case self0 (#t (let () ($Maybe.some Bool.true))) (#f (let () (let ((self0 ($String.eql code$0 "Bool.false"))) (case self0 (#t (let () ($Maybe.some Bool.false))) (#f (let () Maybe.none)))))))))
(define Bool.read (lambda (code$0) ($Bool.read code$0)))
(define ($Kind.Synth.load.cached.def name$0) (((let ((self0 IO.monad)) (case (get self0 0) ('Monad.new (let ((f0 (get self0 1))(f1 (get self0 2))) f0)))) ($IO.get_file ($String.concat ".cache/" ($String.concat name$0 ".file")))) (lambda (cache_file$1) (let ((self1 ($Bool.not ($String.is_empty cache_file$1)))) (case self1 (#t (let () (((let ((self1 IO.monad)) (case (get self1 0) ('Monad.new (let ((f1 (get self1 1))(f2 (get self1 2))) f1)))) ($IO.get_file ($String.concat ".cache/" ($String.concat name$0 ".time")))) (lambda (cache_time$2) (((let ((self2 IO.monad)) (case (get self2 0) ('Monad.new (let ((f2 (get self2 1))(f3 (get self2 2))) f2)))) ($IO.get_file_mtime cache_file$1)) (lambda (cache_file_time$3) (let ((self3 ($String.eql cache_time$2 cache_file_time$3))) (case self3 (#t (let () (((let ((self3 IO.monad)) (case (get self3 0) ('Monad.new (let ((f3 (get self3 1))(f4 (get self3 2))) f3)))) ($IO.get_file ($String.concat ".cache/" ($String.concat name$0 ".term")))) (lambda (cache_term$4) (((let ((self4 IO.monad)) (case (get self4 0) ('Monad.new (let ((f4 (get self4 1))(f5 (get self4 2))) f4)))) ($IO.get_file ($String.concat ".cache/" ($String.concat name$0 ".type")))) (lambda (cache_type$5) (((let ((self5 IO.monad)) (case (get self5 0) ('Monad.new (let ((f5 (get self5 1))(f6 (get self5 2))) f5)))) ($IO.get_file ($String.concat ".cache/" ($String.concat name$0 ".isct")))) (lambda (cache_isct$6) (((let ((self6 IO.monad)) (case (get self6 0) ('Monad.new (let ((f6 (get self6 1))(f7 (get self6 2))) f6)))) ($IO.get_file ($String.concat ".cache/" ($String.concat name$0 ".arit")))) (lambda (cache_arit$7) ((let ((self7 IO.monad)) (case (get self7 0) ('Monad.new (let ((f7 (get self7 1))(f8 (get self7 2))) f8)))) (let ((file$8 cache_file$1)) (let ((code$9 "<cached>")) (let ((orig$10 ($Pair.new 0 0))) (((let ((self10 Maybe.monad)) (case (get self10 0) ('Monad.new (let ((f10 (get self10 1))(f11 (get self10 2))) f10)))) ($Kind.Core.read cache_term$4)) (lambda (term$11) (((let ((self11 Maybe.monad)) (case (get self11 0) ('Monad.new (let ((f11 (get self11 1))(f12 (get self11 2))) f11)))) ($Kind.Core.read cache_type$5)) (lambda (type$12) (((let ((self12 Maybe.monad)) (case (get self12 0) ('Monad.new (let ((f12 (get self12 1))(f13 (get self12 2))) f12)))) ($Bool.read cache_isct$6)) (lambda (isct$13) (((let ((self13 Maybe.monad)) (case (get self13 0) ('Monad.new (let ((f13 (get self13 1))(f14 (get self13 2))) f13)))) ($Maybe.some ($Nat.read cache_arit$7))) (lambda (arit$14) (let ((stat$15 ($Kind.Status.done Bool.true))) ((let ((self15 Maybe.monad)) (case (get self15 0) ('Monad.new (let ((f15 (get self15 1))(f16 (get self15 2))) f16)))) ($Kind.Def.new file$8 code$9 orig$10 name$0 term$11 type$12 isct$13 arit$14 stat$15))))))))))))))))))))))))) (#f (let () ((let ((self3 IO.monad)) (case (get self3 0) ('Monad.new (let ((f3 (get self3 1))(f4 (get self3 2))) f4)))) Maybe.none))))))))))) (#f (let () ((let ((self1 IO.monad)) (case (get self1 0) ('Monad.new (let ((f1 (get self1 1))(f2 (get self1 2))) f2)))) Maybe.none))))))))
(define Kind.Synth.load.cached.def (lambda (name$0) ($Kind.Synth.load.cached.def name$0)))
(define ($Kind.Core.dependencies.go term$0 deps$1) (let ((nil$2 Kind.Term.typ)) (let ((self1 term$0)) (case (get self1 0) ('Kind.Term.var (let ((f1 (get self1 1))(f2 (get self1 2))) deps$1)) ('Kind.Term.ref (let ((f1 (get self1 1))) ($Kind.Map.set f1 Unit.new deps$1))) ('Kind.Term.typ (let () deps$1)) ('Kind.Term.all (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))(f4 (get self1 4))(f5 (get self1 5))) (let ((deps$8 ($Kind.Core.dependencies.go f4 deps$1))) (let ((deps$9 ($Kind.Core.dependencies.go ((f5 nil$2) nil$2) deps$8))) deps$9)))) ('Kind.Term.lam (let ((f1 (get self1 1))(f2 (get self1 2))) (let ((deps$5 ($Kind.Core.dependencies.go (f2 nil$2) deps$1))) deps$5))) ('Kind.Term.app (let ((f1 (get self1 1))(f2 (get self1 2))) (let ((deps$5 ($Kind.Core.dependencies.go f1 deps$1))) (let ((deps$6 ($Kind.Core.dependencies.go f2 deps$5))) deps$6)))) ('Kind.Term.let (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))) (let ((deps$6 ($Kind.Core.dependencies.go f2 deps$1))) (let ((deps$7 ($Kind.Core.dependencies.go (f3 nil$2) deps$6))) deps$7)))) ('Kind.Term.def (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))) (let ((deps$6 ($Kind.Core.dependencies.go f2 deps$1))) (let ((deps$7 ($Kind.Core.dependencies.go (f3 nil$2) deps$6))) deps$7)))) ('Kind.Term.ann (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))) (let ((deps$6 ($Kind.Core.dependencies.go f2 deps$1))) (let ((deps$7 ($Kind.Core.dependencies.go f3 deps$6))) deps$7)))) ('Kind.Term.gol (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))) deps$1)) ('Kind.Term.hol (let ((f1 (get self1 1))) deps$1)) ('Kind.Term.nat (let ((f1 (get self1 1))) deps$1)) ('Kind.Term.chr (let ((f1 (get self1 1))) deps$1)) ('Kind.Term.str (let ((f1 (get self1 1))) deps$1)) ('Kind.Term.cse (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))(f4 (get self1 4))(f5 (get self1 5))(f6 (get self1 6))) deps$1)) ('Kind.Term.ori (let ((f1 (get self1 1))(f2 (get self1 2))) deps$1))))))
(define Kind.Core.dependencies.go (lambda (term$0) (lambda (deps$1) ($Kind.Core.dependencies.go term$0 deps$1))))
(define ($BitsMap.to_list.go xs$1 key$2 list$3) (let ((self0 xs$1)) (case (get self0 0) ('BitsMap.new (let () list$3)) ('BitsMap.tie (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((list0$7 (let ((self3 f0)) (case (get self3 0) ('Maybe.none (let () list$3)) ('Maybe.some (let ((f3 (get self3 1))) ($List.cons ($Pair.new ($Bits.reverse key$2) f3) list$3))))))) (let ((list1$8 ($BitsMap.to_list.go f1 ($Bits.o key$2) list0$7))) (let ((list2$9 ($BitsMap.to_list.go f2 ($Bits.i key$2) list1$8))) list2$9))))))))
(define BitsMap.to_list.go (lambda (xs$1) (lambda (key$2) (lambda (list$3) ($BitsMap.to_list.go xs$1 key$2 list$3)))))
(define ($Kind.Map.to_list xs$1) (let ((kvs$2 ($List.reverse ($BitsMap.to_list.go xs$1 Bits.e List.nil)))) ($List.mapped kvs$2 (lambda (kv$3) (let ((self2 kv$3)) (case (get self2 0) ('Pair.new (let ((f2 (get self2 1))(f3 (get self2 2))) ($Pair.new ($Kind.Name.from_bits f2) f3)))))))))
(define Kind.Map.to_list (lambda (xs$1) ($Kind.Map.to_list xs$1)))
(define ($Kind.Map.keys xs$1) ($List.mapped ($Kind.Map.to_list xs$1) Pair.fst))
(define Kind.Map.keys (lambda (xs$1) ($Kind.Map.keys xs$1)))
(define ($Kind.Synth.load.cached names$0 defs$1) (let ((self0 names$0)) (case (get self0 0) ('List.nil (let () ((let ((self0 IO.monad)) (case (get self0 0) ('Monad.new (let ((f0 (get self0 1))(f1 (get self0 2))) f1)))) ($Maybe.some defs$1)))) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 ($Kind.Synth.load.cached.is_loop f0 defs$1))) (case self2 (#t (let () ($Kind.Synth.load.cached f1 defs$1))) (#f (let () (let ((name$4 f0)) (((let ((self3 IO.monad)) (case (get self3 0) ('Monad.new (let ((f3 (get self3 1))(f4 (get self3 2))) f3)))) ($Kind.Synth.load.cached.def name$4)) (lambda (defn$5) (let ((self4 defn$5)) (case (get self4 0) ('Maybe.none (let () ((let ((self4 IO.monad)) (case (get self4 0) ('Monad.new (let ((f4 (get self4 1))(f5 (get self4 2))) f5)))) Maybe.none))) ('Maybe.some (let ((f4 (get self4 1))) (let ((self5 f4)) (case (get self5 0) ('Kind.Def.new (let ((f5 (get self5 1))(f6 (get self5 2))(f7 (get self5 3))(f8 (get self5 4))(f9 (get self5 5))(f10 (get self5 6))(f11 (get self5 7))(f12 (get self5 8))(f13 (get self5 9))) (let ((defs$16 ($Kind.Map.set name$4 f4 defs$1))) (let ((deps$17 Kind.Map.new)) (let ((deps$18 ($Kind.Core.dependencies.go f9 deps$17))) (let ((deps$19 ($Kind.Core.dependencies.go f10 deps$18))) (let ((deps$20 ($Kind.Map.keys deps$19))) (((let ((self19 IO.monad)) (case (get self19 0) ('Monad.new (let ((f19 (get self19 1))(f20 (get self19 2))) f19)))) ($Kind.Synth.load.cached deps$20 defs$16)) (lambda (defs$21) (let ((self20 defs$21)) (case (get self20 0) ('Maybe.none (let () ((let ((self20 IO.monad)) (case (get self20 0) ('Monad.new (let ((f20 (get self20 1))(f21 (get self20 2))) f21)))) Maybe.none))) ('Maybe.some (let ((f20 (get self20 1))) ($Kind.Synth.load.cached f1 f20))))))))))))))))))))))))))))))))
(define Kind.Synth.load.cached (lambda (names$0) (lambda (defs$1) ($Kind.Synth.load.cached names$0 defs$1))))
(define ($Kind.Synth.load.go name$0 files$1 defs$2) (let ((self0 files$1)) (case (get self0 0) ('List.nil (let () ((let ((self0 IO.monad)) (case (get self0 0) ('Monad.new (let ((f0 (get self0 1))(f1 (get self0 2))) f1)))) Maybe.none))) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) (((let ((self2 IO.monad)) (case (get self2 0) ('Monad.new (let ((f2 (get self2 1))(f3 (get self2 2))) f2)))) ($IO.get_file f0)) (lambda (code$5) (let ((read$6 ($Kind.Defs.read f0 code$5 defs$2))) (let ((self4 read$6)) (case (get self4 0) ('Either.left (let ((f4 (get self4 1))) ($Kind.Synth.load.go name$0 f1 defs$2))) ('Either.right (let ((f4 (get self4 1))) (let ((defs$8 f4)) (let ((self6 ($Kind.Map.get name$0 defs$8))) (case (get self6 0) ('Maybe.none (let () ($Kind.Synth.load.go name$0 f1 defs$8))) ('Maybe.some (let ((f6 (get self6 1))) ((let ((self7 IO.monad)) (case (get self7 0) ('Monad.new (let ((f7 (get self7 1))(f8 (get self7 2))) f8)))) ($Maybe.some defs$8)))))))))))))))))))
(define Kind.Synth.load.go (lambda (name$0) (lambda (files$1) (lambda (defs$2) ($Kind.Synth.load.go name$0 files$1 defs$2)))))
(define ($Kind.Synth.files_of.make names$0 last$1) (let ((self0 names$0)) (case (get self0 0) ('List.nil (let () List.nil)) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((head$4 ($String.concat last$1 ($String.concat f0 ".kind")))) (let ((tail$5 ($Kind.Synth.files_of.make f1 ($String.concat last$1 ($String.concat f0 "/"))))) ($List.cons head$4 tail$5))))))))
(define Kind.Synth.files_of.make (lambda (names$0) (lambda (last$1) ($Kind.Synth.files_of.make names$0 last$1))))
(define ($String.length.go xs$0 n$1) (let ((self0 xs$0)) (case (= (string-length self0) 0) (#t (let () n$1)) (#f (let ((f0 (char->integer (string-ref self0 0)))(f1 (let ((_str_ self0)) (substring _str_ 1 (string-length _str_))))) ($String.length.go f1 ($Nat.succ n$1)))))))
(define String.length.go (lambda (xs$0) (lambda (n$1) ($String.length.go xs$0 n$1))))
(define ($String.length xs$0) ($String.length.go xs$0 0))
(define String.length (lambda (xs$0) ($String.length xs$0)))
(define ($String.split.go xs$0 match$1 last$2) (let ((self0 xs$0)) (case (= (string-length self0) 0) (#t (let () ($List.cons last$2 List.nil))) (#f (let ((f0 (char->integer (string-ref self0 0)))(f1 (let ((_str_ self0)) (substring _str_ 1 (string-length _str_))))) (let ((self2 ($String.starts_with xs$0 match$1))) (case self2 (#t (let () (let ((rest$5 ($String.drop ($String.length match$1) xs$0))) ($List.cons last$2 ($String.split.go rest$5 match$1 ""))))) (#f (let () (let ((next$5 ($String.cons f0 String.nil))) ($String.split.go f1 match$1 ($String.concat last$2 next$5))))))))))))
(define String.split.go (lambda (xs$0) (lambda (match$1) (lambda (last$2) ($String.split.go xs$0 match$1 last$2)))))
(define ($String.split xs$0 match$1) ($String.split.go xs$0 match$1 ""))
(define String.split (lambda (xs$0) (lambda (match$1) ($String.split xs$0 match$1))))
(define ($Kind.Synth.files_of name$0) ($List.reverse ($Kind.Synth.files_of.make ($String.split name$0 ".") "")))
(define Kind.Synth.files_of (lambda (name$0) ($Kind.Synth.files_of name$0)))
(define ($Kind.Synth.load name$0 defs$1) (((let ((self0 IO.monad)) (case (get self0 0) ('Monad.new (let ((f0 (get self0 1))(f1 (get self0 2))) f0)))) ($Kind.Synth.load.cached ($List.cons name$0 List.nil) defs$1)) (lambda (cached_defs$2) (let ((self1 cached_defs$2)) (case (get self1 0) ('Maybe.none (let () ($Kind.Synth.load.go name$0 ($Kind.Synth.files_of name$0) defs$1))) ('Maybe.some (let ((f1 (get self1 1))) ((let ((self2 IO.monad)) (case (get self2 0) ('Monad.new (let ((f2 (get self2 1))(f3 (get self2 2))) f3)))) ($Maybe.some f1)))))))))
(define Kind.Synth.load (lambda (name$0) (lambda (defs$1) ($Kind.Synth.load name$0 defs$1))))
(define ($Kind.Status.wait) (vector 'Kind.Status.wait))
(define Kind.Status.wait ($Kind.Status.wait))
(define ($Kind.Check.result value$1 errors$2) (vector 'Kind.Check.result value$1 errors$2))
(define Kind.Check.result (lambda (value$1) (lambda (errors$2) ($Kind.Check.result value$1 errors$2))))
(define ($Kind.Error.undefined_reference origin$0 name$1) (vector 'Kind.Error.undefined_reference origin$0 name$1))
(define Kind.Error.undefined_reference (lambda (origin$0) (lambda (name$1) ($Kind.Error.undefined_reference origin$0 name$1))))
(define ($Kind.Error.waiting name$0) (vector 'Kind.Error.waiting name$0))
(define Kind.Error.waiting (lambda (name$0) ($Kind.Error.waiting name$0)))
(define ($Kind.Error.indirect name$0) (vector 'Kind.Error.indirect name$0))
(define Kind.Error.indirect (lambda (name$0) ($Kind.Error.indirect name$0)))
(define ($Maybe.mapped m$1 f$3) (let ((self0 m$1)) (case (get self0 0) ('Maybe.none (let () Maybe.none)) ('Maybe.some (let ((f0 (get self0 1))) ($Maybe.some (f$3 f0)))))))
(define Maybe.mapped (lambda (m$1) (lambda (f$3) ($Maybe.mapped m$1 f$3))))
(define ($Kind.MPath.o path$0) ($Maybe.mapped path$0 Kind.Path.o))
(define Kind.MPath.o (lambda (path$0) ($Kind.MPath.o path$0)))
(define ($Kind.MPath.i path$0) ($Maybe.mapped path$0 Kind.Path.i))
(define Kind.MPath.i (lambda (path$0) ($Kind.MPath.i path$0)))
(define ($Kind.Error.patch path$0 term$1) (vector 'Kind.Error.patch path$0 term$1))
(define Kind.Error.patch (lambda (path$0) (lambda (term$1) ($Kind.Error.patch path$0 term$1))))
(define ($Kind.MPath.to_bits path$0) (let ((self0 path$0)) (case (get self0 0) ('Maybe.none (let () Bits.e)) ('Maybe.some (let ((f0 (get self0 1))) (f0 Bits.e))))))
(define Kind.MPath.to_bits (lambda (path$0) ($Kind.MPath.to_bits path$0)))
(define ($Kind.Error.type_mismatch origin$0 expected$1 detected$2 context$3) (vector 'Kind.Error.type_mismatch origin$0 expected$1 detected$2 context$3))
(define Kind.Error.type_mismatch (lambda (origin$0) (lambda (expected$1) (lambda (detected$2) (lambda (context$3) ($Kind.Error.type_mismatch origin$0 expected$1 detected$2 context$3))))))
(define ($Kind.Error.show_goal name$0 dref$1 verb$2 goal$3 context$4) (vector 'Kind.Error.show_goal name$0 dref$1 verb$2 goal$3 context$4))
(define Kind.Error.show_goal (lambda (name$0) (lambda (dref$1) (lambda (verb$2) (lambda (goal$3) (lambda (context$4) ($Kind.Error.show_goal name$0 dref$1 verb$2 goal$3 context$4)))))))
(define ($Kind.Term.check.infer_with_types vars$0 defs$1 ctx$2 path$3 orig$4) (let ((self0 vars$0)) (case (get self0 0) ('List.nil (let () ($Kind.Check.result ($Maybe.some List.nil) List.nil))) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 f0)) (case (get self2 0) ('Kind.Ann.new (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))) (let ((self5 (let ((self5 f4)) (case (get self5 0) ('Maybe.none (let () (let ((self5 ($Kind.Term.check f3 Maybe.none defs$1 ctx$2 path$3 orig$4))) (case (get self5 0) ('Kind.Check.result (let ((f5 (get self5 1))(f6 (get self5 2))) (let ((self7 f5)) (case (get self7 0) ('Maybe.none (let () ($Kind.Check.result Maybe.none f6))) ('Maybe.some (let ((f7 (get self7 1))) (let ((self8 ($Kind.Check.result ($Maybe.some ($Maybe.some f7)) List.nil))) (case (get self8 0) ('Kind.Check.result (let ((f8 (get self8 1))(f9 (get self8 2))) ($Kind.Check.result f8 ($List.concat f6 f9)))))))))))))))) ('Maybe.some (let ((f5 (get self5 1))) ($Kind.Check.result ($Maybe.some ($Maybe.some f5)) List.nil))))))) (case (get self5 0) ('Kind.Check.result (let ((f5 (get self5 1))(f6 (get self5 2))) (let ((self7 f5)) (case (get self7 0) ('Maybe.none (let () ($Kind.Check.result Maybe.none f6))) ('Maybe.some (let ((f7 (get self7 1))) (let ((self8 (let ((self8 ($Kind.Term.check.infer_with_types f1 defs$1 ctx$2 path$3 orig$4))) (case (get self8 0) ('Kind.Check.result (let ((f8 (get self8 1))(f9 (get self8 2))) (let ((self10 f8)) (case (get self10 0) ('Maybe.none (let () ($Kind.Check.result Maybe.none f9))) ('Maybe.some (let ((f10 (get self10 1))) (let ((self11 ($Kind.Check.result ($Maybe.some ($List.cons ($Kind.Ann.new f2 f3 f7) f10)) List.nil))) (case (get self11 0) ('Kind.Check.result (let ((f11 (get self11 1))(f12 (get self11 2))) ($Kind.Check.result f11 ($List.concat f9 f12)))))))))))))))) (case (get self8 0) ('Kind.Check.result (let ((f8 (get self8 1))(f9 (get self8 2))) ($Kind.Check.result f8 ($List.concat f6 f9)))))))))))))))))))))))
(define Kind.Term.check.infer_with_types (lambda (vars$0) (lambda (defs$1) (lambda (ctx$2) (lambda (path$3) (lambda (orig$4) ($Kind.Term.check.infer_with_types vars$0 defs$1 ctx$2 path$3 orig$4)))))))
(define ($Kind.Term.normalize term$0 defs$1) (let ((self0 ($Kind.Term.reduce term$0 defs$1))) (case (get self0 0) ('Kind.Term.var (let ((f0 (get self0 1))(f1 (get self0 2))) ($Kind.Term.var f0 f1))) ('Kind.Term.ref (let ((f0 (get self0 1))) ($Kind.Term.ref f0))) ('Kind.Term.typ (let () Kind.Term.typ)) ('Kind.Term.all (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))) ($Kind.Term.all f0 f1 f2 ($Kind.Term.normalize f3 defs$1) (lambda (s$7) (lambda (x$8) ($Kind.Term.normalize ((f4 s$7) x$8) defs$1)))))) ('Kind.Term.lam (let ((f0 (get self0 1))(f1 (get self0 2))) ($Kind.Term.lam f0 (lambda (x$4) ($Kind.Term.normalize (f1 x$4) defs$1))))) ('Kind.Term.app (let ((f0 (get self0 1))(f1 (get self0 2))) ($Kind.Term.app ($Kind.Term.normalize f0 defs$1) ($Kind.Term.normalize f1 defs$1)))) ('Kind.Term.let (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Kind.Term.let f0 ($Kind.Term.normalize f1 defs$1) (lambda (x$5) ($Kind.Term.normalize (f2 x$5) defs$1))))) ('Kind.Term.def (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Kind.Term.def f0 ($Kind.Term.normalize f1 defs$1) (lambda (x$5) ($Kind.Term.normalize (f2 x$5) defs$1))))) ('Kind.Term.ann (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Kind.Term.ann f0 ($Kind.Term.normalize f1 defs$1) ($Kind.Term.normalize f2 defs$1)))) ('Kind.Term.gol (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Kind.Term.gol f0 f1 f2))) ('Kind.Term.hol (let ((f0 (get self0 1))) ($Kind.Term.hol f0))) ('Kind.Term.nat (let ((f0 (get self0 1))) ($Kind.Term.nat f0))) ('Kind.Term.chr (let ((f0 (get self0 1))) ($Kind.Term.chr f0))) ('Kind.Term.str (let ((f0 (get self0 1))) ($Kind.Term.str f0))) ('Kind.Term.cse (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))(f5 (get self0 6))) term$0)) ('Kind.Term.ori (let ((f0 (get self0 1))(f1 (get self0 2))) ($Kind.Term.normalize f1 defs$1))))))
(define Kind.Term.normalize (lambda (term$0) (lambda (defs$1) ($Kind.Term.normalize term$0 defs$1))))
(define ($Kind.Term.desugar_cse.motive.go wyth$0 moti$1 name$2 expr$3 etyp$4 rtyp$5 defs$6 size$7) (let ((self0 wyth$0)) (case (get self0 0) ('List.nil (let () (let ((self0 moti$1)) (case (get self0 0) ('Maybe.none (let () (let ((self0 rtyp$5)) (case (get self0 0) ('Maybe.none (let () ($Kind.Term.hol Bits.e))) ('Maybe.some (let ((f0 (get self0 1))) ($Kind.Term.normalize f0 Kind.Map.new))))))) ('Maybe.some (let ((f0 (get self0 1))) f0)))))) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 f0)) (case (get self2 0) ('Kind.Ann.new (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))) ($Kind.Term.all Bool.false "" f2 ($Maybe.default f4 ($Kind.Term.hol Bits.e)) (lambda (s$13) (lambda (x$14) ($Kind.Term.desugar_cse.motive f1 moti$1 name$2 expr$3 etyp$4 rtyp$5 defs$6 ($Nat.succ ($Nat.succ size$7)))))))))))))))
(define Kind.Term.desugar_cse.motive.go (lambda (wyth$0) (lambda (moti$1) (lambda (name$2) (lambda (expr$3) (lambda (etyp$4) (lambda (rtyp$5) (lambda (defs$6) (lambda (size$7) ($Kind.Term.desugar_cse.motive.go wyth$0 moti$1 name$2 expr$3 etyp$4 rtyp$5 defs$6 size$7))))))))))
(define ($List.tail xs$1) (let ((self0 xs$1)) (case (get self0 0) ('List.nil (let () List.nil)) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) f1)))))
(define List.tail (lambda (xs$1) ($List.tail xs$1)))
(define ($Kind.Term.SmartMotive.vals.cont expr$0 term$1 args$2 defs$3) (let ((self0 ($Kind.Term.reduce term$1 defs$3))) (case (get self0 0) ('Kind.Term.var (let ((f0 (get self0 1))(f1 (get self0 2))) ($List.cons expr$0 ($List.tail ($List.reverse args$2))))) ('Kind.Term.ref (let ((f0 (get self0 1))) ($List.cons expr$0 ($List.tail ($List.reverse args$2))))) ('Kind.Term.typ (let () ($List.cons expr$0 ($List.tail ($List.reverse args$2))))) ('Kind.Term.all (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))) ($List.cons expr$0 ($List.tail ($List.reverse args$2))))) ('Kind.Term.lam (let ((f0 (get self0 1))(f1 (get self0 2))) ($List.cons expr$0 ($List.tail ($List.reverse args$2))))) ('Kind.Term.app (let ((f0 (get self0 1))(f1 (get self0 2))) ($Kind.Term.SmartMotive.vals.cont expr$0 f0 ($List.cons f1 args$2) defs$3))) ('Kind.Term.let (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($List.cons expr$0 ($List.tail ($List.reverse args$2))))) ('Kind.Term.def (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($List.cons expr$0 ($List.tail ($List.reverse args$2))))) ('Kind.Term.ann (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($List.cons expr$0 ($List.tail ($List.reverse args$2))))) ('Kind.Term.gol (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($List.cons expr$0 ($List.tail ($List.reverse args$2))))) ('Kind.Term.hol (let ((f0 (get self0 1))) ($List.cons expr$0 ($List.tail ($List.reverse args$2))))) ('Kind.Term.nat (let ((f0 (get self0 1))) ($List.cons expr$0 ($List.tail ($List.reverse args$2))))) ('Kind.Term.chr (let ((f0 (get self0 1))) ($List.cons expr$0 ($List.tail ($List.reverse args$2))))) ('Kind.Term.str (let ((f0 (get self0 1))) ($List.cons expr$0 ($List.tail ($List.reverse args$2))))) ('Kind.Term.cse (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))(f5 (get self0 6))) ($List.cons expr$0 ($List.tail ($List.reverse args$2))))) ('Kind.Term.ori (let ((f0 (get self0 1))(f1 (get self0 2))) ($List.cons expr$0 ($List.tail ($List.reverse args$2))))))))
(define Kind.Term.SmartMotive.vals.cont (lambda (expr$0) (lambda (term$1) (lambda (args$2) (lambda (defs$3) ($Kind.Term.SmartMotive.vals.cont expr$0 term$1 args$2 defs$3))))))
(define ($Kind.Term.SmartMotive.vals expr$0 type$1 defs$2) (let ((self0 ($Kind.Term.reduce type$1 defs$2))) (case (get self0 0) ('Kind.Term.var (let ((f0 (get self0 1))(f1 (get self0 2))) ($Kind.Term.SmartMotive.vals.cont expr$0 type$1 List.nil defs$2))) ('Kind.Term.ref (let ((f0 (get self0 1))) ($Kind.Term.SmartMotive.vals.cont expr$0 type$1 List.nil defs$2))) ('Kind.Term.typ (let () ($Kind.Term.SmartMotive.vals.cont expr$0 type$1 List.nil defs$2))) ('Kind.Term.all (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))) ($Kind.Term.SmartMotive.vals expr$0 ((f4 Kind.Term.typ) Kind.Term.typ) defs$2))) ('Kind.Term.lam (let ((f0 (get self0 1))(f1 (get self0 2))) ($Kind.Term.SmartMotive.vals.cont expr$0 type$1 List.nil defs$2))) ('Kind.Term.app (let ((f0 (get self0 1))(f1 (get self0 2))) ($Kind.Term.SmartMotive.vals.cont expr$0 type$1 List.nil defs$2))) ('Kind.Term.let (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Kind.Term.SmartMotive.vals.cont expr$0 type$1 List.nil defs$2))) ('Kind.Term.def (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Kind.Term.SmartMotive.vals.cont expr$0 type$1 List.nil defs$2))) ('Kind.Term.ann (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Kind.Term.SmartMotive.vals.cont expr$0 type$1 List.nil defs$2))) ('Kind.Term.gol (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Kind.Term.SmartMotive.vals.cont expr$0 type$1 List.nil defs$2))) ('Kind.Term.hol (let ((f0 (get self0 1))) ($Kind.Term.SmartMotive.vals.cont expr$0 type$1 List.nil defs$2))) ('Kind.Term.nat (let ((f0 (get self0 1))) ($Kind.Term.SmartMotive.vals.cont expr$0 type$1 List.nil defs$2))) ('Kind.Term.chr (let ((f0 (get self0 1))) ($Kind.Term.SmartMotive.vals.cont expr$0 type$1 List.nil defs$2))) ('Kind.Term.str (let ((f0 (get self0 1))) ($Kind.Term.SmartMotive.vals.cont expr$0 type$1 List.nil defs$2))) ('Kind.Term.cse (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))(f5 (get self0 6))) ($Kind.Term.SmartMotive.vals.cont expr$0 type$1 List.nil defs$2))) ('Kind.Term.ori (let ((f0 (get self0 1))(f1 (get self0 2))) ($Kind.Term.SmartMotive.vals.cont expr$0 type$1 List.nil defs$2))))))
(define Kind.Term.SmartMotive.vals (lambda (expr$0) (lambda (type$1) (lambda (defs$2) ($Kind.Term.SmartMotive.vals expr$0 type$1 defs$2)))))
(define ($Kind.Term.SmartMotive.nams.cont name$0 term$1 binds$2 defs$3) (let ((self0 ($Kind.Term.reduce term$1 defs$3))) (case (get self0 0) ('Kind.Term.var (let ((f0 (get self0 1))(f1 (get self0 2))) ($List.cons name$0 ($List.tail binds$2)))) ('Kind.Term.ref (let ((f0 (get self0 1))) ($List.cons name$0 ($List.tail binds$2)))) ('Kind.Term.typ (let () ($List.cons name$0 ($List.tail binds$2)))) ('Kind.Term.all (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))) ($Kind.Term.SmartMotive.nams.cont name$0 ((f4 ($Kind.Term.ref f1)) ($Kind.Term.ref f2)) ($List.cons ($String.flatten ($List.cons name$0 ($List.cons "." ($List.cons f2 List.nil)))) binds$2) defs$3))) ('Kind.Term.lam (let ((f0 (get self0 1))(f1 (get self0 2))) ($List.cons name$0 ($List.tail binds$2)))) ('Kind.Term.app (let ((f0 (get self0 1))(f1 (get self0 2))) ($List.cons name$0 ($List.tail binds$2)))) ('Kind.Term.let (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($List.cons name$0 ($List.tail binds$2)))) ('Kind.Term.def (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($List.cons name$0 ($List.tail binds$2)))) ('Kind.Term.ann (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($List.cons name$0 ($List.tail binds$2)))) ('Kind.Term.gol (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($List.cons name$0 ($List.tail binds$2)))) ('Kind.Term.hol (let ((f0 (get self0 1))) ($List.cons name$0 ($List.tail binds$2)))) ('Kind.Term.nat (let ((f0 (get self0 1))) ($List.cons name$0 ($List.tail binds$2)))) ('Kind.Term.chr (let ((f0 (get self0 1))) ($List.cons name$0 ($List.tail binds$2)))) ('Kind.Term.str (let ((f0 (get self0 1))) ($List.cons name$0 ($List.tail binds$2)))) ('Kind.Term.cse (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))(f5 (get self0 6))) ($List.cons name$0 ($List.tail binds$2)))) ('Kind.Term.ori (let ((f0 (get self0 1))(f1 (get self0 2))) ($List.cons name$0 ($List.tail binds$2)))))))
(define Kind.Term.SmartMotive.nams.cont (lambda (name$0) (lambda (term$1) (lambda (binds$2) (lambda (defs$3) ($Kind.Term.SmartMotive.nams.cont name$0 term$1 binds$2 defs$3))))))
(define ($Kind.Term.SmartMotive.nams name$0 type$1 defs$2) (let ((self0 ($Kind.Term.reduce type$1 defs$2))) (case (get self0 0) ('Kind.Term.var (let ((f0 (get self0 1))(f1 (get self0 2))) List.nil)) ('Kind.Term.ref (let ((f0 (get self0 1))) List.nil)) ('Kind.Term.typ (let () List.nil)) ('Kind.Term.all (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))) ($Kind.Term.SmartMotive.nams.cont name$0 f3 List.nil defs$2))) ('Kind.Term.lam (let ((f0 (get self0 1))(f1 (get self0 2))) List.nil)) ('Kind.Term.app (let ((f0 (get self0 1))(f1 (get self0 2))) List.nil)) ('Kind.Term.let (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) List.nil)) ('Kind.Term.def (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) List.nil)) ('Kind.Term.ann (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) List.nil)) ('Kind.Term.gol (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) List.nil)) ('Kind.Term.hol (let ((f0 (get self0 1))) List.nil)) ('Kind.Term.nat (let ((f0 (get self0 1))) List.nil)) ('Kind.Term.chr (let ((f0 (get self0 1))) List.nil)) ('Kind.Term.str (let ((f0 (get self0 1))) List.nil)) ('Kind.Term.cse (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))(f5 (get self0 6))) List.nil)) ('Kind.Term.ori (let ((f0 (get self0 1))(f1 (get self0 2))) List.nil)))))
(define Kind.Term.SmartMotive.nams (lambda (name$0) (lambda (type$1) (lambda (defs$2) ($Kind.Term.SmartMotive.nams name$0 type$1 defs$2)))))
(define ($List.zip as$2 bs$3) (let ((self0 as$2)) (case (get self0 0) ('List.nil (let () List.nil)) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 bs$3)) (case (get self2 0) ('List.nil (let () List.nil)) ('List.cons (let ((f2 (get self2 1))(f3 (get self2 2))) ($List.cons ($Pair.new f0 f2) ($List.zip f1 f3)))))))))))
(define List.zip (lambda (as$2) (lambda (bs$3) ($List.zip as$2 bs$3))))
(define ($Nat.gte n$0 m$1) (>= n$0 m$1))
(define Nat.gte (lambda (n$0) (lambda (m$1) ($Nat.gte n$0 m$1))))
(define ($Bits.concat a$0 b$1) (let ((self0 a$0)) (case (get self0 0) ('Bits.e (let () b$1)) ('Bits.o (let ((f0 (get self0 1))) ($Bits.o ($Bits.concat f0 b$1)))) ('Bits.i (let ((f0 (get self0 1))) ($Bits.i ($Bits.concat f0 b$1)))))))
(define Bits.concat (lambda (a$0) (lambda (b$1) ($Bits.concat a$0 b$1))))
(define ($Nat.sub n$0 m$1) (max (- n$0 m$1) 0))
(define Nat.sub (lambda (n$0) (lambda (m$1) ($Nat.sub n$0 m$1))))
(define ($Kind.Term.serialize.go term$0 depth$1 init$2 diff$3 x$4) (let ((self0 term$0)) (case (get self0 0) ('Kind.Term.var (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 ($Nat.gte f1 init$2))) (case self2 (#t (let () (let ((name$7 (Bits.concat ($Nat.to_bits ($Nat.pred ($Nat.sub depth$1 f1)))))) ($Bits.o ($Bits.o ($Bits.i (name$7 x$4))))))) (#f (let () (let ((name$7 (Bits.concat ($Nat.to_bits f1)))) ($Bits.o ($Bits.i ($Bits.o (name$7 x$4))))))))))) ('Kind.Term.ref (let ((f0 (get self0 1))) (let ((name$6 (Bits.concat ($Kind.Name.to_bits f0)))) ($Bits.o ($Bits.o ($Bits.o (name$6 x$4))))))) ('Kind.Term.typ (let () ($Bits.o ($Bits.i ($Bits.i x$4))))) ('Kind.Term.all (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))) (let ((eras$10 (let ((self5 f0)) (case self5 (#t (let () Bits.i)) (#f (let () Bits.o)))))) (let ((self$11 (Bits.concat ($Kind.Name.to_bits f1)))) (let ((xtyp$12 ((((Kind.Term.serialize.go f3) depth$1) init$2) diff$3))) (let ((body$13 ((((Kind.Term.serialize.go ((f4 ($Kind.Term.var f1 depth$1)) ($Kind.Term.var f2 ($Nat.succ depth$1)))) ($Nat.succ ($Nat.succ depth$1))) init$2) diff$3))) ($Bits.i ($Bits.o ($Bits.o (eras$10 (self$11 (xtyp$12 (body$13 x$4))))))))))))) ('Kind.Term.lam (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((body$7 ((((Kind.Term.serialize.go (f1 ($Kind.Term.var f0 depth$1))) ($Nat.succ depth$1)) init$2) diff$3))) ($Bits.i ($Bits.o ($Bits.i (body$7 x$4))))))) ('Kind.Term.app (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((func$7 ((((Kind.Term.serialize.go f0) depth$1) init$2) diff$3))) (let ((argm$8 ((((Kind.Term.serialize.go f1) depth$1) init$2) diff$3))) ($Bits.i ($Bits.i ($Bits.o (func$7 (argm$8 x$4))))))))) ('Kind.Term.let (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((expr$8 ((((Kind.Term.serialize.go f1) depth$1) init$2) diff$3))) (let ((body$9 ((((Kind.Term.serialize.go (f2 ($Kind.Term.var f0 depth$1))) ($Nat.succ depth$1)) init$2) diff$3))) ($Bits.i ($Bits.i ($Bits.i (expr$8 (body$9 x$4))))))))) ('Kind.Term.def (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Kind.Term.serialize.go (f2 f1) depth$1 init$2 diff$3 x$4))) ('Kind.Term.ann (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Kind.Term.serialize.go f1 depth$1 init$2 diff$3 x$4))) ('Kind.Term.gol (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((name$8 (Bits.concat ($Kind.Name.to_bits f0)))) ($Bits.o ($Bits.o ($Bits.o (name$8 x$4))))))) ('Kind.Term.hol (let ((f0 (get self0 1))) x$4)) ('Kind.Term.nat (let ((f0 (get self0 1))) ($Kind.Term.serialize.go ($Kind.Term.unroll_nat f0) depth$1 init$2 diff$3 x$4))) ('Kind.Term.chr (let ((f0 (get self0 1))) ($Kind.Term.serialize.go ($Kind.Term.unroll_chr f0) depth$1 init$2 diff$3 x$4))) ('Kind.Term.str (let ((f0 (get self0 1))) ($Kind.Term.serialize.go ($Kind.Term.unroll_str f0) depth$1 init$2 diff$3 x$4))) ('Kind.Term.cse (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))(f5 (get self0 6))) (diff$3 x$4))) ('Kind.Term.ori (let ((f0 (get self0 1))(f1 (get self0 2))) ($Kind.Term.serialize.go f1 depth$1 init$2 diff$3 x$4))))))
(define Kind.Term.serialize.go (lambda (term$0) (lambda (depth$1) (lambda (init$2) (lambda (diff$3) (lambda (x$4) ($Kind.Term.serialize.go term$0 depth$1 init$2 diff$3 x$4)))))))
(define ($Kind.Term.serialize term$0 depth$1 side$2) (let ((diff$3 (let ((self0 side$2)) (case self0 (#t (let () Bits.o)) (#f (let () Bits.i)))))) ($Kind.Term.serialize.go term$0 depth$1 depth$1 diff$3 Bits.e)))
(define Kind.Term.serialize (lambda (term$0) (lambda (depth$1) (lambda (side$2) ($Kind.Term.serialize term$0 depth$1 side$2)))))
(define ($Bits.eql a$0 b$1) (let ((self0 a$0)) (case (get self0 0) ('Bits.e (let () (let ((self0 b$1)) (case (get self0 0) ('Bits.e (let () Bool.true)) ('Bits.o (let ((f0 (get self0 1))) Bool.false)) ('Bits.i (let ((f0 (get self0 1))) Bool.false)))))) ('Bits.o (let ((f0 (get self0 1))) (let ((self1 b$1)) (case (get self1 0) ('Bits.e (let () Bool.false)) ('Bits.o (let ((f1 (get self1 1))) ($Bits.eql f0 f1))) ('Bits.i (let ((f1 (get self1 1))) Bool.false)))))) ('Bits.i (let ((f0 (get self0 1))) (let ((self1 b$1)) (case (get self1 0) ('Bits.e (let () Bool.false)) ('Bits.o (let ((f1 (get self1 1))) Bool.false)) ('Bits.i (let ((f1 (get self1 1))) ($Bits.eql f0 f1))))))))))
(define Bits.eql (lambda (a$0) (lambda (b$1) ($Bits.eql a$0 b$1))))
(define ($Kind.Term.identical a$0 b$1 lv$2) (let ((ah$3 ($Kind.Term.serialize a$0 lv$2 Bool.false))) (let ((bh$4 ($Kind.Term.serialize b$1 lv$2 Bool.true))) ($Bits.eql ah$3 bh$4))))
(define Kind.Term.identical (lambda (a$0) (lambda (b$1) (lambda (lv$2) ($Kind.Term.identical a$0 b$1 lv$2)))))
(define ($Kind.Term.SmartMotive.replace term$0 from$1 to$2 lv$3) (let ((self0 ($Kind.Term.identical term$0 from$1 lv$3))) (case self0 (#t (let () to$2)) (#f (let () (let ((self0 term$0)) (case (get self0 0) ('Kind.Term.var (let ((f0 (get self0 1))(f1 (get self0 2))) ($Kind.Term.var f0 f1))) ('Kind.Term.ref (let ((f0 (get self0 1))) ($Kind.Term.ref f0))) ('Kind.Term.typ (let () Kind.Term.typ)) ('Kind.Term.all (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))) (let ((xtyp$9 ($Kind.Term.SmartMotive.replace f3 from$1 to$2 lv$3))) (let ((body$10 ((f4 ($Kind.Term.ref f1)) ($Kind.Term.ref f2)))) (let ((body$11 ($Kind.Term.SmartMotive.replace body$10 from$1 to$2 ($Nat.succ ($Nat.succ lv$3))))) ($Kind.Term.all f0 f1 f2 xtyp$9 (lambda (s$12) (lambda (x$13) body$11)))))))) ('Kind.Term.lam (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((body$6 (f1 ($Kind.Term.ref f0)))) (let ((body$7 ($Kind.Term.SmartMotive.replace body$6 from$1 to$2 ($Nat.succ lv$3)))) ($Kind.Term.lam f0 (lambda (x$8) body$7)))))) ('Kind.Term.app (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((func$6 ($Kind.Term.SmartMotive.replace f0 from$1 to$2 lv$3))) (let ((argm$7 ($Kind.Term.SmartMotive.replace f1 from$1 to$2 lv$3))) ($Kind.Term.app func$6 argm$7))))) ('Kind.Term.let (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((expr$7 ($Kind.Term.SmartMotive.replace f1 from$1 to$2 lv$3))) (let ((body$8 (f2 ($Kind.Term.ref f0)))) (let ((body$9 ($Kind.Term.SmartMotive.replace body$8 from$1 to$2 ($Nat.succ lv$3)))) ($Kind.Term.let f0 expr$7 (lambda (x$10) body$9))))))) ('Kind.Term.def (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((expr$7 ($Kind.Term.SmartMotive.replace f1 from$1 to$2 lv$3))) (let ((body$8 (f2 ($Kind.Term.ref f0)))) (let ((body$9 ($Kind.Term.SmartMotive.replace body$8 from$1 to$2 ($Nat.succ lv$3)))) ($Kind.Term.def f0 expr$7 (lambda (x$10) body$9))))))) ('Kind.Term.ann (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((term$7 ($Kind.Term.SmartMotive.replace f1 from$1 to$2 lv$3))) (let ((type$8 ($Kind.Term.SmartMotive.replace f2 from$1 to$2 lv$3))) ($Kind.Term.ann f0 term$7 type$8))))) ('Kind.Term.gol (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) term$0)) ('Kind.Term.hol (let ((f0 (get self0 1))) term$0)) ('Kind.Term.nat (let ((f0 (get self0 1))) term$0)) ('Kind.Term.chr (let ((f0 (get self0 1))) term$0)) ('Kind.Term.str (let ((f0 (get self0 1))) term$0)) ('Kind.Term.cse (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))(f5 (get self0 6))) term$0)) ('Kind.Term.ori (let ((f0 (get self0 1))(f1 (get self0 2))) ($Kind.Term.SmartMotive.replace f1 from$1 to$2 lv$3))))))))))
(define Kind.Term.SmartMotive.replace (lambda (term$0) (lambda (from$1) (lambda (to$2) (lambda (lv$3) ($Kind.Term.SmartMotive.replace term$0 from$1 to$2 lv$3))))))
(define ($Kind.Term.SmartMotive.make name$0 expr$1 type$2 moti$3 size$4 defs$5) (let ((vals$6 ($Kind.Term.SmartMotive.vals expr$1 type$2 defs$5))) (let ((nams$7 ($Kind.Term.SmartMotive.nams name$0 type$2 defs$5))) (let ((subs$8 ($List.zip nams$7 vals$6))) ($List.fold subs$8 moti$3 (lambda (sub$9) (lambda (moti$10) (let ((self5 sub$9)) (case (get self5 0) ('Pair.new (let ((f5 (get self5 1))(f6 (get self5 2))) ($Kind.Term.SmartMotive.replace moti$10 f6 ($Kind.Term.ref f5) size$4))))))))))))
(define Kind.Term.SmartMotive.make (lambda (name$0) (lambda (expr$1) (lambda (type$2) (lambda (moti$3) (lambda (size$4) (lambda (defs$5) ($Kind.Term.SmartMotive.make name$0 expr$1 type$2 moti$3 size$4 defs$5))))))))
(define ($Kind.Term.desugar_cse.motive wyth$0 moti$1 name$2 expr$3 etyp$4 rtyp$5 defs$6 size$7) (let ((done$8 ($Kind.Term.desugar_cse.motive.go wyth$0 moti$1 name$2 expr$3 etyp$4 rtyp$5 defs$6 size$7))) (let ((self1 moti$1)) (case (get self1 0) ('Maybe.none (let () ($Kind.Term.SmartMotive.make name$2 expr$3 etyp$4 done$8 size$7 defs$6))) ('Maybe.some (let ((f1 (get self1 1))) done$8))))))
(define Kind.Term.desugar_cse.motive (lambda (wyth$0) (lambda (moti$1) (lambda (name$2) (lambda (expr$3) (lambda (etyp$4) (lambda (rtyp$5) (lambda (defs$6) (lambda (size$7) ($Kind.Term.desugar_cse.motive wyth$0 moti$1 name$2 expr$3 etyp$4 rtyp$5 defs$6 size$7))))))))))
(define ($Kind.Term.desugar_cse.argument name$0 wyth$1 type$2 body$3 defs$4) (let ((self0 ($Kind.Term.reduce type$2 defs$4))) (case (get self0 0) ('Kind.Term.var (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 wyth$1)) (case (get self2 0) ('List.nil (let () body$3)) ('List.cons (let ((f2 (get self2 1))(f3 (get self2 2))) (let ((self4 f2)) (case (get self4 0) ('Kind.Ann.new (let ((f4 (get self4 1))(f5 (get self4 2))(f6 (get self4 3))) ($Kind.Term.lam f4 (lambda (x$12) ($Kind.Term.desugar_cse.argument name$0 f3 type$2 body$3 defs$4))))))))))))) ('Kind.Term.ref (let ((f0 (get self0 1))) (let ((self1 wyth$1)) (case (get self1 0) ('List.nil (let () body$3)) ('List.cons (let ((f1 (get self1 1))(f2 (get self1 2))) (let ((self3 f1)) (case (get self3 0) ('Kind.Ann.new (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Kind.Term.lam f3 (lambda (x$11) ($Kind.Term.desugar_cse.argument name$0 f2 type$2 body$3 defs$4))))))))))))) ('Kind.Term.typ (let () (let ((self0 wyth$1)) (case (get self0 0) ('List.nil (let () body$3)) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 f0)) (case (get self2 0) ('Kind.Ann.new (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))) ($Kind.Term.lam f2 (lambda (x$10) ($Kind.Term.desugar_cse.argument name$0 f1 type$2 body$3 defs$4))))))))))))) ('Kind.Term.all (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))) ($Kind.Term.lam (let ((self5 ($String.is_empty f2))) (case self5 (#t (let () name$0)) (#f (let () ($String.flatten ($List.cons name$0 ($List.cons "." ($List.cons f2 List.nil)))))))) (lambda (x$10) ($Kind.Term.desugar_cse.argument name$0 wyth$1 ((f4 ($Kind.Term.var f1 0)) ($Kind.Term.var f2 0)) body$3 defs$4))))) ('Kind.Term.lam (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 wyth$1)) (case (get self2 0) ('List.nil (let () body$3)) ('List.cons (let ((f2 (get self2 1))(f3 (get self2 2))) (let ((self4 f2)) (case (get self4 0) ('Kind.Ann.new (let ((f4 (get self4 1))(f5 (get self4 2))(f6 (get self4 3))) ($Kind.Term.lam f4 (lambda (x$12) ($Kind.Term.desugar_cse.argument name$0 f3 type$2 body$3 defs$4))))))))))))) ('Kind.Term.app (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 wyth$1)) (case (get self2 0) ('List.nil (let () body$3)) ('List.cons (let ((f2 (get self2 1))(f3 (get self2 2))) (let ((self4 f2)) (case (get self4 0) ('Kind.Ann.new (let ((f4 (get self4 1))(f5 (get self4 2))(f6 (get self4 3))) ($Kind.Term.lam f4 (lambda (x$12) ($Kind.Term.desugar_cse.argument name$0 f3 type$2 body$3 defs$4))))))))))))) ('Kind.Term.let (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 wyth$1)) (case (get self3 0) ('List.nil (let () body$3)) ('List.cons (let ((f3 (get self3 1))(f4 (get self3 2))) (let ((self5 f3)) (case (get self5 0) ('Kind.Ann.new (let ((f5 (get self5 1))(f6 (get self5 2))(f7 (get self5 3))) ($Kind.Term.lam f5 (lambda (x$13) ($Kind.Term.desugar_cse.argument name$0 f4 type$2 body$3 defs$4))))))))))))) ('Kind.Term.def (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 wyth$1)) (case (get self3 0) ('List.nil (let () body$3)) ('List.cons (let ((f3 (get self3 1))(f4 (get self3 2))) (let ((self5 f3)) (case (get self5 0) ('Kind.Ann.new (let ((f5 (get self5 1))(f6 (get self5 2))(f7 (get self5 3))) ($Kind.Term.lam f5 (lambda (x$13) ($Kind.Term.desugar_cse.argument name$0 f4 type$2 body$3 defs$4))))))))))))) ('Kind.Term.ann (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 wyth$1)) (case (get self3 0) ('List.nil (let () body$3)) ('List.cons (let ((f3 (get self3 1))(f4 (get self3 2))) (let ((self5 f3)) (case (get self5 0) ('Kind.Ann.new (let ((f5 (get self5 1))(f6 (get self5 2))(f7 (get self5 3))) ($Kind.Term.lam f5 (lambda (x$13) ($Kind.Term.desugar_cse.argument name$0 f4 type$2 body$3 defs$4))))))))))))) ('Kind.Term.gol (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 wyth$1)) (case (get self3 0) ('List.nil (let () body$3)) ('List.cons (let ((f3 (get self3 1))(f4 (get self3 2))) (let ((self5 f3)) (case (get self5 0) ('Kind.Ann.new (let ((f5 (get self5 1))(f6 (get self5 2))(f7 (get self5 3))) ($Kind.Term.lam f5 (lambda (x$13) ($Kind.Term.desugar_cse.argument name$0 f4 type$2 body$3 defs$4))))))))))))) ('Kind.Term.hol (let ((f0 (get self0 1))) (let ((self1 wyth$1)) (case (get self1 0) ('List.nil (let () body$3)) ('List.cons (let ((f1 (get self1 1))(f2 (get self1 2))) (let ((self3 f1)) (case (get self3 0) ('Kind.Ann.new (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Kind.Term.lam f3 (lambda (x$11) ($Kind.Term.desugar_cse.argument name$0 f2 type$2 body$3 defs$4))))))))))))) ('Kind.Term.nat (let ((f0 (get self0 1))) (let ((self1 wyth$1)) (case (get self1 0) ('List.nil (let () body$3)) ('List.cons (let ((f1 (get self1 1))(f2 (get self1 2))) (let ((self3 f1)) (case (get self3 0) ('Kind.Ann.new (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Kind.Term.lam f3 (lambda (x$11) ($Kind.Term.desugar_cse.argument name$0 f2 type$2 body$3 defs$4))))))))))))) ('Kind.Term.chr (let ((f0 (get self0 1))) (let ((self1 wyth$1)) (case (get self1 0) ('List.nil (let () body$3)) ('List.cons (let ((f1 (get self1 1))(f2 (get self1 2))) (let ((self3 f1)) (case (get self3 0) ('Kind.Ann.new (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Kind.Term.lam f3 (lambda (x$11) ($Kind.Term.desugar_cse.argument name$0 f2 type$2 body$3 defs$4))))))))))))) ('Kind.Term.str (let ((f0 (get self0 1))) (let ((self1 wyth$1)) (case (get self1 0) ('List.nil (let () body$3)) ('List.cons (let ((f1 (get self1 1))(f2 (get self1 2))) (let ((self3 f1)) (case (get self3 0) ('Kind.Ann.new (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Kind.Term.lam f3 (lambda (x$11) ($Kind.Term.desugar_cse.argument name$0 f2 type$2 body$3 defs$4))))))))))))) ('Kind.Term.cse (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))(f5 (get self0 6))) (let ((self6 wyth$1)) (case (get self6 0) ('List.nil (let () body$3)) ('List.cons (let ((f6 (get self6 1))(f7 (get self6 2))) (let ((self8 f6)) (case (get self8 0) ('Kind.Ann.new (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))) ($Kind.Term.lam f8 (lambda (x$16) ($Kind.Term.desugar_cse.argument name$0 f7 type$2 body$3 defs$4))))))))))))) ('Kind.Term.ori (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 wyth$1)) (case (get self2 0) ('List.nil (let () body$3)) ('List.cons (let ((f2 (get self2 1))(f3 (get self2 2))) (let ((self4 f2)) (case (get self4 0) ('Kind.Ann.new (let ((f4 (get self4 1))(f5 (get self4 2))(f6 (get self4 3))) ($Kind.Term.lam f4 (lambda (x$12) ($Kind.Term.desugar_cse.argument name$0 f3 type$2 body$3 defs$4))))))))))))))))
(define Kind.Term.desugar_cse.argument (lambda (name$0) (lambda (wyth$1) (lambda (type$2) (lambda (body$3) (lambda (defs$4) ($Kind.Term.desugar_cse.argument name$0 wyth$1 type$2 body$3 defs$4)))))))
(define ($Maybe.or a$1 b$2) (let ((self0 a$1)) (case (get self0 0) ('Maybe.none (let () b$2)) ('Maybe.some (let ((f0 (get self0 1))) ($Maybe.some f0))))))
(define Maybe.or (lambda (a$1) (lambda (b$2) ($Maybe.or a$1 b$2))))
(define ($Kind.Term.desugar_cse.cases expr$0 name$1 wyth$2 cses$3 type$4 defs$5 ctxt$6) (let ((self0 ($Kind.Term.reduce type$4 defs$5))) (case (get self0 0) ('Kind.Term.var (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((expr$9 ($List.for wyth$2 expr$0 (lambda (defn$9) (lambda (expr$10) ($Kind.Term.app expr$10 (let ((self4 defn$9)) (case (get self4 0) ('Kind.Ann.new (let ((f4 (get self4 1))(f5 (get self4 2))(f6 (get self4 3))) f5)))))))))) expr$9))) ('Kind.Term.ref (let ((f0 (get self0 1))) (let ((expr$8 ($List.for wyth$2 expr$0 (lambda (defn$8) (lambda (expr$9) ($Kind.Term.app expr$9 (let ((self3 defn$8)) (case (get self3 0) ('Kind.Ann.new (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) f4)))))))))) expr$8))) ('Kind.Term.typ (let () (let ((expr$7 ($List.for wyth$2 expr$0 (lambda (defn$7) (lambda (expr$8) ($Kind.Term.app expr$8 (let ((self2 defn$7)) (case (get self2 0) ('Kind.Ann.new (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))) f3)))))))))) expr$7))) ('Kind.Term.all (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))) (let ((argm$12 ($Maybe.or ($Kind.Map.get f2 cses$3) ($Kind.Map.get "_" cses$3)))) (let ((argm$13 ($Maybe.default argm$12 ($Kind.Term.ref ($String.concat name$1 ($String.concat "_" ($String.concat f2 "_case"))))))) (let ((argm$14 ($Kind.Term.desugar_cse.argument name$1 wyth$2 f3 argm$13 defs$5))) (let ((expr$15 ($Kind.Term.app expr$0 argm$14))) (let ((type$16 ((f4 ($Kind.Term.var f1 0)) ($Kind.Term.var f2 0)))) ($Kind.Term.desugar_cse.cases expr$15 name$1 wyth$2 cses$3 type$16 defs$5 ctxt$6)))))))) ('Kind.Term.lam (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((expr$9 ($List.for wyth$2 expr$0 (lambda (defn$9) (lambda (expr$10) ($Kind.Term.app expr$10 (let ((self4 defn$9)) (case (get self4 0) ('Kind.Ann.new (let ((f4 (get self4 1))(f5 (get self4 2))(f6 (get self4 3))) f5)))))))))) expr$9))) ('Kind.Term.app (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((expr$9 ($List.for wyth$2 expr$0 (lambda (defn$9) (lambda (expr$10) ($Kind.Term.app expr$10 (let ((self4 defn$9)) (case (get self4 0) ('Kind.Ann.new (let ((f4 (get self4 1))(f5 (get self4 2))(f6 (get self4 3))) f5)))))))))) expr$9))) ('Kind.Term.let (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((expr$10 ($List.for wyth$2 expr$0 (lambda (defn$10) (lambda (expr$11) ($Kind.Term.app expr$11 (let ((self5 defn$10)) (case (get self5 0) ('Kind.Ann.new (let ((f5 (get self5 1))(f6 (get self5 2))(f7 (get self5 3))) f6)))))))))) expr$10))) ('Kind.Term.def (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((expr$10 ($List.for wyth$2 expr$0 (lambda (defn$10) (lambda (expr$11) ($Kind.Term.app expr$11 (let ((self5 defn$10)) (case (get self5 0) ('Kind.Ann.new (let ((f5 (get self5 1))(f6 (get self5 2))(f7 (get self5 3))) f6)))))))))) expr$10))) ('Kind.Term.ann (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((expr$10 ($List.for wyth$2 expr$0 (lambda (defn$10) (lambda (expr$11) ($Kind.Term.app expr$11 (let ((self5 defn$10)) (case (get self5 0) ('Kind.Ann.new (let ((f5 (get self5 1))(f6 (get self5 2))(f7 (get self5 3))) f6)))))))))) expr$10))) ('Kind.Term.gol (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((expr$10 ($List.for wyth$2 expr$0 (lambda (defn$10) (lambda (expr$11) ($Kind.Term.app expr$11 (let ((self5 defn$10)) (case (get self5 0) ('Kind.Ann.new (let ((f5 (get self5 1))(f6 (get self5 2))(f7 (get self5 3))) f6)))))))))) expr$10))) ('Kind.Term.hol (let ((f0 (get self0 1))) (let ((expr$8 ($List.for wyth$2 expr$0 (lambda (defn$8) (lambda (expr$9) ($Kind.Term.app expr$9 (let ((self3 defn$8)) (case (get self3 0) ('Kind.Ann.new (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) f4)))))))))) expr$8))) ('Kind.Term.nat (let ((f0 (get self0 1))) (let ((expr$8 ($List.for wyth$2 expr$0 (lambda (defn$8) (lambda (expr$9) ($Kind.Term.app expr$9 (let ((self3 defn$8)) (case (get self3 0) ('Kind.Ann.new (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) f4)))))))))) expr$8))) ('Kind.Term.chr (let ((f0 (get self0 1))) (let ((expr$8 ($List.for wyth$2 expr$0 (lambda (defn$8) (lambda (expr$9) ($Kind.Term.app expr$9 (let ((self3 defn$8)) (case (get self3 0) ('Kind.Ann.new (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) f4)))))))))) expr$8))) ('Kind.Term.str (let ((f0 (get self0 1))) (let ((expr$8 ($List.for wyth$2 expr$0 (lambda (defn$8) (lambda (expr$9) ($Kind.Term.app expr$9 (let ((self3 defn$8)) (case (get self3 0) ('Kind.Ann.new (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) f4)))))))))) expr$8))) ('Kind.Term.cse (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))(f5 (get self0 6))) (let ((expr$13 ($List.for wyth$2 expr$0 (lambda (defn$13) (lambda (expr$14) ($Kind.Term.app expr$14 (let ((self8 defn$13)) (case (get self8 0) ('Kind.Ann.new (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))) f9)))))))))) expr$13))) ('Kind.Term.ori (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((expr$9 ($List.for wyth$2 expr$0 (lambda (defn$9) (lambda (expr$10) ($Kind.Term.app expr$10 (let ((self4 defn$9)) (case (get self4 0) ('Kind.Ann.new (let ((f4 (get self4 1))(f5 (get self4 2))(f6 (get self4 3))) f5)))))))))) expr$9))))))
(define Kind.Term.desugar_cse.cases (lambda (expr$0) (lambda (name$1) (lambda (wyth$2) (lambda (cses$3) (lambda (type$4) (lambda (defs$5) (lambda (ctxt$6) ($Kind.Term.desugar_cse.cases expr$0 name$1 wyth$2 cses$3 type$4 defs$5 ctxt$6)))))))))
(define ($Kind.Term.desugar_cse expr$0 name$1 wyth$2 cses$3 moti$4 etyp$5 rtyp$6 defs$7 ctxt$8) (let ((self0 ($Kind.Term.reduce etyp$5 defs$7))) (case (get self0 0) ('Kind.Term.var (let ((f0 (get self0 1))(f1 (get self0 2))) Maybe.none)) ('Kind.Term.ref (let ((f0 (get self0 1))) Maybe.none)) ('Kind.Term.typ (let () Maybe.none)) ('Kind.Term.all (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))) (let ((moti$14 ($Kind.Term.desugar_cse.motive wyth$2 moti$4 name$1 expr$0 etyp$5 rtyp$6 defs$7 ($List.length ctxt$8)))) (let ((argm$15 ($Kind.Term.desugar_cse.argument name$1 List.nil f3 moti$14 defs$7))) (let ((expr$16 ($Kind.Term.app expr$0 argm$15))) (let ((type$17 ((f4 ($Kind.Term.var f1 0)) ($Kind.Term.var f2 0)))) ($Maybe.some ($Kind.Term.desugar_cse.cases expr$16 name$1 wyth$2 cses$3 type$17 defs$7 ctxt$8)))))))) ('Kind.Term.lam (let ((f0 (get self0 1))(f1 (get self0 2))) Maybe.none)) ('Kind.Term.app (let ((f0 (get self0 1))(f1 (get self0 2))) Maybe.none)) ('Kind.Term.let (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) Maybe.none)) ('Kind.Term.def (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) Maybe.none)) ('Kind.Term.ann (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) Maybe.none)) ('Kind.Term.gol (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) Maybe.none)) ('Kind.Term.hol (let ((f0 (get self0 1))) Maybe.none)) ('Kind.Term.nat (let ((f0 (get self0 1))) Maybe.none)) ('Kind.Term.chr (let ((f0 (get self0 1))) Maybe.none)) ('Kind.Term.str (let ((f0 (get self0 1))) Maybe.none)) ('Kind.Term.cse (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))(f5 (get self0 6))) Maybe.none)) ('Kind.Term.ori (let ((f0 (get self0 1))(f1 (get self0 2))) Maybe.none)))))
(define Kind.Term.desugar_cse (lambda (expr$0) (lambda (name$1) (lambda (wyth$2) (lambda (cses$3) (lambda (moti$4) (lambda (etyp$5) (lambda (rtyp$6) (lambda (defs$7) (lambda (ctxt$8) ($Kind.Term.desugar_cse expr$0 name$1 wyth$2 cses$3 moti$4 etyp$5 rtyp$6 defs$7 ctxt$8)))))))))))
(define ($Kind.Error.cant_infer origin$0 term$1 context$2) (vector 'Kind.Error.cant_infer origin$0 term$1 context$2))
(define Kind.Error.cant_infer (lambda (origin$0) (lambda (term$1) (lambda (context$2) ($Kind.Error.cant_infer origin$0 term$1 context$2)))))
(define ($BitsSet.has bits$0 set$1) (let ((self0 ($BitsMap.get bits$0 set$1))) (case (get self0 0) ('Maybe.none (let () Bool.false)) ('Maybe.some (let ((f0 (get self0 1))) Bool.true)))))
(define BitsSet.has (lambda (bits$0) (lambda (set$1) ($BitsSet.has bits$0 set$1))))
(define ($BitsSet.mut.has bits$0 set$1) ($BitsSet.has bits$0 set$1))
(define BitsSet.mut.has (lambda (bits$0) (lambda (set$1) ($BitsSet.mut.has bits$0 set$1))))
(define ($Kind.Term.equal.extra_holes.funari term$0 arity$1) (let ((self0 term$0)) (case (get self0 0) ('Kind.Term.var (let ((f0 (get self0 1))(f1 (get self0 2))) ($Maybe.some ($Pair.new f0 arity$1)))) ('Kind.Term.ref (let ((f0 (get self0 1))) ($Maybe.some ($Pair.new f0 arity$1)))) ('Kind.Term.typ (let () Maybe.none)) ('Kind.Term.all (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))) Maybe.none)) ('Kind.Term.lam (let ((f0 (get self0 1))(f1 (get self0 2))) Maybe.none)) ('Kind.Term.app (let ((f0 (get self0 1))(f1 (get self0 2))) ($Kind.Term.equal.extra_holes.funari f0 ($Nat.succ arity$1)))) ('Kind.Term.let (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) Maybe.none)) ('Kind.Term.def (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) Maybe.none)) ('Kind.Term.ann (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) Maybe.none)) ('Kind.Term.gol (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) Maybe.none)) ('Kind.Term.hol (let ((f0 (get self0 1))) Maybe.none)) ('Kind.Term.nat (let ((f0 (get self0 1))) Maybe.none)) ('Kind.Term.chr (let ((f0 (get self0 1))) Maybe.none)) ('Kind.Term.str (let ((f0 (get self0 1))) Maybe.none)) ('Kind.Term.cse (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))(f5 (get self0 6))) Maybe.none)) ('Kind.Term.ori (let ((f0 (get self0 1))(f1 (get self0 2))) ($Kind.Term.equal.extra_holes.funari f1 arity$1))))))
(define Kind.Term.equal.extra_holes.funari (lambda (term$0) (lambda (arity$1) ($Kind.Term.equal.extra_holes.funari term$0 arity$1))))
(define ($Kind.Term.has_holes term$0) (let ((self0 term$0)) (case (get self0 0) ('Kind.Term.var (let ((f0 (get self0 1))(f1 (get self0 2))) Bool.false)) ('Kind.Term.ref (let ((f0 (get self0 1))) Bool.false)) ('Kind.Term.typ (let () Bool.false)) ('Kind.Term.all (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))) ($Bool.or ($Kind.Term.has_holes f3) ($Kind.Term.has_holes ((f4 Kind.Term.typ) Kind.Term.typ))))) ('Kind.Term.lam (let ((f0 (get self0 1))(f1 (get self0 2))) ($Kind.Term.has_holes (f1 Kind.Term.typ)))) ('Kind.Term.app (let ((f0 (get self0 1))(f1 (get self0 2))) ($Bool.or ($Kind.Term.has_holes f0) ($Kind.Term.has_holes f1)))) ('Kind.Term.let (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Bool.or ($Kind.Term.has_holes f1) ($Kind.Term.has_holes (f2 Kind.Term.typ))))) ('Kind.Term.def (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Bool.or ($Kind.Term.has_holes f1) ($Kind.Term.has_holes (f2 Kind.Term.typ))))) ('Kind.Term.ann (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Bool.or ($Kind.Term.has_holes f1) ($Kind.Term.has_holes f2)))) ('Kind.Term.gol (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) Bool.false)) ('Kind.Term.hol (let ((f0 (get self0 1))) Bool.true)) ('Kind.Term.nat (let ((f0 (get self0 1))) Bool.false)) ('Kind.Term.chr (let ((f0 (get self0 1))) Bool.false)) ('Kind.Term.str (let ((f0 (get self0 1))) Bool.false)) ('Kind.Term.cse (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))(f5 (get self0 6))) Bool.false)) ('Kind.Term.ori (let ((f0 (get self0 1))(f1 (get self0 2))) ($Kind.Term.has_holes f1))))))
(define Kind.Term.has_holes (lambda (term$0) ($Kind.Term.has_holes term$0)))
(define ($Kind.Term.equal.hole path$0 term$1) (let ((self0 term$1)) (case (get self0 0) ('Kind.Term.var (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 ($Kind.Term.has_holes term$1))) (case self2 (#t (let () ($Kind.Check.result ($Maybe.some Bool.true) List.nil))) (#f (let () ($Kind.Check.result ($Maybe.some Bool.true) ($List.cons ($Kind.Error.patch path$0 ($Kind.Term.normalize term$1 Kind.Map.new)) List.nil)))))))) ('Kind.Term.ref (let ((f0 (get self0 1))) (let ((self1 ($Kind.Term.has_holes term$1))) (case self1 (#t (let () ($Kind.Check.result ($Maybe.some Bool.true) List.nil))) (#f (let () ($Kind.Check.result ($Maybe.some Bool.true) ($List.cons ($Kind.Error.patch path$0 ($Kind.Term.normalize term$1 Kind.Map.new)) List.nil)))))))) ('Kind.Term.typ (let () (let ((self0 ($Kind.Term.has_holes term$1))) (case self0 (#t (let () ($Kind.Check.result ($Maybe.some Bool.true) List.nil))) (#f (let () ($Kind.Check.result ($Maybe.some Bool.true) ($List.cons ($Kind.Error.patch path$0 ($Kind.Term.normalize term$1 Kind.Map.new)) List.nil)))))))) ('Kind.Term.all (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))) (let ((self5 ($Kind.Term.has_holes term$1))) (case self5 (#t (let () ($Kind.Check.result ($Maybe.some Bool.true) List.nil))) (#f (let () ($Kind.Check.result ($Maybe.some Bool.true) ($List.cons ($Kind.Error.patch path$0 ($Kind.Term.normalize term$1 Kind.Map.new)) List.nil)))))))) ('Kind.Term.lam (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 ($Kind.Term.has_holes term$1))) (case self2 (#t (let () ($Kind.Check.result ($Maybe.some Bool.true) List.nil))) (#f (let () ($Kind.Check.result ($Maybe.some Bool.true) ($List.cons ($Kind.Error.patch path$0 ($Kind.Term.normalize term$1 Kind.Map.new)) List.nil)))))))) ('Kind.Term.app (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 ($Kind.Term.has_holes term$1))) (case self2 (#t (let () ($Kind.Check.result ($Maybe.some Bool.true) List.nil))) (#f (let () ($Kind.Check.result ($Maybe.some Bool.true) ($List.cons ($Kind.Error.patch path$0 ($Kind.Term.normalize term$1 Kind.Map.new)) List.nil)))))))) ('Kind.Term.let (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ($Kind.Term.has_holes term$1))) (case self3 (#t (let () ($Kind.Check.result ($Maybe.some Bool.true) List.nil))) (#f (let () ($Kind.Check.result ($Maybe.some Bool.true) ($List.cons ($Kind.Error.patch path$0 ($Kind.Term.normalize term$1 Kind.Map.new)) List.nil)))))))) ('Kind.Term.def (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ($Kind.Term.has_holes term$1))) (case self3 (#t (let () ($Kind.Check.result ($Maybe.some Bool.true) List.nil))) (#f (let () ($Kind.Check.result ($Maybe.some Bool.true) ($List.cons ($Kind.Error.patch path$0 ($Kind.Term.normalize term$1 Kind.Map.new)) List.nil)))))))) ('Kind.Term.ann (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ($Kind.Term.has_holes term$1))) (case self3 (#t (let () ($Kind.Check.result ($Maybe.some Bool.true) List.nil))) (#f (let () ($Kind.Check.result ($Maybe.some Bool.true) ($List.cons ($Kind.Error.patch path$0 ($Kind.Term.normalize term$1 Kind.Map.new)) List.nil)))))))) ('Kind.Term.gol (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ($Kind.Term.has_holes term$1))) (case self3 (#t (let () ($Kind.Check.result ($Maybe.some Bool.true) List.nil))) (#f (let () ($Kind.Check.result ($Maybe.some Bool.true) ($List.cons ($Kind.Error.patch path$0 ($Kind.Term.normalize term$1 Kind.Map.new)) List.nil)))))))) ('Kind.Term.hol (let ((f0 (get self0 1))) ($Kind.Check.result ($Maybe.some Bool.true) List.nil))) ('Kind.Term.nat (let ((f0 (get self0 1))) (let ((self1 ($Kind.Term.has_holes term$1))) (case self1 (#t (let () ($Kind.Check.result ($Maybe.some Bool.true) List.nil))) (#f (let () ($Kind.Check.result ($Maybe.some Bool.true) ($List.cons ($Kind.Error.patch path$0 ($Kind.Term.normalize term$1 Kind.Map.new)) List.nil)))))))) ('Kind.Term.chr (let ((f0 (get self0 1))) (let ((self1 ($Kind.Term.has_holes term$1))) (case self1 (#t (let () ($Kind.Check.result ($Maybe.some Bool.true) List.nil))) (#f (let () ($Kind.Check.result ($Maybe.some Bool.true) ($List.cons ($Kind.Error.patch path$0 ($Kind.Term.normalize term$1 Kind.Map.new)) List.nil)))))))) ('Kind.Term.str (let ((f0 (get self0 1))) (let ((self1 ($Kind.Term.has_holes term$1))) (case self1 (#t (let () ($Kind.Check.result ($Maybe.some Bool.true) List.nil))) (#f (let () ($Kind.Check.result ($Maybe.some Bool.true) ($List.cons ($Kind.Error.patch path$0 ($Kind.Term.normalize term$1 Kind.Map.new)) List.nil)))))))) ('Kind.Term.cse (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))(f5 (get self0 6))) (let ((self6 ($Kind.Term.has_holes term$1))) (case self6 (#t (let () ($Kind.Check.result ($Maybe.some Bool.true) List.nil))) (#f (let () ($Kind.Check.result ($Maybe.some Bool.true) ($List.cons ($Kind.Error.patch path$0 ($Kind.Term.normalize term$1 Kind.Map.new)) List.nil)))))))) ('Kind.Term.ori (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 ($Kind.Term.has_holes term$1))) (case self2 (#t (let () ($Kind.Check.result ($Maybe.some Bool.true) List.nil))) (#f (let () ($Kind.Check.result ($Maybe.some Bool.true) ($List.cons ($Kind.Error.patch path$0 ($Kind.Term.normalize term$1 Kind.Map.new)) List.nil)))))))))))
(define Kind.Term.equal.hole (lambda (path$0) (lambda (term$1) ($Kind.Term.equal.hole path$0 term$1))))
(define ($Kind.Term.equal.extra_holes.filler a$0 b$1) (let ((self0 a$0)) (case (get self0 0) ('Kind.Term.var (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 b$1)) (case (get self2 0) ('Kind.Term.var (let ((f2 (get self2 1))(f3 (get self2 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.ref (let ((f2 (get self2 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.typ (let () ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.all (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))(f5 (get self2 4))(f6 (get self2 5))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.lam (let ((f2 (get self2 1))(f3 (get self2 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.app (let ((f2 (get self2 1))(f3 (get self2 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.let (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.def (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.ann (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.gol (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.hol (let ((f2 (get self2 1))) (let ((self3 ($Kind.Term.equal.hole f2 a$0))) (case (get self3 0) ('Kind.Check.result (let ((f3 (get self3 1))(f4 (get self3 2))) (let ((self5 f3)) (case (get self5 0) ('Maybe.none (let () ($Kind.Check.result Maybe.none f4))) ('Maybe.some (let ((f5 (get self5 1))) (let ((self6 ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) (case (get self6 0) ('Kind.Check.result (let ((f6 (get self6 1))(f7 (get self6 2))) ($Kind.Check.result f6 ($List.concat f4 f7)))))))))))))))) ('Kind.Term.nat (let ((f2 (get self2 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.chr (let ((f2 (get self2 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.str (let ((f2 (get self2 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.cse (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))(f5 (get self2 4))(f6 (get self2 5))(f7 (get self2 6))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.ori (let ((f2 (get self2 1))(f3 (get self2 2))) ($Kind.Term.equal.extra_holes.filler a$0 f3))))))) ('Kind.Term.ref (let ((f0 (get self0 1))) (let ((self1 b$1)) (case (get self1 0) ('Kind.Term.var (let ((f1 (get self1 1))(f2 (get self1 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.ref (let ((f1 (get self1 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.typ (let () ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.all (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))(f4 (get self1 4))(f5 (get self1 5))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.lam (let ((f1 (get self1 1))(f2 (get self1 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.app (let ((f1 (get self1 1))(f2 (get self1 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.let (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.def (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.ann (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.gol (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.hol (let ((f1 (get self1 1))) (let ((self2 ($Kind.Term.equal.hole f1 a$0))) (case (get self2 0) ('Kind.Check.result (let ((f2 (get self2 1))(f3 (get self2 2))) (let ((self4 f2)) (case (get self4 0) ('Maybe.none (let () ($Kind.Check.result Maybe.none f3))) ('Maybe.some (let ((f4 (get self4 1))) (let ((self5 ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) (case (get self5 0) ('Kind.Check.result (let ((f5 (get self5 1))(f6 (get self5 2))) ($Kind.Check.result f5 ($List.concat f3 f6)))))))))))))))) ('Kind.Term.nat (let ((f1 (get self1 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.chr (let ((f1 (get self1 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.str (let ((f1 (get self1 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.cse (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))(f4 (get self1 4))(f5 (get self1 5))(f6 (get self1 6))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.ori (let ((f1 (get self1 1))(f2 (get self1 2))) ($Kind.Term.equal.extra_holes.filler a$0 f2))))))) ('Kind.Term.typ (let () (let ((self0 b$1)) (case (get self0 0) ('Kind.Term.var (let ((f0 (get self0 1))(f1 (get self0 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.ref (let ((f0 (get self0 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.typ (let () ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.all (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.lam (let ((f0 (get self0 1))(f1 (get self0 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.app (let ((f0 (get self0 1))(f1 (get self0 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.let (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.def (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.ann (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.gol (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.hol (let ((f0 (get self0 1))) (let ((self1 ($Kind.Term.equal.hole f0 a$0))) (case (get self1 0) ('Kind.Check.result (let ((f1 (get self1 1))(f2 (get self1 2))) (let ((self3 f1)) (case (get self3 0) ('Maybe.none (let () ($Kind.Check.result Maybe.none f2))) ('Maybe.some (let ((f3 (get self3 1))) (let ((self4 ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) (case (get self4 0) ('Kind.Check.result (let ((f4 (get self4 1))(f5 (get self4 2))) ($Kind.Check.result f4 ($List.concat f2 f5)))))))))))))))) ('Kind.Term.nat (let ((f0 (get self0 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.chr (let ((f0 (get self0 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.str (let ((f0 (get self0 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.cse (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))(f5 (get self0 6))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.ori (let ((f0 (get self0 1))(f1 (get self0 2))) ($Kind.Term.equal.extra_holes.filler a$0 f1))))))) ('Kind.Term.all (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))) (let ((self5 b$1)) (case (get self5 0) ('Kind.Term.var (let ((f5 (get self5 1))(f6 (get self5 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.ref (let ((f5 (get self5 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.typ (let () ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.all (let ((f5 (get self5 1))(f6 (get self5 2))(f7 (get self5 3))(f8 (get self5 4))(f9 (get self5 5))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.lam (let ((f5 (get self5 1))(f6 (get self5 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.app (let ((f5 (get self5 1))(f6 (get self5 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.let (let ((f5 (get self5 1))(f6 (get self5 2))(f7 (get self5 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.def (let ((f5 (get self5 1))(f6 (get self5 2))(f7 (get self5 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.ann (let ((f5 (get self5 1))(f6 (get self5 2))(f7 (get self5 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.gol (let ((f5 (get self5 1))(f6 (get self5 2))(f7 (get self5 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.hol (let ((f5 (get self5 1))) (let ((self6 ($Kind.Term.equal.hole f5 a$0))) (case (get self6 0) ('Kind.Check.result (let ((f6 (get self6 1))(f7 (get self6 2))) (let ((self8 f6)) (case (get self8 0) ('Maybe.none (let () ($Kind.Check.result Maybe.none f7))) ('Maybe.some (let ((f8 (get self8 1))) (let ((self9 ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) (case (get self9 0) ('Kind.Check.result (let ((f9 (get self9 1))(f10 (get self9 2))) ($Kind.Check.result f9 ($List.concat f7 f10)))))))))))))))) ('Kind.Term.nat (let ((f5 (get self5 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.chr (let ((f5 (get self5 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.str (let ((f5 (get self5 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.cse (let ((f5 (get self5 1))(f6 (get self5 2))(f7 (get self5 3))(f8 (get self5 4))(f9 (get self5 5))(f10 (get self5 6))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.ori (let ((f5 (get self5 1))(f6 (get self5 2))) ($Kind.Term.equal.extra_holes.filler a$0 f6))))))) ('Kind.Term.lam (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 b$1)) (case (get self2 0) ('Kind.Term.var (let ((f2 (get self2 1))(f3 (get self2 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.ref (let ((f2 (get self2 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.typ (let () ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.all (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))(f5 (get self2 4))(f6 (get self2 5))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.lam (let ((f2 (get self2 1))(f3 (get self2 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.app (let ((f2 (get self2 1))(f3 (get self2 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.let (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.def (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.ann (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.gol (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.hol (let ((f2 (get self2 1))) (let ((self3 ($Kind.Term.equal.hole f2 a$0))) (case (get self3 0) ('Kind.Check.result (let ((f3 (get self3 1))(f4 (get self3 2))) (let ((self5 f3)) (case (get self5 0) ('Maybe.none (let () ($Kind.Check.result Maybe.none f4))) ('Maybe.some (let ((f5 (get self5 1))) (let ((self6 ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) (case (get self6 0) ('Kind.Check.result (let ((f6 (get self6 1))(f7 (get self6 2))) ($Kind.Check.result f6 ($List.concat f4 f7)))))))))))))))) ('Kind.Term.nat (let ((f2 (get self2 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.chr (let ((f2 (get self2 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.str (let ((f2 (get self2 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.cse (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))(f5 (get self2 4))(f6 (get self2 5))(f7 (get self2 6))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.ori (let ((f2 (get self2 1))(f3 (get self2 2))) ($Kind.Term.equal.extra_holes.filler a$0 f3))))))) ('Kind.Term.app (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 b$1)) (case (get self2 0) ('Kind.Term.var (let ((f2 (get self2 1))(f3 (get self2 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.ref (let ((f2 (get self2 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.typ (let () ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.all (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))(f5 (get self2 4))(f6 (get self2 5))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.lam (let ((f2 (get self2 1))(f3 (get self2 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.app (let ((f2 (get self2 1))(f3 (get self2 2))) (let ((self4 ($Kind.Term.equal.extra_holes.filler f0 f2))) (case (get self4 0) ('Kind.Check.result (let ((f4 (get self4 1))(f5 (get self4 2))) (let ((self6 f4)) (case (get self6 0) ('Maybe.none (let () ($Kind.Check.result Maybe.none f5))) ('Maybe.some (let ((f6 (get self6 1))) (let ((self7 ($Kind.Term.equal.extra_holes.filler f1 f3))) (case (get self7 0) ('Kind.Check.result (let ((f7 (get self7 1))(f8 (get self7 2))) ($Kind.Check.result f7 ($List.concat f5 f8)))))))))))))))) ('Kind.Term.let (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.def (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.ann (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.gol (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.hol (let ((f2 (get self2 1))) (let ((self3 ($Kind.Term.equal.hole f2 a$0))) (case (get self3 0) ('Kind.Check.result (let ((f3 (get self3 1))(f4 (get self3 2))) (let ((self5 f3)) (case (get self5 0) ('Maybe.none (let () ($Kind.Check.result Maybe.none f4))) ('Maybe.some (let ((f5 (get self5 1))) (let ((self6 ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) (case (get self6 0) ('Kind.Check.result (let ((f6 (get self6 1))(f7 (get self6 2))) ($Kind.Check.result f6 ($List.concat f4 f7)))))))))))))))) ('Kind.Term.nat (let ((f2 (get self2 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.chr (let ((f2 (get self2 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.str (let ((f2 (get self2 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.cse (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))(f5 (get self2 4))(f6 (get self2 5))(f7 (get self2 6))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.ori (let ((f2 (get self2 1))(f3 (get self2 2))) ($Kind.Term.equal.extra_holes.filler a$0 f3))))))) ('Kind.Term.let (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 b$1)) (case (get self3 0) ('Kind.Term.var (let ((f3 (get self3 1))(f4 (get self3 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.ref (let ((f3 (get self3 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.typ (let () ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.all (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))(f6 (get self3 4))(f7 (get self3 5))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.lam (let ((f3 (get self3 1))(f4 (get self3 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.app (let ((f3 (get self3 1))(f4 (get self3 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.let (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.def (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.ann (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.gol (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.hol (let ((f3 (get self3 1))) (let ((self4 ($Kind.Term.equal.hole f3 a$0))) (case (get self4 0) ('Kind.Check.result (let ((f4 (get self4 1))(f5 (get self4 2))) (let ((self6 f4)) (case (get self6 0) ('Maybe.none (let () ($Kind.Check.result Maybe.none f5))) ('Maybe.some (let ((f6 (get self6 1))) (let ((self7 ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) (case (get self7 0) ('Kind.Check.result (let ((f7 (get self7 1))(f8 (get self7 2))) ($Kind.Check.result f7 ($List.concat f5 f8)))))))))))))))) ('Kind.Term.nat (let ((f3 (get self3 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.chr (let ((f3 (get self3 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.str (let ((f3 (get self3 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.cse (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))(f6 (get self3 4))(f7 (get self3 5))(f8 (get self3 6))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.ori (let ((f3 (get self3 1))(f4 (get self3 2))) ($Kind.Term.equal.extra_holes.filler a$0 f4))))))) ('Kind.Term.def (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 b$1)) (case (get self3 0) ('Kind.Term.var (let ((f3 (get self3 1))(f4 (get self3 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.ref (let ((f3 (get self3 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.typ (let () ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.all (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))(f6 (get self3 4))(f7 (get self3 5))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.lam (let ((f3 (get self3 1))(f4 (get self3 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.app (let ((f3 (get self3 1))(f4 (get self3 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.let (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.def (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.ann (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.gol (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.hol (let ((f3 (get self3 1))) (let ((self4 ($Kind.Term.equal.hole f3 a$0))) (case (get self4 0) ('Kind.Check.result (let ((f4 (get self4 1))(f5 (get self4 2))) (let ((self6 f4)) (case (get self6 0) ('Maybe.none (let () ($Kind.Check.result Maybe.none f5))) ('Maybe.some (let ((f6 (get self6 1))) (let ((self7 ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) (case (get self7 0) ('Kind.Check.result (let ((f7 (get self7 1))(f8 (get self7 2))) ($Kind.Check.result f7 ($List.concat f5 f8)))))))))))))))) ('Kind.Term.nat (let ((f3 (get self3 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.chr (let ((f3 (get self3 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.str (let ((f3 (get self3 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.cse (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))(f6 (get self3 4))(f7 (get self3 5))(f8 (get self3 6))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.ori (let ((f3 (get self3 1))(f4 (get self3 2))) ($Kind.Term.equal.extra_holes.filler a$0 f4))))))) ('Kind.Term.ann (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 b$1)) (case (get self3 0) ('Kind.Term.var (let ((f3 (get self3 1))(f4 (get self3 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.ref (let ((f3 (get self3 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.typ (let () ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.all (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))(f6 (get self3 4))(f7 (get self3 5))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.lam (let ((f3 (get self3 1))(f4 (get self3 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.app (let ((f3 (get self3 1))(f4 (get self3 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.let (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.def (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.ann (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.gol (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.hol (let ((f3 (get self3 1))) (let ((self4 ($Kind.Term.equal.hole f3 a$0))) (case (get self4 0) ('Kind.Check.result (let ((f4 (get self4 1))(f5 (get self4 2))) (let ((self6 f4)) (case (get self6 0) ('Maybe.none (let () ($Kind.Check.result Maybe.none f5))) ('Maybe.some (let ((f6 (get self6 1))) (let ((self7 ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) (case (get self7 0) ('Kind.Check.result (let ((f7 (get self7 1))(f8 (get self7 2))) ($Kind.Check.result f7 ($List.concat f5 f8)))))))))))))))) ('Kind.Term.nat (let ((f3 (get self3 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.chr (let ((f3 (get self3 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.str (let ((f3 (get self3 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.cse (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))(f6 (get self3 4))(f7 (get self3 5))(f8 (get self3 6))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.ori (let ((f3 (get self3 1))(f4 (get self3 2))) ($Kind.Term.equal.extra_holes.filler a$0 f4))))))) ('Kind.Term.gol (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 b$1)) (case (get self3 0) ('Kind.Term.var (let ((f3 (get self3 1))(f4 (get self3 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.ref (let ((f3 (get self3 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.typ (let () ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.all (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))(f6 (get self3 4))(f7 (get self3 5))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.lam (let ((f3 (get self3 1))(f4 (get self3 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.app (let ((f3 (get self3 1))(f4 (get self3 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.let (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.def (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.ann (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.gol (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.hol (let ((f3 (get self3 1))) (let ((self4 ($Kind.Term.equal.hole f3 a$0))) (case (get self4 0) ('Kind.Check.result (let ((f4 (get self4 1))(f5 (get self4 2))) (let ((self6 f4)) (case (get self6 0) ('Maybe.none (let () ($Kind.Check.result Maybe.none f5))) ('Maybe.some (let ((f6 (get self6 1))) (let ((self7 ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) (case (get self7 0) ('Kind.Check.result (let ((f7 (get self7 1))(f8 (get self7 2))) ($Kind.Check.result f7 ($List.concat f5 f8)))))))))))))))) ('Kind.Term.nat (let ((f3 (get self3 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.chr (let ((f3 (get self3 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.str (let ((f3 (get self3 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.cse (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))(f6 (get self3 4))(f7 (get self3 5))(f8 (get self3 6))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.ori (let ((f3 (get self3 1))(f4 (get self3 2))) ($Kind.Term.equal.extra_holes.filler a$0 f4))))))) ('Kind.Term.hol (let ((f0 (get self0 1))) (let ((self1 ($Kind.Term.equal.hole f0 b$1))) (case (get self1 0) ('Kind.Check.result (let ((f1 (get self1 1))(f2 (get self1 2))) (let ((self3 f1)) (case (get self3 0) ('Maybe.none (let () ($Kind.Check.result Maybe.none f2))) ('Maybe.some (let ((f3 (get self3 1))) (let ((self4 ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) (case (get self4 0) ('Kind.Check.result (let ((f4 (get self4 1))(f5 (get self4 2))) ($Kind.Check.result f4 ($List.concat f2 f5)))))))))))))))) ('Kind.Term.nat (let ((f0 (get self0 1))) (let ((self1 b$1)) (case (get self1 0) ('Kind.Term.var (let ((f1 (get self1 1))(f2 (get self1 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.ref (let ((f1 (get self1 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.typ (let () ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.all (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))(f4 (get self1 4))(f5 (get self1 5))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.lam (let ((f1 (get self1 1))(f2 (get self1 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.app (let ((f1 (get self1 1))(f2 (get self1 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.let (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.def (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.ann (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.gol (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.hol (let ((f1 (get self1 1))) (let ((self2 ($Kind.Term.equal.hole f1 a$0))) (case (get self2 0) ('Kind.Check.result (let ((f2 (get self2 1))(f3 (get self2 2))) (let ((self4 f2)) (case (get self4 0) ('Maybe.none (let () ($Kind.Check.result Maybe.none f3))) ('Maybe.some (let ((f4 (get self4 1))) (let ((self5 ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) (case (get self5 0) ('Kind.Check.result (let ((f5 (get self5 1))(f6 (get self5 2))) ($Kind.Check.result f5 ($List.concat f3 f6)))))))))))))))) ('Kind.Term.nat (let ((f1 (get self1 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.chr (let ((f1 (get self1 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.str (let ((f1 (get self1 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.cse (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))(f4 (get self1 4))(f5 (get self1 5))(f6 (get self1 6))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.ori (let ((f1 (get self1 1))(f2 (get self1 2))) ($Kind.Term.equal.extra_holes.filler a$0 f2))))))) ('Kind.Term.chr (let ((f0 (get self0 1))) (let ((self1 b$1)) (case (get self1 0) ('Kind.Term.var (let ((f1 (get self1 1))(f2 (get self1 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.ref (let ((f1 (get self1 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.typ (let () ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.all (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))(f4 (get self1 4))(f5 (get self1 5))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.lam (let ((f1 (get self1 1))(f2 (get self1 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.app (let ((f1 (get self1 1))(f2 (get self1 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.let (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.def (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.ann (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.gol (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.hol (let ((f1 (get self1 1))) (let ((self2 ($Kind.Term.equal.hole f1 a$0))) (case (get self2 0) ('Kind.Check.result (let ((f2 (get self2 1))(f3 (get self2 2))) (let ((self4 f2)) (case (get self4 0) ('Maybe.none (let () ($Kind.Check.result Maybe.none f3))) ('Maybe.some (let ((f4 (get self4 1))) (let ((self5 ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) (case (get self5 0) ('Kind.Check.result (let ((f5 (get self5 1))(f6 (get self5 2))) ($Kind.Check.result f5 ($List.concat f3 f6)))))))))))))))) ('Kind.Term.nat (let ((f1 (get self1 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.chr (let ((f1 (get self1 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.str (let ((f1 (get self1 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.cse (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))(f4 (get self1 4))(f5 (get self1 5))(f6 (get self1 6))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.ori (let ((f1 (get self1 1))(f2 (get self1 2))) ($Kind.Term.equal.extra_holes.filler a$0 f2))))))) ('Kind.Term.str (let ((f0 (get self0 1))) (let ((self1 b$1)) (case (get self1 0) ('Kind.Term.var (let ((f1 (get self1 1))(f2 (get self1 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.ref (let ((f1 (get self1 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.typ (let () ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.all (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))(f4 (get self1 4))(f5 (get self1 5))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.lam (let ((f1 (get self1 1))(f2 (get self1 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.app (let ((f1 (get self1 1))(f2 (get self1 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.let (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.def (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.ann (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.gol (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.hol (let ((f1 (get self1 1))) (let ((self2 ($Kind.Term.equal.hole f1 a$0))) (case (get self2 0) ('Kind.Check.result (let ((f2 (get self2 1))(f3 (get self2 2))) (let ((self4 f2)) (case (get self4 0) ('Maybe.none (let () ($Kind.Check.result Maybe.none f3))) ('Maybe.some (let ((f4 (get self4 1))) (let ((self5 ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) (case (get self5 0) ('Kind.Check.result (let ((f5 (get self5 1))(f6 (get self5 2))) ($Kind.Check.result f5 ($List.concat f3 f6)))))))))))))))) ('Kind.Term.nat (let ((f1 (get self1 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.chr (let ((f1 (get self1 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.str (let ((f1 (get self1 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.cse (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))(f4 (get self1 4))(f5 (get self1 5))(f6 (get self1 6))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.ori (let ((f1 (get self1 1))(f2 (get self1 2))) ($Kind.Term.equal.extra_holes.filler a$0 f2))))))) ('Kind.Term.cse (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))(f5 (get self0 6))) (let ((self6 b$1)) (case (get self6 0) ('Kind.Term.var (let ((f6 (get self6 1))(f7 (get self6 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.ref (let ((f6 (get self6 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.typ (let () ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.all (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))(f9 (get self6 4))(f10 (get self6 5))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.lam (let ((f6 (get self6 1))(f7 (get self6 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.app (let ((f6 (get self6 1))(f7 (get self6 2))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.let (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.def (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.ann (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.gol (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.hol (let ((f6 (get self6 1))) (let ((self7 ($Kind.Term.equal.hole f6 a$0))) (case (get self7 0) ('Kind.Check.result (let ((f7 (get self7 1))(f8 (get self7 2))) (let ((self9 f7)) (case (get self9 0) ('Maybe.none (let () ($Kind.Check.result Maybe.none f8))) ('Maybe.some (let ((f9 (get self9 1))) (let ((self10 ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) (case (get self10 0) ('Kind.Check.result (let ((f10 (get self10 1))(f11 (get self10 2))) ($Kind.Check.result f10 ($List.concat f8 f11)))))))))))))))) ('Kind.Term.nat (let ((f6 (get self6 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.chr (let ((f6 (get self6 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.str (let ((f6 (get self6 1))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.cse (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))(f9 (get self6 4))(f10 (get self6 5))(f11 (get self6 6))) ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Kind.Term.ori (let ((f6 (get self6 1))(f7 (get self6 2))) ($Kind.Term.equal.extra_holes.filler a$0 f7))))))) ('Kind.Term.ori (let ((f0 (get self0 1))(f1 (get self0 2))) ($Kind.Term.equal.extra_holes.filler f1 b$1))))))
(define Kind.Term.equal.extra_holes.filler (lambda (a$0) (lambda (b$1) ($Kind.Term.equal.extra_holes.filler a$0 b$1))))
(define ($Kind.Term.equal.extra_holes a$0 b$1) (let ((self0 ($Kind.Term.equal.extra_holes.funari a$0 0))) (case (get self0 0) ('Maybe.none (let () ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Maybe.some (let ((f0 (get self0 1))) (let ((self1 ($Kind.Term.equal.extra_holes.funari b$1 0))) (case (get self1 0) ('Maybe.none (let () ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) ('Maybe.some (let ((f1 (get self1 1))) (let ((self2 f0)) (case (get self2 0) ('Pair.new (let ((f2 (get self2 1))(f3 (get self2 2))) (let ((self4 f1)) (case (get self4 0) ('Pair.new (let ((f4 (get self4 1))(f5 (get self4 2))) (let ((same_fun$8 ($String.eql f2 f4))) (let ((same_ari$9 ($Nat.eql f3 f5))) (let ((self8 ($Bool.and same_fun$8 same_ari$9))) (case self8 (#t (let () ($Kind.Term.equal.extra_holes.filler a$0 b$1))) (#f (let () ($Kind.Check.result ($Maybe.some Unit.new) List.nil))))))))))))))))))))))))
(define Kind.Term.equal.extra_holes (lambda (a$0) (lambda (b$1) ($Kind.Term.equal.extra_holes a$0 b$1))))
(define ($BitsSet.set bits$0 set$1) ($BitsMap.set bits$0 Unit.new set$1))
(define BitsSet.set (lambda (bits$0) (lambda (set$1) ($BitsSet.set bits$0 set$1))))
(define ($BitsSet.mut.set bits$0 set$1) ($BitsSet.set bits$0 set$1))
(define BitsSet.mut.set (lambda (bits$0) (lambda (set$1) ($BitsSet.mut.set bits$0 set$1))))
(define ($Bool.eql a$0 b$1) (let ((self0 a$0)) (case self0 (#t (let () b$1)) (#f (let () ($Bool.not b$1))))))
(define Bool.eql (lambda (a$0) (lambda (b$1) ($Bool.eql a$0 b$1))))
(define ($Kind.Term.equal.go a$0 b$1 defs$2 lv$3 seen$4) (let ((ah$5 ($Kind.Term.serialize ($Kind.Term.reduce a$0 Kind.Map.new) lv$3 Bool.false))) (let ((bh$6 ($Kind.Term.serialize ($Kind.Term.reduce b$1 Kind.Map.new) lv$3 Bool.true))) (let ((self2 ($Bits.eql ah$5 bh$6))) (case self2 (#t (let () ($Kind.Check.result ($Maybe.some Bool.true) List.nil))) (#f (let () (let ((a1$7 ($Kind.Term.reduce a$0 defs$2))) (let ((b1$8 ($Kind.Term.reduce b$1 defs$2))) (let ((ah$9 ($Kind.Term.serialize a1$7 lv$3 Bool.false))) (let ((bh$10 ($Kind.Term.serialize b1$8 lv$3 Bool.true))) (let ((self6 ($Bits.eql ah$9 bh$10))) (case self6 (#t (let () ($Kind.Check.result ($Maybe.some Bool.true) List.nil))) (#f (let () (let ((id$11 ($Bits.concat ah$9 bh$10))) (let ((self7 ($BitsSet.mut.has id$11 seen$4))) (case self7 (#t (let () (let ((self7 ($Kind.Term.equal.extra_holes a$0 b$1))) (case (get self7 0) ('Kind.Check.result (let ((f7 (get self7 1))(f8 (get self7 2))) (let ((self9 f7)) (case (get self9 0) ('Maybe.none (let () ($Kind.Check.result Maybe.none f8))) ('Maybe.some (let ((f9 (get self9 1))) (let ((self10 ($Kind.Check.result ($Maybe.some Bool.true) List.nil))) (case (get self10 0) ('Kind.Check.result (let ((f10 (get self10 1))(f11 (get self10 2))) ($Kind.Check.result f10 ($List.concat f8 f11)))))))))))))))) (#f (let () (let ((self7 a1$7)) (case (get self7 0) ('Kind.Term.var (let ((f7 (get self7 1))(f8 (get self7 2))) (let ((self9 b1$8)) (case (get self9 0) ('Kind.Term.var (let ((f9 (get self9 1))(f10 (get self9 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.ref (let ((f9 (get self9 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.typ (let () ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.all (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))(f12 (get self9 4))(f13 (get self9 5))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.lam (let ((f9 (get self9 1))(f10 (get self9 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.app (let ((f9 (get self9 1))(f10 (get self9 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.let (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.def (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.ann (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.gol (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.hol (let ((f9 (get self9 1))) ($Kind.Term.equal.hole f9 a$0))) ('Kind.Term.nat (let ((f9 (get self9 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.chr (let ((f9 (get self9 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.str (let ((f9 (get self9 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.cse (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))(f12 (get self9 4))(f13 (get self9 5))(f14 (get self9 6))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.ori (let ((f9 (get self9 1))(f10 (get self9 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))))) ('Kind.Term.ref (let ((f7 (get self7 1))) (let ((self8 b1$8)) (case (get self8 0) ('Kind.Term.var (let ((f8 (get self8 1))(f9 (get self8 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.ref (let ((f8 (get self8 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.typ (let () ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.all (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))(f11 (get self8 4))(f12 (get self8 5))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.lam (let ((f8 (get self8 1))(f9 (get self8 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.app (let ((f8 (get self8 1))(f9 (get self8 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.let (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.def (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.ann (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.gol (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.hol (let ((f8 (get self8 1))) ($Kind.Term.equal.hole f8 a$0))) ('Kind.Term.nat (let ((f8 (get self8 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.chr (let ((f8 (get self8 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.str (let ((f8 (get self8 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.cse (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))(f11 (get self8 4))(f12 (get self8 5))(f13 (get self8 6))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.ori (let ((f8 (get self8 1))(f9 (get self8 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))))) ('Kind.Term.typ (let () (let ((self7 b1$8)) (case (get self7 0) ('Kind.Term.var (let ((f7 (get self7 1))(f8 (get self7 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.ref (let ((f7 (get self7 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.typ (let () ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.all (let ((f7 (get self7 1))(f8 (get self7 2))(f9 (get self7 3))(f10 (get self7 4))(f11 (get self7 5))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.lam (let ((f7 (get self7 1))(f8 (get self7 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.app (let ((f7 (get self7 1))(f8 (get self7 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.let (let ((f7 (get self7 1))(f8 (get self7 2))(f9 (get self7 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.def (let ((f7 (get self7 1))(f8 (get self7 2))(f9 (get self7 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.ann (let ((f7 (get self7 1))(f8 (get self7 2))(f9 (get self7 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.gol (let ((f7 (get self7 1))(f8 (get self7 2))(f9 (get self7 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.hol (let ((f7 (get self7 1))) ($Kind.Term.equal.hole f7 a$0))) ('Kind.Term.nat (let ((f7 (get self7 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.chr (let ((f7 (get self7 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.str (let ((f7 (get self7 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.cse (let ((f7 (get self7 1))(f8 (get self7 2))(f9 (get self7 3))(f10 (get self7 4))(f11 (get self7 5))(f12 (get self7 6))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.ori (let ((f7 (get self7 1))(f8 (get self7 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))))) ('Kind.Term.all (let ((f7 (get self7 1))(f8 (get self7 2))(f9 (get self7 3))(f10 (get self7 4))(f11 (get self7 5))) (let ((self12 b1$8)) (case (get self12 0) ('Kind.Term.var (let ((f12 (get self12 1))(f13 (get self12 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.ref (let ((f12 (get self12 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.typ (let () ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.all (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))(f15 (get self12 4))(f16 (get self12 5))) (let ((seen$22 ($BitsSet.mut.set id$11 seen$4))) (let ((a1_body$23 ((f11 ($Kind.Term.var f8 lv$3)) ($Kind.Term.var f9 ($Nat.succ lv$3))))) (let ((b1_body$24 ((f16 ($Kind.Term.var f13 lv$3)) ($Kind.Term.var f14 ($Nat.succ lv$3))))) (let ((eq_self$25 ($String.eql f8 f13))) (let ((eq_eras$26 ($Bool.eql f7 f12))) (let ((self22 ($Bool.and eq_self$25 eq_eras$26))) (case self22 (#t (let () (let ((self22 ($Kind.Term.equal.go f10 f15 defs$2 lv$3 seen$22))) (case (get self22 0) ('Kind.Check.result (let ((f22 (get self22 1))(f23 (get self22 2))) (let ((self24 f22)) (case (get self24 0) ('Maybe.none (let () ($Kind.Check.result Maybe.none f23))) ('Maybe.some (let ((f24 (get self24 1))) (let ((self25 (let ((self25 ($Kind.Term.equal.go a1_body$23 b1_body$24 defs$2 ($Nat.succ ($Nat.succ lv$3)) seen$22))) (case (get self25 0) ('Kind.Check.result (let ((f25 (get self25 1))(f26 (get self25 2))) (let ((self27 f25)) (case (get self27 0) ('Maybe.none (let () ($Kind.Check.result Maybe.none f26))) ('Maybe.some (let ((f27 (get self27 1))) (let ((self28 ($Kind.Check.result ($Maybe.some ($Bool.and f24 f27)) List.nil))) (case (get self28 0) ('Kind.Check.result (let ((f28 (get self28 1))(f29 (get self28 2))) ($Kind.Check.result f28 ($List.concat f26 f29)))))))))))))))) (case (get self25 0) ('Kind.Check.result (let ((f25 (get self25 1))(f26 (get self25 2))) ($Kind.Check.result f25 ($List.concat f23 f26)))))))))))))))) (#f (let () ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))))))))))) ('Kind.Term.lam (let ((f12 (get self12 1))(f13 (get self12 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.app (let ((f12 (get self12 1))(f13 (get self12 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.let (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.def (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.ann (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.gol (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.hol (let ((f12 (get self12 1))) ($Kind.Term.equal.hole f12 a$0))) ('Kind.Term.nat (let ((f12 (get self12 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.chr (let ((f12 (get self12 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.str (let ((f12 (get self12 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.cse (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))(f15 (get self12 4))(f16 (get self12 5))(f17 (get self12 6))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.ori (let ((f12 (get self12 1))(f13 (get self12 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))))) ('Kind.Term.lam (let ((f7 (get self7 1))(f8 (get self7 2))) (let ((self9 b1$8)) (case (get self9 0) ('Kind.Term.var (let ((f9 (get self9 1))(f10 (get self9 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.ref (let ((f9 (get self9 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.typ (let () ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.all (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))(f12 (get self9 4))(f13 (get self9 5))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.lam (let ((f9 (get self9 1))(f10 (get self9 2))) (let ((seen$16 ($BitsSet.mut.set id$11 seen$4))) (let ((a1_body$17 (f8 ($Kind.Term.var f7 lv$3)))) (let ((b1_body$18 (f10 ($Kind.Term.var f9 lv$3)))) (let ((self14 ($Kind.Term.equal.go a1_body$17 b1_body$18 defs$2 ($Nat.succ lv$3) seen$16))) (case (get self14 0) ('Kind.Check.result (let ((f14 (get self14 1))(f15 (get self14 2))) (let ((self16 f14)) (case (get self16 0) ('Maybe.none (let () ($Kind.Check.result Maybe.none f15))) ('Maybe.some (let ((f16 (get self16 1))) (let ((self17 ($Kind.Check.result ($Maybe.some f16) List.nil))) (case (get self17 0) ('Kind.Check.result (let ((f17 (get self17 1))(f18 (get self17 2))) ($Kind.Check.result f17 ($List.concat f15 f18))))))))))))))))))) ('Kind.Term.app (let ((f9 (get self9 1))(f10 (get self9 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.let (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.def (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.ann (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.gol (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.hol (let ((f9 (get self9 1))) ($Kind.Term.equal.hole f9 a$0))) ('Kind.Term.nat (let ((f9 (get self9 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.chr (let ((f9 (get self9 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.str (let ((f9 (get self9 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.cse (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))(f12 (get self9 4))(f13 (get self9 5))(f14 (get self9 6))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.ori (let ((f9 (get self9 1))(f10 (get self9 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))))) ('Kind.Term.app (let ((f7 (get self7 1))(f8 (get self7 2))) (let ((self9 b1$8)) (case (get self9 0) ('Kind.Term.var (let ((f9 (get self9 1))(f10 (get self9 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.ref (let ((f9 (get self9 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.typ (let () ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.all (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))(f12 (get self9 4))(f13 (get self9 5))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.lam (let ((f9 (get self9 1))(f10 (get self9 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.app (let ((f9 (get self9 1))(f10 (get self9 2))) (let ((seen$16 ($BitsSet.mut.set id$11 seen$4))) (let ((self12 ($Kind.Term.equal.go f7 f9 defs$2 lv$3 seen$16))) (case (get self12 0) ('Kind.Check.result (let ((f12 (get self12 1))(f13 (get self12 2))) (let ((self14 f12)) (case (get self14 0) ('Maybe.none (let () ($Kind.Check.result Maybe.none f13))) ('Maybe.some (let ((f14 (get self14 1))) (let ((self15 (let ((self15 ($Kind.Term.equal.go f8 f10 defs$2 lv$3 seen$16))) (case (get self15 0) ('Kind.Check.result (let ((f15 (get self15 1))(f16 (get self15 2))) (let ((self17 f15)) (case (get self17 0) ('Maybe.none (let () ($Kind.Check.result Maybe.none f16))) ('Maybe.some (let ((f17 (get self17 1))) (let ((self18 ($Kind.Check.result ($Maybe.some ($Bool.and f14 f17)) List.nil))) (case (get self18 0) ('Kind.Check.result (let ((f18 (get self18 1))(f19 (get self18 2))) ($Kind.Check.result f18 ($List.concat f16 f19)))))))))))))))) (case (get self15 0) ('Kind.Check.result (let ((f15 (get self15 1))(f16 (get self15 2))) ($Kind.Check.result f15 ($List.concat f13 f16))))))))))))))))) ('Kind.Term.let (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.def (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.ann (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.gol (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.hol (let ((f9 (get self9 1))) ($Kind.Term.equal.hole f9 a$0))) ('Kind.Term.nat (let ((f9 (get self9 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.chr (let ((f9 (get self9 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.str (let ((f9 (get self9 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.cse (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))(f12 (get self9 4))(f13 (get self9 5))(f14 (get self9 6))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.ori (let ((f9 (get self9 1))(f10 (get self9 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))))) ('Kind.Term.let (let ((f7 (get self7 1))(f8 (get self7 2))(f9 (get self7 3))) (let ((self10 b1$8)) (case (get self10 0) ('Kind.Term.var (let ((f10 (get self10 1))(f11 (get self10 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.ref (let ((f10 (get self10 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.typ (let () ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.all (let ((f10 (get self10 1))(f11 (get self10 2))(f12 (get self10 3))(f13 (get self10 4))(f14 (get self10 5))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.lam (let ((f10 (get self10 1))(f11 (get self10 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.app (let ((f10 (get self10 1))(f11 (get self10 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.let (let ((f10 (get self10 1))(f11 (get self10 2))(f12 (get self10 3))) (let ((seen$18 ($BitsSet.mut.set id$11 seen$4))) (let ((a1_body$19 (f9 ($Kind.Term.var f7 lv$3)))) (let ((b1_body$20 (f12 ($Kind.Term.var f10 lv$3)))) (let ((self16 ($Kind.Term.equal.go f8 f11 defs$2 lv$3 seen$18))) (case (get self16 0) ('Kind.Check.result (let ((f16 (get self16 1))(f17 (get self16 2))) (let ((self18 f16)) (case (get self18 0) ('Maybe.none (let () ($Kind.Check.result Maybe.none f17))) ('Maybe.some (let ((f18 (get self18 1))) (let ((self19 (let ((self19 ($Kind.Term.equal.go a1_body$19 b1_body$20 defs$2 ($Nat.succ lv$3) seen$18))) (case (get self19 0) ('Kind.Check.result (let ((f19 (get self19 1))(f20 (get self19 2))) (let ((self21 f19)) (case (get self21 0) ('Maybe.none (let () ($Kind.Check.result Maybe.none f20))) ('Maybe.some (let ((f21 (get self21 1))) (let ((self22 ($Kind.Check.result ($Maybe.some ($Bool.and f18 f21)) List.nil))) (case (get self22 0) ('Kind.Check.result (let ((f22 (get self22 1))(f23 (get self22 2))) ($Kind.Check.result f22 ($List.concat f20 f23)))))))))))))))) (case (get self19 0) ('Kind.Check.result (let ((f19 (get self19 1))(f20 (get self19 2))) ($Kind.Check.result f19 ($List.concat f17 f20))))))))))))))))))) ('Kind.Term.def (let ((f10 (get self10 1))(f11 (get self10 2))(f12 (get self10 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.ann (let ((f10 (get self10 1))(f11 (get self10 2))(f12 (get self10 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.gol (let ((f10 (get self10 1))(f11 (get self10 2))(f12 (get self10 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.hol (let ((f10 (get self10 1))) ($Kind.Term.equal.hole f10 a$0))) ('Kind.Term.nat (let ((f10 (get self10 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.chr (let ((f10 (get self10 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.str (let ((f10 (get self10 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.cse (let ((f10 (get self10 1))(f11 (get self10 2))(f12 (get self10 3))(f13 (get self10 4))(f14 (get self10 5))(f15 (get self10 6))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.ori (let ((f10 (get self10 1))(f11 (get self10 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))))) ('Kind.Term.def (let ((f7 (get self7 1))(f8 (get self7 2))(f9 (get self7 3))) (let ((self10 b1$8)) (case (get self10 0) ('Kind.Term.var (let ((f10 (get self10 1))(f11 (get self10 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.ref (let ((f10 (get self10 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.typ (let () ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.all (let ((f10 (get self10 1))(f11 (get self10 2))(f12 (get self10 3))(f13 (get self10 4))(f14 (get self10 5))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.lam (let ((f10 (get self10 1))(f11 (get self10 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.app (let ((f10 (get self10 1))(f11 (get self10 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.let (let ((f10 (get self10 1))(f11 (get self10 2))(f12 (get self10 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.def (let ((f10 (get self10 1))(f11 (get self10 2))(f12 (get self10 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.ann (let ((f10 (get self10 1))(f11 (get self10 2))(f12 (get self10 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.gol (let ((f10 (get self10 1))(f11 (get self10 2))(f12 (get self10 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.hol (let ((f10 (get self10 1))) ($Kind.Term.equal.hole f10 a$0))) ('Kind.Term.nat (let ((f10 (get self10 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.chr (let ((f10 (get self10 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.str (let ((f10 (get self10 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.cse (let ((f10 (get self10 1))(f11 (get self10 2))(f12 (get self10 3))(f13 (get self10 4))(f14 (get self10 5))(f15 (get self10 6))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.ori (let ((f10 (get self10 1))(f11 (get self10 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))))) ('Kind.Term.ann (let ((f7 (get self7 1))(f8 (get self7 2))(f9 (get self7 3))) (let ((self10 b1$8)) (case (get self10 0) ('Kind.Term.var (let ((f10 (get self10 1))(f11 (get self10 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.ref (let ((f10 (get self10 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.typ (let () ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.all (let ((f10 (get self10 1))(f11 (get self10 2))(f12 (get self10 3))(f13 (get self10 4))(f14 (get self10 5))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.lam (let ((f10 (get self10 1))(f11 (get self10 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.app (let ((f10 (get self10 1))(f11 (get self10 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.let (let ((f10 (get self10 1))(f11 (get self10 2))(f12 (get self10 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.def (let ((f10 (get self10 1))(f11 (get self10 2))(f12 (get self10 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.ann (let ((f10 (get self10 1))(f11 (get self10 2))(f12 (get self10 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.gol (let ((f10 (get self10 1))(f11 (get self10 2))(f12 (get self10 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.hol (let ((f10 (get self10 1))) ($Kind.Term.equal.hole f10 a$0))) ('Kind.Term.nat (let ((f10 (get self10 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.chr (let ((f10 (get self10 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.str (let ((f10 (get self10 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.cse (let ((f10 (get self10 1))(f11 (get self10 2))(f12 (get self10 3))(f13 (get self10 4))(f14 (get self10 5))(f15 (get self10 6))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.ori (let ((f10 (get self10 1))(f11 (get self10 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))))) ('Kind.Term.gol (let ((f7 (get self7 1))(f8 (get self7 2))(f9 (get self7 3))) (let ((self10 b1$8)) (case (get self10 0) ('Kind.Term.var (let ((f10 (get self10 1))(f11 (get self10 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.ref (let ((f10 (get self10 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.typ (let () ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.all (let ((f10 (get self10 1))(f11 (get self10 2))(f12 (get self10 3))(f13 (get self10 4))(f14 (get self10 5))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.lam (let ((f10 (get self10 1))(f11 (get self10 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.app (let ((f10 (get self10 1))(f11 (get self10 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.let (let ((f10 (get self10 1))(f11 (get self10 2))(f12 (get self10 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.def (let ((f10 (get self10 1))(f11 (get self10 2))(f12 (get self10 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.ann (let ((f10 (get self10 1))(f11 (get self10 2))(f12 (get self10 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.gol (let ((f10 (get self10 1))(f11 (get self10 2))(f12 (get self10 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.hol (let ((f10 (get self10 1))) ($Kind.Term.equal.hole f10 a$0))) ('Kind.Term.nat (let ((f10 (get self10 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.chr (let ((f10 (get self10 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.str (let ((f10 (get self10 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.cse (let ((f10 (get self10 1))(f11 (get self10 2))(f12 (get self10 3))(f13 (get self10 4))(f14 (get self10 5))(f15 (get self10 6))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.ori (let ((f10 (get self10 1))(f11 (get self10 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))))) ('Kind.Term.hol (let ((f7 (get self7 1))) ($Kind.Term.equal.hole f7 b$1))) ('Kind.Term.nat (let ((f7 (get self7 1))) (let ((self8 b1$8)) (case (get self8 0) ('Kind.Term.var (let ((f8 (get self8 1))(f9 (get self8 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.ref (let ((f8 (get self8 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.typ (let () ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.all (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))(f11 (get self8 4))(f12 (get self8 5))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.lam (let ((f8 (get self8 1))(f9 (get self8 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.app (let ((f8 (get self8 1))(f9 (get self8 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.let (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.def (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.ann (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.gol (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.hol (let ((f8 (get self8 1))) ($Kind.Term.equal.hole f8 a$0))) ('Kind.Term.nat (let ((f8 (get self8 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.chr (let ((f8 (get self8 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.str (let ((f8 (get self8 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.cse (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))(f11 (get self8 4))(f12 (get self8 5))(f13 (get self8 6))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.ori (let ((f8 (get self8 1))(f9 (get self8 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))))) ('Kind.Term.chr (let ((f7 (get self7 1))) (let ((self8 b1$8)) (case (get self8 0) ('Kind.Term.var (let ((f8 (get self8 1))(f9 (get self8 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.ref (let ((f8 (get self8 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.typ (let () ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.all (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))(f11 (get self8 4))(f12 (get self8 5))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.lam (let ((f8 (get self8 1))(f9 (get self8 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.app (let ((f8 (get self8 1))(f9 (get self8 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.let (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.def (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.ann (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.gol (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.hol (let ((f8 (get self8 1))) ($Kind.Term.equal.hole f8 a$0))) ('Kind.Term.nat (let ((f8 (get self8 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.chr (let ((f8 (get self8 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.str (let ((f8 (get self8 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.cse (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))(f11 (get self8 4))(f12 (get self8 5))(f13 (get self8 6))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.ori (let ((f8 (get self8 1))(f9 (get self8 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))))) ('Kind.Term.str (let ((f7 (get self7 1))) (let ((self8 b1$8)) (case (get self8 0) ('Kind.Term.var (let ((f8 (get self8 1))(f9 (get self8 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.ref (let ((f8 (get self8 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.typ (let () ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.all (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))(f11 (get self8 4))(f12 (get self8 5))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.lam (let ((f8 (get self8 1))(f9 (get self8 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.app (let ((f8 (get self8 1))(f9 (get self8 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.let (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.def (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.ann (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.gol (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.hol (let ((f8 (get self8 1))) ($Kind.Term.equal.hole f8 a$0))) ('Kind.Term.nat (let ((f8 (get self8 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.chr (let ((f8 (get self8 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.str (let ((f8 (get self8 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.cse (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))(f11 (get self8 4))(f12 (get self8 5))(f13 (get self8 6))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.ori (let ((f8 (get self8 1))(f9 (get self8 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))))) ('Kind.Term.cse (let ((f7 (get self7 1))(f8 (get self7 2))(f9 (get self7 3))(f10 (get self7 4))(f11 (get self7 5))(f12 (get self7 6))) (let ((self13 b1$8)) (case (get self13 0) ('Kind.Term.var (let ((f13 (get self13 1))(f14 (get self13 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.ref (let ((f13 (get self13 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.typ (let () ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.all (let ((f13 (get self13 1))(f14 (get self13 2))(f15 (get self13 3))(f16 (get self13 4))(f17 (get self13 5))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.lam (let ((f13 (get self13 1))(f14 (get self13 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.app (let ((f13 (get self13 1))(f14 (get self13 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.let (let ((f13 (get self13 1))(f14 (get self13 2))(f15 (get self13 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.def (let ((f13 (get self13 1))(f14 (get self13 2))(f15 (get self13 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.ann (let ((f13 (get self13 1))(f14 (get self13 2))(f15 (get self13 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.gol (let ((f13 (get self13 1))(f14 (get self13 2))(f15 (get self13 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.hol (let ((f13 (get self13 1))) ($Kind.Term.equal.hole f13 a$0))) ('Kind.Term.nat (let ((f13 (get self13 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.chr (let ((f13 (get self13 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.str (let ((f13 (get self13 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.cse (let ((f13 (get self13 1))(f14 (get self13 2))(f15 (get self13 3))(f16 (get self13 4))(f17 (get self13 5))(f18 (get self13 6))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.ori (let ((f13 (get self13 1))(f14 (get self13 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))))))) ('Kind.Term.ori (let ((f7 (get self7 1))(f8 (get self7 2))) (let ((self9 b1$8)) (case (get self9 0) ('Kind.Term.var (let ((f9 (get self9 1))(f10 (get self9 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.ref (let ((f9 (get self9 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.typ (let () ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.all (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))(f12 (get self9 4))(f13 (get self9 5))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.lam (let ((f9 (get self9 1))(f10 (get self9 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.app (let ((f9 (get self9 1))(f10 (get self9 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.let (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.def (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.ann (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.gol (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.hol (let ((f9 (get self9 1))) ($Kind.Term.equal.hole f9 a$0))) ('Kind.Term.nat (let ((f9 (get self9 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.chr (let ((f9 (get self9 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.str (let ((f9 (get self9 1))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.cse (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))(f12 (get self9 4))(f13 (get self9 5))(f14 (get self9 6))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil))) ('Kind.Term.ori (let ((f9 (get self9 1))(f10 (get self9 2))) ($Kind.Check.result ($Maybe.some Bool.false) List.nil)))))))))))))))))))))))))))))
(define Kind.Term.equal.go (lambda (a$0) (lambda (b$1) (lambda (defs$2) (lambda (lv$3) (lambda (seen$4) ($Kind.Term.equal.go a$0 b$1 defs$2 lv$3 seen$4)))))))
(define ($BitsSet.new) BitsMap.new)
(define BitsSet.new ($BitsSet.new))
(define ($BitsSet.mut.new a$0) BitsSet.new)
(define BitsSet.mut.new (lambda (a$0) ($BitsSet.mut.new a$0)))
(define ($Kind.Term.check term$0 type$1 defs$2 ctx$3 path$4 orig$5) (let ((self0 (let ((self0 term$0)) (case (get self0 0) ('Kind.Term.var (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 ($List.at_last f1 ctx$3))) (case (get self2 0) ('Maybe.none (let () ($Kind.Check.result type$1 ($List.cons ($Kind.Error.undefined_reference orig$5 f0) List.nil)))) ('Maybe.some (let ((f2 (get self2 1))) ($Kind.Check.result ($Maybe.some (let ((self3 f2)) (case (get self3 0) ('Pair.new (let ((f3 (get self3 1))(f4 (get self3 2))) f4))))) List.nil))))))) ('Kind.Term.ref (let ((f0 (get self0 1))) (let ((self1 ($Kind.Map.get f0 defs$2))) (case (get self1 0) ('Maybe.none (let () ($Kind.Check.result type$1 ($List.cons ($Kind.Error.undefined_reference orig$5 f0) List.nil)))) ('Maybe.some (let ((f1 (get self1 1))) (let ((self2 f1)) (case (get self2 0) ('Kind.Def.new (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))(f5 (get self2 4))(f6 (get self2 5))(f7 (get self2 6))(f8 (get self2 7))(f9 (get self2 8))(f10 (get self2 9))) (let ((ref_name$17 f5)) (let ((ref_type$18 f7)) (let ((ref_term$19 f6)) (let ((ref_stat$20 f10)) (let ((self15 ref_stat$20)) (case (get self15 0) ('Kind.Status.init (let () ($Kind.Check.result ($Maybe.some ref_type$18) ($List.cons ($Kind.Error.waiting ref_name$17) List.nil)))) ('Kind.Status.wait (let () ($Kind.Check.result ($Maybe.some ref_type$18) List.nil))) ('Kind.Status.done (let ((f15 (get self15 1))) ($Kind.Check.result ($Maybe.some ref_type$18) List.nil))) ('Kind.Status.fail (let ((f15 (get self15 1))) ($Kind.Check.result ($Maybe.some ref_type$18) ($List.cons ($Kind.Error.indirect ref_name$17) List.nil)))))))))))))))))))) ('Kind.Term.typ (let () ($Kind.Check.result ($Maybe.some Kind.Term.typ) List.nil))) ('Kind.Term.all (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))) (let ((ctx_size$11 ($List.length ctx$3))) (let ((self_var$12 ($Kind.Term.var f1 ctx_size$11))) (let ((body_var$13 ($Kind.Term.var f2 ($Nat.succ ctx_size$11)))) (let ((body_ctx$14 ($List.cons ($Pair.new f2 f3) ($List.cons ($Pair.new f1 term$0) ctx$3)))) (let ((self9 ($Kind.Term.check f3 ($Maybe.some Kind.Term.typ) defs$2 ctx$3 ($Kind.MPath.o path$4) orig$5))) (case (get self9 0) ('Kind.Check.result (let ((f9 (get self9 1))(f10 (get self9 2))) (let ((self11 f9)) (case (get self11 0) ('Maybe.none (let () ($Kind.Check.result Maybe.none f10))) ('Maybe.some (let ((f11 (get self11 1))) (let ((self12 (let ((self12 ($Kind.Term.check ((f4 self_var$12) body_var$13) ($Maybe.some Kind.Term.typ) defs$2 body_ctx$14 ($Kind.MPath.i path$4) orig$5))) (case (get self12 0) ('Kind.Check.result (let ((f12 (get self12 1))(f13 (get self12 2))) (let ((self14 f12)) (case (get self14 0) ('Maybe.none (let () ($Kind.Check.result Maybe.none f13))) ('Maybe.some (let ((f14 (get self14 1))) (let ((self15 ($Kind.Check.result ($Maybe.some Kind.Term.typ) List.nil))) (case (get self15 0) ('Kind.Check.result (let ((f15 (get self15 1))(f16 (get self15 2))) ($Kind.Check.result f15 ($List.concat f13 f16)))))))))))))))) (case (get self12 0) ('Kind.Check.result (let ((f12 (get self12 1))(f13 (get self12 2))) ($Kind.Check.result f12 ($List.concat f10 f13)))))))))))))))))))) ('Kind.Term.lam (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 type$1)) (case (get self2 0) ('Maybe.none (let () (let ((lam_type$8 ($Kind.Term.hol Bits.e))) (let ((lam_term$9 ($Kind.Term.ann Bool.false term$0 lam_type$8))) ($Kind.Check.result type$1 ($List.cons ($Kind.Error.patch ($Kind.MPath.to_bits path$4) lam_term$9) List.nil)))))) ('Maybe.some (let ((f2 (get self2 1))) (let ((typv$9 ($Kind.Term.reduce f2 defs$2))) (let ((self4 typv$9)) (case (get self4 0) ('Kind.Term.var (let ((f4 (get self4 1))(f5 (get self4 2))) (let ((expected$12 ($Either.left "function"))) (let ((detected$13 ($Either.right f2))) ($Kind.Check.result type$1 ($List.cons ($Kind.Error.type_mismatch orig$5 expected$12 detected$13 ctx$3) List.nil)))))) ('Kind.Term.ref (let ((f4 (get self4 1))) (let ((expected$11 ($Either.left "function"))) (let ((detected$12 ($Either.right f2))) ($Kind.Check.result type$1 ($List.cons ($Kind.Error.type_mismatch orig$5 expected$11 detected$12 ctx$3) List.nil)))))) ('Kind.Term.typ (let () (let ((expected$10 ($Either.left "function"))) (let ((detected$11 ($Either.right f2))) ($Kind.Check.result type$1 ($List.cons ($Kind.Error.type_mismatch orig$5 expected$10 detected$11 ctx$3) List.nil)))))) ('Kind.Term.all (let ((f4 (get self4 1))(f5 (get self4 2))(f6 (get self4 3))(f7 (get self4 4))(f8 (get self4 5))) (let ((ctx_size$15 ($List.length ctx$3))) (let ((self_var$16 term$0)) (let ((body_var$17 ($Kind.Term.var f0 ctx_size$15))) (let ((body_typ$18 ((f8 self_var$16) body_var$17))) (let ((body_ctx$19 ($List.cons ($Pair.new f0 f7) ctx$3))) (let ((self14 ($Kind.Term.check (f1 body_var$17) ($Maybe.some body_typ$18) defs$2 body_ctx$19 ($Kind.MPath.o path$4) orig$5))) (case (get self14 0) ('Kind.Check.result (let ((f14 (get self14 1))(f15 (get self14 2))) (let ((self16 f14)) (case (get self16 0) ('Maybe.none (let () ($Kind.Check.result Maybe.none f15))) ('Maybe.some (let ((f16 (get self16 1))) (let ((self17 ($Kind.Check.result ($Maybe.some f2) List.nil))) (case (get self17 0) ('Kind.Check.result (let ((f17 (get self17 1))(f18 (get self17 2))) ($Kind.Check.result f17 ($List.concat f15 f18))))))))))))))))))))) ('Kind.Term.lam (let ((f4 (get self4 1))(f5 (get self4 2))) (let ((expected$12 ($Either.left "function"))) (let ((detected$13 ($Either.right f2))) ($Kind.Check.result type$1 ($List.cons ($Kind.Error.type_mismatch orig$5 expected$12 detected$13 ctx$3) List.nil)))))) ('Kind.Term.app (let ((f4 (get self4 1))(f5 (get self4 2))) (let ((expected$12 ($Either.left "function"))) (let ((detected$13 ($Either.right f2))) ($Kind.Check.result type$1 ($List.cons ($Kind.Error.type_mismatch orig$5 expected$12 detected$13 ctx$3) List.nil)))))) ('Kind.Term.let (let ((f4 (get self4 1))(f5 (get self4 2))(f6 (get self4 3))) (let ((expected$13 ($Either.left "function"))) (let ((detected$14 ($Either.right f2))) ($Kind.Check.result type$1 ($List.cons ($Kind.Error.type_mismatch orig$5 expected$13 detected$14 ctx$3) List.nil)))))) ('Kind.Term.def (let ((f4 (get self4 1))(f5 (get self4 2))(f6 (get self4 3))) (let ((expected$13 ($Either.left "function"))) (let ((detected$14 ($Either.right f2))) ($Kind.Check.result type$1 ($List.cons ($Kind.Error.type_mismatch orig$5 expected$13 detected$14 ctx$3) List.nil)))))) ('Kind.Term.ann (let ((f4 (get self4 1))(f5 (get self4 2))(f6 (get self4 3))) (let ((expected$13 ($Either.left "function"))) (let ((detected$14 ($Either.right f2))) ($Kind.Check.result type$1 ($List.cons ($Kind.Error.type_mismatch orig$5 expected$13 detected$14 ctx$3) List.nil)))))) ('Kind.Term.gol (let ((f4 (get self4 1))(f5 (get self4 2))(f6 (get self4 3))) (let ((expected$13 ($Either.left "function"))) (let ((detected$14 ($Either.right f2))) ($Kind.Check.result type$1 ($List.cons ($Kind.Error.type_mismatch orig$5 expected$13 detected$14 ctx$3) List.nil)))))) ('Kind.Term.hol (let ((f4 (get self4 1))) (let ((expected$11 ($Either.left "function"))) (let ((detected$12 ($Either.right f2))) ($Kind.Check.result type$1 ($List.cons ($Kind.Error.type_mismatch orig$5 expected$11 detected$12 ctx$3) List.nil)))))) ('Kind.Term.nat (let ((f4 (get self4 1))) (let ((expected$11 ($Either.left "function"))) (let ((detected$12 ($Either.right f2))) ($Kind.Check.result type$1 ($List.cons ($Kind.Error.type_mismatch orig$5 expected$11 detected$12 ctx$3) List.nil)))))) ('Kind.Term.chr (let ((f4 (get self4 1))) (let ((expected$11 ($Either.left "function"))) (let ((detected$12 ($Either.right f2))) ($Kind.Check.result type$1 ($List.cons ($Kind.Error.type_mismatch orig$5 expected$11 detected$12 ctx$3) List.nil)))))) ('Kind.Term.str (let ((f4 (get self4 1))) (let ((expected$11 ($Either.left "function"))) (let ((detected$12 ($Either.right f2))) ($Kind.Check.result type$1 ($List.cons ($Kind.Error.type_mismatch orig$5 expected$11 detected$12 ctx$3) List.nil)))))) ('Kind.Term.cse (let ((f4 (get self4 1))(f5 (get self4 2))(f6 (get self4 3))(f7 (get self4 4))(f8 (get self4 5))(f9 (get self4 6))) (let ((expected$16 ($Either.left "function"))) (let ((detected$17 ($Either.right f2))) ($Kind.Check.result type$1 ($List.cons ($Kind.Error.type_mismatch orig$5 expected$16 detected$17 ctx$3) List.nil)))))) ('Kind.Term.ori (let ((f4 (get self4 1))(f5 (get self4 2))) (let ((expected$12 ($Either.left "function"))) (let ((detected$13 ($Either.right f2))) ($Kind.Check.result type$1 ($List.cons ($Kind.Error.type_mismatch orig$5 expected$12 detected$13 ctx$3) List.nil))))))))))))))) ('Kind.Term.app (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 ($Kind.Term.check f0 Maybe.none defs$2 ctx$3 ($Kind.MPath.o path$4) orig$5))) (case (get self2 0) ('Kind.Check.result (let ((f2 (get self2 1))(f3 (get self2 2))) (let ((self4 f2)) (case (get self4 0) ('Maybe.none (let () ($Kind.Check.result Maybe.none f3))) ('Maybe.some (let ((f4 (get self4 1))) (let ((func_typ$11 ($Kind.Term.reduce f4 defs$2))) (let ((self6 (let ((self6 func_typ$11)) (case (get self6 0) ('Kind.Term.var (let ((f6 (get self6 1))(f7 (get self6 2))) (let ((expected$14 ($Either.left "function"))) (let ((detected$15 ($Either.right func_typ$11))) (let ((orig$16 (let ((self10 f0)) (case (get self10 0) ('Kind.Term.var (let ((f10 (get self10 1))(f11 (get self10 2))) orig$5)) ('Kind.Term.ref (let ((f10 (get self10 1))) orig$5)) ('Kind.Term.typ (let () orig$5)) ('Kind.Term.all (let ((f10 (get self10 1))(f11 (get self10 2))(f12 (get self10 3))(f13 (get self10 4))(f14 (get self10 5))) orig$5)) ('Kind.Term.lam (let ((f10 (get self10 1))(f11 (get self10 2))) orig$5)) ('Kind.Term.app (let ((f10 (get self10 1))(f11 (get self10 2))) orig$5)) ('Kind.Term.let (let ((f10 (get self10 1))(f11 (get self10 2))(f12 (get self10 3))) orig$5)) ('Kind.Term.def (let ((f10 (get self10 1))(f11 (get self10 2))(f12 (get self10 3))) orig$5)) ('Kind.Term.ann (let ((f10 (get self10 1))(f11 (get self10 2))(f12 (get self10 3))) orig$5)) ('Kind.Term.gol (let ((f10 (get self10 1))(f11 (get self10 2))(f12 (get self10 3))) orig$5)) ('Kind.Term.hol (let ((f10 (get self10 1))) orig$5)) ('Kind.Term.nat (let ((f10 (get self10 1))) orig$5)) ('Kind.Term.chr (let ((f10 (get self10 1))) orig$5)) ('Kind.Term.str (let ((f10 (get self10 1))) orig$5)) ('Kind.Term.cse (let ((f10 (get self10 1))(f11 (get self10 2))(f12 (get self10 3))(f13 (get self10 4))(f14 (get self10 5))(f15 (get self10 6))) orig$5)) ('Kind.Term.ori (let ((f10 (get self10 1))(f11 (get self10 2))) ($Maybe.some f10))))))) ($Kind.Check.result type$1 ($List.cons ($Kind.Error.type_mismatch orig$16 expected$14 detected$15 ctx$3) List.nil))))))) ('Kind.Term.ref (let ((f6 (get self6 1))) (let ((expected$13 ($Either.left "function"))) (let ((detected$14 ($Either.right func_typ$11))) (let ((orig$15 (let ((self9 f0)) (case (get self9 0) ('Kind.Term.var (let ((f9 (get self9 1))(f10 (get self9 2))) orig$5)) ('Kind.Term.ref (let ((f9 (get self9 1))) orig$5)) ('Kind.Term.typ (let () orig$5)) ('Kind.Term.all (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))(f12 (get self9 4))(f13 (get self9 5))) orig$5)) ('Kind.Term.lam (let ((f9 (get self9 1))(f10 (get self9 2))) orig$5)) ('Kind.Term.app (let ((f9 (get self9 1))(f10 (get self9 2))) orig$5)) ('Kind.Term.let (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) orig$5)) ('Kind.Term.def (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) orig$5)) ('Kind.Term.ann (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) orig$5)) ('Kind.Term.gol (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) orig$5)) ('Kind.Term.hol (let ((f9 (get self9 1))) orig$5)) ('Kind.Term.nat (let ((f9 (get self9 1))) orig$5)) ('Kind.Term.chr (let ((f9 (get self9 1))) orig$5)) ('Kind.Term.str (let ((f9 (get self9 1))) orig$5)) ('Kind.Term.cse (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))(f12 (get self9 4))(f13 (get self9 5))(f14 (get self9 6))) orig$5)) ('Kind.Term.ori (let ((f9 (get self9 1))(f10 (get self9 2))) ($Maybe.some f9))))))) ($Kind.Check.result type$1 ($List.cons ($Kind.Error.type_mismatch orig$15 expected$13 detected$14 ctx$3) List.nil))))))) ('Kind.Term.typ (let () (let ((expected$12 ($Either.left "function"))) (let ((detected$13 ($Either.right func_typ$11))) (let ((orig$14 (let ((self8 f0)) (case (get self8 0) ('Kind.Term.var (let ((f8 (get self8 1))(f9 (get self8 2))) orig$5)) ('Kind.Term.ref (let ((f8 (get self8 1))) orig$5)) ('Kind.Term.typ (let () orig$5)) ('Kind.Term.all (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))(f11 (get self8 4))(f12 (get self8 5))) orig$5)) ('Kind.Term.lam (let ((f8 (get self8 1))(f9 (get self8 2))) orig$5)) ('Kind.Term.app (let ((f8 (get self8 1))(f9 (get self8 2))) orig$5)) ('Kind.Term.let (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))) orig$5)) ('Kind.Term.def (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))) orig$5)) ('Kind.Term.ann (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))) orig$5)) ('Kind.Term.gol (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))) orig$5)) ('Kind.Term.hol (let ((f8 (get self8 1))) orig$5)) ('Kind.Term.nat (let ((f8 (get self8 1))) orig$5)) ('Kind.Term.chr (let ((f8 (get self8 1))) orig$5)) ('Kind.Term.str (let ((f8 (get self8 1))) orig$5)) ('Kind.Term.cse (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))(f11 (get self8 4))(f12 (get self8 5))(f13 (get self8 6))) orig$5)) ('Kind.Term.ori (let ((f8 (get self8 1))(f9 (get self8 2))) ($Maybe.some f8))))))) ($Kind.Check.result type$1 ($List.cons ($Kind.Error.type_mismatch orig$14 expected$12 detected$13 ctx$3) List.nil))))))) ('Kind.Term.all (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))(f9 (get self6 4))(f10 (get self6 5))) (let ((self11 ($Kind.Term.check f1 ($Maybe.some f9) defs$2 ctx$3 ($Kind.MPath.i path$4) orig$5))) (case (get self11 0) ('Kind.Check.result (let ((f11 (get self11 1))(f12 (get self11 2))) (let ((self13 f11)) (case (get self13 0) ('Maybe.none (let () ($Kind.Check.result Maybe.none f12))) ('Maybe.some (let ((f13 (get self13 1))) (let ((self14 ($Kind.Check.result ($Maybe.some ((f10 f0) f1)) List.nil))) (case (get self14 0) ('Kind.Check.result (let ((f14 (get self14 1))(f15 (get self14 2))) ($Kind.Check.result f14 ($List.concat f12 f15)))))))))))))))) ('Kind.Term.lam (let ((f6 (get self6 1))(f7 (get self6 2))) (let ((expected$14 ($Either.left "function"))) (let ((detected$15 ($Either.right func_typ$11))) (let ((orig$16 (let ((self10 f0)) (case (get self10 0) ('Kind.Term.var (let ((f10 (get self10 1))(f11 (get self10 2))) orig$5)) ('Kind.Term.ref (let ((f10 (get self10 1))) orig$5)) ('Kind.Term.typ (let () orig$5)) ('Kind.Term.all (let ((f10 (get self10 1))(f11 (get self10 2))(f12 (get self10 3))(f13 (get self10 4))(f14 (get self10 5))) orig$5)) ('Kind.Term.lam (let ((f10 (get self10 1))(f11 (get self10 2))) orig$5)) ('Kind.Term.app (let ((f10 (get self10 1))(f11 (get self10 2))) orig$5)) ('Kind.Term.let (let ((f10 (get self10 1))(f11 (get self10 2))(f12 (get self10 3))) orig$5)) ('Kind.Term.def (let ((f10 (get self10 1))(f11 (get self10 2))(f12 (get self10 3))) orig$5)) ('Kind.Term.ann (let ((f10 (get self10 1))(f11 (get self10 2))(f12 (get self10 3))) orig$5)) ('Kind.Term.gol (let ((f10 (get self10 1))(f11 (get self10 2))(f12 (get self10 3))) orig$5)) ('Kind.Term.hol (let ((f10 (get self10 1))) orig$5)) ('Kind.Term.nat (let ((f10 (get self10 1))) orig$5)) ('Kind.Term.chr (let ((f10 (get self10 1))) orig$5)) ('Kind.Term.str (let ((f10 (get self10 1))) orig$5)) ('Kind.Term.cse (let ((f10 (get self10 1))(f11 (get self10 2))(f12 (get self10 3))(f13 (get self10 4))(f14 (get self10 5))(f15 (get self10 6))) orig$5)) ('Kind.Term.ori (let ((f10 (get self10 1))(f11 (get self10 2))) ($Maybe.some f10))))))) ($Kind.Check.result type$1 ($List.cons ($Kind.Error.type_mismatch orig$16 expected$14 detected$15 ctx$3) List.nil))))))) ('Kind.Term.app (let ((f6 (get self6 1))(f7 (get self6 2))) (let ((expected$14 ($Either.left "function"))) (let ((detected$15 ($Either.right func_typ$11))) (let ((orig$16 (let ((self10 f0)) (case (get self10 0) ('Kind.Term.var (let ((f10 (get self10 1))(f11 (get self10 2))) orig$5)) ('Kind.Term.ref (let ((f10 (get self10 1))) orig$5)) ('Kind.Term.typ (let () orig$5)) ('Kind.Term.all (let ((f10 (get self10 1))(f11 (get self10 2))(f12 (get self10 3))(f13 (get self10 4))(f14 (get self10 5))) orig$5)) ('Kind.Term.lam (let ((f10 (get self10 1))(f11 (get self10 2))) orig$5)) ('Kind.Term.app (let ((f10 (get self10 1))(f11 (get self10 2))) orig$5)) ('Kind.Term.let (let ((f10 (get self10 1))(f11 (get self10 2))(f12 (get self10 3))) orig$5)) ('Kind.Term.def (let ((f10 (get self10 1))(f11 (get self10 2))(f12 (get self10 3))) orig$5)) ('Kind.Term.ann (let ((f10 (get self10 1))(f11 (get self10 2))(f12 (get self10 3))) orig$5)) ('Kind.Term.gol (let ((f10 (get self10 1))(f11 (get self10 2))(f12 (get self10 3))) orig$5)) ('Kind.Term.hol (let ((f10 (get self10 1))) orig$5)) ('Kind.Term.nat (let ((f10 (get self10 1))) orig$5)) ('Kind.Term.chr (let ((f10 (get self10 1))) orig$5)) ('Kind.Term.str (let ((f10 (get self10 1))) orig$5)) ('Kind.Term.cse (let ((f10 (get self10 1))(f11 (get self10 2))(f12 (get self10 3))(f13 (get self10 4))(f14 (get self10 5))(f15 (get self10 6))) orig$5)) ('Kind.Term.ori (let ((f10 (get self10 1))(f11 (get self10 2))) ($Maybe.some f10))))))) ($Kind.Check.result type$1 ($List.cons ($Kind.Error.type_mismatch orig$16 expected$14 detected$15 ctx$3) List.nil))))))) ('Kind.Term.let (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) (let ((expected$15 ($Either.left "function"))) (let ((detected$16 ($Either.right func_typ$11))) (let ((orig$17 (let ((self11 f0)) (case (get self11 0) ('Kind.Term.var (let ((f11 (get self11 1))(f12 (get self11 2))) orig$5)) ('Kind.Term.ref (let ((f11 (get self11 1))) orig$5)) ('Kind.Term.typ (let () orig$5)) ('Kind.Term.all (let ((f11 (get self11 1))(f12 (get self11 2))(f13 (get self11 3))(f14 (get self11 4))(f15 (get self11 5))) orig$5)) ('Kind.Term.lam (let ((f11 (get self11 1))(f12 (get self11 2))) orig$5)) ('Kind.Term.app (let ((f11 (get self11 1))(f12 (get self11 2))) orig$5)) ('Kind.Term.let (let ((f11 (get self11 1))(f12 (get self11 2))(f13 (get self11 3))) orig$5)) ('Kind.Term.def (let ((f11 (get self11 1))(f12 (get self11 2))(f13 (get self11 3))) orig$5)) ('Kind.Term.ann (let ((f11 (get self11 1))(f12 (get self11 2))(f13 (get self11 3))) orig$5)) ('Kind.Term.gol (let ((f11 (get self11 1))(f12 (get self11 2))(f13 (get self11 3))) orig$5)) ('Kind.Term.hol (let ((f11 (get self11 1))) orig$5)) ('Kind.Term.nat (let ((f11 (get self11 1))) orig$5)) ('Kind.Term.chr (let ((f11 (get self11 1))) orig$5)) ('Kind.Term.str (let ((f11 (get self11 1))) orig$5)) ('Kind.Term.cse (let ((f11 (get self11 1))(f12 (get self11 2))(f13 (get self11 3))(f14 (get self11 4))(f15 (get self11 5))(f16 (get self11 6))) orig$5)) ('Kind.Term.ori (let ((f11 (get self11 1))(f12 (get self11 2))) ($Maybe.some f11))))))) ($Kind.Check.result type$1 ($List.cons ($Kind.Error.type_mismatch orig$17 expected$15 detected$16 ctx$3) List.nil))))))) ('Kind.Term.def (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) (let ((expected$15 ($Either.left "function"))) (let ((detected$16 ($Either.right func_typ$11))) (let ((orig$17 (let ((self11 f0)) (case (get self11 0) ('Kind.Term.var (let ((f11 (get self11 1))(f12 (get self11 2))) orig$5)) ('Kind.Term.ref (let ((f11 (get self11 1))) orig$5)) ('Kind.Term.typ (let () orig$5)) ('Kind.Term.all (let ((f11 (get self11 1))(f12 (get self11 2))(f13 (get self11 3))(f14 (get self11 4))(f15 (get self11 5))) orig$5)) ('Kind.Term.lam (let ((f11 (get self11 1))(f12 (get self11 2))) orig$5)) ('Kind.Term.app (let ((f11 (get self11 1))(f12 (get self11 2))) orig$5)) ('Kind.Term.let (let ((f11 (get self11 1))(f12 (get self11 2))(f13 (get self11 3))) orig$5)) ('Kind.Term.def (let ((f11 (get self11 1))(f12 (get self11 2))(f13 (get self11 3))) orig$5)) ('Kind.Term.ann (let ((f11 (get self11 1))(f12 (get self11 2))(f13 (get self11 3))) orig$5)) ('Kind.Term.gol (let ((f11 (get self11 1))(f12 (get self11 2))(f13 (get self11 3))) orig$5)) ('Kind.Term.hol (let ((f11 (get self11 1))) orig$5)) ('Kind.Term.nat (let ((f11 (get self11 1))) orig$5)) ('Kind.Term.chr (let ((f11 (get self11 1))) orig$5)) ('Kind.Term.str (let ((f11 (get self11 1))) orig$5)) ('Kind.Term.cse (let ((f11 (get self11 1))(f12 (get self11 2))(f13 (get self11 3))(f14 (get self11 4))(f15 (get self11 5))(f16 (get self11 6))) orig$5)) ('Kind.Term.ori (let ((f11 (get self11 1))(f12 (get self11 2))) ($Maybe.some f11))))))) ($Kind.Check.result type$1 ($List.cons ($Kind.Error.type_mismatch orig$17 expected$15 detected$16 ctx$3) List.nil))))))) ('Kind.Term.ann (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) (let ((expected$15 ($Either.left "function"))) (let ((detected$16 ($Either.right func_typ$11))) (let ((orig$17 (let ((self11 f0)) (case (get self11 0) ('Kind.Term.var (let ((f11 (get self11 1))(f12 (get self11 2))) orig$5)) ('Kind.Term.ref (let ((f11 (get self11 1))) orig$5)) ('Kind.Term.typ (let () orig$5)) ('Kind.Term.all (let ((f11 (get self11 1))(f12 (get self11 2))(f13 (get self11 3))(f14 (get self11 4))(f15 (get self11 5))) orig$5)) ('Kind.Term.lam (let ((f11 (get self11 1))(f12 (get self11 2))) orig$5)) ('Kind.Term.app (let ((f11 (get self11 1))(f12 (get self11 2))) orig$5)) ('Kind.Term.let (let ((f11 (get self11 1))(f12 (get self11 2))(f13 (get self11 3))) orig$5)) ('Kind.Term.def (let ((f11 (get self11 1))(f12 (get self11 2))(f13 (get self11 3))) orig$5)) ('Kind.Term.ann (let ((f11 (get self11 1))(f12 (get self11 2))(f13 (get self11 3))) orig$5)) ('Kind.Term.gol (let ((f11 (get self11 1))(f12 (get self11 2))(f13 (get self11 3))) orig$5)) ('Kind.Term.hol (let ((f11 (get self11 1))) orig$5)) ('Kind.Term.nat (let ((f11 (get self11 1))) orig$5)) ('Kind.Term.chr (let ((f11 (get self11 1))) orig$5)) ('Kind.Term.str (let ((f11 (get self11 1))) orig$5)) ('Kind.Term.cse (let ((f11 (get self11 1))(f12 (get self11 2))(f13 (get self11 3))(f14 (get self11 4))(f15 (get self11 5))(f16 (get self11 6))) orig$5)) ('Kind.Term.ori (let ((f11 (get self11 1))(f12 (get self11 2))) ($Maybe.some f11))))))) ($Kind.Check.result type$1 ($List.cons ($Kind.Error.type_mismatch orig$17 expected$15 detected$16 ctx$3) List.nil))))))) ('Kind.Term.gol (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) (let ((expected$15 ($Either.left "function"))) (let ((detected$16 ($Either.right func_typ$11))) (let ((orig$17 (let ((self11 f0)) (case (get self11 0) ('Kind.Term.var (let ((f11 (get self11 1))(f12 (get self11 2))) orig$5)) ('Kind.Term.ref (let ((f11 (get self11 1))) orig$5)) ('Kind.Term.typ (let () orig$5)) ('Kind.Term.all (let ((f11 (get self11 1))(f12 (get self11 2))(f13 (get self11 3))(f14 (get self11 4))(f15 (get self11 5))) orig$5)) ('Kind.Term.lam (let ((f11 (get self11 1))(f12 (get self11 2))) orig$5)) ('Kind.Term.app (let ((f11 (get self11 1))(f12 (get self11 2))) orig$5)) ('Kind.Term.let (let ((f11 (get self11 1))(f12 (get self11 2))(f13 (get self11 3))) orig$5)) ('Kind.Term.def (let ((f11 (get self11 1))(f12 (get self11 2))(f13 (get self11 3))) orig$5)) ('Kind.Term.ann (let ((f11 (get self11 1))(f12 (get self11 2))(f13 (get self11 3))) orig$5)) ('Kind.Term.gol (let ((f11 (get self11 1))(f12 (get self11 2))(f13 (get self11 3))) orig$5)) ('Kind.Term.hol (let ((f11 (get self11 1))) orig$5)) ('Kind.Term.nat (let ((f11 (get self11 1))) orig$5)) ('Kind.Term.chr (let ((f11 (get self11 1))) orig$5)) ('Kind.Term.str (let ((f11 (get self11 1))) orig$5)) ('Kind.Term.cse (let ((f11 (get self11 1))(f12 (get self11 2))(f13 (get self11 3))(f14 (get self11 4))(f15 (get self11 5))(f16 (get self11 6))) orig$5)) ('Kind.Term.ori (let ((f11 (get self11 1))(f12 (get self11 2))) ($Maybe.some f11))))))) ($Kind.Check.result type$1 ($List.cons ($Kind.Error.type_mismatch orig$17 expected$15 detected$16 ctx$3) List.nil))))))) ('Kind.Term.hol (let ((f6 (get self6 1))) (let ((expected$13 ($Either.left "function"))) (let ((detected$14 ($Either.right func_typ$11))) (let ((orig$15 (let ((self9 f0)) (case (get self9 0) ('Kind.Term.var (let ((f9 (get self9 1))(f10 (get self9 2))) orig$5)) ('Kind.Term.ref (let ((f9 (get self9 1))) orig$5)) ('Kind.Term.typ (let () orig$5)) ('Kind.Term.all (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))(f12 (get self9 4))(f13 (get self9 5))) orig$5)) ('Kind.Term.lam (let ((f9 (get self9 1))(f10 (get self9 2))) orig$5)) ('Kind.Term.app (let ((f9 (get self9 1))(f10 (get self9 2))) orig$5)) ('Kind.Term.let (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) orig$5)) ('Kind.Term.def (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) orig$5)) ('Kind.Term.ann (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) orig$5)) ('Kind.Term.gol (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) orig$5)) ('Kind.Term.hol (let ((f9 (get self9 1))) orig$5)) ('Kind.Term.nat (let ((f9 (get self9 1))) orig$5)) ('Kind.Term.chr (let ((f9 (get self9 1))) orig$5)) ('Kind.Term.str (let ((f9 (get self9 1))) orig$5)) ('Kind.Term.cse (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))(f12 (get self9 4))(f13 (get self9 5))(f14 (get self9 6))) orig$5)) ('Kind.Term.ori (let ((f9 (get self9 1))(f10 (get self9 2))) ($Maybe.some f9))))))) ($Kind.Check.result type$1 ($List.cons ($Kind.Error.type_mismatch orig$15 expected$13 detected$14 ctx$3) List.nil))))))) ('Kind.Term.nat (let ((f6 (get self6 1))) (let ((expected$13 ($Either.left "function"))) (let ((detected$14 ($Either.right func_typ$11))) (let ((orig$15 (let ((self9 f0)) (case (get self9 0) ('Kind.Term.var (let ((f9 (get self9 1))(f10 (get self9 2))) orig$5)) ('Kind.Term.ref (let ((f9 (get self9 1))) orig$5)) ('Kind.Term.typ (let () orig$5)) ('Kind.Term.all (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))(f12 (get self9 4))(f13 (get self9 5))) orig$5)) ('Kind.Term.lam (let ((f9 (get self9 1))(f10 (get self9 2))) orig$5)) ('Kind.Term.app (let ((f9 (get self9 1))(f10 (get self9 2))) orig$5)) ('Kind.Term.let (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) orig$5)) ('Kind.Term.def (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) orig$5)) ('Kind.Term.ann (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) orig$5)) ('Kind.Term.gol (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) orig$5)) ('Kind.Term.hol (let ((f9 (get self9 1))) orig$5)) ('Kind.Term.nat (let ((f9 (get self9 1))) orig$5)) ('Kind.Term.chr (let ((f9 (get self9 1))) orig$5)) ('Kind.Term.str (let ((f9 (get self9 1))) orig$5)) ('Kind.Term.cse (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))(f12 (get self9 4))(f13 (get self9 5))(f14 (get self9 6))) orig$5)) ('Kind.Term.ori (let ((f9 (get self9 1))(f10 (get self9 2))) ($Maybe.some f9))))))) ($Kind.Check.result type$1 ($List.cons ($Kind.Error.type_mismatch orig$15 expected$13 detected$14 ctx$3) List.nil))))))) ('Kind.Term.chr (let ((f6 (get self6 1))) (let ((expected$13 ($Either.left "function"))) (let ((detected$14 ($Either.right func_typ$11))) (let ((orig$15 (let ((self9 f0)) (case (get self9 0) ('Kind.Term.var (let ((f9 (get self9 1))(f10 (get self9 2))) orig$5)) ('Kind.Term.ref (let ((f9 (get self9 1))) orig$5)) ('Kind.Term.typ (let () orig$5)) ('Kind.Term.all (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))(f12 (get self9 4))(f13 (get self9 5))) orig$5)) ('Kind.Term.lam (let ((f9 (get self9 1))(f10 (get self9 2))) orig$5)) ('Kind.Term.app (let ((f9 (get self9 1))(f10 (get self9 2))) orig$5)) ('Kind.Term.let (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) orig$5)) ('Kind.Term.def (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) orig$5)) ('Kind.Term.ann (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) orig$5)) ('Kind.Term.gol (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) orig$5)) ('Kind.Term.hol (let ((f9 (get self9 1))) orig$5)) ('Kind.Term.nat (let ((f9 (get self9 1))) orig$5)) ('Kind.Term.chr (let ((f9 (get self9 1))) orig$5)) ('Kind.Term.str (let ((f9 (get self9 1))) orig$5)) ('Kind.Term.cse (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))(f12 (get self9 4))(f13 (get self9 5))(f14 (get self9 6))) orig$5)) ('Kind.Term.ori (let ((f9 (get self9 1))(f10 (get self9 2))) ($Maybe.some f9))))))) ($Kind.Check.result type$1 ($List.cons ($Kind.Error.type_mismatch orig$15 expected$13 detected$14 ctx$3) List.nil))))))) ('Kind.Term.str (let ((f6 (get self6 1))) (let ((expected$13 ($Either.left "function"))) (let ((detected$14 ($Either.right func_typ$11))) (let ((orig$15 (let ((self9 f0)) (case (get self9 0) ('Kind.Term.var (let ((f9 (get self9 1))(f10 (get self9 2))) orig$5)) ('Kind.Term.ref (let ((f9 (get self9 1))) orig$5)) ('Kind.Term.typ (let () orig$5)) ('Kind.Term.all (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))(f12 (get self9 4))(f13 (get self9 5))) orig$5)) ('Kind.Term.lam (let ((f9 (get self9 1))(f10 (get self9 2))) orig$5)) ('Kind.Term.app (let ((f9 (get self9 1))(f10 (get self9 2))) orig$5)) ('Kind.Term.let (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) orig$5)) ('Kind.Term.def (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) orig$5)) ('Kind.Term.ann (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) orig$5)) ('Kind.Term.gol (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) orig$5)) ('Kind.Term.hol (let ((f9 (get self9 1))) orig$5)) ('Kind.Term.nat (let ((f9 (get self9 1))) orig$5)) ('Kind.Term.chr (let ((f9 (get self9 1))) orig$5)) ('Kind.Term.str (let ((f9 (get self9 1))) orig$5)) ('Kind.Term.cse (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))(f12 (get self9 4))(f13 (get self9 5))(f14 (get self9 6))) orig$5)) ('Kind.Term.ori (let ((f9 (get self9 1))(f10 (get self9 2))) ($Maybe.some f9))))))) ($Kind.Check.result type$1 ($List.cons ($Kind.Error.type_mismatch orig$15 expected$13 detected$14 ctx$3) List.nil))))))) ('Kind.Term.cse (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))(f9 (get self6 4))(f10 (get self6 5))(f11 (get self6 6))) (let ((expected$18 ($Either.left "function"))) (let ((detected$19 ($Either.right func_typ$11))) (let ((orig$20 (let ((self14 f0)) (case (get self14 0) ('Kind.Term.var (let ((f14 (get self14 1))(f15 (get self14 2))) orig$5)) ('Kind.Term.ref (let ((f14 (get self14 1))) orig$5)) ('Kind.Term.typ (let () orig$5)) ('Kind.Term.all (let ((f14 (get self14 1))(f15 (get self14 2))(f16 (get self14 3))(f17 (get self14 4))(f18 (get self14 5))) orig$5)) ('Kind.Term.lam (let ((f14 (get self14 1))(f15 (get self14 2))) orig$5)) ('Kind.Term.app (let ((f14 (get self14 1))(f15 (get self14 2))) orig$5)) ('Kind.Term.let (let ((f14 (get self14 1))(f15 (get self14 2))(f16 (get self14 3))) orig$5)) ('Kind.Term.def (let ((f14 (get self14 1))(f15 (get self14 2))(f16 (get self14 3))) orig$5)) ('Kind.Term.ann (let ((f14 (get self14 1))(f15 (get self14 2))(f16 (get self14 3))) orig$5)) ('Kind.Term.gol (let ((f14 (get self14 1))(f15 (get self14 2))(f16 (get self14 3))) orig$5)) ('Kind.Term.hol (let ((f14 (get self14 1))) orig$5)) ('Kind.Term.nat (let ((f14 (get self14 1))) orig$5)) ('Kind.Term.chr (let ((f14 (get self14 1))) orig$5)) ('Kind.Term.str (let ((f14 (get self14 1))) orig$5)) ('Kind.Term.cse (let ((f14 (get self14 1))(f15 (get self14 2))(f16 (get self14 3))(f17 (get self14 4))(f18 (get self14 5))(f19 (get self14 6))) orig$5)) ('Kind.Term.ori (let ((f14 (get self14 1))(f15 (get self14 2))) ($Maybe.some f14))))))) ($Kind.Check.result type$1 ($List.cons ($Kind.Error.type_mismatch orig$20 expected$18 detected$19 ctx$3) List.nil))))))) ('Kind.Term.ori (let ((f6 (get self6 1))(f7 (get self6 2))) (let ((expected$14 ($Either.left "function"))) (let ((detected$15 ($Either.right func_typ$11))) (let ((orig$16 (let ((self10 f0)) (case (get self10 0) ('Kind.Term.var (let ((f10 (get self10 1))(f11 (get self10 2))) orig$5)) ('Kind.Term.ref (let ((f10 (get self10 1))) orig$5)) ('Kind.Term.typ (let () orig$5)) ('Kind.Term.all (let ((f10 (get self10 1))(f11 (get self10 2))(f12 (get self10 3))(f13 (get self10 4))(f14 (get self10 5))) orig$5)) ('Kind.Term.lam (let ((f10 (get self10 1))(f11 (get self10 2))) orig$5)) ('Kind.Term.app (let ((f10 (get self10 1))(f11 (get self10 2))) orig$5)) ('Kind.Term.let (let ((f10 (get self10 1))(f11 (get self10 2))(f12 (get self10 3))) orig$5)) ('Kind.Term.def (let ((f10 (get self10 1))(f11 (get self10 2))(f12 (get self10 3))) orig$5)) ('Kind.Term.ann (let ((f10 (get self10 1))(f11 (get self10 2))(f12 (get self10 3))) orig$5)) ('Kind.Term.gol (let ((f10 (get self10 1))(f11 (get self10 2))(f12 (get self10 3))) orig$5)) ('Kind.Term.hol (let ((f10 (get self10 1))) orig$5)) ('Kind.Term.nat (let ((f10 (get self10 1))) orig$5)) ('Kind.Term.chr (let ((f10 (get self10 1))) orig$5)) ('Kind.Term.str (let ((f10 (get self10 1))) orig$5)) ('Kind.Term.cse (let ((f10 (get self10 1))(f11 (get self10 2))(f12 (get self10 3))(f13 (get self10 4))(f14 (get self10 5))(f15 (get self10 6))) orig$5)) ('Kind.Term.ori (let ((f10 (get self10 1))(f11 (get self10 2))) ($Maybe.some f10))))))) ($Kind.Check.result type$1 ($List.cons ($Kind.Error.type_mismatch orig$16 expected$14 detected$15 ctx$3) List.nil))))))))))) (case (get self6 0) ('Kind.Check.result (let ((f6 (get self6 1))(f7 (get self6 2))) ($Kind.Check.result f6 ($List.concat f3 f7))))))))))))))))) ('Kind.Term.let (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((ctx_size$9 ($List.length ctx$3))) (let ((self4 ($Kind.Term.check f1 Maybe.none defs$2 ctx$3 ($Kind.MPath.o path$4) orig$5))) (case (get self4 0) ('Kind.Check.result (let ((f4 (get self4 1))(f5 (get self4 2))) (let ((self6 f4)) (case (get self6 0) ('Maybe.none (let () ($Kind.Check.result Maybe.none f5))) ('Maybe.some (let ((f6 (get self6 1))) (let ((body_val$13 (f2 ($Kind.Term.var f0 ctx_size$9)))) (let ((body_ctx$14 ($List.cons ($Pair.new f0 f6) ctx$3))) (let ((self9 (let ((self9 ($Kind.Term.check body_val$13 type$1 defs$2 body_ctx$14 ($Kind.MPath.i path$4) orig$5))) (case (get self9 0) ('Kind.Check.result (let ((f9 (get self9 1))(f10 (get self9 2))) (let ((self11 f9)) (case (get self11 0) ('Maybe.none (let () ($Kind.Check.result Maybe.none f10))) ('Maybe.some (let ((f11 (get self11 1))) (let ((self12 ($Kind.Check.result ($Maybe.some f11) List.nil))) (case (get self12 0) ('Kind.Check.result (let ((f12 (get self12 1))(f13 (get self12 2))) ($Kind.Check.result f12 ($List.concat f10 f13)))))))))))))))) (case (get self9 0) ('Kind.Check.result (let ((f9 (get self9 1))(f10 (get self9 2))) ($Kind.Check.result f9 ($List.concat f5 f10))))))))))))))))))) ('Kind.Term.def (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((ctx_size$9 ($List.length ctx$3))) (let ((self4 ($Kind.Term.check f1 Maybe.none defs$2 ctx$3 ($Kind.MPath.o path$4) orig$5))) (case (get self4 0) ('Kind.Check.result (let ((f4 (get self4 1))(f5 (get self4 2))) (let ((self6 f4)) (case (get self6 0) ('Maybe.none (let () ($Kind.Check.result Maybe.none f5))) ('Maybe.some (let ((f6 (get self6 1))) (let ((body_val$13 (f2 ($Kind.Term.ann Bool.true f1 f6)))) (let ((body_ctx$14 ($List.cons ($Pair.new f0 f6) ctx$3))) (let ((self9 (let ((self9 ($Kind.Term.check body_val$13 type$1 defs$2 body_ctx$14 ($Kind.MPath.i path$4) orig$5))) (case (get self9 0) ('Kind.Check.result (let ((f9 (get self9 1))(f10 (get self9 2))) (let ((self11 f9)) (case (get self11 0) ('Maybe.none (let () ($Kind.Check.result Maybe.none f10))) ('Maybe.some (let ((f11 (get self11 1))) (let ((self12 ($Kind.Check.result ($Maybe.some f11) List.nil))) (case (get self12 0) ('Kind.Check.result (let ((f12 (get self12 1))(f13 (get self12 2))) ($Kind.Check.result f12 ($List.concat f10 f13)))))))))))))))) (case (get self9 0) ('Kind.Check.result (let ((f9 (get self9 1))(f10 (get self9 2))) ($Kind.Check.result f9 ($List.concat f5 f10))))))))))))))))))) ('Kind.Term.ann (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 f0)) (case self3 (#t (let () ($Kind.Check.result ($Maybe.some f2) List.nil))) (#f (let () (let ((self3 ($Kind.Term.check f1 ($Maybe.some f2) defs$2 ctx$3 ($Kind.MPath.o path$4) orig$5))) (case (get self3 0) ('Kind.Check.result (let ((f3 (get self3 1))(f4 (get self3 2))) (let ((self5 f3)) (case (get self5 0) ('Maybe.none (let () ($Kind.Check.result Maybe.none f4))) ('Maybe.some (let ((f5 (get self5 1))) (let ((self6 (let ((self6 ($Kind.Term.check f2 ($Maybe.some Kind.Term.typ) defs$2 ctx$3 ($Kind.MPath.i path$4) orig$5))) (case (get self6 0) ('Kind.Check.result (let ((f6 (get self6 1))(f7 (get self6 2))) (let ((self8 f6)) (case (get self8 0) ('Maybe.none (let () ($Kind.Check.result Maybe.none f7))) ('Maybe.some (let ((f8 (get self8 1))) (let ((self9 ($Kind.Check.result ($Maybe.some f2) List.nil))) (case (get self9 0) ('Kind.Check.result (let ((f9 (get self9 1))(f10 (get self9 2))) ($Kind.Check.result f9 ($List.concat f7 f10)))))))))))))))) (case (get self6 0) ('Kind.Check.result (let ((f6 (get self6 1))(f7 (get self6 2))) ($Kind.Check.result f6 ($List.concat f4 f7)))))))))))))))))))) ('Kind.Term.gol (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Kind.Check.result type$1 ($List.cons ($Kind.Error.show_goal f0 f1 f2 type$1 ctx$3) List.nil)))) ('Kind.Term.hol (let ((f0 (get self0 1))) ($Kind.Check.result type$1 List.nil))) ('Kind.Term.nat (let ((f0 (get self0 1))) ($Kind.Check.result ($Maybe.some ($Kind.Term.ref "Nat")) List.nil))) ('Kind.Term.chr (let ((f0 (get self0 1))) ($Kind.Check.result ($Maybe.some ($Kind.Term.ref "Char")) List.nil))) ('Kind.Term.str (let ((f0 (get self0 1))) ($Kind.Check.result ($Maybe.some ($Kind.Term.ref "String")) List.nil))) ('Kind.Term.cse (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))(f5 (get self0 6))) (let ((expr$12 f1)) (let ((self7 ($Kind.Term.check expr$12 Maybe.none defs$2 ctx$3 ($Kind.MPath.o path$4) orig$5))) (case (get self7 0) ('Kind.Check.result (let ((f7 (get self7 1))(f8 (get self7 2))) (let ((self9 f7)) (case (get self9 0) ('Maybe.none (let () ($Kind.Check.result Maybe.none f8))) ('Maybe.some (let ((f9 (get self9 1))) (let ((self10 (let ((self10 ($Kind.Term.check.infer_with_types f3 defs$2 ctx$3 path$4 orig$5))) (case (get self10 0) ('Kind.Check.result (let ((f10 (get self10 1))(f11 (get self10 2))) (let ((self12 f10)) (case (get self12 0) ('Maybe.none (let () ($Kind.Check.result Maybe.none f11))) ('Maybe.some (let ((f12 (get self12 1))) (let ((dsug$19 ($Kind.Term.desugar_cse f1 f2 f12 f4 f5 f9 type$1 defs$2 ctx$3))) (let ((self14 (let ((self14 dsug$19)) (case (get self14 0) ('Maybe.none (let () ($Kind.Check.result type$1 ($List.cons ($Kind.Error.cant_infer orig$5 term$0 ctx$3) List.nil)))) ('Maybe.some (let ((f14 (get self14 1))) ($Kind.Check.result type$1 ($List.cons ($Kind.Error.patch ($Kind.MPath.to_bits path$4) f14) List.nil)))))))) (case (get self14 0) ('Kind.Check.result (let ((f14 (get self14 1))(f15 (get self14 2))) ($Kind.Check.result f14 ($List.concat f11 f15))))))))))))))))) (case (get self10 0) ('Kind.Check.result (let ((f10 (get self10 1))(f11 (get self10 2))) ($Kind.Check.result f10 ($List.concat f8 f11))))))))))))))))) ('Kind.Term.ori (let ((f0 (get self0 1))(f1 (get self0 2))) ($Kind.Term.check f1 type$1 defs$2 ctx$3 path$4 ($Maybe.some f0)))))))) (case (get self0 0) ('Kind.Check.result (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 f0)) (case (get self2 0) ('Maybe.none (let () ($Kind.Check.result Maybe.none f1))) ('Maybe.some (let ((f2 (get self2 1))) (let ((self3 (let ((self3 type$1)) (case (get self3 0) ('Maybe.none (let () ($Kind.Check.result ($Maybe.some f2) List.nil))) ('Maybe.some (let ((f3 (get self3 1))) (let ((self4 ($Kind.Term.equal.go f3 f2 defs$2 ($List.length ctx$3) ($BitsSet.mut.new Unit.new)))) (case (get self4 0) ('Kind.Check.result (let ((f4 (get self4 1))(f5 (get self4 2))) (let ((self6 f4)) (case (get self6 0) ('Maybe.none (let () ($Kind.Check.result Maybe.none f5))) ('Maybe.some (let ((f6 (get self6 1))) (let ((self7 (let ((self7 f6)) (case self7 (#t (let () ($Kind.Check.result ($Maybe.some f3) List.nil))) (#f (let () ($Kind.Check.result type$1 ($List.cons ($Kind.Error.type_mismatch orig$5 ($Either.right f3) ($Either.right f2) ctx$3) List.nil)))))))) (case (get self7 0) ('Kind.Check.result (let ((f7 (get self7 1))(f8 (get self7 2))) ($Kind.Check.result f7 ($List.concat f5 f8)))))))))))))))))))) (case (get self3 0) ('Kind.Check.result (let ((f3 (get self3 1))(f4 (get self3 2))) ($Kind.Check.result f3 ($List.concat f1 f4)))))))))))))))
(define Kind.Term.check (lambda (term$0) (lambda (type$1) (lambda (defs$2) (lambda (ctx$3) (lambda (path$4) (lambda (orig$5) ($Kind.Term.check term$0 type$1 defs$2 ctx$3 path$4 orig$5))))))))
(define ($Kind.Path.nil x$0) x$0)
(define Kind.Path.nil (lambda (x$0) ($Kind.Path.nil x$0)))
(define ($Kind.MPath.nil) ($Maybe.some Kind.Path.nil))
(define Kind.MPath.nil ($Kind.MPath.nil))
(define ($List.is_empty list$1) (let ((self0 list$1)) (case (get self0 0) ('List.nil (let () Bool.true)) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) Bool.false)))))
(define List.is_empty (lambda (list$1) ($List.is_empty list$1)))
(define ($Kind.Term.patch_at path$0 term$1 fn$2) (let ((self0 term$1)) (case (get self0 0) ('Kind.Term.var (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 path$0)) (case (get self2 0) ('Bits.e (let () (fn$2 term$1))) ('Bits.o (let ((f2 (get self2 1))) term$1)) ('Bits.i (let ((f2 (get self2 1))) term$1)))))) ('Kind.Term.ref (let ((f0 (get self0 1))) (let ((self1 path$0)) (case (get self1 0) ('Bits.e (let () (fn$2 term$1))) ('Bits.o (let ((f1 (get self1 1))) term$1)) ('Bits.i (let ((f1 (get self1 1))) term$1)))))) ('Kind.Term.typ (let () (let ((self0 path$0)) (case (get self0 0) ('Bits.e (let () (fn$2 term$1))) ('Bits.o (let ((f0 (get self0 1))) term$1)) ('Bits.i (let ((f0 (get self0 1))) term$1)))))) ('Kind.Term.all (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))) (let ((self5 path$0)) (case (get self5 0) ('Bits.e (let () (fn$2 term$1))) ('Bits.o (let ((f5 (get self5 1))) ($Kind.Term.all f0 f1 f2 ($Kind.Term.patch_at f5 f3 fn$2) f4))) ('Bits.i (let ((f5 (get self5 1))) ($Kind.Term.all f0 f1 f2 f3 (lambda (s$9) (lambda (x$10) ($Kind.Term.patch_at f5 ((f4 s$9) x$10) fn$2)))))))))) ('Kind.Term.lam (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 path$0)) (case (get self2 0) ('Bits.e (let () (fn$2 term$1))) ('Bits.o (let ((f2 (get self2 1))) ($Kind.Term.lam f0 (lambda (x$6) ($Kind.Term.patch_at ($Bits.tail path$0) (f1 x$6) fn$2))))) ('Bits.i (let ((f2 (get self2 1))) ($Kind.Term.lam f0 (lambda (x$6) ($Kind.Term.patch_at ($Bits.tail path$0) (f1 x$6) fn$2))))))))) ('Kind.Term.app (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 path$0)) (case (get self2 0) ('Bits.e (let () (fn$2 term$1))) ('Bits.o (let ((f2 (get self2 1))) ($Kind.Term.app ($Kind.Term.patch_at f2 f0 fn$2) f1))) ('Bits.i (let ((f2 (get self2 1))) ($Kind.Term.app f0 ($Kind.Term.patch_at f2 f1 fn$2)))))))) ('Kind.Term.let (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 path$0)) (case (get self3 0) ('Bits.e (let () (fn$2 term$1))) ('Bits.o (let ((f3 (get self3 1))) ($Kind.Term.let f0 ($Kind.Term.patch_at f3 f1 fn$2) f2))) ('Bits.i (let ((f3 (get self3 1))) ($Kind.Term.let f0 f1 (lambda (x$7) ($Kind.Term.patch_at f3 (f2 x$7) fn$2))))))))) ('Kind.Term.def (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 path$0)) (case (get self3 0) ('Bits.e (let () (fn$2 term$1))) ('Bits.o (let ((f3 (get self3 1))) ($Kind.Term.def f0 ($Kind.Term.patch_at f3 f1 fn$2) f2))) ('Bits.i (let ((f3 (get self3 1))) ($Kind.Term.def f0 f1 (lambda (x$7) ($Kind.Term.patch_at f3 (f2 x$7) fn$2))))))))) ('Kind.Term.ann (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 path$0)) (case (get self3 0) ('Bits.e (let () (fn$2 term$1))) ('Bits.o (let ((f3 (get self3 1))) ($Kind.Term.ann f0 ($Kind.Term.patch_at f3 f1 fn$2) f2))) ('Bits.i (let ((f3 (get self3 1))) ($Kind.Term.ann f0 f1 ($Kind.Term.patch_at f3 f2 fn$2)))))))) ('Kind.Term.gol (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 path$0)) (case (get self3 0) ('Bits.e (let () (fn$2 term$1))) ('Bits.o (let ((f3 (get self3 1))) term$1)) ('Bits.i (let ((f3 (get self3 1))) term$1)))))) ('Kind.Term.hol (let ((f0 (get self0 1))) (let ((self1 path$0)) (case (get self1 0) ('Bits.e (let () (fn$2 term$1))) ('Bits.o (let ((f1 (get self1 1))) term$1)) ('Bits.i (let ((f1 (get self1 1))) term$1)))))) ('Kind.Term.nat (let ((f0 (get self0 1))) (let ((self1 path$0)) (case (get self1 0) ('Bits.e (let () (fn$2 term$1))) ('Bits.o (let ((f1 (get self1 1))) term$1)) ('Bits.i (let ((f1 (get self1 1))) term$1)))))) ('Kind.Term.chr (let ((f0 (get self0 1))) (let ((self1 path$0)) (case (get self1 0) ('Bits.e (let () (fn$2 term$1))) ('Bits.o (let ((f1 (get self1 1))) term$1)) ('Bits.i (let ((f1 (get self1 1))) term$1)))))) ('Kind.Term.str (let ((f0 (get self0 1))) (let ((self1 path$0)) (case (get self1 0) ('Bits.e (let () (fn$2 term$1))) ('Bits.o (let ((f1 (get self1 1))) term$1)) ('Bits.i (let ((f1 (get self1 1))) term$1)))))) ('Kind.Term.cse (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))(f5 (get self0 6))) (let ((self6 path$0)) (case (get self6 0) ('Bits.e (let () (fn$2 term$1))) ('Bits.o (let ((f6 (get self6 1))) term$1)) ('Bits.i (let ((f6 (get self6 1))) term$1)))))) ('Kind.Term.ori (let ((f0 (get self0 1))(f1 (get self0 2))) ($Kind.Term.ori f0 ($Kind.Term.patch_at path$0 f1 fn$2)))))))
(define Kind.Term.patch_at (lambda (path$0) (lambda (term$1) (lambda (fn$2) ($Kind.Term.patch_at path$0 term$1 fn$2)))))
(define ($Kind.Synth.fix file$0 code$1 orig$2 name$3 term$4 type$5 isct$6 arit$7 defs$8 errs$9 fixd$10) (let ((self0 errs$9)) (case (get self0 0) ('List.nil (let () (let ((self0 fixd$10)) (case self0 (#t (let () (let ((type$11 ($Kind.Term.bind List.nil (lambda (x$11) ($Bits.i x$11)) type$5))) (let ((term$12 ($Kind.Term.bind List.nil (lambda (x$12) ($Bits.o x$12)) term$4))) (let ((defs$13 ($Kind.Map.set name$3 ($Kind.Def.new file$0 code$1 orig$2 name$3 term$12 type$11 isct$6 arit$7 Kind.Status.init) defs$8))) ((let ((self3 IO.monad)) (case (get self3 0) ('Monad.new (let ((f3 (get self3 1))(f4 (get self3 2))) f4)))) ($Maybe.some defs$13))))))) (#f (let () ((let ((self0 IO.monad)) (case (get self0 0) ('Monad.new (let ((f0 (get self0 1))(f1 (get self0 2))) f1)))) Maybe.none))))))) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 f0)) (case (get self2 0) ('Kind.Error.type_mismatch (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))(f5 (get self2 4))) ($Kind.Synth.fix file$0 code$1 orig$2 name$3 term$4 type$5 isct$6 arit$7 defs$8 f1 fixd$10))) ('Kind.Error.show_goal (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))(f5 (get self2 4))(f6 (get self2 5))) ($Kind.Synth.fix file$0 code$1 orig$2 name$3 term$4 type$5 isct$6 arit$7 defs$8 f1 fixd$10))) ('Kind.Error.waiting (let ((f2 (get self2 1))) (((let ((self3 IO.monad)) (case (get self3 0) ('Monad.new (let ((f3 (get self3 1))(f4 (get self3 2))) f3)))) ($Kind.Synth.one f2 defs$8)) (lambda (new_defs$14) (let ((self4 new_defs$14)) (case (get self4 0) ('Maybe.none (let () ($Kind.Synth.fix file$0 code$1 orig$2 name$3 term$4 type$5 isct$6 arit$7 defs$8 f1 fixd$10))) ('Maybe.some (let ((f4 (get self4 1))) ($Kind.Synth.fix file$0 code$1 orig$2 name$3 term$4 type$5 isct$6 arit$7 f4 f1 Bool.true))))))))) ('Kind.Error.indirect (let ((f2 (get self2 1))) ($Kind.Synth.fix file$0 code$1 orig$2 name$3 term$4 type$5 isct$6 arit$7 defs$8 f1 fixd$10))) ('Kind.Error.patch (let ((f2 (get self2 1))(f3 (get self2 2))) (let ((self4 f2)) (case (get self4 0) ('Bits.e (let () ((let ((self4 IO.monad)) (case (get self4 0) ('Monad.new (let ((f4 (get self4 1))(f5 (get self4 2))) f5)))) Maybe.none))) ('Bits.o (let ((f4 (get self4 1))) (let ((term$16 ($Kind.Term.patch_at f4 term$4 (lambda (x$16) f3)))) ($Kind.Synth.fix file$0 code$1 orig$2 name$3 term$16 type$5 isct$6 arit$7 defs$8 f1 Bool.true)))) ('Bits.i (let ((f4 (get self4 1))) (let ((type$16 ($Kind.Term.patch_at f4 type$5 (lambda (x$16) f3)))) ($Kind.Synth.fix file$0 code$1 orig$2 name$3 term$4 type$16 isct$6 arit$7 defs$8 f1 Bool.true)))))))) ('Kind.Error.undefined_reference (let ((f2 (get self2 1))(f3 (get self2 2))) (((let ((self4 IO.monad)) (case (get self4 0) ('Monad.new (let ((f4 (get self4 1))(f5 (get self4 2))) f4)))) ($Kind.Synth.one f3 defs$8)) (lambda (new_defs$15) (let ((self5 new_defs$15)) (case (get self5 0) ('Maybe.none (let () ($Kind.Synth.fix file$0 code$1 orig$2 name$3 term$4 type$5 isct$6 arit$7 defs$8 f1 fixd$10))) ('Maybe.some (let ((f5 (get self5 1))) ($Kind.Synth.fix file$0 code$1 orig$2 name$3 term$4 type$5 isct$6 arit$7 f5 f1 Bool.true))))))))) ('Kind.Error.cant_infer (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))) ($Kind.Synth.fix file$0 code$1 orig$2 name$3 term$4 type$5 isct$6 arit$7 defs$8 f1 fixd$10))))))))))
(define Kind.Synth.fix (lambda (file$0) (lambda (code$1) (lambda (orig$2) (lambda (name$3) (lambda (term$4) (lambda (type$5) (lambda (isct$6) (lambda (arit$7) (lambda (defs$8) (lambda (errs$9) (lambda (fixd$10) ($Kind.Synth.fix file$0 code$1 orig$2 name$3 term$4 type$5 isct$6 arit$7 defs$8 errs$9 fixd$10)))))))))))))
(define ($Kind.Status.fail errors$0) (vector 'Kind.Status.fail errors$0))
(define Kind.Status.fail (lambda (errors$0) ($Kind.Status.fail errors$0)))
(define ($Kind.Synth.one name$0 defs$1) (let ((self0 ($Kind.Map.get name$0 defs$1))) (case (get self0 0) ('Maybe.none (let () (((let ((self0 IO.monad)) (case (get self0 0) ('Monad.new (let ((f0 (get self0 1))(f1 (get self0 2))) f0)))) IO.get_time) (lambda (time_a$2) (((let ((self1 IO.monad)) (case (get self1 0) ('Monad.new (let ((f1 (get self1 1))(f2 (get self1 2))) f1)))) ($Kind.Synth.load name$0 defs$1)) (lambda (loaded$3) (let ((self2 loaded$3)) (case (get self2 0) ('Maybe.none (let () ((let ((self2 IO.monad)) (case (get self2 0) ('Monad.new (let ((f2 (get self2 1))(f3 (get self2 2))) f3)))) Maybe.none))) ('Maybe.some (let ((f2 (get self2 1))) (((let ((self3 IO.monad)) (case (get self3 0) ('Monad.new (let ((f3 (get self3 1))(f4 (get self3 2))) f3)))) IO.get_time) (lambda (time_b$5) (((let ((self4 IO.monad)) (case (get self4 0) ('Monad.new (let ((f4 (get self4 1))(f5 (get self4 2))) f4)))) ($Kind.Synth.one name$0 f2)) (lambda (result$6) (((let ((self5 IO.monad)) (case (get self5 0) ('Monad.new (let ((f5 (get self5 1))(f6 (get self5 2))) f5)))) IO.get_time) (lambda (time_c$7) ((let ((self6 IO.monad)) (case (get self6 0) ('Monad.new (let ((f6 (get self6 1))(f7 (get self6 2))) f7)))) result$6))))))))))))))))) ('Maybe.some (let ((f0 (get self0 1))) (let ((self1 f0)) (case (get self1 0) ('Kind.Def.new (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))(f4 (get self1 4))(f5 (get self1 5))(f6 (get self1 6))(f7 (get self1 7))(f8 (get self1 8))(f9 (get self1 9))) (let ((file$12 f1)) (let ((code$13 f2)) (let ((orig$14 f3)) (let ((name$15 f4)) (let ((term$16 f5)) (let ((type$17 f6)) (let ((isct$18 f7)) (let ((arit$19 f8)) (let ((stat$20 f9)) (let ((self19 stat$20)) (case (get self19 0) ('Kind.Status.init (let () (let ((defs$21 ($Kind.Map.set name$15 ($Kind.Def.new file$12 code$13 orig$14 name$15 term$16 type$17 isct$18 arit$19 Kind.Status.wait) defs$1))) (let ((checked$22 (let ((self20 ($Kind.Term.check type$17 ($Maybe.some Kind.Term.typ) defs$21 List.nil ($Kind.MPath.i Kind.MPath.nil) Maybe.none))) (case (get self20 0) ('Kind.Check.result (let ((f20 (get self20 1))(f21 (get self20 2))) (let ((self22 f20)) (case (get self22 0) ('Maybe.none (let () ($Kind.Check.result Maybe.none f21))) ('Maybe.some (let ((f22 (get self22 1))) (let ((self23 (let ((self23 ($Kind.Term.check term$16 ($Maybe.some type$17) defs$21 List.nil ($Kind.MPath.o Kind.MPath.nil) Maybe.none))) (case (get self23 0) ('Kind.Check.result (let ((f23 (get self23 1))(f24 (get self23 2))) (let ((self25 f23)) (case (get self25 0) ('Maybe.none (let () ($Kind.Check.result Maybe.none f24))) ('Maybe.some (let ((f25 (get self25 1))) (let ((self26 ($Kind.Check.result ($Maybe.some Unit.new) List.nil))) (case (get self26 0) ('Kind.Check.result (let ((f26 (get self26 1))(f27 (get self26 2))) ($Kind.Check.result f26 ($List.concat f24 f27)))))))))))))))) (case (get self23 0) ('Kind.Check.result (let ((f23 (get self23 1))(f24 (get self23 2))) ($Kind.Check.result f23 ($List.concat f21 f24)))))))))))))))) (let ((self21 checked$22)) (case (get self21 0) ('Kind.Check.result (let ((f21 (get self21 1))(f22 (get self21 2))) (let ((self23 ($List.is_empty f22))) (case self23 (#t (let () (let ((defs$25 ($Kind.Map.def file$12 code$13 orig$14 name$15 term$16 type$17 isct$18 arit$19 Bool.true defs$21))) ((let ((self24 IO.monad)) (case (get self24 0) ('Monad.new (let ((f24 (get self24 1))(f25 (get self24 2))) f25)))) ($Maybe.some defs$25))))) (#f (let () (((let ((self23 IO.monad)) (case (get self23 0) ('Monad.new (let ((f23 (get self23 1))(f24 (get self23 2))) f23)))) ($Kind.Synth.fix file$12 code$13 orig$14 name$15 term$16 type$17 isct$18 arit$19 defs$21 f22 Bool.false)) (lambda (fixed$25) (let ((self24 fixed$25)) (case (get self24 0) ('Maybe.none (let () (let ((stat$26 ($Kind.Status.fail f22))) (let ((defs$27 ($Kind.Map.set name$15 ($Kind.Def.new file$12 code$13 orig$14 name$15 term$16 type$17 isct$18 arit$19 stat$26) defs$21))) ((let ((self26 IO.monad)) (case (get self26 0) ('Monad.new (let ((f26 (get self26 1))(f27 (get self26 2))) f27)))) ($Maybe.some defs$27)))))) ('Maybe.some (let ((f24 (get self24 1))) ($Kind.Synth.one name$15 f24))))))))))))))))))) ('Kind.Status.wait (let () ((let ((self19 IO.monad)) (case (get self19 0) ('Monad.new (let ((f19 (get self19 1))(f20 (get self19 2))) f20)))) ($Maybe.some defs$1)))) ('Kind.Status.done (let ((f19 (get self19 1))) ((let ((self20 IO.monad)) (case (get self20 0) ('Monad.new (let ((f20 (get self20 1))(f21 (get self20 2))) f21)))) ($Maybe.some defs$1)))) ('Kind.Status.fail (let ((f19 (get self19 1))) ((let ((self20 IO.monad)) (case (get self20 0) ('Monad.new (let ((f20 (get self20 1))(f21 (get self20 2))) f21)))) ($Maybe.some defs$1))))))))))))))))))))))))
(define Kind.Synth.one (lambda (name$0) (lambda (defs$1) ($Kind.Synth.one name$0 defs$1))))
(define ($Kind.Synth.many names$0 defs$1) (let ((self0 names$0)) (case (get self0 0) ('List.nil (let () ((let ((self0 IO.monad)) (case (get self0 0) ('Monad.new (let ((f0 (get self0 1))(f1 (get self0 2))) f1)))) defs$1))) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) (((let ((self2 IO.monad)) (case (get self2 0) ('Monad.new (let ((f2 (get self2 1))(f3 (get self2 2))) f2)))) ($Kind.Synth.one f0 defs$1)) (lambda (new_defs$4) (let ((self3 new_defs$4)) (case (get self3 0) ('Maybe.none (let () ($Kind.Synth.many f1 defs$1))) ('Maybe.some (let ((f3 (get self3 1))) ($Kind.Synth.many f1 f3))))))))))))
(define Kind.Synth.many (lambda (names$0) (lambda (defs$1) ($Kind.Synth.many names$0 defs$1))))
(define ($Kind.Synth.file file$0 defs$1) (((let ((self0 IO.monad)) (case (get self0 0) ('Monad.new (let ((f0 (get self0 1))(f1 (get self0 2))) f0)))) ($IO.get_file file$0)) (lambda (code$2) (let ((read$3 ($Kind.Defs.read file$0 code$2 defs$1))) (let ((self2 read$3)) (case (get self2 0) ('Either.left (let ((f2 (get self2 1))) ((let ((self3 IO.monad)) (case (get self3 0) ('Monad.new (let ((f3 (get self3 1))(f4 (get self3 2))) f4)))) ($Either.left f2)))) ('Either.right (let ((f2 (get self2 1))) (let ((file_defs$5 f2)) (let ((file_keys$6 ($BitsMap.keys file_defs$5))) (let ((file_nams$7 ($List.mapped file_keys$6 Kind.Name.from_bits))) (((let ((self6 IO.monad)) (case (get self6 0) ('Monad.new (let ((f6 (get self6 1))(f7 (get self6 2))) f6)))) ($Kind.Synth.many file_nams$7 file_defs$5)) (lambda (defs$8) ((let ((self7 IO.monad)) (case (get self7 0) ('Monad.new (let ((f7 (get self7 1))(f8 (get self7 2))) f8)))) ($Either.right ($Pair.new file_nams$7 defs$8))))))))))))))))
(define Kind.Synth.file (lambda (file$0) (lambda (defs$1) ($Kind.Synth.file file$0 defs$1))))
(define ($IO.put_string text$0) ($IO.ask "put_string" text$0 (lambda (skip$1) ($IO.end Unit.new))))
(define IO.put_string (lambda (text$0) ($IO.put_string text$0)))
(define ($IO.print text$0) ($IO.put_string ($String.concat text$0 "\xA;")))
(define IO.print (lambda (text$0) ($IO.print text$0)))
(define ($Kind.Term.show.as_nat.go term$0) (let ((self0 term$0)) (case (get self0 0) ('Kind.Term.var (let ((f0 (get self0 1))(f1 (get self0 2))) Maybe.none)) ('Kind.Term.ref (let ((f0 (get self0 1))) (let ((self1 ($String.eql f0 "Nat.zero"))) (case self1 (#t (let () ($Maybe.some 0))) (#f (let () Maybe.none)))))) ('Kind.Term.typ (let () Maybe.none)) ('Kind.Term.all (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))) Maybe.none)) ('Kind.Term.lam (let ((f0 (get self0 1))(f1 (get self0 2))) Maybe.none)) ('Kind.Term.app (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 f0)) (case (get self2 0) ('Kind.Term.var (let ((f2 (get self2 1))(f3 (get self2 2))) Maybe.none)) ('Kind.Term.ref (let ((f2 (get self2 1))) (let ((self3 ($String.eql f2 "Nat.succ"))) (case self3 (#t (let () (((let ((self3 Maybe.monad)) (case (get self3 0) ('Monad.new (let ((f3 (get self3 1))(f4 (get self3 2))) f3)))) ($Kind.Term.show.as_nat.go f1)) (lambda (pred$4) ((let ((self4 Maybe.monad)) (case (get self4 0) ('Monad.new (let ((f4 (get self4 1))(f5 (get self4 2))) f5)))) ($Nat.succ pred$4)))))) (#f (let () Maybe.none)))))) ('Kind.Term.typ (let () Maybe.none)) ('Kind.Term.all (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))(f5 (get self2 4))(f6 (get self2 5))) Maybe.none)) ('Kind.Term.lam (let ((f2 (get self2 1))(f3 (get self2 2))) Maybe.none)) ('Kind.Term.app (let ((f2 (get self2 1))(f3 (get self2 2))) Maybe.none)) ('Kind.Term.let (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))) Maybe.none)) ('Kind.Term.def (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))) Maybe.none)) ('Kind.Term.ann (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))) Maybe.none)) ('Kind.Term.gol (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))) Maybe.none)) ('Kind.Term.hol (let ((f2 (get self2 1))) Maybe.none)) ('Kind.Term.nat (let ((f2 (get self2 1))) Maybe.none)) ('Kind.Term.chr (let ((f2 (get self2 1))) Maybe.none)) ('Kind.Term.str (let ((f2 (get self2 1))) Maybe.none)) ('Kind.Term.cse (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))(f5 (get self2 4))(f6 (get self2 5))(f7 (get self2 6))) Maybe.none)) ('Kind.Term.ori (let ((f2 (get self2 1))(f3 (get self2 2))) Maybe.none)))))) ('Kind.Term.let (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) Maybe.none)) ('Kind.Term.def (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) Maybe.none)) ('Kind.Term.ann (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) Maybe.none)) ('Kind.Term.gol (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) Maybe.none)) ('Kind.Term.hol (let ((f0 (get self0 1))) Maybe.none)) ('Kind.Term.nat (let ((f0 (get self0 1))) Maybe.none)) ('Kind.Term.chr (let ((f0 (get self0 1))) Maybe.none)) ('Kind.Term.str (let ((f0 (get self0 1))) Maybe.none)) ('Kind.Term.cse (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))(f5 (get self0 6))) Maybe.none)) ('Kind.Term.ori (let ((f0 (get self0 1))(f1 (get self0 2))) Maybe.none)))))
(define Kind.Term.show.as_nat.go (lambda (term$0) ($Kind.Term.show.as_nat.go term$0)))
(define ($Kind.Term.show.as_nat term$0) ($Maybe.mapped ($Kind.Term.show.as_nat.go term$0) Nat.show))
(define Kind.Term.show.as_nat (lambda (term$0) ($Kind.Term.show.as_nat term$0)))
(define ($Kind.Name.show name$0) name$0)
(define Kind.Name.show (lambda (name$0) ($Kind.Name.show name$0)))
(define ($Bits.to_nat b$0) (let ((self0 b$0)) (case (get self0 0) ('Bits.e (let () 0)) ('Bits.o (let ((f0 (get self0 1))) ($Nat.mul 2 ($Bits.to_nat f0)))) ('Bits.i (let ((f0 (get self0 1))) ($Nat.succ ($Nat.mul 2 ($Bits.to_nat f0))))))))
(define Bits.to_nat (lambda (b$0) ($Bits.to_nat b$0)))
(define ($Kind.Term.show.is_ref term$0 name$1) (let ((self0 term$0)) (case (get self0 0) ('Kind.Term.var (let ((f0 (get self0 1))(f1 (get self0 2))) Bool.false)) ('Kind.Term.ref (let ((f0 (get self0 1))) ($String.eql name$1 f0))) ('Kind.Term.typ (let () Bool.false)) ('Kind.Term.all (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))) Bool.false)) ('Kind.Term.lam (let ((f0 (get self0 1))(f1 (get self0 2))) Bool.false)) ('Kind.Term.app (let ((f0 (get self0 1))(f1 (get self0 2))) Bool.false)) ('Kind.Term.let (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) Bool.false)) ('Kind.Term.def (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) Bool.false)) ('Kind.Term.ann (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) Bool.false)) ('Kind.Term.gol (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) Bool.false)) ('Kind.Term.hol (let ((f0 (get self0 1))) Bool.false)) ('Kind.Term.nat (let ((f0 (get self0 1))) Bool.false)) ('Kind.Term.chr (let ((f0 (get self0 1))) Bool.false)) ('Kind.Term.str (let ((f0 (get self0 1))) Bool.false)) ('Kind.Term.cse (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))(f5 (get self0 6))) Bool.false)) ('Kind.Term.ori (let ((f0 (get self0 1))(f1 (get self0 2))) Bool.false)))))
(define Kind.Term.show.is_ref (lambda (term$0) (lambda (name$1) ($Kind.Term.show.is_ref term$0 name$1))))
(define ($Kind.Term.show.app.done term$0 path$1 args$2) (let ((arity$3 ($List.length args$2))) (let ((self1 ($Bool.and ($Kind.Term.show.is_ref term$0 "Equal") ($Nat.eql arity$3 3)))) (case self1 (#t (let () (let ((func$4 ($Kind.Term.show.go term$0 path$1))) (let ((eq_lft$5 ($Maybe.default ($List.at 1 args$2) "?"))) (let ((eq_rgt$6 ($Maybe.default ($List.at 2 args$2) "?"))) ($String.flatten ($List.cons eq_lft$5 ($List.cons " == " ($List.cons eq_rgt$6 List.nil))))))))) (#f (let () (let ((func$4 ($Kind.Term.show.go term$0 path$1))) (let ((wrap$5 (let ((self2 func$4)) (case (= (string-length self2) 0) (#t (let () Bool.false)) (#f (let ((f2 (char->integer (string-ref self2 0)))(f3 (let ((_str_ self2)) (substring _str_ 1 (string-length _str_))))) ($U16.eql f2 40))))))) (let ((args$6 ($String.join "," args$2))) (let ((func$7 (let ((self4 wrap$5)) (case self4 (#t (let () ($String.flatten ($List.cons "(" ($List.cons func$4 ($List.cons ")" List.nil)))))) (#f (let () func$4)))))) ($String.flatten ($List.cons func$7 ($List.cons "(" ($List.cons args$6 ($List.cons ")" List.nil)))))))))))))))
(define Kind.Term.show.app.done (lambda (term$0) (lambda (path$1) (lambda (args$2) ($Kind.Term.show.app.done term$0 path$1 args$2)))))
(define ($Kind.Term.show.app term$0 path$1 args$2) (let ((self0 term$0)) (case (get self0 0) ('Kind.Term.var (let ((f0 (get self0 1))(f1 (get self0 2))) ($Kind.Term.show.app.done term$0 path$1 args$2))) ('Kind.Term.ref (let ((f0 (get self0 1))) ($Kind.Term.show.app.done term$0 path$1 args$2))) ('Kind.Term.typ (let () ($Kind.Term.show.app.done term$0 path$1 args$2))) ('Kind.Term.all (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))) ($Kind.Term.show.app.done term$0 path$1 args$2))) ('Kind.Term.lam (let ((f0 (get self0 1))(f1 (get self0 2))) ($Kind.Term.show.app.done term$0 path$1 args$2))) ('Kind.Term.app (let ((f0 (get self0 1))(f1 (get self0 2))) ($Kind.Term.show.app f0 ($Kind.MPath.o path$1) ($List.cons ($Kind.Term.show.go f1 ($Kind.MPath.i path$1)) args$2)))) ('Kind.Term.let (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Kind.Term.show.app.done term$0 path$1 args$2))) ('Kind.Term.def (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Kind.Term.show.app.done term$0 path$1 args$2))) ('Kind.Term.ann (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Kind.Term.show.app.done term$0 path$1 args$2))) ('Kind.Term.gol (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Kind.Term.show.app.done term$0 path$1 args$2))) ('Kind.Term.hol (let ((f0 (get self0 1))) ($Kind.Term.show.app.done term$0 path$1 args$2))) ('Kind.Term.nat (let ((f0 (get self0 1))) ($Kind.Term.show.app.done term$0 path$1 args$2))) ('Kind.Term.chr (let ((f0 (get self0 1))) ($Kind.Term.show.app.done term$0 path$1 args$2))) ('Kind.Term.str (let ((f0 (get self0 1))) ($Kind.Term.show.app.done term$0 path$1 args$2))) ('Kind.Term.cse (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))(f5 (get self0 6))) ($Kind.Term.show.app.done term$0 path$1 args$2))) ('Kind.Term.ori (let ((f0 (get self0 1))(f1 (get self0 2))) ($Kind.Term.show.app f1 path$1 args$2))))))
(define Kind.Term.show.app (lambda (term$0) (lambda (path$1) (lambda (args$2) ($Kind.Term.show.app term$0 path$1 args$2)))))
(define ($U16.show_hex a$0) (let ((self0 a$0)) (case #t (#t (let ((f0 (u16-to-word self0))) ($Nat.to_string_base 16 ($Bits.to_nat ($Word.to_bits f0))))))))
(define U16.show_hex (lambda (a$0) ($U16.show_hex a$0)))
(define ($Kind.Code.escape.char chr$0) (let ((self0 ($U16.eql chr$0 Kind.Code.backslash))) (case self0 (#t (let () ($String.cons Kind.Code.backslash ($String.cons chr$0 String.nil)))) (#f (let () (let ((self0 ($U16.eql chr$0 34))) (case self0 (#t (let () ($String.cons Kind.Code.backslash ($String.cons chr$0 String.nil)))) (#f (let () (let ((self0 ($U16.eql chr$0 39))) (case self0 (#t (let () ($String.cons Kind.Code.backslash ($String.cons chr$0 String.nil)))) (#f (let () (let ((self0 ($U16.btw 32 chr$0 126))) (case self0 (#t (let () ($String.cons chr$0 String.nil))) (#f (let () ($String.concat ($String.cons Kind.Code.backslash String.nil) ($String.concat "u{" ($String.concat ($U16.show_hex chr$0) "}"))))))))))))))))))))
(define Kind.Code.escape.char (lambda (chr$0) ($Kind.Code.escape.char chr$0)))
(define ($Kind.Code.escape.go str$0 result$1) (let ((self0 str$0)) (case (= (string-length self0) 0) (#t (let () ($String.reverse result$1))) (#f (let ((f0 (char->integer (string-ref self0 0)))(f1 (let ((_str_ self0)) (substring _str_ 1 (string-length _str_))))) ($Kind.Code.escape.go f1 ($String.concat ($String.reverse ($Kind.Code.escape.char f0)) result$1)))))))
(define Kind.Code.escape.go (lambda (str$0) (lambda (result$1) ($Kind.Code.escape.go str$0 result$1))))
(define ($Kind.Code.escape str$0) ($Kind.Code.escape.go str$0 ""))
(define Kind.Code.escape (lambda (str$0) ($Kind.Code.escape str$0)))
(define ($BitsMap.to_list xs$1) ($List.reverse ($BitsMap.to_list.go xs$1 Bits.e List.nil)))
(define BitsMap.to_list (lambda (xs$1) ($BitsMap.to_list xs$1)))
(define ($Kind.Term.show.go term$0 path$1) (let ((self0 ($Kind.Term.show.as_nat term$0))) (case (get self0 0) ('Maybe.none (let () (let ((self0 term$0)) (case (get self0 0) ('Kind.Term.var (let ((f0 (get self0 1))(f1 (get self0 2))) ($Kind.Name.show f0))) ('Kind.Term.ref (let ((f0 (get self0 1))) (let ((name$3 ($Kind.Name.show f0))) (let ((self2 path$1)) (case (get self2 0) ('Maybe.none (let () name$3)) ('Maybe.some (let ((f2 (get self2 1))) (let ((path_val$5 ($Bits.concat ($Kind.Path.to_bits f2) ($Bits.i Bits.e)))) (let ((path_str$6 ($Nat.show ($Bits.to_nat path_val$5)))) ($String.flatten ($List.cons name$3 ($List.cons ($Kind.Code.color "2" ($String.concat "-" path_str$6)) List.nil)))))))))))) ('Kind.Term.typ (let () "Type")) ('Kind.Term.all (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))) (let ((eras$7 f0)) (let ((self$8 ($Kind.Name.show f1))) (let ((name$9 ($Kind.Name.show f2))) (let ((type$10 ($Kind.Term.show.go f3 ($Kind.MPath.o path$1)))) (let ((open$11 (let ((self9 eras$7)) (case self9 (#t (let () "<")) (#f (let () "(")))))) (let ((clos$12 (let ((self10 eras$7)) (case self10 (#t (let () ">")) (#f (let () ")")))))) (let ((body$13 ($Kind.Term.show.go ((f4 ($Kind.Term.var f1 0)) ($Kind.Term.var f2 0)) ($Kind.MPath.i path$1)))) ($String.flatten ($List.cons self$8 ($List.cons open$11 ($List.cons name$9 ($List.cons ":" ($List.cons type$10 ($List.cons clos$12 ($List.cons " " ($List.cons body$13 List.nil)))))))))))))))))) ('Kind.Term.lam (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((name$4 ($Kind.Name.show f0))) (let ((body$5 ($Kind.Term.show.go (f1 ($Kind.Term.var f0 0)) ($Kind.MPath.o path$1)))) ($String.flatten ($List.cons "(" ($List.cons name$4 ($List.cons ") " ($List.cons body$5 List.nil))))))))) ('Kind.Term.app (let ((f0 (get self0 1))(f1 (get self0 2))) ($Kind.Term.show.app term$0 path$1 List.nil))) ('Kind.Term.let (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((name$5 ($Kind.Name.show f0))) (let ((expr$6 ($Kind.Term.show.go f1 ($Kind.MPath.o path$1)))) (let ((body$7 ($Kind.Term.show.go (f2 ($Kind.Term.var f0 0)) ($Kind.MPath.i path$1)))) ($String.flatten ($List.cons "let " ($List.cons name$5 ($List.cons " = " ($List.cons expr$6 ($List.cons "; " ($List.cons body$7 List.nil)))))))))))) ('Kind.Term.def (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((name$5 ($Kind.Name.show f0))) (let ((expr$6 ($Kind.Term.show.go f1 ($Kind.MPath.o path$1)))) (let ((body$7 ($Kind.Term.show.go (f2 ($Kind.Term.var f0 0)) ($Kind.MPath.i path$1)))) ($String.flatten ($List.cons "def " ($List.cons name$5 ($List.cons " = " ($List.cons expr$6 ($List.cons "; " ($List.cons body$7 List.nil)))))))))))) ('Kind.Term.ann (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((term$5 ($Kind.Term.show.go f1 ($Kind.MPath.o path$1)))) (let ((type$6 ($Kind.Term.show.go f2 ($Kind.MPath.i path$1)))) ($String.flatten ($List.cons term$5 ($List.cons "::" ($List.cons type$6 List.nil)))))))) ('Kind.Term.gol (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((name$5 ($Kind.Name.show f0))) ($String.flatten ($List.cons "?" ($List.cons name$5 List.nil)))))) ('Kind.Term.hol (let ((f0 (get self0 1))) "_")) ('Kind.Term.nat (let ((f0 (get self0 1))) ($String.flatten ($List.cons ($Nat.show f0) List.nil)))) ('Kind.Term.chr (let ((f0 (get self0 1))) ($String.flatten ($List.cons "'" ($List.cons ($Kind.Code.escape.char f0) ($List.cons "'" List.nil)))))) ('Kind.Term.str (let ((f0 (get self0 1))) ($String.flatten ($List.cons "\"" ($List.cons ($Kind.Code.escape f0) ($List.cons "\"" List.nil)))))) ('Kind.Term.cse (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))(f5 (get self0 6))) (let ((expr$8 ($Kind.Term.show.go f1 ($Kind.MPath.o path$1)))) (let ((name$9 ($Kind.Name.show f2))) (let ((wyth$10 ($String.join "; " ($List.mapped f3 (lambda (with_var$10) (let ((self9 with_var$10)) (case (get self9 0) ('Kind.Ann.new (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) (let ((self12 f11)) (case (get self12 0) ('Maybe.none (let () f9)) ('Maybe.some (let ((f12 (get self12 1))) ($String.concat f9 ($String.concat ": " ($Kind.Term.show.go f12 Maybe.none)))))))))))))))) (let ((cses$11 ($BitsMap.to_list f4))) (let ((cses$12 ($String.join "" ($List.mapped cses$11 (lambda (x$12) (let ((name$13 ($Kind.Name.from_bits ($Pair.fst x$12)))) (let ((term$14 ($Kind.Term.show.go ($Pair.snd x$12) Maybe.none))) ($String.flatten ($List.cons name$13 ($List.cons ": " ($List.cons term$14 ($List.cons "; " List.nil)))))))))))) (let ((moti$13 (let ((self11 f5)) (case (get self11 0) ('Maybe.none (let () "")) ('Maybe.some (let ((f11 (get self11 1))) ($String.flatten ($List.cons ": " ($List.cons ($Kind.Term.show.go f11 Maybe.none) List.nil))))))))) ($String.flatten ($List.cons "case " ($List.cons expr$8 ($List.cons " as " ($List.cons name$9 ($List.cons wyth$10 ($List.cons " { " ($List.cons cses$12 ($List.cons "}" ($List.cons moti$13 List.nil)))))))))))))))))) ('Kind.Term.ori (let ((f0 (get self0 1))(f1 (get self0 2))) ($Kind.Term.show.go f1 path$1))))))) ('Maybe.some (let ((f0 (get self0 1))) f0)))))
(define Kind.Term.show.go (lambda (term$0) (lambda (path$1) ($Kind.Term.show.go term$0 path$1))))
(define ($Kind.Term.show term$0) ($Kind.Term.show.go term$0 Maybe.none))
(define Kind.Term.show (lambda (term$0) ($Kind.Term.show term$0)))
(define ($Kind.Defs.report.types defs$0 names$1) (let ((types$2 "")) (let ((types$3 ($List.for names$1 types$2 (lambda (name$3) (lambda (types$4) (let ((self3 ($Kind.Map.get name$3 defs$0))) (case (get self3 0) ('Maybe.none (let () types$4)) ('Maybe.some (let ((f3 (get self3 1))) (let ((self4 f3)) (case (get self4 0) ('Kind.Def.new (let ((f4 (get self4 1))(f5 (get self4 2))(f6 (get self4 3))(f7 (get self4 4))(f8 (get self4 5))(f9 (get self4 6))(f10 (get self4 7))(f11 (get self4 8))(f12 (get self4 9))) ($String.concat types$4 ($String.concat name$3 ($String.concat ": " ($String.concat ($Kind.Term.show f9) "\xA;"))))))))))))))))) types$3)))
(define Kind.Defs.report.types (lambda (defs$0) (lambda (names$1) ($Kind.Defs.report.types defs$0 names$1))))
(define ($List.filter f$1 xs$2) (let ((self0 xs$2)) (case (get self0 0) ('List.nil (let () List.nil)) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 (f$1 f0))) (case self2 (#t (let () ($List.cons f0 ($List.filter f$1 f1)))) (#f (let () ($List.filter f$1 f1))))))))))
(define List.filter (lambda (f$1) (lambda (xs$2) ($List.filter f$1 xs$2))))
(define ($Kind.Error.is_undef error$0) (let ((self0 error$0)) (case (get self0 0) ('Kind.Error.type_mismatch (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))) Bool.false)) ('Kind.Error.show_goal (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))) Bool.false)) ('Kind.Error.waiting (let ((f0 (get self0 1))) Bool.false)) ('Kind.Error.indirect (let ((f0 (get self0 1))) Bool.false)) ('Kind.Error.patch (let ((f0 (get self0 1))(f1 (get self0 2))) Bool.false)) ('Kind.Error.undefined_reference (let ((f0 (get self0 1))(f1 (get self0 2))) Bool.true)) ('Kind.Error.cant_infer (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) Bool.false)))))
(define Kind.Error.is_undef (lambda (error$0) ($Kind.Error.is_undef error$0)))
(define ($Kind.Error.is_mistake error$0) (let ((self0 error$0)) (case (get self0 0) ('Kind.Error.type_mismatch (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))) Bool.true)) ('Kind.Error.show_goal (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))) Bool.false)) ('Kind.Error.waiting (let ((f0 (get self0 1))) Bool.false)) ('Kind.Error.indirect (let ((f0 (get self0 1))) Bool.false)) ('Kind.Error.patch (let ((f0 (get self0 1))(f1 (get self0 2))) Bool.false)) ('Kind.Error.undefined_reference (let ((f0 (get self0 1))(f1 (get self0 2))) Bool.false)) ('Kind.Error.cant_infer (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) Bool.true)))))
(define Kind.Error.is_mistake (lambda (error$0) ($Kind.Error.is_mistake error$0)))
(define ($Kind.Error.is_goal error$0) (let ((self0 error$0)) (case (get self0 0) ('Kind.Error.type_mismatch (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))) Bool.false)) ('Kind.Error.show_goal (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))) Bool.true)) ('Kind.Error.waiting (let ((f0 (get self0 1))) Bool.false)) ('Kind.Error.indirect (let ((f0 (get self0 1))) Bool.false)) ('Kind.Error.patch (let ((f0 (get self0 1))(f1 (get self0 2))) Bool.false)) ('Kind.Error.undefined_reference (let ((f0 (get self0 1))(f1 (get self0 2))) Bool.false)) ('Kind.Error.cant_infer (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) Bool.false)))))
(define Kind.Error.is_goal (lambda (error$0) ($Kind.Error.is_goal error$0)))
(define ($Kind.Error.relevant errors$0) (let ((undefs$1 ($List.filter Kind.Error.is_undef errors$0))) (let ((mistakes$2 ($List.filter Kind.Error.is_mistake errors$0))) (let ((goals$3 ($List.filter Kind.Error.is_goal errors$0))) (let ((self3 undefs$1)) (case (get self3 0) ('List.nil (let () (let ((self3 mistakes$2)) (case (get self3 0) ('List.nil (let () goals$3)) ('List.cons (let ((f3 (get self3 1))(f4 (get self3 2))) ($List.concat ($List.cons f3 List.nil) goals$3))))))) ('List.cons (let ((f3 (get self3 1))(f4 (get self3 2))) ($List.concat undefs$1 goals$3)))))))))
(define Kind.Error.relevant (lambda (errors$0) ($Kind.Error.relevant errors$0)))
(define ($String.to_bits str$0) (let ((self0 str$0)) (case (= (string-length self0) 0) (#t (let () Bits.e)) (#f (let ((f0 (char->integer (string-ref self0 0)))(f1 (let ((_str_ self0)) (substring _str_ 1 (string-length _str_))))) ($Bits.concat ($U16.to_bits f0) ($String.to_bits f1)))))))
(define String.to_bits (lambda (str$0) ($String.to_bits str$0)))
(define ($Map.from_list xs$1) (let ((self0 xs$1)) (case (get self0 0) ('List.nil (let () BitsMap.new)) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 f0)) (case (get self2 0) ('Pair.new (let ((f2 (get self2 1))(f3 (get self2 2))) ($BitsMap.set ($String.to_bits f2) f3 ($Map.from_list f1)))))))))))
(define Map.from_list (lambda (xs$1) ($Map.from_list xs$1)))
(define ($Kind.Context.show context$0) (let ((self0 context$0)) (case (get self0 0) ('List.nil (let () "")) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 f0)) (case (get self2 0) ('Pair.new (let ((f2 (get self2 1))(f3 (get self2 2))) (let ((name$5 ($Kind.Name.show f2))) (let ((type$6 ($Kind.Term.show ($Kind.Term.normalize f3 Kind.Map.new)))) (let ((rest$7 ($Kind.Context.show f1))) ($String.concat rest$7 ($String.concat "- " ($String.concat name$5 ($String.concat ": " ($String.concat type$6 "\xA;")))))))))))))))))
(define Kind.Context.show (lambda (context$0) ($Kind.Context.show context$0)))
(define ($Kind.Term.expand_at path$0 term$1 defs$2) ($Kind.Term.patch_at path$0 term$1 (lambda (term$3) (let ((self1 term$3)) (case (get self1 0) ('Kind.Term.var (let ((f1 (get self1 1))(f2 (get self1 2))) term$3)) ('Kind.Term.ref (let ((f1 (get self1 1))) (let ((self2 ($Kind.Map.get f1 defs$2))) (case (get self2 0) ('Maybe.none (let () ($Kind.Term.ref f1))) ('Maybe.some (let ((f2 (get self2 1))) (let ((self3 f2)) (case (get self3 0) ('Kind.Def.new (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))(f6 (get self3 4))(f7 (get self3 5))(f8 (get self3 6))(f9 (get self3 7))(f10 (get self3 8))(f11 (get self3 9))) f7)))))))))) ('Kind.Term.typ (let () term$3)) ('Kind.Term.all (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))(f4 (get self1 4))(f5 (get self1 5))) term$3)) ('Kind.Term.lam (let ((f1 (get self1 1))(f2 (get self1 2))) term$3)) ('Kind.Term.app (let ((f1 (get self1 1))(f2 (get self1 2))) term$3)) ('Kind.Term.let (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))) term$3)) ('Kind.Term.def (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))) term$3)) ('Kind.Term.ann (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))) term$3)) ('Kind.Term.gol (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))) term$3)) ('Kind.Term.hol (let ((f1 (get self1 1))) term$3)) ('Kind.Term.nat (let ((f1 (get self1 1))) term$3)) ('Kind.Term.chr (let ((f1 (get self1 1))) term$3)) ('Kind.Term.str (let ((f1 (get self1 1))) term$3)) ('Kind.Term.cse (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))(f4 (get self1 4))(f5 (get self1 5))(f6 (get self1 6))) term$3)) ('Kind.Term.ori (let ((f1 (get self1 1))(f2 (get self1 2))) term$3)))))))
(define Kind.Term.expand_at (lambda (path$0) (lambda (term$1) (lambda (defs$2) ($Kind.Term.expand_at path$0 term$1 defs$2)))))
(define ($Kind.Term.expand_ct term$0 defs$1 arity$2) (let ((self0 term$0)) (case (get self0 0) ('Kind.Term.var (let ((f0 (get self0 1))(f1 (get self0 2))) ($Kind.Term.var f0 f1))) ('Kind.Term.ref (let ((f0 (get self0 1))) (let ((self1 ($Kind.Map.get f0 defs$1))) (case (get self1 0) ('Maybe.none (let () ($Kind.Term.ref f0))) ('Maybe.some (let ((f1 (get self1 1))) (let ((self2 f1)) (case (get self2 0) ('Kind.Def.new (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))(f5 (get self2 4))(f6 (get self2 5))(f7 (get self2 6))(f8 (get self2 7))(f9 (get self2 8))(f10 (get self2 9))) (let ((self11 ($Bool.and f8 ($Nat.gtn arity$2 f9)))) (case self11 (#t (let () f6)) (#f (let () ($Kind.Term.ref f0))))))))))))))) ('Kind.Term.typ (let () Kind.Term.typ)) ('Kind.Term.all (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))) ($Kind.Term.all f0 f1 f2 ($Kind.Term.expand_ct f3 defs$1 0) (lambda (s$8) (lambda (x$9) ($Kind.Term.expand_ct ((f4 s$8) x$9) defs$1 0)))))) ('Kind.Term.lam (let ((f0 (get self0 1))(f1 (get self0 2))) ($Kind.Term.lam f0 (lambda (x$5) ($Kind.Term.expand_ct (f1 x$5) defs$1 0))))) ('Kind.Term.app (let ((f0 (get self0 1))(f1 (get self0 2))) ($Kind.Term.app ($Kind.Term.expand_ct f0 defs$1 ($Nat.succ arity$2)) ($Kind.Term.expand_ct f1 defs$1 0)))) ('Kind.Term.let (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Kind.Term.let f0 ($Kind.Term.expand_ct f1 defs$1 0) (lambda (x$6) ($Kind.Term.expand_ct (f2 x$6) defs$1 0))))) ('Kind.Term.def (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Kind.Term.def f0 ($Kind.Term.expand_ct f1 defs$1 0) (lambda (x$6) ($Kind.Term.expand_ct (f2 x$6) defs$1 0))))) ('Kind.Term.ann (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Kind.Term.ann f0 ($Kind.Term.expand_ct f1 defs$1 0) ($Kind.Term.expand_ct f2 defs$1 0)))) ('Kind.Term.gol (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Kind.Term.gol f0 f1 f2))) ('Kind.Term.hol (let ((f0 (get self0 1))) ($Kind.Term.hol f0))) ('Kind.Term.nat (let ((f0 (get self0 1))) ($Kind.Term.nat f0))) ('Kind.Term.chr (let ((f0 (get self0 1))) ($Kind.Term.chr f0))) ('Kind.Term.str (let ((f0 (get self0 1))) ($Kind.Term.str f0))) ('Kind.Term.cse (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))(f5 (get self0 6))) term$0)) ('Kind.Term.ori (let ((f0 (get self0 1))(f1 (get self0 2))) ($Kind.Term.ori f0 f1))))))
(define Kind.Term.expand_ct (lambda (term$0) (lambda (defs$1) (lambda (arity$2) ($Kind.Term.expand_ct term$0 defs$1 arity$2)))))
(define ($Kind.Term.expand dref$0 term$1 defs$2) (let ((term$3 ($Kind.Term.normalize term$1 Kind.Map.new))) (let ((term$4 ($List.for dref$0 term$3 (lambda (path$4) (lambda (term$5) (let ((term$6 ($Kind.Term.expand_at path$4 term$5 defs$2))) (let ((term$7 ($Kind.Term.normalize term$6 Kind.Map.new))) (let ((term$8 ($Kind.Term.expand_ct term$7 defs$2 0))) (let ((term$9 ($Kind.Term.normalize term$8 Kind.Map.new))) term$9))))))))) term$4)))
(define Kind.Term.expand (lambda (dref$0) (lambda (term$1) (lambda (defs$2) ($Kind.Term.expand dref$0 term$1 defs$2)))))
(define ($Kind.Error.show error$0 defs$1) (let ((self0 error$0)) (case (get self0 0) ('Kind.Error.type_mismatch (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))) (let ((expected$6 (let ((self4 f1)) (case (get self4 0) ('Either.left (let ((f4 (get self4 1))) f4)) ('Either.right (let ((f4 (get self4 1))) ($Kind.Term.show ($Kind.Term.normalize f4 ($Map.from_list List.nil))))))))) (let ((detected$7 (let ((self5 f2)) (case (get self5 0) ('Either.left (let ((f5 (get self5 1))) f5)) ('Either.right (let ((f5 (get self5 1))) ($Kind.Term.show ($Kind.Term.normalize f5 ($Map.from_list List.nil))))))))) ($String.concat "Type mismatch.\xA;" ($String.concat "- Expected: " ($String.concat expected$6 ($String.concat "\xA;" ($String.concat "- Detected: " ($String.concat detected$7 ($String.concat "\xA;" (let ((self6 f3)) (case (get self6 0) ('List.nil (let () "")) ('List.cons (let ((f6 (get self6 1))(f7 (get self6 2))) ($String.concat "With context:\xA;" ($Kind.Context.show f3))))))))))))))))) ('Kind.Error.show_goal (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))) (let ((goal_name$7 ($String.concat "Goal ?" ($String.concat ($Kind.Name.show f0) ":\xA;")))) (let ((with_type$8 (let ((self6 f3)) (case (get self6 0) ('Maybe.none (let () "")) ('Maybe.some (let ((f6 (get self6 1))) (let ((goal$9 ($Kind.Term.expand f1 f6 defs$1))) ($String.concat "With type: " ($String.concat (let ((self8 f2)) (case self8 (#t (let () ($Kind.Term.show.go goal$9 ($Maybe.some (lambda (x$10) x$10))))) (#f (let () ($Kind.Term.show goal$9))))) "\xA;"))))))))) (let ((with_ctxt$9 (let ((self7 f4)) (case (get self7 0) ('List.nil (let () "")) ('List.cons (let ((f7 (get self7 1))(f8 (get self7 2))) ($String.concat "With context:\xA;" ($Kind.Context.show f4)))))))) ($String.flatten ($List.cons goal_name$7 ($List.cons with_type$8 ($List.cons with_ctxt$9 List.nil))))))))) ('Kind.Error.waiting (let ((f0 (get self0 1))) ($String.concat "Waiting for '" ($String.concat f0 "'.")))) ('Kind.Error.indirect (let ((f0 (get self0 1))) ($String.concat "Error on dependency '" ($String.concat f0 "'.")))) ('Kind.Error.patch (let ((f0 (get self0 1))(f1 (get self0 2))) ($String.concat "Patching: " ($Kind.Term.show f1)))) ('Kind.Error.undefined_reference (let ((f0 (get self0 1))(f1 (get self0 2))) ($String.concat "Undefined reference: " ($String.concat ($Kind.Name.show f1) "\xA;")))) ('Kind.Error.cant_infer (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((term$5 ($Kind.Term.show f1))) (let ((context$6 ($Kind.Context.show f2))) ($String.concat "Can't infer type of: " ($String.concat term$5 ($String.concat "\xA;" ($String.concat "With context:\xA;" context$6)))))))))))
(define Kind.Error.show (lambda (error$0) (lambda (defs$1) ($Kind.Error.show error$0 defs$1))))
(define ($Kind.Error.origin error$0) (let ((self0 error$0)) (case (get self0 0) ('Kind.Error.type_mismatch (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))) f0)) ('Kind.Error.show_goal (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))) Maybe.none)) ('Kind.Error.waiting (let ((f0 (get self0 1))) Maybe.none)) ('Kind.Error.indirect (let ((f0 (get self0 1))) Maybe.none)) ('Kind.Error.patch (let ((f0 (get self0 1))(f1 (get self0 2))) Maybe.none)) ('Kind.Error.undefined_reference (let ((f0 (get self0 1))(f1 (get self0 2))) f0)) ('Kind.Error.cant_infer (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) f0)))))
(define Kind.Error.origin (lambda (error$0) ($Kind.Error.origin error$0)))
(define ($Kind.Defs.report.errors defs$0) (let ((errors$1 "")) (let ((errors$2 ($List.for ($BitsMap.keys defs$0) errors$1 (lambda (key$2) (lambda (errors$3) (let ((name$4 ($Kind.Name.from_bits key$2))) (let ((defn$5 ($Kind.Map.get name$4 defs$0))) (let ((self5 defn$5)) (case (get self5 0) ('Maybe.none (let () errors$3)) ('Maybe.some (let ((f5 (get self5 1))) (let ((self6 f5)) (case (get self6 0) ('Kind.Def.new (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))(f9 (get self6 4))(f10 (get self6 5))(f11 (get self6 6))(f12 (get self6 7))(f13 (get self6 8))(f14 (get self6 9))) (let ((self15 f14)) (case (get self15 0) ('Kind.Status.init (let () errors$3)) ('Kind.Status.wait (let () errors$3)) ('Kind.Status.done (let ((f15 (get self15 1))) errors$3)) ('Kind.Status.fail (let ((f15 (get self15 1))) (let ((self16 f15)) (case (get self16 0) ('List.nil (let () errors$3)) ('List.cons (let ((f16 (get self16 1))(f17 (get self16 2))) (let ((name_str$19 f9)) (let ((rel_errs$20 ($Kind.Error.relevant f15))) (let ((errors$21 ($List.for rel_errs$20 errors$3 (lambda (err$21) (lambda (errors$22) (let ((err_msg$23 ($Kind.Error.show err$21 defs$0))) (let ((ori_val$24 ($Kind.Error.origin err$21))) (let ((self24 ori_val$24)) (case (get self24 0) ('Maybe.none (let () ($String.concat errors$22 ($String.concat err_msg$23 "\xA;")))) ('Maybe.some (let ((f24 (get self24 1))) (let ((self25 f24)) (case (get self25 0) ('Pair.new (let ((f25 (get self25 1))(f26 (get self25 2))) (let ((inside$28 ($String.concat "Inside '" ($String.concat f6 "':\xA;")))) (let ((source$29 ($Kind.Code.highlight f7 f25 f26))) ($String.concat errors$22 ($String.concat err_msg$23 ($String.concat inside$28 ($String.concat source$29 ($String.concat "\xA;" "\xA;")))))))))))))))))))))) errors$21)))))))))))))))))))))))))) errors$2)))
(define Kind.Defs.report.errors (lambda (defs$0) ($Kind.Defs.report.errors defs$0)))
(define ($Kind.Defs.report defs$0 names$1) (let ((types$2 ($Kind.Defs.report.types defs$0 names$1))) (let ((errors$3 ($Kind.Defs.report.errors defs$0))) (let ((errors$4 (let ((self2 errors$3)) (case (= (string-length self2) 0) (#t (let () "All terms check.")) (#f (let ((f2 (char->integer (string-ref self2 0)))(f3 (let ((_str_ self2)) (substring _str_ 1 (string-length _str_))))) errors$3)))))) ($String.concat types$2 ($String.concat "\xA;" errors$4))))))
(define Kind.Defs.report (lambda (defs$0) (lambda (names$1) ($Kind.Defs.report defs$0 names$1))))
(define ($IO.set_file name$0 content$1) ($IO.ask "set_file" ($String.concat name$0 ($String.concat "=" content$1)) (lambda (ok$2) ($IO.end Unit.new))))
(define IO.set_file (lambda (name$0) (lambda (content$1) ($IO.set_file name$0 content$1))))
(define ($Kind.Core.var_name indx$0 name$1 brui$2 vars$3) (let ((self0 indx$0)) (case (= self0 0) (#t (let () (let ((self0 brui$2)) (case (= self0 0) (#t (let () name$1)) (#f (let ((f0 (- self0 1))) ($String.concat name$1 ($String.concat "^" ($Nat.show brui$2))))))))) (#f (let ((f0 (- self0 1))) (let ((self1 vars$3)) (case (get self1 0) ('List.nil (let () "unbound")) ('List.cons (let ((f1 (get self1 1))(f2 (get self1 2))) (let ((brui$7 (let ((self3 ($String.eql name$1 f1))) (case self3 (#t (let () ($Nat.succ brui$2))) (#f (let () brui$2)))))) ($Kind.Core.var_name f0 name$1 brui$7 f2)))))))))))
(define Kind.Core.var_name (lambda (indx$0) (lambda (name$1) (lambda (brui$2) (lambda (vars$3) ($Kind.Core.var_name indx$0 name$1 brui$2 vars$3))))))
(define ($Kind.Core.show.go term$0 indx$1 vars$2) (let ((self0 term$0)) (case (get self0 0) ('Kind.Term.var (let ((f0 (get self0 1))(f1 (get self0 2))) ($Kind.Core.var_name ($Nat.pred ($Nat.sub indx$1 f1)) f0 0 vars$2))) ('Kind.Term.ref (let ((f0 (get self0 1))) ($Kind.Name.show f0))) ('Kind.Term.typ (let () "*")) ('Kind.Term.all (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))) (let ((eras$8 f0)) (let ((init$9 (let ((self6 eras$8)) (case self6 (#t (let () "%")) (#f (let () "@")))))) (let ((self$10 ($Kind.Name.show f1))) (let ((name$11 ($Kind.Name.show f2))) (let ((xtyp$12 ($Kind.Core.show.go f3 indx$1 vars$2))) (let ((body$13 ($Kind.Core.show.go ((f4 ($Kind.Term.var f1 indx$1)) ($Kind.Term.var f2 ($Nat.succ indx$1))) ($Nat.succ ($Nat.succ indx$1)) ($List.cons f2 ($List.cons f1 vars$2))))) ($String.flatten ($List.cons init$9 ($List.cons self$10 ($List.cons "(" ($List.cons name$11 ($List.cons ":" ($List.cons xtyp$12 ($List.cons ") " ($List.cons body$13 List.nil))))))))))))))))) ('Kind.Term.lam (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((name$5 ($Kind.Name.show f0))) (let ((body$6 ($Kind.Core.show.go (f1 ($Kind.Term.var f0 indx$1)) ($Nat.succ indx$1) ($List.cons f0 vars$2)))) ($String.flatten ($List.cons "#" ($List.cons name$5 ($List.cons " " ($List.cons body$6 List.nil))))))))) ('Kind.Term.app (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((func$5 ($Kind.Core.show.go f0 indx$1 vars$2))) (let ((argm$6 ($Kind.Core.show.go f1 indx$1 vars$2))) ($String.flatten ($List.cons "(" ($List.cons func$5 ($List.cons " " ($List.cons argm$6 ($List.cons ")" List.nil)))))))))) ('Kind.Term.let (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((name$6 ($Kind.Name.show f0))) (let ((expr$7 ($Kind.Core.show.go f1 indx$1 vars$2))) (let ((body$8 ($Kind.Core.show.go (f2 ($Kind.Term.var f0 indx$1)) ($Nat.succ indx$1) ($List.cons f0 vars$2)))) ($String.flatten ($List.cons "!" ($List.cons name$6 ($List.cons " = " ($List.cons expr$7 ($List.cons "; " ($List.cons body$8 List.nil)))))))))))) ('Kind.Term.def (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((name$6 ($Kind.Name.show f0))) (let ((expr$7 ($Kind.Core.show.go f1 indx$1 vars$2))) (let ((body$8 ($Kind.Core.show.go (f2 ($Kind.Term.var f0 indx$1)) ($Nat.succ indx$1) ($List.cons f0 vars$2)))) ($String.flatten ($List.cons "$" ($List.cons name$6 ($List.cons " = " ($List.cons expr$7 ($List.cons "; " ($List.cons body$8 List.nil)))))))))))) ('Kind.Term.ann (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((term$6 ($Kind.Core.show.go f1 indx$1 vars$2))) (let ((type$7 ($Kind.Core.show.go f2 indx$1 vars$2))) ($String.flatten ($List.cons "{" ($List.cons term$6 ($List.cons ":" ($List.cons type$7 ($List.cons "}" List.nil)))))))))) ('Kind.Term.gol (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) "<GOL>")) ('Kind.Term.hol (let ((f0 (get self0 1))) "<HOL>")) ('Kind.Term.nat (let ((f0 (get self0 1))) ($String.flatten ($List.cons "+" ($List.cons ($Nat.show f0) List.nil))))) ('Kind.Term.chr (let ((f0 (get self0 1))) ($String.flatten ($List.cons "'" ($List.cons ($Kind.Code.escape.char f0) ($List.cons "'" List.nil)))))) ('Kind.Term.str (let ((f0 (get self0 1))) ($String.flatten ($List.cons "\"" ($List.cons ($Kind.Code.escape f0) ($List.cons "\"" List.nil)))))) ('Kind.Term.cse (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))(f5 (get self0 6))) "<CSE>")) ('Kind.Term.ori (let ((f0 (get self0 1))(f1 (get self0 2))) ($Kind.Core.show.go f1 indx$1 vars$2))))))
(define Kind.Core.show.go (lambda (term$0) (lambda (indx$1) (lambda (vars$2) ($Kind.Core.show.go term$0 indx$1 vars$2)))))
(define ($Kind.Core.show term$0) ($Kind.Core.show.go term$0 0 List.nil))
(define Kind.Core.show (lambda (term$0) ($Kind.Core.show term$0)))
(define ($Bool.show b$0) (let ((self0 b$0)) (case self0 (#t (let () "Bool.true")) (#f (let () "Bool.false")))))
(define Bool.show (lambda (b$0) ($Bool.show b$0)))
(define ($Kind.Defs.cache.go kvs$0) (let ((self0 kvs$0)) (case (get self0 0) ('List.nil (let () ((let ((self0 IO.monad)) (case (get self0 0) ('Monad.new (let ((f0 (get self0 1))(f1 (get self0 2))) f1)))) Unit.new))) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 f0)) (case (get self2 0) ('Pair.new (let ((f2 (get self2 1))(f3 (get self2 2))) (let ((self4 f3)) (case (get self4 0) ('Kind.Def.new (let ((f4 (get self4 1))(f5 (get self4 2))(f6 (get self4 3))(f7 (get self4 4))(f8 (get self4 5))(f9 (get self4 6))(f10 (get self4 7))(f11 (get self4 8))(f12 (get self4 9))) (let ((self13 f12)) (case (get self13 0) ('Kind.Status.init (let () ($Kind.Defs.cache.go f1))) ('Kind.Status.wait (let () ($Kind.Defs.cache.go f1))) ('Kind.Status.done (let ((f13 (get self13 1))) (((let ((self14 IO.monad)) (case (get self14 0) ('Monad.new (let ((f14 (get self14 1))(f15 (get self14 2))) f14)))) ($IO.get_file_mtime f4)) (lambda (time$15) (((let ((self15 IO.monad)) (case (get self15 0) ('Monad.new (let ((f15 (get self15 1))(f16 (get self15 2))) f15)))) ($IO.set_file ($String.concat ".cache/" ($String.concat f2 ".term")) ($Kind.Core.show f8))) (lambda ($16) (((let ((self16 IO.monad)) (case (get self16 0) ('Monad.new (let ((f16 (get self16 1))(f17 (get self16 2))) f16)))) ($IO.set_file ($String.concat ".cache/" ($String.concat f2 ".type")) ($Kind.Core.show f9))) (lambda ($17) (((let ((self17 IO.monad)) (case (get self17 0) ('Monad.new (let ((f17 (get self17 1))(f18 (get self17 2))) f17)))) ($IO.set_file ($String.concat ".cache/" ($String.concat f2 ".isct")) ($Bool.show f10))) (lambda ($18) (((let ((self18 IO.monad)) (case (get self18 0) ('Monad.new (let ((f18 (get self18 1))(f19 (get self18 2))) f18)))) ($IO.set_file ($String.concat ".cache/" ($String.concat f2 ".arit")) ($Nat.show f11))) (lambda ($19) (((let ((self19 IO.monad)) (case (get self19 0) ('Monad.new (let ((f19 (get self19 1))(f20 (get self19 2))) f19)))) ($IO.set_file ($String.concat ".cache/" ($String.concat f2 ".file")) f4)) (lambda ($20) (((let ((self20 IO.monad)) (case (get self20 0) ('Monad.new (let ((f20 (get self20 1))(f21 (get self20 2))) f20)))) ($IO.set_file ($String.concat ".cache/" ($String.concat f2 ".time")) time$15)) (lambda ($21) ($Kind.Defs.cache.go f1))))))))))))))))) ('Kind.Status.fail (let ((f13 (get self13 1))) ($Kind.Defs.cache.go f1))))))))))))))))))
(define Kind.Defs.cache.go (lambda (kvs$0) ($Kind.Defs.cache.go kvs$0)))
(define ($Kind.Defs.cache defs$0) ($Kind.Defs.cache.go ($Kind.Map.to_list defs$0)))
(define Kind.Defs.cache (lambda (defs$0) ($Kind.Defs.cache defs$0)))
(define ($Kind.api.io.check_file file$0) (((let ((self0 IO.monad)) (case (get self0 0) ('Monad.new (let ((f0 (get self0 1))(f1 (get self0 2))) f0)))) ($Kind.Synth.file file$0 Kind.Map.new)) (lambda (loaded$1) (let ((self1 loaded$1)) (case (get self1 0) ('Either.left (let ((f1 (get self1 1))) (((let ((self2 IO.monad)) (case (get self2 0) ('Monad.new (let ((f2 (get self2 1))(f3 (get self2 2))) f2)))) ($IO.print ($String.flatten ($List.cons "On '" ($List.cons file$0 ($List.cons "':" List.nil)))))) (lambda ($3) ($IO.print f1))))) ('Either.right (let ((f1 (get self1 1))) (let ((self2 f1)) (case (get self2 0) ('Pair.new (let ((f2 (get self2 1))(f3 (get self2 2))) (let ((nams$5 f2)) (let ((defs$6 f3)) (let ((self6 nams$5)) (case (get self6 0) ('List.nil (let () ($IO.print ($String.concat "File not found or empty: '" ($String.concat file$0 "'."))))) ('List.cons (let ((f6 (get self6 1))(f7 (get self6 2))) (((let ((self8 IO.monad)) (case (get self8 0) ('Monad.new (let ((f8 (get self8 1))(f9 (get self8 2))) f8)))) ($IO.print ($Kind.Defs.report defs$6 nams$5))) (lambda ($9) ($Kind.Defs.cache defs$6))))))))))))))))))))
(define Kind.api.io.check_file (lambda (file$0) ($Kind.api.io.check_file file$0)))
(define ($Test.main) ($Kind.api.io.check_file "./Kind/api/export.kind"))
(define Test.main ($Test.main))
(run_io Test.main)
