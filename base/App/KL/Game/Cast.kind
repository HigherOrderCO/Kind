type App.KL.Game.Cast {
  new(
    player: String
    target: Hexagonal.Axial
    letter: Char
  )
}

type App.KL.Game.Cast.Preview {
  new(
    skill: Maybe<App.KL.Game.Skill>
    picks: App.KL.Game.Picks
  )
}

type App.KL.Game.Cast.Result {
  failure
  success(
    game: App.KL.Game
    hits: App.KL.Game.Indicators
    ap_used: I32
  )
}

// Pushes a cast to a cast list
App.KL.Game.Cast.push(
  player: String
  target: Hexagonal.Axial
  letter: Char
  casts: List<App.KL.Game.Cast>
): List<App.KL.Game.Cast>
  App.KL.Game.Cast.new(player, target, letter) & casts

// Returns the current picks of a player as a map of Coord->Letter
App.KL.Game.Cast.picks_of(
  player: String
  game: App.KL.Game
): App.KL.Game.Picks
  let result = {{}, Hexagonal.Axial.BBT.new! } :: Pair<Map<Unit>, App.KL.Game.Picks>
  let casts  = game@casts

  for cast in casts with result:
    open cast
    let {seen, map} = result
    if player =? cast.player then
      let skill = App.KL.Game.Cast.get_skill(cast, game)
      let letter = Char.to_string(cast.letter)
      case skill seen{letter} {
        some none: 
          { seen{letter} <- unit, Hexagonal.Axial.BBT.set!(cast.target, cast.letter, map) }
      } default {seen, map}
    else
      result
  
  result@snd
  
// Gets the skill associated with a cast
App.KL.Game.Cast.get_skill(
  cast: App.KL.Game.Cast
  game: App.KL.Game
): Maybe<App.KL.Game.Skill>
  App.KL.Game.Skill.get(cast@player, cast@letter, game)
  
// Gets the skill associated with a cast
App.KL.Game.Cast.get_skill(
  cast: App.KL.Game.Cast
  game: App.KL.Game
): Maybe<App.KL.Game.Skill>
  open game
  open cast
  Maybe {
    get player = game.players{cast@player}
    get hero_id = player@hero_id
    get hero = App.KL.Game.Hero.get_by_id(hero_id)
    get skill = hero@skills{Char.to_string(cast.letter)}
    return skill
  }

// Gets the coord associated with a cast
App.KL.Game.Cast.get_coord(
  cast: App.KL.Game.Cast
  game: App.KL.Game
): Maybe<Hexagonal.Axial>
  App.KL.Game.Board.find_player_coord(cast@player, game@board)

// Gets the creature associated with a cast
App.KL.Game.Cast.get_creature(
  cast: App.KL.Game.Cast
  game: App.KL.Game
): Maybe<App.KL.Game.Creature>
  Maybe {
    get coord = App.KL.Game.Cast.get_coord(cast, game)
    get tile = Hexagonal.Axial.BBT.get!(coord, game@board)
    tile@creature
  }

// Gets the hero associated with a cast
App.KL.Game.Cast.get_hero(
  cast: App.KL.Game.Cast
  game: App.KL.Game
): Maybe<App.KL.Game.Hero>
  Maybe {
    get creature = App.KL.Game.Cast.get_creature(cast, game)
    return creature@hero
  }

// Sorts a game's casts by delay, in ascending order, removing duplicates
App.KL.Game.Cast.sort(game: App.KL.Game): List<App.KL.Game.Cast>
  open game
  let state = {{}, []} :: Pair<Map<Unit>, List<Pair<App.KL.Game.Cast,U64>>>
  for cast in game.casts with state:
    let {seen, casts} = state
    let key = cast@player | "::" | Char.to_string(cast@letter)
    case seen{key} as got {
      none: 
        let seen = seen{key} <- unit
        case App.KL.Game.Cast.get_skill(cast, game) as got_skill {
          none: {seen, casts}
          some: {seen, {cast, got_skill.value@delay} & casts}
        }
      some: {seen, casts}
    }
  let list = List.sort!((a,b) U64.cmp(a@snd, b@snd), state@snd)
  let list = List.map!!((a) a@fst, list)
  list

// Applies a cast, modifying the game state
App.KL.Game.Cast.apply(
  cast: App.KL.Game.Cast
  game: App.KL.Game
): App.KL.Game.Cast.Result
  open game
  open cast
  Maybe {
    get skill = App.KL.Game.Cast.get_skill(cast, game)
    get coord = App.KL.Game.Cast.get_coord(cast, game)
    let result = skill@effect(coord, cast@target, game@board)
    return case result {
      err: App.KL.Game.Cast.Result.failure
      new: App.KL.Game.Cast.Result.success(game@board <- result.board, result.indicators, result.ap_used)
    }
  } <> App.KL.Game.Cast.Result.failure


// TODO: modularize
// Runs all casts up to a given delay with a filter
App.KL.Game.Cast.simulate(
  max_delay: U64
  filter: App.KL.Game.Cast -> Bool
  game: App.KL.Game
): App.KL.Game
  let casts = App.KL.Game.Cast.sort(game)
  let casts = List.filter!(filter, casts)
  App.KL.Game.Cast.simulate.go(casts, max_delay, game)

App.KL.Game.Cast.simulate.go(
  casts: List<App.KL.Game.Cast>
  max_delay: U64
  game: App.KL.Game
): App.KL.Game
  open game
  Maybe {
    get cast = List.head!(casts)
    get skill = App.KL.Game.Cast.get_skill(cast, game)
    let cast_delay = skill@delay
    if cast_delay <? max_delay then Maybe {
      let result = App.KL.Game.Cast.apply(cast, game)
      let game = case result {
        failure: game
        success: result.game
      }
      return App.KL.Game.Cast.simulate.go(List.tail!(casts), max_delay, game)
    } else Maybe {
      return game
    }
  } <> game
