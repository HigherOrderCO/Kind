App.KL.Game.Phase.Play.when(
  local: App.KL.Game.State.Local
  game: App.KL.Game
  event: App.Event,
): IO<Maybe<App.State.local<App.KL.State>>>
  let room = String.take(16, Crypto.Keccak.hash(local@room))
  let controls = local@hud

  open game
  case event {
    frame:
      open event.info
      log("Screen size: " | U32.show(local@screen_size@fst) | ", " | U32.show(local@screen_size@snd))
      let picks = App.KL.Game.Cast.picks_of(local@user, game)
      let new_local = local@preview <- (local@preview@picks <- picks)
      let new_local = new_local@screen_size <- event.info.screen_size
      App.set_local!(App.KL.State.Local.game(new_local))
    mouse_move:
      // mouse move on canvas
      if String.eql("game_screen", event.id) then
        let {x,y} = event.mouse_pos
        let local = local@hud <- local@hud@skill <- none
        let local = local@mouse <- {x / 2, y / 2}
        App.set_local!(App.KL.State.Local.game(local))
      // mouse move on interface
      else
        let default_controls = App.KL.Game.Controls.Hud.initial
        let controls = 
          switch String.starts_with(event.id) {
            // hover on skills
            "SK":
              let key = String.drop(2, event.id)
              Maybe {
                get user     = game@players{local@user}
                get hero_id  = user@hero_id
                get hero     = App.KL.Game.Hero.get_by_id(hero_id)
                get skill    = hero@skills{key}
                let controls = local@hud@skill <- some(skill)
                return controls
              } <> controls
          } default controls
        let local = local@hud <- controls
        App.set_local!(App.KL.State.Local.game(local))
    key_down:
      // if tab (esc) pressed 
      if event.code =? 32#16 then
        log("ENTROU")
        let local = App.KL.Game.Phase.Play.when.invert_tab(true, controls, local)
        App.set_local!(App.KL.State.Local.game(local))
      else 
        case game@moment {
          preparation:
            let preview = local@preview
            switch U16.eql(event.code) {
              
              27#16:
                let preview = preview@skill <- none
                IO {
                  App.new_post!(room, App.KL.Game.Phase.Play.Event.cast.cancel_casts)
                  App.set_local!(App.KL.State.Local.game(local@preview <- preview))
                }
            }default
            local = 
              Maybe {
                get casted_skill  = App.KL.Game.Skill.get(local@user, event.code, game)
                let skill       =
                  case preview@skill as skill {
                    none: 
                      some({event.code, 1})
                    some:
                      if skill.value@fst =? event.code then
                        none
                      else 
                        some({event.code, 1})
                  }          
                return local@preview <- preview@skill <- skill
              } <> local
            IO {
              App.new_post!(room, App.KL.Game.Phase.Play.Event.cast.cancel_skill(event.code))
              App.set_local!(App.KL.State.Local.game(local))
            }
        } default App.pass!
    key_up:
      // if tab (esc) released
      if event.code =? 32#16 then
        log("SAIU")
        let local = App.KL.Game.Phase.Play.when.invert_tab(false, controls, local)
        App.set_local!(App.KL.State.Local.game(local))
      else
        App.pass!
    mouse_down: 
      case game.moment {
        initial:
          App.KL.Game.Phase.Play.when.initial.mouse_down(room, local, game)
        preparation:
          App.KL.Game.Phase.Play.when.preparation.mouse_down(room, local, game)
        execution:
          let preview = local@preview
          let preview = preview@skill <- none
          App.set_local!(App.KL.State.Local.game(local@preview <- preview))
      }
    mouse_click:
      // switch tab
      let local = App.KL.Game.Phase.Play.when.switch_tab(event.id, local)
      App.set_local!(App.KL.State.Local.game(local))
  } default App.pass!

App.KL.Game.Phase.Play.when.switch_tab(
  event_id: String
  local: App.KL.Game.State.Local
): App.KL.Game.State.Local
  let controls = local@hud
  let actual_tab = controls@tab_which
  let to_string  = App.KL.Game.Controls.Hud.Tab.show
  let stats  = App.KL.Game.Controls.Hud.Tab.stats
  let skills = App.KL.Game.Controls.Hud.Tab.skills
  let recap  = App.KL.Game.Controls.Hud.Tab.recap
  let tab = switch String.eql(event_id) {
    to_string(stats): stats
    to_string(recap): recap
    to_string(skills): skills
  } default actual_tab

  let controls = controls@tab_which <- tab
  let local = local@hud <- controls
  local

App.KL.Game.Phase.Play.when.invert_tab(
  active: Bool
  controls: App.KL.Game.Controls.Hud
  local: App.KL.Game.State.Local
): App.KL.Game.State.Local
  let controls = controls@tab_active <- active
  let local = local@hud <- controls
  local

App.KL.Game.Phase.Play.when.initial.mouse_down(room: String, local: App.KL.Game.State.Local, game: App.KL.Game): IO<Maybe<App.State.local<App.KL.State>>>
  let coord = Hexagonal.Axial.from_screen_xy(local@mouse, App.KL.Constants.hexagon_radius, U32.to_i32(local@screen_size@fst) / 4, U32.to_i32(local@screen_size@snd) / 4)
  
  if App.KL.Game.Board.Blueprint.base.valid(coord, local@user, game@players, game@blueprint) then
    App.new_post!(room, App.KL.Game.Phase.Play.Event.set_init_pos.serial(coord))
  else
    App.pass!

  

App.KL.Game.Phase.Play.when.preparation.mouse_down(room: String, local: App.KL.Game.State.Local, game: App.KL.Game): IO<Maybe<App.State.local<App.KL.State>>>
  let preview = local@preview
  case preview@skill as skill{
    none:
      let coord = Hexagonal.Axial.from_screen_xy(local@mouse, App.KL.Constants.hexagon_radius, U32.to_i32(local@screen_size@fst) / 4, U32.to_i32(local@screen_size@snd) / 4)
      let new_local = local@info <- coord
      App.set_local!(App.KL.State.Local.game(new_local))
    some:
      let {char, count} = skill.value // Skill key and count for how many coords have been chosen after selecting skill
      let coord = Hexagonal.Axial.from_screen_xy(local@mouse, App.KL.Constants.hexagon_radius, U32.to_i32(local@screen_size@fst) / 4, U32.to_i32(local@screen_size@snd) / 4)
      let skill = App.KL.Game.Skill.get(local@user, char, game)
      case skill {
        none: App.pass!
        some:
          let pattern     = App.KL.Game.Skill.get_pattern(skill.value)

          // Checks if skill can or if it will be cast at a repeating tile
          let can_cast =
            if App.KL.Game.Skill.can_repeat(skill.value) then
              true
            else
              let picks = preview@picks
              let can_cast = true 

              // Checks if there is already a pick for that tile and skill
              for new_coord:new_char in picks with can_cast: 
                can_cast && not((new_coord =? coord) && (new_char =? char))
              can_cast

          // Updates skill field in preview until all the required picks have been done
          let new_skill = 
            if count <? pattern then
              some({char, count + 1})
            else
              none
          let preview = preview@skill <- new_skill

          // Updates data
          if can_cast then
            IO {
              App.new_post!(room, App.KL.Game.Phase.Play.Event.cast.serial(char, coord))
              App.set_local!(App.KL.State.Local.game(local@preview <- preview))
            }
          else
            App.pass!
      }
    }
