
// BOARD DRAWING
// =============

type App.KL.Game.Phase.Play.draw.SkillInfo {
  new(
    hero: String
    name: String
    delay: U64
  )
}

// draw all the screen (round, seconds, canvas, list of skills)
App.KL.Game.Phase.Play.draw(img: VoxBox, local: App.KL.Game.State.Local, game: App.KL.Game): DOM
  open game

  <div style={ 
    "width": "100vw", 
    "height": "100vh", 
    "display": "flex", 
    "flex-direction": "row", 
    "justify-content": "flex-start", 
    //"align-items": "center",
    "position": "relative"
  }>
    {App.KL.Game.Phase.Play.draw.skills_menu(game)}

    <div style={ 
      "width": "calc(100% - 200px)", 
      "height": "100%", 
      "display": "flex", 
      "flex-direction": "column", 
      "justify-content": "center", 
      "align-items": "center",
      "position": "relative"
    }>
    
      <div style={"font-size": "24px", "font-family": "monospace"}>
        case game.moment {
          preparation: 
            "Turn "
            | Nat.show(U64.to_nat(game.turn))
            | ". Casting in "
            | Nat.show(U64.to_nat(game.moment.countdown))
            | " ticks..."
          execution: case game.moment.casts {
            nil:
              "End of turn "
              | Nat.show(U64.to_nat(game.turn))
              | "."
            cons: Maybe {
              let cast = game.moment.casts.head
              get skill = App.KL.Game.Cast.get_skill(cast, game)
              get hero = App.KL.Game.Cast.get_hero(cast, game)
              let text = hero@name | " used " | skill@name | "!"
              let text = text | if game.moment.success then "" else " But it failed."
              return text
            } <> "Invalid cast."
          }
        }
      </div>
      <div>{ 
        let width = Nat.show(I32.to_nat(App.KL.Constants.center_x * 2))
        let height = Nat.show(I32.to_nat(App.KL.Constants.center_y * 2))
        DOM.vbox(
          { "id": "game_screen",
            "width": width,
            "height": height,
            "scale": "2"},
          {},
          App.KL.Game.Phase.Play.draw.canvas(img, local, game)) 
      }</div>
    </div>
  </div>

// CANVAS DRAWING
// ================

// draw canvas
App.KL.Game.Phase.Play.draw.canvas(
  img: VoxBox
  local: App.KL.Game.State.Local
  game: App.KL.Game
): VoxBox
  open game
  let hits = case game.moment {
    preparation: none
    execution: some(game.moment.hits)
  }
  let img = App.KL.Game.Phase.Play.draw.board(game, local@preview, hits, local@user, local@mouse, img) 
  let img = App.KL.Game.Phase.Play.draw.cursor(local@mouse, img)
  img

// draw canvas board
App.KL.Game.Phase.Play.draw.board(
  game: App.KL.Game
  preview: App.KL.Game.Cast.Preview
  hits: Maybe<App.KL.Game.Indicators>
  user: String
  mouse: Pair<U32, U32>
  img: VoxBox
): VoxBox

  map = game@board
  mouse_coord = Hexagonal.Axial.from_screen_xy(mouse, App.KL.Constants.hexagon_radius, App.KL.Constants.center_x, App.KL.Constants.center_y)
  indicators = App.KL.Game.Phase.Play.Draw.get_indicators(preview@skill, mouse_coord, user, game)
  ap_used = App.KL.Game.Moment.get_player_used_ap(game) // If there is a skill being cast, returns the player address and used ap
  map = Hexagonal.Axial.BBT.to_list!(map)
  for pos in map with img:
    {coord, tile} = pos
    img = App.KL.Game.Phase.Play.draw.tile.terrain(tile@terrain, preview@picks, indicators, hits, coord, mouse_coord, img)
    img = App.KL.Game.Phase.Play.draw.tile.creature(tile@creature, coord, ap_used, img)
    img
  img


App.KL.Game.Phase.Play.Draw.get_indicators(
  skill: Maybe<App.KL.Game.Skill>, 
  target: Hexagonal.Axial,
  player: String,
  game: App.KL.Game
): App.KL.Game.Indicators

  Maybe {
    get skill      = skill
    let game       = App.KL.Game.Cast.simulate(skill@delay, (x) String.eql(x@player, player), game)
    get center     = App.KL.Game.Board.find_player_coord(player, game@board)
    get creature   = App.KL.Game.Board.Creature.get(center, game@board)
    let indicator  = App.KL.Game.Indicator.blue
    let indicators = Hexagonal.Axial.BBT.new!
    let haste      = App.KL.Game.Creature.get_total_haste(creature)
    let coords     = Hexagonal.Axial.range(center, Nat.to_i32(U64.to_nat(skill@range)) + haste)
    // set range indicator
    for coord in coords with indicators:
      Hexagonal.Axial.BBT.set!(coord, indicator, indicators)
    let areas = App.KL.Game.Effect.indicators.get_indicators(center, skill, target, game@board)
    return Hexagonal.Axial.BBT.union!(indicators, areas)
  } <> Hexagonal.Axial.BBT.new<App.KL.Game.Indicator>

// draw mouse indicator
App.KL.Game.Phase.Play.draw.cursor(
  mouse: Pair<U32, U32>
  img: VoxBox
): VoxBox
  coord = Hexagonal.Axial.from_screen_xy(mouse, App.KL.Constants.hexagon_radius, App.KL.Constants.center_x, App.KL.Constants.center_y)
  {x,y} = App.KL.Game.Phase.Play.draw.centralize(coord)
  VoxBox.Draw.image(x, y, 0#32, App.KL.Game.Field.Grass.Assets.mouse_ui, img)

// draws tile terrain
App.KL.Game.Phase.Play.draw.tile.terrain(
  terrain: App.KL.Game.Terrain
  picks: App.KL.Game.Picks
  areas: App.KL.Game.Indicators
  hits: Maybe<App.KL.Game.Indicators>
  tile_coord: Hexagonal.Axial
  mouse_coord: Hexagonal.Axial
  img: VoxBox
): VoxBox
  indicator = Hexagonal.Axial.BBT.get!(tile_coord, hits <> areas) <> App.KL.Game.Indicator.background
  {i, j} = App.KL.Game.Phase.Play.draw.centralize(tile_coord)
  field = App.KL.Game.Field.get_by_id.default(terrain@field_id)
  field_drawing = field@draw(terrain, indicator)
  tile_drawing = VoxBox.Draw.image(i, j, 0#32, field_drawing, img)
  tile_drawing = App.KL.Game.Phase.Play.draw.letter(tile_coord, picks, tile_drawing)
  tile_drawing

// draws tile creature if any
App.KL.Game.Phase.Play.draw.tile.creature(
  creature: Maybe<App.KL.Game.Creature>,
  coord: Hexagonal.Axial,
  ap_used: Maybe<Pair<String, I32>>
  img: VoxBox
): VoxBox
  case creature {
    none: img
    some:
      {cx, cy} = Hexagonal.Axial.to_screen_xy(coord, App.KL.Constants.hexagon_radius, App.KL.Constants.center_x, App.KL.Constants.center_y)
      let cx = cx - (128::U32)
      let cy = cy - (128::U32)
      let hero = creature.value@hero
      let drawing = hero@draw(creature.value)
      //let aux = I32.to_u32(App.KL.Constants.hexagon_radius) //U32
      //let cy = cy - (aux * 2) //U32
      //let cx = cx - aux //U32
      let img = VoxBox.Draw.image(cx, cy, 0u, drawing, img)
      let img = App.KL.Game.Phase.Play.Bar.show_hp(cx + 128 - 16, cy + 128 - 28, creature.value, img)
      let img = App.KL.Game.Phase.Play.draw.ap(cx - 12, cy - 32, creature.value, ap_used, img)
      img
  }

// Skill Menu
// ==========

App.KL.Game.Phase.Play.draw.get_game_heroes(game: App.KL.Game): List<App.KL.Game.Hero>
  open game
  let list = Map.values!(game.players)
  let list = List.mapped!(list)!((player) App.KL.Game.Hero.get_by_id(player@hero_id <> 65536))
  let list = List.somes!(list)
  list

App.KL.Game.Phase.Play.draw.get_game_skills(game: App.KL.Game): List<Pair<String,Pair<App.KL.Game.Hero, App.KL.Game.Skill>>>
  open game
  let game_heroes = App.KL.Game.Phase.Play.draw.get_game_heroes(game)
  let game_skills = List.flatten!(List.mapped!(game_heroes)!((hero) List.mapped!(Map.to_list!(hero@skills))!((x) {Pair.fst!!(x), {hero,Pair.snd!!(x)}})))
  let game_skills = List.sort!((a,b) let as = Pair.snd!!(Pair.snd!!(a)); bs = Pair.snd!!(Pair.snd!!(b)); U64.cmp(as@delay, bs@delay), game_skills)
  game_skills

App.KL.Game.Phase.Play.draw.get_casting_skill(game: App.KL.Game): Maybe<App.KL.Game.Skill>
  open game
  case game.moment {
    execution: case game.moment.casts {
      nil: none
      cons: App.KL.Game.Cast.get_skill(game.moment.casts.head, game)
    }
  } default none

App.KL.Game.Phase.Play.draw.skills_menu(game: App.KL.Game): DOM
  open game

  let game_skills = App.KL.Game.Phase.Play.draw.get_game_skills(game)
  let casting_skill = App.KL.Game.Phase.Play.draw.get_casting_skill(game)
  let skill_infos = List.mapped!(game_skills)!((letter_hero_skill)
    let {letter, hero_skill} = letter_hero_skill
    let {hero, skill} = hero_skill
    let background = case casting_skill {
      none: "none"
      some: if String.eql(casting_skill.value@name, skill@name)
        then "rgb(220,220,220)"
        else "none"
    }
    <div style={
      "background": background
      "display": "flex"
      "align-items": "center"
    }>
      <img style={"margin": "4px"} src=hero@picture(false,0)></img>
      <span style={"margin-left": "4px"}>"[" | letter | "] " | skill@name</span>
    </div>)

    <div style={"width": "200px", "height": "100%", "background": "rgb(245,245,245)"}>
      for skill_info in skill_infos:
        skill_info
    </div>


// AUX FUNCTIONS
// =============

App.KL.Game.Phase.Play.draw.letter(
  tile_coord: Hexagonal.Axial
  picks: App.KL.Game.Picks
  img: VoxBox
): VoxBox
  case Hexagonal.Axial.BBT.get!(tile_coord, picks) as got {
    none: img
    some: 
      screen_coord = Hexagonal.Axial.to_screen_xy(tile_coord, App.KL.Constants.hexagon_radius, App.KL.Constants.center_x, App.KL.Constants.center_y)
      {cx, cy} = App.KL.Game.Phase.Play.draw.centralize_letter(screen_coord)
      VoxBox.Draw.text(Char.to_string(got.value), PixelFont.black, Pos32.new(cx,cy,0u), img)
  }

App.KL.Game.Phase.Play.draw.centralize_letter(screen_coord: Pair<U32, U32>): Pair<U32, U32>
  { screen_coord@fst - 2, screen_coord@snd - 6 }
  
// Centralizes an image in the hexagon 
// TODO: won't be used after we start using assets from KL only
App.KL.Game.Phase.Play.draw.centralize(
  coord: Hexagonal.Axial
): Pair(U32, U32)
  let {i, j} = Hexagonal.Axial.to_screen_xy(coord, App.KL.Constants.hexagon_radius, App.KL.Constants.center_x, App.KL.Constants.center_y)
  let aux = I32.to_u32(App.KL.Constants.hexagon_radius)
  let i = i - aux
  let j = j - aux
  {i, j}

App.KL.Game.Phase.Play.draw.hp(
  cx: U32
  cy: U32
  creature: App.KL.Game.Creature
  img: VoxBox
): VoxBox
  let hp = I32.to_int(creature@hp)
  let hp = Nat.show(Int.to_nat(hp))
  VoxBox.Draw.text(hp, PixelFont.small_black, Pos32.new(cx,cy,0), img)

App.KL.Game.Phase.Play.draw.ap(
  x: U32
  y: U32
  creature: App.KL.Game.Creature
  ap_used: Maybe<Pair<String, I32>>
  img: VoxBox
): VoxBox
  no_cast = App.KL.Game.Phase.Play.draw.ap.bars(x, y, creature@ap, 0, 0, I32.to_u32(creature@hero@max_ap), img)
  case ap_used {
    none: 
      no_cast
    some:
      // Verifies if the creature is the one casting current ability
      if String.eql(ap_used.value@fst, creature@player <> "none") then 
        App.KL.Game.Phase.Play.draw.ap.bars(x, y, creature@ap, ap_used.value@snd, 0, I32.to_u32(creature@hero@max_ap), img)
      else
        no_cast
  }

      
App.KL.Game.Phase.Play.draw.ap.bars(x: U32 y: U32, blue: I32, red: I32, bar_idx: U32, bar_quantity: U32, img: VoxBox): VoxBox
  if I32.eql(0, blue) then
    if I32.eql(0, red) then 
      if U32.gte(bar_idx, bar_quantity) then
        img
      else 
        img = VoxBox.Draw.image(x + (12 * bar_idx), y, 10, App.KL.Game.Phase.Play.Ap.Assets.gray, img)
        App.KL.Game.Phase.Play.draw.ap.bars(x, y, blue, red, bar_idx + 1, bar_quantity, img)
    else
      img = VoxBox.Draw.image(x + (12 * bar_idx), y, 10, App.KL.Game.Phase.Play.Ap.Assets.red, img)
      App.KL.Game.Phase.Play.draw.ap.bars(x, y, blue, red - 1, bar_idx + 1, bar_quantity, img)
  else 
    img = VoxBox.Draw.image(x + (12 * bar_idx), y, 10, App.KL.Game.Phase.Play.Ap.Assets.blue, img)
    App.KL.Game.Phase.Play.draw.ap.bars(x, y, blue - 1, red, bar_idx + 1, bar_quantity, img)


  


App.KL.Game.Phase.Play.draw.shield(
  cx: U32
  cy: U32
  creature: App.KL.Game.Creature
  img: VoxBox
): VoxBox
  let shield = App.KL.Game.Board.Creature.total_shield(creature)
  let shield = I32.to_int(shield)
  let shield = Nat.show(Int.to_nat(shield))
  VoxBox.Draw.text(shield, PixelFont.small_black, Pos32.new(cx, cy, 0), img)

