
// BOARD DRAWING
// =============

type App.KL.Game.Phase.Play.draw.SkillInfo {
  new(
    hero: String
    name: String
    delay: U64
  )
}

// draw all the screen (round, seconds, canvas, list of skills)
App.KL.Game.Phase.Play.draw(img: VoxBox, local: App.KL.Game.State.Local, game: App.KL.Game): DOM
  open game

  let countdown = case game.moment {
    preparation: U64.to_nat(game.moment.countdown)
    execution: 0
  }

  let blue_hp = I32.sub(App.KL.Constants.max_score, game.score@points@snd)
  let red_hp = I32.sub(App.KL.Constants.max_score, game.score@points@fst)

  <div style={ 
    "width": "100vw", 
    "height": "100vh", 
    "display": "flex", 
    "flex-direction": "row", 
    "justify-content": "flex-start", 
    "position": "relative"
    "background":
      if countdown =? 0 then
        "rgb(220,220,220)"
      else if (countdown <? 64) && ((countdown % 12) <? 4) then
        "rgb(232,232,232)"
      else
        "rgb(255,255,255)"
    //"align-items": "center",
  }>
    {App.KL.Game.Phase.Play.draw.skills_menu(game)}

    <div style={ 
      "width": "calc(100% - 200px)", 
      "height": "100%", 
      "display": "flex", 
      "flex-direction": "column", 
      "justify-content": "center", 
      "align-items": "center",
      "position": "relative",
      "background-size": "2px 2px",
    }>
      <div style={"font-size": "32px", "font-family": "monospace"}>
        <span style={"color": "rgb(0,0,160)"}>Nat.show(I32.to_nat(blue_hp))</span>
        <span>" X "</span>
        <span style={"color": "rgb(160,0,0)"}>Nat.show(I32.to_nat(red_hp))</span>
        //<span>" of " | String.show_clean(I32.show(App.KL.Constants.max_score))</span>
      </div>
      <div style={"font-size": "32px", "font-family": "monospace"}>
        case game.moment {
          preparation: 
            Nat.show(Nat.div(U64.to_nat(game.moment.countdown), 16))
          execution: case game.moment.casts {
            nil:
              "End of turn "
              | Nat.show(U64.to_nat(game.turn))
              | "."
            cons: Maybe {
              let cast = game.moment.casts.head
              get skill = App.KL.Game.Cast.get_skill(cast, game)
              get hero = App.KL.Game.Cast.get_hero(cast, game)
              let text = hero@name | " used " | skill@name | "!"
              let text = text | if game.moment.success then "" else " But it failed."
              return text
            } <> "Invalid cast."
          }
        }
      </div>
      <div>{ 
        let width = Nat.show(I32.to_nat(App.KL.Constants.center_x * 2))
        let height = Nat.show(I32.to_nat(App.KL.Constants.center_y * 2))
        DOM.vbox(
          { "id": "game_screen",
            "width": width,
            "height": height,
            "scale": "2"},
          {},
          App.KL.Game.Phase.Play.draw.canvas(img, local, game)) 
      }</div>
    </div>

    <div style={
      "width": "200px"
      "height": "100%"
      "background": "rgb(220,220,220)"
      "border-left": "1px solid black"
      "padding": "4px"
      "font-family": "monospace"
      "font-size": "16px"
    }>
      "TODO :)"
    </div>

  </div>

// CANVAS DRAWING
// ================

// draw canvas
App.KL.Game.Phase.Play.draw.canvas(
  img: VoxBox
  local: App.KL.Game.State.Local
  game: App.KL.Game
): VoxBox
  open game
  let hits = case game.moment {
    preparation: none
    execution: some(game.moment.hits)
  }
  let img = App.KL.Game.Phase.Play.draw.board(game, local@preview, hits, local@user, local@mouse, img) 
  let img = App.KL.Game.Phase.Play.draw.cursor(local@mouse, img)
  img

// draw canvas board
App.KL.Game.Phase.Play.draw.board(
  game: App.KL.Game
  preview: App.KL.Game.Cast.Preview
  hits: Maybe<App.KL.Game.Indicators>
  user: String
  mouse: Pair<U32, U32>
  img: VoxBox
): VoxBox

  map = game@board
  mouse_coord = Hexagonal.Axial.from_screen_xy(mouse, App.KL.Constants.hexagon_radius, App.KL.Constants.center_x, App.KL.Constants.center_y)
  indicators = App.KL.Game.Phase.Play.Draw.get_indicators(preview@skill, mouse_coord, user, game)
  ap_used = App.KL.Game.Moment.get_player_used_ap(game) // If there is a skill being cast, returns the player address and used ap
  map = Hexagonal.Axial.Map.to_list!(map)
  for pos in map with img:
    {coord, tile} = pos
    img = App.KL.Game.Phase.Play.draw.tile.terrain(tile@terrain, preview@picks, indicators, hits, coord, mouse_coord, img)
    img = App.KL.Game.Phase.Play.draw.tile.creature(game, tile@creature, coord, ap_used, img)
    img = App.KL.Game.Phase.Play.draw.tile.token(game, tile@token, coord, img)
    img
  img

App.KL.Game.Phase.Play.draw.tile.token(
  game: App.KL.Game
  token: Maybe<App.KL.Game.Token>,
  token_coord: Hexagonal.Axial,
  img: VoxBox
): VoxBox
  without token: img
  let col = case App.KL.Game.Token.get_dominance(token) as team {
    none: Col32.new(100,100,100,255)
    some:
      case team.value {    
        blue: Col32.new(0, 0, 255, 255)
        red:  Col32.new(255, 0, 0, 255)
      } default Col32.new(100,100,100,255)
  }
  let coords = Hexagonal.Axial.range(token_coord, token@range)
  for coord in coords with img:
    let {cx, cy} = 
      Hexagonal.Axial.to_screen_xy(
        coord,
        App.KL.Constants.hexagon_radius,
        App.KL.Constants.center_x,
        App.KL.Constants.center_y
      )
    
    if Hexagonal.Axial.eql(coord, token_coord) then
      VoxBox.Draw.square(cx,cy,2,10,10,col,img)
    else
      VoxBox.Draw.square(cx,cy,2,5,5,col,img)
  img

  

App.KL.Game.Phase.Play.Draw.get_indicators(
  skill: Maybe<App.KL.Game.Skill>, 
  target: Hexagonal.Axial,
  player: String,
  game: App.KL.Game
): App.KL.Game.Indicators

  Maybe {
    get skill      = skill
    let game       = App.KL.Game.Cast.simulate(skill@delay, (x) String.eql(x@player, player), game)
    get center     = App.KL.Game.Board.find_player_coord(player, game@board)
    get creature   = App.KL.Game.Board.Creature.get(center, game@board)
    let indicator  = App.KL.Game.Indicator.blue
    let indicators = Hexagonal.Axial.Map.new!
    //let haste      = App.KL.Game.Creature.get_total_haste(creature)
    //let coords     = Hexagonal.Axial.range(center, Nat.to_i32(U64.to_nat(skill@range)) + haste)
    let coords     = Hexagonal.Axial.range(center, Nat.to_i32(U64.to_nat(skill@range)))
    // set range indicator
    for coord in coords with indicators:
      Hexagonal.Axial.Map.set!(coord, indicator, indicators)
    let areas = App.KL.Game.Effect.indicators.get_indicators(center, skill, target, game@board)
    return Hexagonal.Axial.Map.union!(indicators, areas)
  } <> Hexagonal.Axial.Map.new<App.KL.Game.Indicator>

// draw mouse indicator
App.KL.Game.Phase.Play.draw.cursor(
  mouse: Pair<U32, U32>
  img: VoxBox
): VoxBox
  coord = Hexagonal.Axial.from_screen_xy(mouse, App.KL.Constants.hexagon_radius, App.KL.Constants.center_x, App.KL.Constants.center_y)
  {x,y} = App.KL.Game.Phase.Play.draw.centralize(coord)
  VoxBox.Draw.image(x, y, 0#32, App.KL.Game.Field.Grass.Assets.mouse_ui, img)

// draws tile terrain
App.KL.Game.Phase.Play.draw.tile.terrain(
  terrain: App.KL.Game.Terrain
  picks: App.KL.Game.Picks
  areas: App.KL.Game.Indicators
  hits: Maybe<App.KL.Game.Indicators>
  tile_coord: Hexagonal.Axial
  mouse_coord: Hexagonal.Axial
  img: VoxBox
): VoxBox
  indicator = Hexagonal.Axial.Map.get!(tile_coord, hits <> areas) <> App.KL.Game.Indicator.background
  {i, j} = App.KL.Game.Phase.Play.draw.centralize(tile_coord)
  field = App.KL.Game.Field.get_by_id.default(terrain@field_id)
  field_drawing = field@draw(terrain, indicator)
  tile_drawing = VoxBox.Draw.image(i, j, 0#32, field_drawing, img)
  tile_drawing = App.KL.Game.Phase.Play.draw.letter(tile_coord, picks, tile_drawing)
  tile_drawing

App.KL.Game.Phase.Play.draw.tile.creature.get_draw_pose(game: App.KL.Game, coord: Hexagonal.Axial): App.KL.Game.Hero.Draw.Pose
  open game
  case game.moment {
    preparation:
      App.KL.Game.Hero.Draw.Pose.idle
    execution: case game.moment.casts {
      nil:
        App.KL.Game.Hero.Draw.Pose.idle
      cons: Maybe { 
        get success = if game.moment.success then some(unit) else none
        get creature = App.KL.Game.Board.Creature.get(coord, game.board)
        let cast = game.moment.casts.head
        get player = creature@player
        open cast
        if String.eql(player, cast.player) then Maybe {
          let frame = game.moment.frame
          let center = game.moment.coord <> coord
          let target = cast.target
          let letter = cast.letter
          get skill = App.KL.Game.Cast.get_skill(cast, game)
          get creature = App.KL.Game.Cast.get_creature(cast, game)
          return App.KL.Game.Hero.Draw.Pose.cast(frame, center, target, letter, skill, creature)
        } else none
      } <> App.KL.Game.Hero.Draw.Pose.idle
    }
  }

// draws tile creature if any
App.KL.Game.Phase.Play.draw.tile.creature(
  game: App.KL.Game
  creature: Maybe<App.KL.Game.Creature>,
  coord: Hexagonal.Axial,
  ap_used: Maybe<Pair<String, I32>>
  img: VoxBox
): VoxBox
  case creature {
    none: img
    some:
      let hero = creature.value@hero
      let draw_pose = App.KL.Game.Phase.Play.draw.tile.creature.get_draw_pose(game, coord)
      let {draw_coord, draw_voxbox} = hero@draw(draw_pose)
      let draw_coord = draw_coord <> coord
      //let aux = I32.to_u32(App.KL.Constants.hexagon_radius) //U32
      //let cy = cy - (aux * 2) //U32
      //let cx = cx - aux //U32
      //log(U32.show( cy + 100))
      {cx, cy} = Hexagonal.Axial.to_screen_xy(draw_coord, App.KL.Constants.hexagon_radius, App.KL.Constants.center_x, App.KL.Constants.center_y)
      let cx = cx - (128::U32)
      let cy = cy - (128::U32)
      let img = VoxBox.Draw.image(cx, cy, 0u, draw_voxbox, img)
      open creature.value as creature
      case creature.player { 
        none:
          img
        some:
          let img = App.KL.Game.Phase.Play.Bar.show_hp(cx + 111, cy + 100, creature.value, img)
          let img = App.KL.Game.Phase.Play.draw.ap(cx - 12, cy - 32, creature.value, ap_used, img)
          img
      }

  }

// Skill Menu
// ==========

App.KL.Game.Phase.Play.draw.get_game_heroes(game: App.KL.Game): List<App.KL.Game.Hero>
  open game
  let list = Map.values!(game.players)
  let list = List.mapped!(list)!((player) App.KL.Game.Hero.get_by_id(player@hero_id <> 65536))
  let list = List.somes!(list)
  list

App.KL.Game.Phase.Play.draw.get_game_skills(game: App.KL.Game): List<Pair<String,Pair<App.KL.Game.Hero, App.KL.Game.Skill>>>
  open game
  let game_heroes = App.KL.Game.Phase.Play.draw.get_game_heroes(game)
  let game_skills = List.flatten!(List.mapped!(game_heroes)!((hero) List.mapped!(Map.to_list!(hero@skills))!((x) {Pair.fst!!(x), {hero,Pair.snd!!(x)}})))
  let game_skills = List.sort!((a,b) let as = Pair.snd!!(Pair.snd!!(a)); bs = Pair.snd!!(Pair.snd!!(b)); U64.cmp(as@delay, bs@delay), game_skills)
  game_skills

App.KL.Game.Phase.Play.draw.get_casting_skill(game: App.KL.Game): Maybe<App.KL.Game.Skill>
  open game
  case game.moment {
    execution: case game.moment.casts {
      nil: none
      cons: App.KL.Game.Cast.get_skill(game.moment.casts.head, game)
    }
  } default none

App.KL.Game.Phase.Play.draw.skills_menu(game: App.KL.Game): DOM
  open game

  let game_skills = App.KL.Game.Phase.Play.draw.get_game_skills(game)
  let casting_skill = App.KL.Game.Phase.Play.draw.get_casting_skill(game)
  let skill_infos = List.mapped!(game_skills)!((letter_hero_skill)
    let {letter, hero_skill} = letter_hero_skill
    let {hero, skill} = hero_skill
    let background = case casting_skill {
      none: "none"
      some: if String.eql(casting_skill.value@name, skill@name)
        then "rgba(0,0,0,0.05)"
        else "none"
    }
    <div style={
      "background": background
      "display": "flex"
      "align-items": "center"
    }>
      <img style={"margin": "4px"} src=hero@picture(false,0)></img>
      <span style={"margin-left": "4px"}>"[" | letter | "] " | skill@name</span>
    </div>)

    <div style={
      "width": "200px"
      "height": "100%"
      "background": "rgb(220,220,220)"
      "border-right": "1px solid black"
      "font-family": "monospace"
      "font-size": "16px"
    }>
      for skill_info in skill_infos:
        skill_info
    </div>


// AUX FUNCTIONS
// =============

App.KL.Game.Phase.Play.draw.letter(
  tile_coord: Hexagonal.Axial
  picks: App.KL.Game.Picks
  img: VoxBox
): VoxBox
  case Hexagonal.Axial.Map.get!(tile_coord, picks) as got {
    none: img
    some: 
      screen_coord = Hexagonal.Axial.to_screen_xy(tile_coord, App.KL.Constants.hexagon_radius, App.KL.Constants.center_x, App.KL.Constants.center_y)
      {cx, cy} = App.KL.Game.Phase.Play.draw.centralize_letter(screen_coord)
      VoxBox.Draw.text(Char.to_string(got.value), PixelFont.black, Pos32.new(cx,cy,0u), img)
  }

App.KL.Game.Phase.Play.draw.centralize_letter(screen_coord: Pair<U32, U32>): Pair<U32, U32>
  { screen_coord@fst - 2, screen_coord@snd - 6 }
  
// Centralizes an image in the hexagon 
// TODO: won't be used after we start using assets from KL only
App.KL.Game.Phase.Play.draw.centralize(
  coord: Hexagonal.Axial
): Pair(U32, U32)
  let {i, j} = Hexagonal.Axial.to_screen_xy(coord, App.KL.Constants.hexagon_radius, App.KL.Constants.center_x, App.KL.Constants.center_y)
  let aux = I32.to_u32(App.KL.Constants.hexagon_radius)
  let i = i - aux
  let j = j - aux
  {i, j}

App.KL.Game.Phase.Play.draw.hp(
  cx: U32
  cy: U32
  creature: App.KL.Game.Creature
  img: VoxBox
): VoxBox
  let hp = I32.to_int(creature@hp)
  let hp = Nat.show(Int.to_nat(hp))
  VoxBox.Draw.text(hp, PixelFont.small_black, Pos32.new(cx,cy,0), img)

App.KL.Game.Phase.Play.draw.ap(
  x: U32
  y: U32
  creature: App.KL.Game.Creature
  ap_used: Maybe<Pair<String, I32>>
  img: VoxBox
): VoxBox
  no_cast = App.KL.Game.Phase.Play.draw.ap.bars(x, y, creature@ap, 0, 0, I32.to_u32(creature@hero@max_ap), img)
  case ap_used {
    none: 
      no_cast
    some:
      // Verifies if the creature is the one casting current ability
      if String.eql(ap_used.value@fst, creature@player <> "none") then 
        App.KL.Game.Phase.Play.draw.ap.bars(x, y, creature@ap, ap_used.value@snd, 0, I32.to_u32(creature@hero@max_ap), img)
      else
        no_cast
  }

      
App.KL.Game.Phase.Play.draw.ap.bars(x: U32 y: U32, blue: I32, red: I32, bar_idx: U32, bar_quantity: U32, img: VoxBox): VoxBox
  if I32.eql(0, blue) then
    if I32.eql(0, red) then 
      if U32.gte(bar_idx, bar_quantity) then
        img
      else 
        img = VoxBox.Draw.image(x + (12 * bar_idx), y, 10, App.KL.Game.Phase.Play.Ap.Assets.gray, img)
        App.KL.Game.Phase.Play.draw.ap.bars(x, y, blue, red, bar_idx + 1, bar_quantity, img)
    else
      img = VoxBox.Draw.image(x + (12 * bar_idx), y, 10, App.KL.Game.Phase.Play.Ap.Assets.red, img)
      App.KL.Game.Phase.Play.draw.ap.bars(x, y, blue, red - 1, bar_idx + 1, bar_quantity, img)
  else 
    img = VoxBox.Draw.image(x + (12 * bar_idx), y, 10, App.KL.Game.Phase.Play.Ap.Assets.blue, img)
    App.KL.Game.Phase.Play.draw.ap.bars(x, y, blue - 1, red, bar_idx + 1, bar_quantity, img)


  


App.KL.Game.Phase.Play.draw.shield(
  cx: U32
  cy: U32
  creature: App.KL.Game.Creature
  img: VoxBox
): VoxBox
  let shield = App.KL.Game.Creature.Status.shield.total(creature)
  let shield = I32.to_int(shield)
  let shield = Nat.show(Int.to_nat(shield))
  VoxBox.Draw.text(shield, PixelFont.small_black, Pos32.new(cx, cy, 0), img)

