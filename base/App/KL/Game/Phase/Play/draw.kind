App.KL.Game.Phase.Play.draw.fator.number: F64
  1.5

App.KL.Game.Phase.Play.draw.fator.string: String
  F64.show(App.KL.Game.Phase.Play.draw.fator.number)

App.KL.Game.Phase.Play.draw.theme.secondary: String
  "#eb6bff"

type PlayersInfo {
  new(
    team: App.KL.Game.Team
    creature: Maybe<App.KL.Game.Creature>
    hero_id: Maybe<Nat>
  )
}

SkillInfo: Type
  Pair<String,Pair<App.KL.Game.Hero, App.KL.Game.Skill>>

// draw all the screen (round, seconds, canvas, list of skills)
App.KL.Game.Phase.Play.draw(img: VoxBox, local: App.KL.Game.State.Local, game: App.KL.Game): DOM
  <div style={ 
    "width": "max(100vw, 900px)",
    "height": "max(100vh, 650px)",
    "max-height": "max(100vh, 650px)",
    "position": "relative"
    "background-color":" #071840"
  }>
    // interface
    { App.KL.Game.Phase.Play.draw.interface(local, game) }
    // canvas
    { App.KL.Game.Phase.Play.draw.canvas.elem(local, game, img) }
    // tab
    { App.KL.Game.Phase.Play.draw.tab(local, game) }
  </div>


// AUX FUNCTIONS
// =================================

App.KL.Game.Phase.Play.draw.get_players_heroes(players: Map<App.KL.Game.Player>): List<App.KL.Game.Hero>
  let list = Map.values!(players)
  let list = List.mapped!(list)!((player) App.KL.Game.Hero.get_by_id(player@hero_id <> 65536))
  let list = List.somes!(list)
  list

App.KL.Game.Phase.Play.draw.get_players_skills(players: Map<App.KL.Game.Player>): List<SkillInfo>
  let game_heroes = App.KL.Game.Phase.Play.draw.get_players_heroes(players)
  let game_skills = List.flatten!(List.mapped!(game_heroes)!((hero) List.mapped!(Map.to_list!(hero@skills))!((x) {Pair.fst!!(x), {hero,Pair.snd!!(x)}})))
  let game_skills = List.sort!((a,b) let as = Pair.snd!!(Pair.snd!!(a)); bs = Pair.snd!!(Pair.snd!!(b)); U64.cmp(as@delay, bs@delay), game_skills)
  game_skills

// return a list with skill info of all players
// the either serves to tell where the walk skills are
App.KL.Game.Phase.Play.draw.get_skills_to_tab(
  players: Map<App.KL.Game.Player>
): List<Either<Unit, SkillInfo>>
  let skills = App.KL.Game.Phase.Play.draw.get_players_skills(players)
  App.KL.Game.Phase.Play.draw.get_skills_to_tab.go(skills, false)
  
App.KL.Game.Phase.Play.draw.get_skills_to_tab.go(
  skills: List<SkillInfo>
  found_walk: Bool
): List<Either<Unit, SkillInfo>>
  case skills {
    nil: []
    cons:
      let skill = skills.head@snd@snd
      if (skill@name =? "Walk") || (skill@delay =? 500) then
        if found_walk then
          App.KL.Game.Phase.Play.draw.get_skills_to_tab.go(skills.tail, found_walk)
        else
          Either.left!!(unit) & App.KL.Game.Phase.Play.draw.get_skills_to_tab.go(skills.tail, true)
      else
        Either.right!!(skills.head) & App.KL.Game.Phase.Play.draw.get_skills_to_tab.go(skills.tail, found_walk)
  }

App.KL.Game.Phase.Play.draw.apply_condition(
  condition: App.KL.Game.Skill -> Bool
  skill_info: SkillInfo
): Bool
  let skill = skill_info@snd@snd
  condition(skill)

App.KL.Game.Phase.Play.draw.get_allies_enemies(
  user: String
  players: Map<App.KL.Game.Player>
): Pair<Map<App.KL.Game.Player>, Map<App.KL.Game.Player>>
  let player = players{user}
  case player {
    none:
      let allies  = App.KL.Game.Player.get_from_team(App.KL.Game.Team.blue, players)
      let enemies = App.KL.Game.Player.get_from_team(App.KL.Game.Team.red,  players)
      {allies, enemies}
    some:
      let allies  = App.KL.Game.Player.get_allies(player.value, players)
      let enemies = App.KL.Game.Player.get_enemies(player.value, players)
      {allies, enemies}
  }

App.KL.Game.Phase.Play.draw.interface.top.get_players(
  players: Map<App.KL.Game.Player>, 
  board: App.KL.Game.Board
): Map<PlayersInfo>
  let result = {}
  for id:player in players with result:
    result{id} <- PlayersInfo.new(player@team, none, player@hero_id)
  for coord:tile in board with result:
    Maybe {
      get creature = tile@creature
      get id = creature@player
      get info = result{id}
      return result{id} <- info@creature <- some(creature)
    } <> result
  result

App.KL.Game.Phase.Play.draw.get_life(creature: Maybe<App.KL.Game.Creature>): I32
  case creature {
    none: 0
    some: creature.value@hp
  }

App.KL.Game.Phase.Play.draw.get_life_percentage(creature: Maybe<App.KL.Game.Creature>): F64
  case creature {
    none: 0
    some: F64.mul(100.0, I32.to_f64(creature.value@hp) / I32.to_f64(creature.value@hero@max_hp))
  }

App.KL.Game.Phase.Play.draw.get_ap(creature: Maybe<App.KL.Game.Creature>): I32
  case creature {
    none: 0
    some: creature.value@ap
  }

App.KL.Game.Phase.Play.draw.wrapper(width: Nat, height: Nat, bt: Nat, id: String, fator: F64, background: String, inner: DOM): DOM
  <div class="pixel-art" id=id style={
    "height": Nat.show(F64.to_nat(fator * Nat.to_f64(height))) | "px", 
    "width": Nat.show(F64.to_nat(fator * Nat.to_f64(width))) | "px", 
    "display": "flex", 
    "background-image": "url("|background|")", 
    "background-size": "100% 100%", 
    "padding-top": Nat.show(F64.to_nat(fator * Nat.to_f64(bt))) | "px"
    // "margin": "0 10px"
  }>
    {inner}
  </div>

App.KL.Game.Phase.Play.draw.get_cursor(
  local: App.KL.Game.State.Local
  game : App.KL.Game
): String
  let cursor =
    Maybe {
      get skill_key = local@preview@skill
      let skill_key = skill_key@fst
      get skill  = App.KL.Game.Skill.get(local@user, skill_key, game)
      return skill@cursor
    } <> App.KL.Game.Cursor.default
  
  App.KL.Game.Cursor.get_img(cursor)

App.KL.Game.Phase.Play.draw.letter(
  tile_coord: Hexagonal.Axial
  picks: App.KL.Game.Picks
  img: VoxBox
): VoxBox
  case Hexagonal.Axial.Map.get!(tile_coord, picks) as got {
    none: img
    some: 
      screen_coord = Hexagonal.Axial.to_screen_xy(tile_coord, App.KL.Constants.hexagon_radius, App.KL.Constants.center_x, App.KL.Constants.center_y)
      {cx, cy} = App.KL.Game.Phase.Play.draw.centralize_letter(screen_coord)
      VoxBox.Draw.text(Char.to_string(got.value), PixelFont.black, Pos32.new(cx,cy,App.KL.Constants.z_index.letter), img)
  }

App.KL.Game.Phase.Play.draw.centralize_letter(screen_coord: Pair<U32, U32>): Pair<U32, U32>
  { screen_coord@fst - 2, screen_coord@snd - 6 }
  
App.KL.Game.Phase.Play.draw.centralize.new(
  coord: Hexagonal.Axial
): Pair(U32, U32)
  let {i, j} = Hexagonal.Axial.to_screen_xy(coord, App.KL.Constants.hexagon_radius, App.KL.Constants.center_x, App.KL.Constants.center_y)
  let i = i - 128
  let j = j - 128 - I32.to_u32(App.KL.Constants.hexagon.extra_height / 2)
  {i, j}

// Centralizes an image in the hexagon 
// TODO: won't be used after we start using assets from KL only
App.KL.Game.Phase.Play.draw.centralize.old(
  coord: Hexagonal.Axial
): Pair(U32, U32)
  let {i, j} = Hexagonal.Axial.to_screen_xy(coord, App.KL.Constants.hexagon_radius, App.KL.Constants.center_x, App.KL.Constants.center_y)
  // log(U32.show(i))
  // log(U32.show(j))
  let aux = I32.to_u32(App.KL.Constants.hexagon_radius)
  let i = i - aux
  let j = j - aux
  {i, j}

App.KL.Game.Phase.Play.draw.hp(
  cx: U32
  cy: U32
  creature: App.KL.Game.Creature
  img: VoxBox
): VoxBox
  let hp = I32.to_int(creature@hp)
  let hp = Nat.show(Int.to_nat(hp))
  VoxBox.Draw.text(hp, PixelFont.small_black, Pos32.new(cx,cy,0), img)

App.KL.Game.Phase.Play.draw.ap(
  x: U32
  y: U32
  creature: App.KL.Game.Creature
  ap_used: Maybe<Pair<String, I32>>
  img: VoxBox
): VoxBox
  no_cast = App.KL.Game.Phase.Play.draw.ap.bars(x, y, creature@ap, 0, 0, I32.to_u32(creature@hero@max_ap), img)
  case ap_used {
    none: 
      no_cast
    some:
      // Verifies if the creature is the one casting current ability
      if String.eql(ap_used.value@fst, creature@player <> "none") then 
        App.KL.Game.Phase.Play.draw.ap.bars(x, y, creature@ap, ap_used.value@snd, 0, I32.to_u32(creature@hero@max_ap), img)
      else
        no_cast
  }

      
App.KL.Game.Phase.Play.draw.ap.bars(x: U32 y: U32, blue: I32, red: I32, bar_idx: U32, bar_quantity: U32, img: VoxBox): VoxBox
  if I32.eql(0, blue) then
    if I32.eql(0, red) then 
      if U32.gte(bar_idx, bar_quantity) then
        img
      else 
        img = VoxBox.Draw.image(x + (12 * bar_idx), y, App.KL.Constants.z_index.ap_bar, App.KL.Game.Phase.Play.Ap.Assets.gray, img)
        App.KL.Game.Phase.Play.draw.ap.bars(x, y, blue, red, bar_idx + 1, bar_quantity, img)
    else
      img = VoxBox.Draw.image(x + (12 * bar_idx), y, App.KL.Constants.z_index.ap_bar, App.KL.Game.Phase.Play.Ap.Assets.red, img)
      App.KL.Game.Phase.Play.draw.ap.bars(x, y, blue, red - 1, bar_idx + 1, bar_quantity, img)
  else 
    img = VoxBox.Draw.image(x + (12 * bar_idx), y, App.KL.Constants.z_index.ap_bar, App.KL.Game.Phase.Play.Ap.Assets.blue, img)
    App.KL.Game.Phase.Play.draw.ap.bars(x, y, blue - 1, red, bar_idx + 1, bar_quantity, img)


  


App.KL.Game.Phase.Play.draw.shield(
  cx: U32
  cy: U32
  creature: App.KL.Game.Creature
  img: VoxBox
): VoxBox
  let shield = App.KL.Game.Creature.Status.shield.total(creature)
  let shield = I32.to_int(shield)
  let shield = Nat.show(Int.to_nat(shield))
  VoxBox.Draw.text(shield, PixelFont.small_black, Pos32.new(cx, cy, 0), img)

App.KL.Game.Phase.Play.draw.gray_overlay(game: App.KL.Game): DOM
  open game
    case game.moment {
      initial: <div></div>
      preparation: <div></div>
      execution: case game.moment.casts {
        nil: 
          let frame_part = U64.to_f64(game.moment.frame) / U64.to_f64(App.KL.Constants.between_turn_delay)
           let opacity = F64.show((1 - frame_part)/2.5)
          <div style=
          { "width": "100%",
            "height": "100%",
            "position": "absolute",
            "background-color":"rgba(165,165,165,"|opacity|")",
            "display": "flex"
          }>
            <div style=
              { "font-size": "4em"
                "margin": "auto"            
                "text-align": "center"
                "color": "white"
              }>
              <div>"Turn " | Nat.show(U64.to_nat(game.turn)) | " ended."</div>
              <div>"Starting Turn " | Nat.show(U64.to_nat(game.turn + 1)) | "!"</div>
            </div>
          </div>
        cons: <div></div>
      }
    }
  
