App.KL.Game.Board.Creature.dot_verify(
  game: App.KL.Game
): App.KL.Game

  let result = {game@board, game@cemetery}
  let aux = App.KL.Game.Board.Creature.dot_verify.aux(game@board)
  for creature in aux with result:
    let coord = creature@fst
    let creature = creature@snd
    open creature
    for dots in creature.status with result:
      let effect = App.KL.Game.Creature.Status.get_effect(dots)
      let effect_result = effect(coord, coord, coord, game@board)
      case effect_result { 
        err: result
        new: {effect_result.board, effect_result.cemetery}
      }
    result
  let game = game@board <- result@fst
  let game = game@cemetery <- game@cemetery ++ result@snd
  game




App.KL.Game.Board.Creature.dot_verify.aux(
  board: App.KL.Game.Board
): List<Pair<Hexagonal.Axial, App.KL.Game.Creature>>

  let list = Hexagonal.Axial.Map.to_list!(board)
  let creatures = []
  for coords in list with creatures:
    coords = coords@fst
    creature = App.KL.Game.Board.Creature.get(coords, board)
    case creature {
      none:
        creatures
      some:
      open creature.value
      {coords, creature.value} & creatures
    }
  creatures
  
