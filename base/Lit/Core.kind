// Litereum: a minimal decentralized computer
// ==========================================

// Types
// -----

// A Litereum term
type Lit.Core.Term {
  // A variable
  var(
    name: String
  )
  // Creates a value
  create(
    type: String
    form: Nat
    vals: List<Lit.Core.Term>
  )
  // Pattern-matches a value
  match(
    type: String
    name: String
    expr: Lit.Core.Term
    cses: List<Pair<List<String>,Lit.Core.Term>>
  )
  // Creates a symbol
  label( 
    name: String
  )
  // Compares two labels
  compare(
    val0: Lit.Core.Term
    val1: Lit.Core.Term
    iflt: Lit.Core.Term
    ifeq: Lit.Core.Term
    ifgt: Lit.Core.Term
  )
  // Calls an external program
  call(
    name: String
    func: String
    argm: Lit.Core.Term
    cont: Lit.Core.Term
  )
  // Binds an new program
  bind(
    name: String
    main: Lit.Core.Term
    cont: Lit.Core.Term
  )
}

// Lit.Core types are algebraic datatypes (ADTs)
type Lit.Core.Type {
  lab
  adt(
    name: String
    forms: List<Lit.Core.Type.Form>
  )
}

// A constructor of an ADT
type Lit.Core.Type.Form {
  new(
    name: String
    fields: List<Lit.Core.Type.Field>
  )
}

// A field of an ADT's constructor
type Lit.Core.Type.Field {
  new(
    name: String
    type: String
  )
}

// A user
type Lit.Core.User {
  new(
    name: String
    pkey: String
  )
}

// A bond
type Lit.Core.Bond {
  new(
    name: String
    ownr: Maybe<String>
    main: Lit.Core.Term
    inty: String
    outy: String
  )
}

// An external call
type Lit.Core.Exec {
  new(
    user: String
    sign: String
    expr: Lit.Core.Term
  )
}

// A paragraph in a Litereum page
type Lit.Core.Line {
  new_type(value: Lit.Core.Type)
  new_bond(value: Lit.Core.Bond)
  new_user(value: Lit.Core.User)
  ext_exec(value: Lit.Core.Exec)
}

// A page of the Litereum book
Lit.Core.Page: Type
  List<Lit.Core.Line>

// A Lit.Core global entry
type Lit.Core.Entry {
  type(value: Lit.Core.Type)
  bond(value: Lit.Core.Bond)
  user(value: Lit.Core.User)
}

// Lit.Core's global state
Lit.Core.World: Type
  Map<Lit.Core.Entry>

// Getters and Setters
// -------------------

Lit.Core.World.get_type(name: String, world: Lit.Core.World): Maybe<Lit.Core.Type>
  case world{name} as entry {
    some: case entry.value {
      type: some(entry.value.value)
    } default none
  } default none
  
Lit.Core.World.get_bond(name: String, world: Lit.Core.World): Maybe<Lit.Core.Bond>
  case world{name} as entry {
    some: case entry.value {
      bond: some(entry.value.value)
    } default none
  } default none

Lit.Core.World.get_user(name: String, world: Lit.Core.World): Maybe<Lit.Core.User>
  case world{name} as entry {
    some: case entry.value {
      user: some(entry.value.value)
    } default none
  } default none

Lit.Core.Type.find_form(name: String, type: Lit.Core.Type): Maybe<Pair<Nat,Lit.Core.Type.Form>>
  case type {
    lab: none
    adt: List.ifind!((i,f) String.eql(f@name,name), type.forms)
  }

// Type-Checking
// -------------

Lit.Core.Type.equal(a: Lit.Core.Type, b: Lit.Core.Type): Bool
  case a b {
    lab lab: true
    adt adt: String.eql(a.name, b.name)
  } default false

Lit.Core.World.check.term(
  term: Lit.Core.Term
  type: Lit.Core.Type
  ctx: Map<Lit.Core.Type>
  world: Lit.Core.World
): Bool
  //log("- chk " | Lit.Lang.show.term(term,world) | " : " | Lit.Lang.show.type.short(type))
  //log("- ctx " | String.join(", ", List.map!!((a) a@fst|":"|Lit.Lang.show.type.short(a@snd), Map.to_list!(ctx))))
  //log("")
  open world
  case term {
    var:
      let var_type = ctx{term.name} abort false
      //log("-- var " | Lit.Core.Type.show(var_type) | " " | Lit.Core.Type.show(type))
      Lit.Core.Type.equal(var_type, type)
    create: case type {
      lab:
        false
      adt:
        use term_type = Lit.Core.World.get_type(term.type,world) abort false
        if Lit.Core.Type.equal(term_type, type) then
          use form = type.forms[term.form] abort false
          Lit.Core.World.check.create.fields(term.vals, form.fields, ctx, world)
        else
          false
    }
    match:
      let expr_type = Lit.Core.World.get_type(term.type,world) abort false
      case expr_type {
        lab:
          false
        adt:
          let expr = Lit.Core.World.check.term(term.expr, expr_type, ctx, world)
          let cses = List.mapped!(term.cses)!((x) x@snd)
          let cses = Lit.Core.World.check.match.cases(cses, type, expr_type.forms, term.name, ctx, world)
          expr && cses
      }
    call:
      use bond = Lit.Core.World.get_bond(term.func,world) abort false
      use inty = Lit.Core.World.get_type(bond.inty,world) abort false
      use outy = Lit.Core.World.get_type(bond.outy,world) abort false
      let ctx2 = ctx{term.name} <- outy
      let argm = Lit.Core.World.check.term(term.argm, inty, ctx, world)
      let cont = Lit.Core.World.check.term(term.cont, inty, ctx2, world)
      argm && cont
    bind:
      // TODO: check access
      use bond = Lit.Core.World.get_bond(term.name,world) abort false
      use inty = Lit.Core.World.get_type(bond.inty,world) abort false
      use outy = Lit.Core.World.get_type(bond.outy,world) abort false
      let ctx2 = ctx{"input"} <- inty
      let ctx2 = ctx{"caller"} <- Lit.Core.Type.lab
      let main = Lit.Core.World.check.term(term.main, outy, ctx2, world)
      main
  } default false

Lit.Core.World.check.create.fields(
  terms: List<Lit.Core.Term>
  fields: List<Lit.Core.Type.Field>
  ctx: Map<Lit.Core.Type>
  world: Lit.Core.World
): Bool
  open world
  case terms fields {
    cons cons:
      let type = Lit.Core.World.get_type(fields.head@type,world) abort false
      let head = Lit.Core.World.check.term(terms.head, type, ctx, world)
      let tail = Lit.Core.World.check.create.fields(terms.tail, fields.tail, ctx, world)
      head && tail
    nil nil:
      true
  } default false

Lit.Core.World.check.match.cases(
  cases: List<Lit.Core.Term>
  type: Lit.Core.Type
  forms: List<Lit.Core.Type.Form>
  name: String
  ctx: Map<Lit.Core.Type>
  world: Lit.Core.World
): Bool
  case cases forms {
    cons cons:
      let ext_ctx = ctx
      for field in forms.head@fields with ext_ctx:
        let type = Lit.Core.World.get_type(field@type, world) <> Lit.Core.Type.lab
        ext_ctx{name | "." | field@name} <- type
      let case_ok = Lit.Core.World.check.term(cases.head, type, ext_ctx, world)
      let rest_ok = Lit.Core.World.check.match.cases(cases.tail, type, forms.tail, name, ctx, world)
      case_ok && rest_ok
    nil nil:
      true
  } default false

// Validation
// ----------

// Checks if:
// - no global binders with the same name
// - variables are used at most once
Litereum.Core.World.validate(
  term: Lit.Core.Term
  used: Map<Bool>
): Pair<Map<Bool>,Bool>
  case term {
    var:
      case used{term.name} as was_used {
        none:
          // undefined variable
          {used, false}
        some: 
          if was_used.value then
            // variable already used
            {used, false}
          else
            // first use of the variable
            {used{term.name} <- true, true}
      }
    create:
      let state = {used, true}
      let state = for val in term.vals:
        let {used, res0} = state
        let {used, res1} = Litereum.Core.World.validate(val, used)
        {used, res0 && res1}
      state
    match:
      let state = Litereum.Core.World.validate(term.expr, used)
      let state = for cse in term.cses:
        let {fields, body} = cse
        let state = for field in fields:
          let {used, resx} = state
          case used{field} as got {
            some: {used, false} // same name used more than once
            none: {used{field} <- false, resx}
          }
        state
      state
    label:
      {used, true}
    compare:
      let {used, res0} = Litereum.Core.World.validate(term.val0, used)
      let {used, res1} = Litereum.Core.World.validate(term.val1, used)
      let {used, res2} = Litereum.Core.World.validate(term.iflt, used)
      let {used, res3} = Litereum.Core.World.validate(term.ifeq, used)
      let {used, res4} = Litereum.Core.World.validate(term.ifgt, used)
      {used, res0 && res1 && res2 && res3 && res4}
    call:
      let used = used{term.name} <- false
      let {used, res0} = Litereum.Core.World.validate(term.argm, used)
      let {used, res1} = Litereum.Core.World.validate(term.cont, used)
      {used, res0 && res1}
    bind:
      let used = used{term.name} <- false
      let {used, res0} = Litereum.Core.World.validate(term.main, used)
      let {used, res1} = Litereum.Core.World.validate(term.cont, used)
      {used, res0 && res1}
  }

// Execution
// ---------

Lit.Core.World.run.page(
  page: Lit.Core.Page
  world: Lit.Core.World
): Maybe<Lit.Core.World>
  case page {
    nil: some(world)
    cons: case Lit.Core.World.run.line(page.head, world) as new_world {
      none: none
      some: Lit.Core.World.run.page(page.tail, new_world.value)
    }
  }

Lit.Core.World.run.line(
  line: Lit.Core.Line
  world: Lit.Core.World
): Maybe<Lit.Core.World>
  case line {
    new_type:
      // TODO: check something?
      let type = line.value
      case type {
        lab:
          none
        adt: 
          log("- new_type: " | type.name)
          case world{type.name} as got_type {
            none: some(world{type.name} <- Lit.Core.Entry.type(type))
          } default log("error: type redefinition: " | type.name) none
      }
    new_bond:
      use bond = line.value
      log("- new_bond: " | bond.name)
      case world{bond.name} as got {
        none:
          let new_world = world{bond.name} <- Lit.Core.Entry.bond(bond)
          let inty = Lit.Core.World.get_type(bond.inty, world) abort log("error: bond inty not found: " | bond.name) none
          let outy = Lit.Core.World.get_type(bond.outy, world) abort log("error: bond outy not found: " | bond.name) none
          let ctx = {"input": inty, "caller": Lit.Core.Type.lab}
          let pass = Lit.Core.World.check.term(bond.main, outy, ctx, new_world)
          if pass then
            some(new_world)
          else
            log("error: bond ill-typed: " | bond.name) none
      } default log("error: bond redefinition: " | bond.name) none
    new_user:
      use user = line.value
      log("- new_user: " | user.name)
      case world{user.name} as got {
        none: some(world{user.name} <- Lit.Core.Entry.user(user))
      } default log("error: user redefinition: " | user.name) none
    ext_exec:
      use exec = line.value
      case world{exec.user} as got_entry {
        some: case got_entry.value as entry {
          user: 
            use user = entry.value
            let {result, world} = Lit.Core.World.run.term(exec.expr, exec.user, world, {})
            log("- ext_exec: " | Lit.Lang.show.term(result, world))
            some(world)
        } default log("error: exec user not a user") none
      } default log("error: exec user undefined") none
  }

Lit.Core.World.run.term(
  term: Lit.Core.Term
  self: String
  world: Lit.Core.World
  vars: Map<Lit.Core.Term>
): Pair<Lit.Core.Term, Lit.Core.World>
  //log("- run " | Lit.Lang.show.term(term,world))
  //log("- var " | String.join(", ", List.map!!((x) x@fst|":"|Lit.Lang.show.term(x@snd,world), Map.to_list!(vars))))
  //log("")
  case term {
    var: 
      case vars{term.name} as got {
        none: {term, world}
        some: Lit.Core.World.run.term(got.value, self, world, vars)
      }
    match: Maybe {
      let {expr, world} = Lit.Core.World.run.term(term.expr, self, world, vars)
      case expr {
        create: case term.cses[expr.form] as selected_case {
          some: 
            let {case_fields, case_body} = selected_case.value
            let vars = for subst in List.zip!!(case_fields, expr.vals):
              let {field, value} = subst
              vars{field} <- value
            Lit.Core.World.run.term(case_body, self, world, vars)
        } default {term, world}
      } default {term,world}
    }
    create:
      let {vals, world} = Lit.Core.World.run.terms(term.vals, self, world, vars)
      {Lit.Core.Term.create(term.type, term.form, vals), world}
    call: case world{term.func} as got {
      none:
        {term, world}
      some: case got.value as entry {
        bond:
          use bond = entry.value
          let {argm,world} = Lit.Core.World.run.term(term.argm, self, world, vars)
          let main_vars = vars
          let main_vars = main_vars{"input"} <- argm
          let main_vars = main_vars{"caller"} <- Lit.Core.Term.label(self)
          let {done,world} = Lit.Core.World.run.term(bond.main, term.func, world, main_vars)
          let cont_vars = vars
          let cont_vars = cont_vars{term.name} <- done
          Lit.Core.World.run.term(term.cont, self, world, cont_vars)
      } default {term,world}
    }
    bind: case world{term.name} as got {
      none:
        {term, world}
      some: case got.value as entry {
        bond:
          use bond = entry.value
          let main_vars = vars
          let main_vars = vars{"input"} <- Lit.Core.Term.var("input")
          let main_vars = vars{"caller"} <- Lit.Core.Term.var("caller")
          let {main, world} = Lit.Core.World.run.term(term.main, self, world, main_vars)
          let world = world{term.name} <- Lit.Core.Entry.bond(bond@main <- main)
          Lit.Core.World.run.term(term.cont, self, world, vars)
      } default {term, world}
    }
    compare: case term.val0 term.val1 {
      label label: 
        let result = case String.cmp(term.val0.name, term.val1.name) {
          ltn: term.iflt
          eql: term.ifeq
          gtn: term.ifgt
        }
        Lit.Core.World.run.term(result, self, world, vars)
    } default {term, world}
  } default {term,world}

Lit.Core.World.run.terms(
  terms: List<Lit.Core.Term>
  self: String
  world: Lit.Core.World
  vars: Map<Lit.Core.Term>
): Pair<List<Lit.Core.Term>, Lit.Core.World>
  case terms {
    nil:
      {[], world}
    cons:
      let {head, world} = Lit.Core.World.run.term(terms.head, self, world, vars)
      let {tail, world} = Lit.Core.World.run.terms(terms.tail, self, world, vars)
      {head & tail, world}
  }

// Tests
// -----

Lit.Core: _

  let world = {}

  let code = `
    user MrDog {
      0123456789abcdef
    }

    type Unit {
      new
    }

    type Bool {
      true
      false
    }

    type Nat {
      zero
      succ{pred: Nat}
    }

    type NatBool {
      new{
        x: Nat,
        y: Bool
      }
    }

    bond not {
      case input : Bool {
        true: Bool/false
        false: Bool/true
      }
    } : Bool -> Bool

    bond double {
      case input : Nat {
        zero:
          Nat/zero
        succ:
          call rest = double(input.pred)
          Nat/succ{pred: Nat/succ{pred: rest}}
      }
    } : Nat -> Nat

    with MrDog {
      call n = double(Nat/succ{pred: Nat/succ{pred: Nat/succ{pred: Nat/zero}}})
      call b = not(Bool/true)
      NatBool/new{x: n, y: b}
    } signed {}

    bond Count.get of Count {
      Nat/zero
    } : Unit -> Nat

    bond Count.inc {
      call count.got = Count.get(Unit/new)
      bind Count.get { Nat/succ{pred: count.got} }
      Unit/new
    } : Unit -> Nat

    with MrDog {
      call x = Count.inc(Unit/new)
      call x = Count.inc(Unit/new)
      call x = Count.inc(Unit/new)
      x
    } signed {}

    with MrDog {
      call x = Count.get(Unit/new)
      x
    } signed {}
  `

  let page = Parser.run!(Lit.Lang.parser.page(world), code) abort IO.print("parse error")

  case Lit.Core.World.run.page(page, world) as result {
    none: IO.print("failure")
    some: IO.print("success")
  }
