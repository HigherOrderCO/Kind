Lit.Bits.serialize.uint(size: Nat, value: Nat): Bits
  case size {
    zero: Bits.e
    succ: if (value % 2) =? 0
      then Bits.o(Lit.Bits.serialize.uint(size.pred, value / 2))
      else Bits.i(Lit.Bits.serialize.uint(size.pred, value / 2))
  }

Lit.Bits.deserialize.uint.go(size: Nat, bits: Bits): Pair<Bits,Nat>
  case size {
    zero: {bits, 0}
    succ: case bits {
      e: {Bits.e, 0}
      o:
        let {bits, value} = Lit.Bits.deserialize.uint.go(size.pred, bits.pred)
        {bits, 2 * value}
      i:
        let {bits, value} = Lit.Bits.deserialize.uint.go(size.pred, bits.pred)
        {bits, 1 + 2 * value}
    }
  }

Lit.Bits.deserialize.uint(size: Nat, bits: Bits): Nat
  Pair.snd!!(Lit.Bits.deserialize.uint.go(size, bits))
  
Lit.Bits.serialize.hash(hash: Lit.Cons.Hash): Bits
  Lit.Bits.serialize.uint(256, U256.to_nat(hash))

Lit.Bits.deserialize.hash.go(bits: Bits): Pair<Bits,Lit.Cons.Hash>
  let {bits, value} = Lit.Bits.deserialize.uint.go(256, bits)
  {bits, Nat.to_u256(value)}

Lit.Bits.deserialize.hash(bits: Bits): Lit.Cons.Hash
  Pair.snd!!(Lit.Bits.deserialize.hash.go(bits))

Lit.Bits.serialize.words(length: Nat, words: Vector<U256,length>): Bits
  case length with words {
    zero: Bits.e
    succ: case words {
      cons: Bits.concat(Lit.Bits.serialize.uint(256, U256.to_nat(words.head)), Lit.Bits.serialize.words(length.pred, words.tail))
    }
  }!

Lit.Bits.deserialize.words.go(length: Nat, bits: Bits): Pair<Bits,Vector<U256,length>>
  case length {
    zero: {bits, Vector.nil!}
    succ: 
      let {bits, head} = Lit.Bits.deserialize.uint.go(256, bits)
      let {bits, tail} = Lit.Bits.deserialize.words.go(length.pred, bits)
      {bits, Vector.cons!<length.pred>(Nat.to_u256(head), tail)}
  }!

Lit.Bits.deserialize.words(length: Nat, bits: Bits): Vector<U256,length>
  Pair.snd!!(Lit.Bits.deserialize.words.go(length, bits))

Lit.Bits.serialize.address(address: Lit.Cons.Address): Bits
  open address
  Bits.flatten([
    Lit.Bits.serialize.uint(8, U8.to_nat(address.ip0)),
    Lit.Bits.serialize.uint(8, U8.to_nat(address.ip1)),
    Lit.Bits.serialize.uint(8, U8.to_nat(address.ip2)),
    Lit.Bits.serialize.uint(8, U8.to_nat(address.ip3)),
    Lit.Bits.serialize.uint(16, U16.to_nat(address.port)),
  ])

Lit.Bits.deserialize.address.go(bits: Bits): Pair<Bits,Lit.Cons.Address>
  let {bits, ip0} = Lit.Bits.deserialize.uint.go(8, bits)
  let {bits, ip1} = Lit.Bits.deserialize.uint.go(8, bits)
  let {bits, ip2} = Lit.Bits.deserialize.uint.go(8, bits)
  let {bits, ip3} = Lit.Bits.deserialize.uint.go(8, bits)
  let {bits, port} = Lit.Bits.deserialize.uint.go(16, bits)
  {bits, Lit.Cons.Address.ipv4(Nat.to_u8(ip0), Nat.to_u8(ip1), Nat.to_u8(ip2), Nat.to_u8(ip3), Nat.to_u16(port))}

Lit.Bits.deserialize.address(bits: Bits): Lit.Cons.Address
  Pair.snd!!(Lit.Bits.deserialize.address.go(bits))

Lit.Bits.serialize.list<A: Type>(item: A -> Bits, list: List<A>): Bits
  case list {
    nil: Bits.o(Bits.e)
    cons: Bits.i(Bits.concat(item(list.head), Lit.Bits.serialize.list<A>(item, list.tail)))
  }

Lit.Bits.deserialize.list.go<A: Type>(item: Bits -> Pair<Bits,A>, bits: Bits): Pair<Bits,List<A>>
  case bits {
    e:
      {Bits.e, []}
    o:
      {bits.pred, []}
    i:
      let bits = bits.pred
      let {bits, head} = item(bits)
      let {bits, tail} = Lit.Bits.deserialize.list.go<A>(item, bits)
      {bits, head & tail}
  }

Lit.Bits.deserialize.list<A: Type>(item: Bits -> Pair<Bits,A>, bits: Bits): List<A>
  Pair.snd!!(Lit.Bits.deserialize.list.go<A>(item, bits))

Lit.Bits.serialize.page(page: Lit.Cons.Page): Bits
  open page
  Bits.flatten([
    Lit.Bits.serialize.uint(256, U256.to_nat(page.prev)),
    Lit.Bits.serialize.uint(256, U256.to_nat(page.nonc)),
    Lit.Bits.serialize.words(40, page.body),
  ])

Lit.Bits.deserialize.page.go(bits: Bits): Pair<Bits,Lit.Cons.Page>
  let {bits,nonc} = Lit.Bits.deserialize.uint.go(256, bits)
  let {bits,prev} = Lit.Bits.deserialize.uint.go(256, bits)
  let {bits,body} = Lit.Bits.deserialize.words.go(40, bits)
  {bits, Lit.Cons.Page.new(Nat.to_u256(prev), Nat.to_u256(nonc), body)}

Lit.Bits.deserialize.page(bits: Bits): Lit.Cons.Page
  Pair.snd!!(Lit.Bits.deserialize.page.go(bits))

Lit.Bits.serialize.message(message: Lit.Cons.Message): Bits
  case message {
    ping: 
      Bits.concat(Lit.Bits.serialize.uint(4,0), Lit.Bits.serialize.list!(Lit.Bits.serialize.address, message.addresses))
    request_page:
      Bits.concat(Lit.Bits.serialize.uint(4,1), Lit.Bits.serialize.uint(256, U256.to_nat(message.hash)))
    share_page:
      Bits.concat(Lit.Bits.serialize.uint(4,2), Lit.Bits.serialize.page(message.page))
  }

Lit.Bits.deserialize.message.go(bits: Bits): Pair<Bits,Lit.Cons.Message>
  let {bits, variant} = Lit.Bits.deserialize.uint.go(4,bits)
  switch Nat.eql(variant) {
    0:
      let {bits, addresses} = Lit.Bits.deserialize.list.go!(Lit.Bits.deserialize.address.go, bits)
      {bits, Lit.Cons.Message.ping(addresses)}
    1: 
      let {bits, hash} = Lit.Bits.deserialize.uint.go(256, bits)
      {bits, Lit.Cons.Message.request_page(Nat.to_u256(hash))}
    2:
      let {bits, page} = Lit.Bits.deserialize.page.go(bits)
      {bits, Lit.Cons.Message.share_page(page)}
  } default {bits, Lit.Cons.Message.ping([])}

Lit.Bits.deserialize.message(bits: Bits): Lit.Cons.Message
  Pair.snd!!(Lit.Bits.deserialize.message.go(bits))
