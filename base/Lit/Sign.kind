// Types
// -----

// A private key is a set of 32 words
Lit.Sign.Private: Type
  Vector<U256, 32>

// A public key is the hash^32 of the private key
Lit.Sign.Public: Type
  Vector<U256, 32>

// An address is the hash of a public key
Lit.Sign.Address: Type
  U256

// A hash is a 256-bit word
Lit.Sign.Hash: Type
  U256

// A signature is a set of 32 words
// - 30 words sign the first 30 bytes of the message hash
// -  2 words sign the checksum
Lit.Sign.Signature: Type
  Vector<U256, 32>

// The 32 bytes to be signed by a signature
Lit.Sign.Summary: Type
  Vector<U8, 32>

// Signatures
// ----------

// Takes the Keccak hash of a list of words
Lit.Sign.Hash.from_words(words: List<U256>): Lit.Sign.Hash
  Crypto.Keccak.hash.words(words)

// Hashes a buffer into a 256-bit signable string
Lit.Sign.Summary.from_bytes(bytes: Pair<U32,Buffer8>): Lit.Sign.Summary
  let hash_bytes = List.drop!(2,Buffer8.to_list(Crypto.Keccak.hash.bytes(bytes)))
  let checksum = List.sum.u32(List.map!!(U8.to_u32,hash_bytes))
  let byte_0 = U32.to_u8(U32.div(checksum, 256))
  let byte_1 = U32.to_u8(U32.mod(checksum, 256))
  Vector.from_list.length!(32, 0, byte_0 & byte_1 & hash_bytes)
  //let vals = Buffer8.to_list(Crypto.Keccak.hash.bytes(bytes))
  //let csum = 7680 :: U32
  //let csum = for i from 2 to List.length!(vals): csum - U8.to_u32(vals[i] <> 0)
  //let vals = vals[0] <- U32.to_u8(U32.div(csum, 256))
  //let vals = vals[1] <- U32.to_u8(U32.mod(csum, 256))
  //let vals = Vector.from_list.length!(32, 0, vals)
  //vals

// Converts a list of words to a signable
Lit.Sign.Summary.from_words(words: List<U256>): Lit.Sign.Summary
  Lit.Sign.Summary.from_bytes(Buffer8.from_list.256(words))

// Converts a UTF-8 string to a signable
Lit.Sign.Summary.from_utf8(str: String): Lit.Sign.Summary
  Lit.Sign.Summary.from_bytes(Buffer8.from_hex(String.to_hex(str)))

// Converts a seed to a private key
Lit.Sign.Private.from_seed(seed: U256): Lit.Sign.Private
  Lit.Sign.Private.from_seed.go(32, seed)

Lit.Sign.Private.from_seed.go(len: Nat, seed: U256): Vector<U256,len>
  case len {
    zero:
      Vector.nil!
    succ:
      let head = Lit.Sign.Hash.from_words([U256.add(seed, Nat.to_u256(len))])
      let tail = Lit.Sign.Private.from_seed.go(len.pred, seed)
      Vector.cons<U256,len.pred>(head, tail)
  }!

// Coverts a private key to an address
Lit.Sign.Public.from_private(pvt: Lit.Sign.Private): Lit.Sign.Private
  Lit.Sign.Public.from_private.go(32, pvt)

Lit.Sign.Public.from_private.go(len: Nat, pvt: Vector<U256,len>): Vector<U256,len>
  case len with pvt {
    zero: Vector.nil!
    succ: case pvt {
      cons:
        let hash = pvt.head
        let hash = for i from 0 to 256:
          Lit.Sign.Hash.from_words([hash])
        Vector.cons<U256,len.pred>(hash, Lit.Sign.Public.from_private.go(len.pred, pvt.tail))
    }
  }!

// Converts a public key to an address
Lit.Sign.Address.from_public(pub: Lit.Sign.Public): Lit.Sign.Address
  let vals = Buffer8.from_list.256(Vector.to_list!(32, pub))
  let addr = Buffer8.to_u256(Crypto.Keccak.hash.bytes(vals)@snd)
  addr

// Signs a signable
Lit.Sign.Signature.sign(msg: Lit.Sign.Summary, pvt: Lit.Sign.Private): Lit.Sign.Signature
  Lit.Sign.Signature.sign.go(32, msg, pvt)

Lit.Sign.Signature.sign.go(len: Nat, msg: Vector<U8,len>, pvt: Vector<U256,len>): Vector<U256,len>
  case len with msg pvt {
    zero: case msg pvt {
      nil nil: Vector.nil!
    }
    succ: case msg pvt {
      cons cons:
        let hash = pvt.head
        let hash = for i from 0 to 256 - U8.to_nat(msg.head):
          Lit.Sign.Hash.from_words([hash])
        Vector.cons<U256,len.pred>(hash, Lit.Sign.Signature.sign.go(len.pred, msg.tail, pvt.tail))
    }
  }!

// Verifies if a signature is correct
Lit.Sign.Signature.verify(msg: Lit.Sign.Summary, addr: Lit.Sign.Address, sig: Lit.Sign.Signature): Bool
  let checksums = Lit.Sign.Signature.checksum(msg)
  let sign_addr = Lit.Sign.Signature.recover(msg, sig)
  checksums && U256.eql(addr, sign_addr)

// Checks if the signable checksum is correct
Lit.Sign.Signature.checksum(msg: Lit.Sign.Summary): Bool
  let bytes = Vector.to_list<U8>(32, msg)
  let byte_0 = U8.to_u32(bytes[0] <> 0#8)
  let byte_1 = U8.to_u32(bytes[1] <> 0#8)
  let checksum_a = List.sum.u32(List.map!!(U8.to_u32,List.drop!(2, bytes)))
  let checksum_b = U32.add(U32.mul(byte_0,256),byte_1)
  U32.eql(checksum_a, checksum_b)
  //let vals = Vector.to_list<U8>(len, msg)
  //let csum = 7650 :: U32
  //let csum = for i from 2 to List.length!(vals):
    //csum - U8.to_u32(vals[i] <> 0)
  //let cs_0 = U8.to_u32(vals[0] <> 0)
  //let cs_1 = U8.to_u32(vals[1] <> 0)
  //U32.eql(csum, U32.add(U32.mul(cs_0, 256), cs_1))

// Returns the public key that signed a message
Lit.Sign.Signature.recover(msg: Lit.Sign.Summary, sig: Lit.Sign.Signature): Lit.Sign.Address
  Lit.Sign.Address.from_public(Lit.Sign.Signature.recover.go(32, msg, sig))

Lit.Sign.Signature.recover.go(len: Nat, msg: Vector<U8,len>, sig: Vector<U256,len>): Vector<U256,len>
  case len with msg sig {
    zero: Vector.nil!
    succ: case msg sig {
      cons cons:
        let hash = sig.head
        let hash = for i from 0 to U8.to_nat(msg.head): Lit.Sign.Hash.from_words([hash])
        Vector.cons<U256,len.pred>(hash, Lit.Sign.Signature.recover.go(len.pred, msg.tail, sig.tail))
    }
  }!

Lit.Sign: _
  let pvt = Lit.Sign.Private.from_seed(123)
  let pub = Lit.Sign.Public.from_private(pvt)
  let adr = Lit.Sign.Address.from_public(pub)
  let msg = Lit.Sign.Summary.from_utf8("oi tudo bem?")
  let sig = Lit.Sign.Signature.sign(msg, pvt)
  let oks = Lit.Sign.Signature.verify(msg, adr, sig)
  IO {
    for val in Vector.to_list!(32, sig):
      IO.print(U256.hex.encode(val))
    IO.print(Bool.show(oks))
  }

