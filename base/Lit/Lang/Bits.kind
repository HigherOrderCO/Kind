Lit.Lang.Bits: String
`

Bits.tail(a: Bits): Pair.Bits
  case a : Bits { 
    e: Bits/e
    o: a.pred
    i: a.pred
  }

Bits.inc(a: Bits): Bits
  case a : Bits { 
    e:
      Bits/i{pred: Bits/e}
    o:
      Bits/i{pred: a.pred}
    i:
      call inc = Bits.inc(a.pred)
      Bits/o{pred: inc}
  }

Bits.size.aux(b: Bits, n: Nat, s: Nat): Nat
  case b : Bits {
    e: s
    o: 
      call rec = Bits.size.aux(b.pred, Nat/succ{pred: n}, s)
      rec
    i:
      call m = Nat.add(n, s)
      call rec = Bits.size.aux(b.pred, Nat/zero, Nat/succ{pred: m})
      rec
  }


Bits.size(b: Bits): Nat
  call size = Bits.size.aux(b, Nat/zero, Nat/zero)
  size

Bits.and(a: Bits, b: Bits): Bits
  case a : Bits { 
    e: b
    o: case b : Bits { 
      e: Bits/o{pred: a.pred}
      o: 
        call rec = Bits.and(a.pred, b.pred)
        Bits/o{pred: rec}
      i:
        call rec = Bits.and(a.pred, b.pred)
        Bits/o{pred: rec}
      }
    i: case b : Bits { 
      e: Bits/i{pred: a.pred}
      o:
        call rec = Bits.and(a.pred, b.pred)
        Bits/o{pred: rec}
      i:
        call rec = Bits.and(a.pred, b.pred)
        Bits/i{pred: rec} 
    }
  }

Bits.concat(a: Bits, b: Bits): Bits
  case a : Bits { 
    e: b
    o:
      call rec = Bits.concat(a.pred, b)
      Bits/o{pred: rec}
    i:
      call rec = Bits.concat(a.pred, b)
      Bits/i{pred: rec}
  }


Bits.not(b: Bits): Bits 
  case b : Bits {
    e: Bits/e
    o: 
      call rec = Bits.not(b.pred)
      Bits/i{pred: rec}
    i:
      call rec = Bits.not(b.pred)
      Bits/o{pred: rec}
  }

Bits.or(a: Bits, b: Bits): Bits
  case a : Bits { 
    e: b
    o: case b : Bits { 
      e: Bits/o{pred: a.pred}
      o: 
        call rec = Bits.or(a.pred, b.pred)
        Bits/o{pred: rec}
      i:
        call rec = Bits.or(a.pred, b.pred)
        Bits/i{pred: rec}
    }
    i: case b : Bits { 
      e: Bits/i{pred: a.pred}
      o: 
        call rec = Bits.or(a.pred, b.pred)
        Bits/i{pred: rec}
      i:
        call rec = Bits.or(a.pred, b.pred)
        Bits/i{pred: rec}
    }
  }

Bits.reverse.aux(a: Bits, r: Bits): Bits
  case a : Bits { 
    e: r
    o:
      call rec = Bits.reverse.aux(a.pred, Bits/o{pred: r})
      rec
    i:
      call rec = Bits.reverse.aux(a.pred, Bits/i{pred: r})
      rec
  }

Bits.reverse(b: Bits): Bits
  call rev = Bits.reverse.aux(b, Bits/e)
  rev

// Operations

Bits.add(a: Bits, b: Bits): Bits
  case b : Bits { 
    e: a
    o: case a : Bits { 
      e: Bits/o{pred: a.pred}
      o: 
        call rec = Bits.add(a.pred, b.pred)
        Bits/o{pred: rec}
      i:
        call rec = Bits.add(a.pred, b.pred)
        Bits/i{pred: rec}
    }
    i: case a : Bits { 
      e: Bits/i{pred: a.pred}
      o:
        call rec = Bits.add(a.pred, b.pred)
        Bits/i{pred: rec}
      i:
        call inc = Bits.inc(a.pred)
        call rec = Bits.add(inc, b.pred)
        Bits/o{pred: rec}
    }
  }


Bits.add_p(a: Bits, b: Bits): BitsBitsBits
  case a : Bits {
    e: 
      call dup = Bits.dup(b)
      case dup : Pair.Bits {
        new: 
          BitsBitsBits/new {
            fst: Bits/e,
            snd: dup.fst,
            trd: dup.snd
          }
      }
    o: case b : Bits {
      e:
        call dup = Bits.dup(Bits/o{pred: a.pred})
        case dup : Pair.Bits {
          new:
            BitsBitsBits/new {
              fst: dup.fst,
              snd: Bits/e,
              trd: dup.snd
            }
        }
      o:
        call rec = Bits.add_p(a.pred, b.pred)
        case rec : BitsBitsBits { 
          new:
            BitsBitsBits/new{
              fst: Bits/o{pred: rec.fst}
              snd: Bits/o{pred: rec.snd}
              trd: Bits/o{pred: rec.trd}
        }

      i:
        call rec = Bits.add_p(a.pred, b.pred)
        case rec : BitsBitsBits { 
          new:
            BitsBitsBits/new{
              fst: Bits/i{pred: rec.fst}
              snd: Bits/i{pred: rec.snd}
              trd: Bits/i{pred: rec.trd}
        }
    }

    i: case b: Bits {
      e:
        call dup = Bits.dup(Bits/i{pred: a.pred})
        case dup : Pair.Bits {
          new:
            BitsBitsBits/new {
              fst: dup.fst,
              snd: Bits/e,
              trd: dup.snd
            }
        }
      o:
        call rec = Bits.add_p(a.pred, b.pred)
        case rec : BitsBitsBits { 
          new:
            BitsBitsBits/new{
              fst: Bits/i{pred: rec.fst}
              snd: Bits/o{pred: rec.snd}
              trd: Bits/i{pred: rec.trd}
        }
    }
      i:
        call rec = Bits.add_p(a.pred, b.pred)
        case rec : BitsBitsBits {
          new:
            call inc = Bits.inc(rec.trd)
            BitsBitsBits/new { 
              fst: Bits/i{pred: rec.fst}
              snd: Bits/i{pred: rec.snd}
              trd: Bits/o{pred: inc}
            }
        }
      }
  }
  

Bits.sub.aux(a: Bits, b: Bits, r: Bits): Bits
  case b : Bits { 
    e: case a : Bits { 
      e: r
      o:
        call rec = Bits.sub.aux(a.pred, b, Bits/o{pred: r})
        rec
      i:
        call rec = Bits.sub.aux(a.pred, b, Bits/i{pred: r})
        rec
    }
    o: case a : Bits { 
      e: 
        call rec = Bits.sub.aux(Bits/o{pred: a.pred}, b.pred, Bits/o{pred: r})
        rec
      o:
        call rec = Bits.sub.aux(a.pred, b.pred, Bits/o{pred: r})
        rec
      i:
        call rec = Bits.sub.aux(a.pred, b.pred, Bits/i{pred: r})
        rec
    }
    i: case a : Bits {
      e: Bits/e
      o:
        call inc = Bits.inc(b.pred)
        call rec = Bits.sub.aux(a.pred, inc , Bits/i{pred: r})
        rec
      i:
        call rec = Bits.sub.aux(a.pred, b.pred, Bits/o{pred: r})
        rec
    }
  }

Bits.sub(a: Bits, b: Bits): Bits
  call aux = Bits.sub.aux(a, b, Bits/e)
  call sub = Bits.reverse(aux)
  sub

Bits.mul.aux(a: Bits, b: Bits, r: Bits): Bits
  case b : Bits { 
    e: r
    o:
      call rec = Bits.mul.aux(Bits/o{pred: a}, b.pred, r)
      rec
    i:
      call add = Bits.add(a, r)
      call rec = Bits.mul.aux(Bits/o{pred: a}, b.pred, add)
      rec
  }

Bits.mul(a: Bits, b: Bits): Bits
  call mul = Bits.mul.aux(a, b, Bits/e)
  mul

////////////

Bits.take(n: Nat, xs: Bits): Bits
  case n : Nat {
    zero: Bits/e
    succ: case xs : Bits {
      e: Bits/e
      o: 
        call rec = Bits.take(n.pred, xs.pred)
        Bits/o{pred: rec}
      i:
        call rec = Bits.take(n.pred, xs.pred)
        Bits/i{pred: rec}
    }
  }

Bits.drop(n: Nat, xs: Bits): Bits
 case n : Nat {
   zero: xs
   succ: case xs : Bits { 
     e: xs
     o:
       call rec = Bits.drop(n.pred, xs.pred)
       rec
     i:
       call rec = Bits.drop(n.pred, xs.pred)
       rec
   }
 }

// Comparisons

Bits.eql(a: Bits, b: Bits): Bool
  case a : Bits { 
    e: case b : Bits { 
      e: Bool/true
      o: Bool/false
      i: Bool/false
    }
    o: case b : Bits { 
      e: Bool/false
      o:
        call rec = Bits.eql(a.pred, b.pred)
        rec
      i: Bool/false
    }
    i: case b : Bits { 
      e: Bool/false
      o: Bool/false
      i: 
        call rec = Bits.eql(a.pred, b.pred)
        rec
    }
  }

Bits.cmp.aux(a: Bits, b: Bits, c: Cmp): BitsBitsCmp
  case a : Bits { 
    e: case b : Bits {
      e:
        BitsBitsCmp/new{
          fst: Bits/e
          snd: Bits/e
          trd: c
        }
      o:
        call rec = Bits.cmp.aux(Bits/e, b.pred, c)
        case rec : BitsBitsCmp {
          new:
            BitsBitsCmp/new{
              fst: Bits/e
              snd: Bits/o{pred: rec.snd}
              trd: rec.trd
            }
        }
      i:
        BitsBitsCmp/new{
          fst: Bits/e
          snd: Bits/o{pred: b.pred}
          trd: Cmp/ltn
        }
    }
    o:
      case b : Bits { 
        e:
          call rec = Bits.cmp.aux(a.pred, Bits/e, c)
          case rec : BitsBitsCmp {
            new:
              BitsBitsCmp/new{
                fst: Bits/o{pred: rec.fst}
                snd: Bits/e
                trd: rec.trd
              }
          }
        o:
          call rec = Bits.cmp.aux(a.pred, b.pred, c)
          case rec : BitsBitsCmp {
            new:
              BitsBitsCmp/new{
                fst: Bits/o{pred: rec.fst}
                snd: Bits/o{pred: rec.snd}
                trd: rec.trd
              }
          }
        i:
          call rec = Bits.cmp.aux(a.pred, b.pred, Cmp/ltn)
          case rec : BitsBitsCmp {
            new:
              BitsBitsCmp/new{
                fst: Bits/o{pred: rec.fst}
                snd: Bits/o{pred: rec.snd}
                trd: rec.trd
              }
          }
      }
    i:
      case b : Bits { 
        e:
          BitsBitsCmp/new{
            fst: Bits/i{pred: a.pred}
            snd: Bits/e
            trd: Cmp/gtn
          }
        o: 
          call rec = Bits.cmp.aux(a.pred, b.pred, Cmp/gtn)
          case rec : BitsBitsCmp {
            new:
              BitsBitsCmp/new{
                fst: Bits/i{pred: rec.fst}
                snd: Bits/o{pred: rec.snd}
                trd: rec.trd
              }
          }
        i:
          call rec = Bits.cmp.aux(a.pred, b.pred, c)
          case rec : BitsBitsCmp {
            new:
              BitsBitsCmp/new{
                fst: Bits/i{pred: rec.fst}
                snd: Bits/i{pred: rec.snd}
                trd: rec.trd
              }
          }
      }
  }

Bits.cmp(a: Bits, b: Bits): BitsBitsCmp
  call bbcmp = Bits.cmp.aux(a, b, Cmp/eql)
  bbcmp

Bits.gte(a: Bits, b: Bits): BitsBitsBool
  call bbcmp = Bits.cmp(a, b)
  case bbcmp : BitsBitsCmp {
    new:
      call gte = Cmp.as_gte(bbcmp.trd)
      BitsBitsBool/new{
        fst: bbcmp.fst
        snd: bbcmp.snd
        trd: gte
      }
  }

Bits.gtn(a: Bits, b: Bits): BitsBitsBool
  call bbcmp = Bits.cmp(a, b)
  case bbcmp : BitsBitsCmp {
    new:
      call gtn = Cmp.as_gtn(bbcmp.trd)
      BitsBitsBool/new{
        fst: bbcmp.fst
        snd: bbcmp.snd
        trd: gtn
      }
  }

Bits.lte(a: Bits, b: Bits): BitsBitsBool
  call bbcmp = Bits.cmp(a,b)
  case bbcmp : BitsBitsCmp {
    new:
      call lte = Cmp.as_lte(bbcmp.trd)
      BitsBitsBool/new{
        fst: bbcmp.fst
        snd: bbcmp.snd
        trd: lte
      }
  }

Bits.ltn(a: Bits, b: Bits): BitsBitsBool
  call bbcmp = Bits.cmp(a,b)
  case bbcmp : BitsBitsCmp {
    new:
      call ltn = Cmp.as_ltn(bbcmp.trd)
      BitsBitsBool/new{
        fst: bbcmp.fst
        snd: bbcmp.snd
        trd: ltn
      }
  }

Bits.dup(a: Bits): Pair.Bits
  case a : Bits {
    e:
      Pair.Bits/new{fst: Bits/e, snd: Bits/e}
    o:
      call dupped = Bits.dup(a.pred)
      case dupped : Pair.Bits {
        new:
          Pair.Bits/new{
            fst: Bits/o{pred: dupped.fst},
            snd: Bits/o{pred: dupped.snd},
          }
      }
    i:
      call dupped = Bits.dup(a.pred)
      case dupped : Pair.Bits {
        new:
          Pair.Bits/new{
            fst: Bits/i{pred: dupped.fst},
            snd: Bits/i{pred: dupped.snd},
          }
      }
  }
`
