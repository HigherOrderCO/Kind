// The body of a Lit.Cons Page can hold up to 8 words
Lit.Cons.Body: Type
  Vector<U256,40>

// A Lit.Cons hash is a 256-bit word
Lit.Cons.Hash: Type
  U256

// An IP networking address
type Lit.Cons.Address {
  ipv4(ip0: U8, ip1: U8, ip2: U8, ip3: U8, port: U16)
}

// A networking peer
type Lit.Cons.Peer {
  new(
    last_seen: Nat
    address: Lit.Cons.Address
  )
}

type Lit.Cons.Message {
  ping(addresses: List<Lit.Cons.Address>)
  request_page(hash: Lit.Cons.Hash)
  share_page(page: Lit.Cons.Page)
}

// A network message received from a sender
type Lit.Cons.Received {
  new(
    sender: Lit.Cons.Peer
    message: Lit.Cons.Message
  )
}

// A Lit.Cons page
type Lit.Cons.Page {
  new(
    prev: U256            // previous page (32 bytes)
    nonc: U256            // nonce + extra data (32 bytes)
    user: U256            // miner address or identifier
    body: Vector<U256,40> // page contents (1280 bytes)
  )
}

// Holds all the pages and aux structures
type Lit.Cons.Store {
  new(
    page: Map<Lit.Cons.Page>           // maps PageHash to Page object
    seen: Map<Unit>                    // set of PageHash that I have downloaded
    children: Map<List<Lit.Cons.Hash>> // maps PageHash to list of PageHash that link to it
    pending: Map<List<Lit.Cons.Page>>  // maps PageHash to list of pages waiting it for inclusion
    score: Map<Lit.Cons.Hash>          // maps PageHash to cached score
    tip: Pair<U256,Lit.Cons.Hash>      // current tip PageHash
  )
}

// The state of a Lit.Cons node
type Lit.Cons.Node {
  new(
    port: Nat
    peers: Map<Lit.Cons.Peer>
    store: Lit.Cons.Store
  )
}

Lit.Cons.Message.show(message: Lit.Cons.Message): String
  case message {
    ping: "ping(" | String.join(",", List.map!!(Lit.Cons.Address.show, message.addresses)) | ")"
    share_page: "share_page(" | Lit.Cons.Hash.show(Lit.Cons.Hash.from_page(message.page)) | ")"
    request_page: "request_page(" | Lit.Cons.Hash.show(message.hash) | ")"
  }

// Takes the Keccak hash of a list of words
Lit.Cons.Hash.from_words(words: List<U256>): Lit.Cons.Hash
  Crypto.Keccak.hash.words(words)

Lit.Cons.Hash.show(hash: Lit.Cons.Hash): String
  String.pad_left(64, '0', Nat.hex.encode(U256.to_nat(hash)))

// Returns the PageHash
Lit.Cons.Hash.from_page(page: Lit.Cons.Page): Lit.Cons.Hash
  use page = page
  if U256.eql(page.prev, 0) && U256.eql(page.nonc, 0) then
    0#256
  else
    let words = Vector.to_list!(40, page.body) ++ [page.nonc, page.prev]
    Lit.Cons.Hash.from_words(words)

// Estimates how many attempts were needed to make this hash
Lit.Cons.Hash.score(hash: U256): U256
  if U256.eql(hash,0) then
    0
  else
    Nat.to_u256(Nat.pow(2,256) / U256.to_nat(hash))

// Increases the Page nonce until it is above target_score
Lit.Cons.Page.mine(page: Lit.Cons.Page, target_score: U256, attempts: U256): Maybe<Lit.Cons.Page>
  let page_score = Lit.Cons.Hash.score(Lit.Cons.Hash.from_page(page))
  //log("Mining. Score: " | U256.hex.encode(Lit.Cons.Hash.from_page(page)) | " " | U256.show(page_score))
  if U256.eql(attempts,0) then
    none
  else if U256.gte(page_score, target_score) then
    some(page)
  else
    Lit.Cons.Page.mine(page@nonc <- page@nonc + 1, target_score, attempts - 1)

// Adds a page to the chain, updating the score, children and tip
// If the prev is null, it is added to a pending map and re-added later
Lit.Cons.Store.add_page(page: Lit.Cons.Page, chain: Lit.Cons.Store): Lit.Cons.Store
  open page
  open chain
  open chain.tip
  let page_hash = Lit.Cons.Hash.from_page(page)
  case chain.page{U256.show(page_hash)} as got_page {
    some: // Page already included: do nothing
      chain
    none: // Page not included
      let prev_hash = page.prev
      case chain.page{U256.show(prev_hash)} as got_prev {
        some: // Parent included: add page and compute infos
          let prev_score     = chain.score{U256.show(prev_hash)} abort chain
          let page_score     = U256.add(prev_score, Lit.Cons.Hash.score(page_hash))
          let prev_children  = chain.children{U256.show(prev_hash)} <> []
          let pendings       = chain.pending{U256.show(page_hash)} <> []
          let chain.page     = chain.page{U256.show(page_hash)} <- page
          let chain.seen     = chain.seen{U256.show(page_hash)} <- unit
          let chain.score    = chain.score{U256.show(page_hash)} <- page_score
          let chain.children = chain.children{U256.show(prev_hash)} <- page_hash & prev_children
          let chain.tip      = if page_score >? Pair.fst!!(chain.tip) then {page_score,page_hash} else chain.tip
          let chain.pending  = Map.delete!(U256.show(page_hash), chain.pending)
          let chain          = Lit.Cons.Store.new(chain.page, chain.seen, chain.children, chain.pending, chain.score, chain.tip)
          let chain          = for pending in pendings: Lit.Cons.Store.add_page(pending, chain)
          chain
        none: // Parent not included
          case chain.seen{U256.show(page_hash)} as seen_page {
            some:
              // Page seen before: do nothing
              chain
            none:
              // Brand new page: add to pending list
              let pending_list  = page & (chain.pending{U256.show(prev_hash)} <> []) // TODO: avoid adding duplicates
              let chain.seen    = chain.seen{U256.show(page_hash)} <- unit
              let chain.pending = chain.pending{U256.show(prev_hash)} <- pending_list
              Lit.Cons.Store.new(chain.page, chain.seen, chain.children, chain.pending, chain.score, chain.tip)
          }
      }
  }

// The initial chain state
Lit.Cons.Store.genesis: Lit.Cons.Store
  let chain.page = {U256.show(0): Lit.Cons.Page.new(0,0,0,Vector.create!(40,()0))}
  let chain.seen = {}
  let chain.score = {U256.show(0): 0#256}
  let chain.pending = {}
  let chain.children = {U256.show(0): []}
  let chain.tip = {0#256, 0#256}
  Lit.Cons.Store.new(chain.page, chain.seen, chain.children, chain.pending, chain.score, chain.tip)

// Returns the longest chain, i.e., the one with most accumulated nonc
Lit.Cons.Store.longest_chain(chain: Lit.Cons.Store): List<Lit.Cons.Page>
  open chain
  open chain.tip
  case chain.page{U256.show(Pair.snd!!(chain.tip))} as tip_page {
    none: []
    some: Lit.Cons.Store.longest_chain.go(tip_page.value, chain.page, [])
  }

Lit.Cons.Store.longest_chain.go(
  page: Lit.Cons.Page
  pages: Map<Lit.Cons.Page>
  result: List<Lit.Cons.Page>
): List<Lit.Cons.Page>
  open page
  let result = List.cons!(page, result)
  if U256.eql(page.prev, 0) then
    result
  else case pages{U256.show(page.prev)} as prev {
    none: result
    some: Lit.Cons.Store.longest_chain.go(prev.value, pages, result)
  }

// Converts the IP of an address to a string
Lit.Cons.Address.show.ip(addr: Lit.Cons.Address): String
  open addr
  let ip0 = Nat.show(U8.to_nat(addr.ip0))
  let ip1 = Nat.show(U8.to_nat(addr.ip1))
  let ip2 = Nat.show(U8.to_nat(addr.ip2))
  let ip3 = Nat.show(U8.to_nat(addr.ip3))
  ip0 | "." | ip1 | "." | ip2 | "." | ip3

// Converts the port of an address to a string
Lit.Cons.Address.show.port(addr: Lit.Cons.Address): String
  open addr
  Nat.show(U16.to_nat(addr.port))

// Converts an address to a string
Lit.Cons.Address.show(addr: Lit.Cons.Address): String
  Lit.Cons.Address.show.ip(addr) | ":" | Lit.Cons.Address.show.port(addr)

Lit.Cons.Peer.show(peer: Lit.Cons.Peer): String
  open peer
  "<" | Lit.Cons.Address.show(peer.address) | ">"

Lit.Cons.Peer.map_from_list(peers: List<Lit.Cons.Peer>): Map<Lit.Cons.Peer>
  Map.from_list!(List.mapped!(peers)!((peer) { Lit.Cons.Address.show(peer@address), peer }))

Lit.Cons.Received.from_udp_message(time: Nat, recv: IO.recv_udp.Message): Maybe<Lit.Cons.Received>
  Maybe {
    open recv
    open recv.from
    let ip = List.mapped!(String.split(recv.from.ip, "."))!((x) Nat.to_u8(Nat.read(x)))
    let port = Nat.to_u16(recv.from.port)
    get ip0 = ip[0]
    get ip1 = ip[1]
    get ip2 = ip[2]
    get ip3 = ip[3]
    let peer = Lit.Cons.Peer.new(time, Lit.Cons.Address.ipv4(ip0, ip1, ip2, ip3, port))
    let msge = Lit.Bits.deserialize.message(Bits.hex.decode(recv.data))
    return Lit.Cons.Received.new(peer, msge)
  }

Lit.Cons.Node.send(node: Lit.Cons.Node, peer: Lit.Cons.Peer, message: Lit.Cons.Message): IO<Unit>
  open node
  open peer
  open peer.address
  let from_port = node.port
  let to_ip     = Lit.Cons.Address.show.ip(peer.address)
  let to_port   = U16.to_nat(peer.address.port)
  IO.send_udp(from_port, to_ip, to_port, Bits.hex.encode(Lit.Bits.serialize.message(message)))

Lit.Cons.Node.get_random_peers(node: Lit.Cons.Node, count: Nat): IO<List<Lit.Cons.Peer>>
  open node
  IO {
    get time = IO.get_time
    use rand = List.get_randoms!(time, count, Map.values!(node.peers))
    return rand.result
  }

Lit.Cons.Node.send_to_random_peers(node: Lit.Cons.Node, count: Nat, message: Lit.Cons.Message): IO<Unit>
  IO {
    get peers = Lit.Cons.Node.get_random_peers(node, count)
    Lit.Cons.Node.broadcast.go(node, message, peers)
  }

Lit.Cons.Node.broadcast(node: Lit.Cons.Node, message: Lit.Cons.Message): IO<Unit>
  Lit.Cons.Node.broadcast.go(node, message, Map.values!(node@peers))

Lit.Cons.Node.broadcast.go(node: Lit.Cons.Node, message: Lit.Cons.Message, peers: List<Lit.Cons.Peer>): IO<Unit>
  case peers {
    nil: IO.pass
    cons: IO {
      Lit.Cons.Node.send(node, peers.head, message)
      Lit.Cons.Node.broadcast.go(node, message, peers.tail)
    }
  }

// Lit.Cons Node
// ================

// Starts a Lit.Cons node at given port
Lit.Cons.Node.init(port: Nat): IO<Unit>
  IO {
    get time = IO.get_time
    let peers = Lit.Cons.Peer.map_from_list([
      Lit.Cons.Peer.new(time, Lit.Cons.Address.ipv4(127,0,0,1,42000))
      Lit.Cons.Peer.new(time, Lit.Cons.Address.ipv4(127,0,0,1,42001))
      Lit.Cons.Peer.new(time, Lit.Cons.Address.ipv4(127,0,0,1,42002))
      Lit.Cons.Peer.new(time, Lit.Cons.Address.ipv4(127,0,0,1,42003))
    ])
    let node = Lit.Cons.Node.new(port, peers, Lit.Cons.Store.genesis)
    Lit.Cons.Node.loop(node)
  }
  
Lit.Cons.Node.loop(node: Lit.Cons.Node): IO<Unit>
  IO {
    // Displays UI
    Lit.Cons.Node.display(node)
    IO.print("")

    // Handle incoming messages
    get inbox = IO.recv_udp(node@port)
    get node = Lit.Cons.Node.handle_inbox(node, inbox)

    // Attempts to mine a page and adds it if successful
    get time = IO.get_time
    let time = Nat.to_u256(time)
    let body = Vector.create!(40, (i) if i =? 39 then time else 0#256)
    let page = Lit.Cons.Page.new(node@store@tip@snd, 0, 0, body)
    let node = Lit.Cons.Node.mine(node, page) <> node

    // Pings random neighbors, sending random peers to them
    Lit.Cons.Node.ping(node)

    // Shares our best block with random neighbors
    Lit.Cons.Node.share_tip(node)

    // Requests contents of pending pages
    Lit.Cons.Node.request_pendings(node)

    // Forgets peers that look inactive
    get node = Lit.Cons.Node.forget_inactive_peers(node)

    // Loop
    IO.sleep(2000)
    Lit.Cons.Node.loop(node)

    return unit
  }

Lit.Cons.Node.display(node: Lit.Cons.Node): IO<Unit>
  open node
  open node.store
  let pages = Lit.Cons.Store.longest_chain(node.store)
  //let pages = Map.values!(node.store.page)
  IO {
    IO.clear
    get time = IO.get_time
    IO.print("~~ String:Chain ~~")
    IO.print("Time     : " | Nat.show(time))
    IO.print("Peers    : " | Nat.show(List.length!(Map.to_list!(node.peers))))
    IO.print("Pendings : " | Nat.show(List.length!(Map.to_list!(node.store.pending))))
    let pages_length = List.length!(pages)
    let pages_indexed = List.index!(pages)
    IO.print("index  | body[0]                                                         | hash                                                             | score") 
    for index_page in pages_indexed: IO {
      let {index, page} = index_page
      let half_count = 6
      if Nat.between(half_count, index, pages_length - half_count) then
        if index =? half_count
        then IO.print("(...)")
        else IO.pass
      else IO {
        open page
        let page_hash = Lit.Cons.Hash.from_page(page)
        let score = node.store.score{U256.show(page_hash)} <> 0#256
        let show_index = Nat.show(index)
        let show_body = String.hex.decode(Nat.hex.encode(U256.to_nat(Vector.head!!(page.body))))
        //let show_body = List.show!(U256.show,Vector.to_list!(32,page.body))
        let show_hash = Lit.Cons.Hash.show(page_hash)
        //let show_hash = Lit.Cons.Hash.show(page.prev)
        let show_score = U256.show(score)
        IO.print(""
          | String.pad_left_exact(6, '0', show_index) | " | "
          | String.pad_left_exact(64, '0', show_body) | " | "
          | String.pad_left_exact(64, '0', show_hash) | " | "
          | String.pad_left_exact(8, '0', show_score))
        //IO.print("[" | Nat.show(index) | "] " | Lit.Cons.Hash.show(page_hash) | " -- score: " | U256.show(score))
      }
    }
  }

Lit.Cons.Node.on_message(node: Lit.Cons.Node, received: Lit.Cons.Received): IO<Lit.Cons.Node>
  open received
  IO {
    get node = Lit.Cons.Node.refresh_peer(node, received.sender)
    open node
    open node.store
    case received.message {
      ping: IO {
        //log("~ received ping")
        //Lit.Cons.Node.send(node, received.sender, Lit.Cons.Message.pong)
        return node
      }
      request_page: 
        //log("~ received request")
        case node.store.page{U256.show(received.message.hash)} as got {
          none: IO {
            return node
          }
          some: IO {
            Lit.Cons.Node.send(node, received.sender, Lit.Cons.Message.share_page(got.value))
            return node
          }
        }
      share_page: IO {
        //log("~ received page")
        return Lit.Cons.Node.add_page(node, received.message.page)
      }
    } default IO {
      return node
    }
  }

Lit.Cons.Node.refresh_peer(node: Lit.Cons.Node, peer: Lit.Cons.Peer): IO<Lit.Cons.Node>
  open node
  open peer
  IO {
    get time = IO.get_time
    let peer = peer@last_seen <- time
    let node = node@peers <- (node.peers{Lit.Cons.Peer.show(peer)} <- peer)
    return node
  }

Lit.Cons.Node.add_page(node: Lit.Cons.Node, page: Lit.Cons.Page): Lit.Cons.Node
  open node
  node@store <- Lit.Cons.Store.add_page(page, node.store)

Lit.Cons.Node.handle_inbox(node: Lit.Cons.Node, inbox: List<IO.recv_udp.Message>): IO<Lit.Cons.Node>
  IO {
    IO.print("Handling incoming UDP messages...")
    Lit.Cons.Node.handle_inbox.go(node, inbox)
  }

Lit.Cons.Node.handle_inbox.go(node: Lit.Cons.Node, inbox: List<IO.recv_udp.Message>): IO<Lit.Cons.Node>
  case inbox {
    nil: IO {
      return node
    }
    cons: IO {
      open inbox.head
      get time = IO.get_time
      use received = Lit.Cons.Received.from_udp_message(time, inbox.head)
      case received {
        none: Lit.Cons.Node.handle_inbox.go(node, inbox.tail)
        some: IO {
          use received = received.value
          get node = Lit.Cons.Node.on_message(node, received)
          get node = Lit.Cons.Node.handle_inbox.go(node, inbox.tail)
          IO.print("- " | Lit.Cons.Peer.show(received.sender) | " " | Lit.Cons.Message.show(received.message))
          return node
        }
      }
    }
  }

Lit.Cons.Node.forget_inactive_peers(node: Lit.Cons.Node): IO<Lit.Cons.Node>
  open node
  IO {
    get time = IO.get_time
    let peers = Map.values!(node.peers)
    let peers = List.filter<Lit.Cons.Peer>((peer) (peer@last_seen + 10000) >? time, peers) 
    return node@peers <- Lit.Cons.Peer.map_from_list(peers)
  }

Lit.Cons.Node.ping(node: Lit.Cons.Node): IO<Unit>
  IO {
    log("Pinging peers...")
    get peers = Lit.Cons.Node.get_random_peers(node, 8)
    let message = Lit.Cons.Message.ping(List.mapped!(peers)!((peer) peer@address))
    Lit.Cons.Node.broadcast(node, message)
  }

Lit.Cons.Node.share_tip(node: Lit.Cons.Node): IO<Unit>
  open node
  open node.store
  IO {
    log("Sharing tip with peers...")
    let tip_page = node.store.page{U256.show(Pair.snd!!(node.store.tip))} abort IO.pass
    let message = Lit.Cons.Message.share_page(tip_page)
    Lit.Cons.Node.broadcast(node, message)
  }

Lit.Cons.Node.request_pendings(node: Lit.Cons.Node): IO<Unit>
  IO {
    log("Requesting pendings...")
    open node
    open node.store
    let pendings = List.map!!(U256.read, Map.keys!(node.store.pending))
    for pending in pendings:
      case node.store.seen{U256.show(pending)} as seen {
        none: 
          let message = Lit.Cons.Message.request_page(pending)
          Lit.Cons.Node.broadcast(node, message)
        some:
          IO.pass
      }
  }

Lit.Cons.Node.mine(node: Lit.Cons.Node, page: Lit.Cons.Page): Maybe<Lit.Cons.Node>
  IO {
    log("Mining page...")
    open node
    open node.store
    let mined_page = Lit.Cons.Page.mine(page, 32, 64)
    case mined_page {
      none: log("- Failure.") none
      some: log("- Success!") some(Lit.Cons.Node.add_page(node, mined_page.value))
    }
  }
