User.rigille.List.monotone_tail<A: Type, O: User.rigille.Order<A>>(x: A, ys: List<A>,
  Hyp: User.rigille.List.monotone<A, O>(List.cons<A>(x, ys))): User.rigille.List.monotone<A, O>(ys)
  open O
  let Hyp0 = ?b :: User.rigille.List.monotone.aux<A, O.rel>(List.cons<A>(x, ys))
  ?a

//List.unique_monotone_permutation<A: Type, O: User.rigille.Order<A>>(xs: List<A>, ys: List<A>,
//    Hyp0: User.rigille.List.monotone<A, O>(xs), Hyp1: User.rigille.List.monotone<A, O>(ys),
//    Hyp2: User.rigille.List.Perm<A>(xs, ys)): xs == ys
//  case Hyp2 {
//    nil: refl,
//    // List.cons(A,Hyp2.x,Hyp2.l0) == List.cons(A,Hyp2.x,Hyp2.l1)
//    skip: let ind = List.unique_monotone_permutation<A, O>(Hyp2.l0, Hyp2.l1)
//    ?d,
//    swap: ?e,
//    trans: ?f,
//  //nil ~ (xs = List.nil<A>,
//         //ys = List.nil<A>),
//
//  //skip(x: A, l0: List<A>, l1: List<A>,
//       //Hyp: User.rigille.List.Perm<A>(l0, l1)) ~ (xs = List.cons<A>(x, l0),
//                                //ys = List.cons<A>(x, l1)),
//
//  //swap(x: A, y: A, l: List<A>) ~ (xs = List.cons<A>(y, List.cons<A>(x, l)),
//                                  //ys = List.cons<A>(x, List.cons<A>(y, l))),
//
//  //trans(l0: List<A>, l1: List<A>, l2: List<A>,
//        //Hyp0: User.rigille.List.Perm<A>(l0, l1), Hyp1: User.rigille.List.Perm<A>(l1, l2)) ~ (xs = l0,
//                                                                   //ys = l2)
//
//  }!
