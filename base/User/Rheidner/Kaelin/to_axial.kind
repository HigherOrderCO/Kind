User.Rheidner.Kaelin.to_axial(coord: Pair(U32, U32)): Pair(U32, U32)
  let {x, y} = coord

  let f = U32.to_f64
  let u = F64.to_u32

  let float_x = F64.sub(f(128u), f(x))
  let float_y = F64.sub(f(128u), f(y))

  let fourth = F64.div(f(1u), f(4u))
  let sixth = F64.div(f(1u), f(6u))
  let third = F64.div(f(1u), f(3u))
  let half = F64.div(f(1u), f(2u))

  let axial_x = F64.sub( F64.mul(float_x, fourth), F64.mul(float_y, sixth) )
  let axial_y = F64.mul(float_y, third)
  let axial_z = F64.sub(F64.sub(f(0u), axial_x), axial_y)

  let axial_x_half = F64.add(axial_x, half)
  let axial_y_half = F64.add(axial_y, half)
  let axial_z_half = F64.add(axial_z, half)

  let round_x = F64.floor(axial_x_half)
  let round_y = F64.floor(axial_y_half)
  let round_z = F64.floor(axial_z_half)

  let diff_x = F64.sub(axial_x, round_x)
  let diff_y = F64.sub(axial_y, round_y)
  let diff_z = F64.sub(axial_z, round_z)
  
  case F64.gtn(diff_x, diff_z) {
    true:
      case F64.gtn(diff_y, diff_x){
        true: 
          let new_y = F64.sub(F64.sub(f(0u), round_x), round_z)
          {u(round_x), u(new_y)}
        false:
          let new_x = F64.sub(F64.sub(f(0u), round_y), round_z)
          {u(new_x), u(round_y)}
      }
    false:
      case F64.gtn(diff_y, diff_z) {
        true:
          let new_y = F64.sub(F64.sub(f(0u), round_x), round_z)
          {u(round_x), u(new_y)}
        false:
          {u(round_x), u(round_y)}
      }
  }
