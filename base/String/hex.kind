String.hex.decode.go(hexs: String): String
  case hexs {
    nil:
      ""
    cons: 
      let init = String.take(4, hexs)
      let rest = String.drop(4, hexs)
      let numb = Parser.run!(Parser.hex_nat, "0x" | init) <> 0
      let char = Nat.to_u16(numb)
      if String.eql(init, "0000") then
        ""
      else
        Char.to_string(char) | String.hex.decode.go(rest)
  }

// U16
String.hex.decode(hexs: String): String
  String.hex.decode.go(hexs)

String.hex.decode.ascii.go(hexs: String): String
  case hexs {
    nil:
      ""
    cons: 
      let init = String.take(2, hexs)
      let rest = String.drop(2, hexs)
      let numb = Parser.run!(Parser.hex_nat, "0x" | init) <> 0
      let char = Nat.to_u16(numb)
      if String.eql(init, "00") then
        ""
      else
        Char.to_string(char) | String.hex.decode.ascii.go(rest)
  }

String.hex.decode.ascii(hexs: String): String
  String.hex.decode.ascii.go(hexs)

String.hex.encode.char_to_hex16(chr: Char): String
  String.pad_left(4, '0', U16.show_hex(chr))

String.hex.encode.go(str: String, result: String): String
  case str {
    nil: result
    cons: String.hex.encode.go(str.tail, result | String.hex.encode.char_to_hex16(str.head))
  }

String.hex.encode(str: String): String
  String.hex.encode.go(str, "")

String.hex.encode.ascii.char_to_hex8(chr: Char): String
  String.pad_left(2, '0', U16.show_hex(chr))

String.hex.encode.ascii.go(str: String, result: String): String
  case str {
    nil: result
    cons: String.hex.encode.ascii.go(str.tail, result | String.hex.encode.ascii.char_to_hex8(str.head))
  }

String.hex.encode.ascii(str: String): String
  String.hex.encode.ascii.go(str, "")

String.hex.encode.utf8(str: String): String
  case str {
    nil: String.nil
    cons:
      let hex = U16.hex_show(str.head)
      String.concat(hex, String.to_hex(str.tail))
  }

// TODO: create String.hex.decode.utf8
// 1 char can have 1, 2, 3 or 4 bytes lenght
// Note: check for surrogate half?
// String.hex.decode.utf8.go(m: Char, n: Char, o: Char, p: Char): String
String.hex.decode.utf8.go(hexs: String): String
  case hexs {
    nil: ""
    cons:
      let c = hexs.head
      log("c: " | Char.to_string(c))
      if U16.ltn(c, 0x80) then "1 byte" // s[0] < 0x80)
      else if U16.eql(U16.and(c, 0xe0), 0xc0) then // s[0] & 0xe0) == 0xc0
        "2 bytes"
      else if U16.eql(U16.and(c, 0xf0), 0xe0) then "3 bytes" // s[0] & 0xf0) == 0xe0
      else if Bool.and( // (s[0] & 0xf8) == 0xf0 && (s[0] <= 0xf4)
        U16.eql(U16.and(c, 0xf8), 0xf0),
        U16.lte(c, 0xf4)) then "4 bytes"
      else
        "invalid"
  }

// U16
String.hex.decode.utf8(hexs: String): String
  String.hex.decode.utf8.go(hexs)


String.hex.from_utf8_2(utf8: String): String
  let m = String.take(2, utf8)
  let rest = String.drop(2, hexs)
  let n = String.take(2, rest)
  log("m:"|)

  let c0 = U16.shl(U16.and(m, 0x1f), 6)
  let c1 = U16.shl(U16.and(n, 0x3f), 0)
  String.hex.decode(U16.show(U16.or(c0, c1)))


// String.from_utf8(buf: Buffer8): Char
String.hex.from_utf8(m: U16, n: U16): String
  // let buf = Buffer8.alloc(4)
  // let m = U8.to_u16(Buffer8.get(0, buf))
  // let m = U8.to_u16(m)
  log("0: "|U16.show(m))
  if U16.ltn(m, 0x80) then // ok
    String.hex.decode(U16.show(m))
  else if U16.eql(U16.and(m, 0xe0), 0xc0) then
    log("2 bytes")
    // let m = Buffer8.get(0, buf)
    // let n = U8.to_u16(n)// Buffer8.get(1, buf))
    let c0 = U16.shl(U16.and(m, 0x1f), 6)
    let c1 = U16.shl(U16.and(n, 0x3f), 0)
    String.hex.decode(U16.show(U16.or(c0, c1)))
  // let m = Buffer8.get(0, buf)
  else ""