String.hex.decode.go(hexs: String): String
  case hexs {
    nil:
      ""
    cons: 
      let init = String.take(4, hexs)
      let rest = String.drop(4, hexs)
      let numb = Parser.run!(Parser.hex_nat, "0x" | init) <> 0
      let char = Nat.to_u16(numb)
      if String.eql(init, "0000") then
        ""
      else
        Char.to_string(char) | String.hex.decode.go(rest)
  }

// U16
String.hex.decode(hexs: String): String
  String.hex.decode.go(hexs)

String.hex.decode.ascii.go(hexs: String): String
  case hexs {
    nil:
      ""
    cons: 
      let init = String.take(2, hexs)
      let rest = String.drop(2, hexs)
      let numb = Parser.run!(Parser.hex_nat, "0x" | init) <> 0
      let char = Nat.to_u16(numb)
      if String.eql(init, "00") then
        ""
      else
        Char.to_string(char) | String.hex.decode.ascii.go(rest)
  }

String.hex.decode.ascii(hexs: String): String
  String.hex.decode.ascii.go(hexs)

String.hex.encode.char_to_hex16(chr: Char): String
  String.pad_left(4, '0', U16.show_hex(chr))

String.hex.encode.go(str: String, result: String): String
  case str {
    nil: result
    cons: String.hex.encode.go(str.tail, result | String.hex.encode.char_to_hex16(str.head))
  }

String.hex.encode(str: String): String
  String.hex.encode.go(str, "")

String.hex.encode.ascii.char_to_hex8(chr: Char): String
  String.pad_left(2, '0', U16.show_hex(chr))

String.hex.encode.ascii.go(str: String, result: String): String
  case str {
    nil: result
    cons: String.hex.encode.ascii.go(str.tail, result | String.hex.encode.ascii.char_to_hex8(str.head))
  }

String.hex.encode.ascii(str: String): String
  String.hex.encode.ascii.go(str, "")

String.hex.encode.utf8(str: String): String
  case str {
    nil: String.nil
    cons:
      let hex = U16.hex_show(str.head)
      String.concat(hex, String.to_hex(str.tail))
  }

// WIP!
// TODO: create String.hex.decode.utf8
// 1 char can have 1, 2, 3 or 4 bytes lenght
// Note: check for surrogate half?
// https://rosettacode.org/wiki/UTF-8_encode_and_decode#JavaScript
String.hex.from_utf8(m: U16, n: U16, o: U16, p: U16): String
  // let m = U8.to_u16(m)
  // let n = U8.to_u16(n)
  log("0m: "|U16.show(m))
  log("0n: "|U16.show(n))
  if U16.ltn(m, 0x80) then // ok
    String.hex.decode(U16.show(m))
  else if U16.eql(U16.and(m, 0xe0), 0xc0) then
    log("2 bytes")
    let c0 = U16.shl(U16.and(m, 0x1f), 6)
    let c1 = U16.shl(U16.and(n, 0x3f), 0)
    String.hex.decode(U16.show(U16.or(c0, c1)))
  else if U16.eql(U16.and(m, 0xf0), 0xe0) then // s[0] & 0xf0) == 0xe0
    "3 bytes" 
  else if Bool.and( // (s[0] & 0xf8) == 0xf0 && (s[0] <= 0xf4)
    U16.eql(U16.and(m, 0xf8), 0xf0),
    U16.lte(m, 0xf4)) then "4 bytes"
  else
    "invalid"