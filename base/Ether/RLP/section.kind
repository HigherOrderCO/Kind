Bool.and.eq_sym(x : Bool, y : Bool, H : Equal(Bool, Bool.and(x, y), true)) : Pair<x == true, y == true>
  case x y with H {
    true true : {refl, refl}
    false false : 
      def H = Bool.false_neq_true(H)
      Empty.absurd!(H)
    true false : 
      def H = Bool.false_neq_true(H)
      Empty.absurd!(H)
    false true : 
      def H = Bool.false_neq_true(H)
      Empty.absurd!(H)
  }!

Ether.RLP.Tree.to_nat(x : Ether.RLP.Tree<Bits>) : Ether.RLP.Tree<Nat>
  case x {
    list : Ether.RLP.Tree.list!(List.map!!(Ether.RLP.Tree.to_nat, x.value))
    tip : Ether.RLP.Tree.tip!(Bits.to_nat(x.value))
  }


Ether.RLP.section.pad_bits8_correctude(value : Bits, H : (Ether.Bits.get_bytes_size(value) =? 1) == true) :
  Bits.take(8,Ether.Bits.pad(8,value)) == Ether.Bits.pad(8,value)
  let H = Ether.Bits.get_bytes_size.identity_bits_8(value, H)
  let simpl = refl :: Nat.eql(Nat.mod(Bits.length(value),8),0,() Bits,value,Bits.trim(Nat.add(Bits.length(value),Nat.sub(8,Nat.mod(Bits.length(value),8))),value)) == Ether.Bits.pad(8,value) 
  case simpl {
    refl :  
      (case Nat.eql(Nat.mod(Bits.length(value),8),0) as H {
       true : (_) Bits.take.identity(8, value, H)
       false : (H1) ?a-70
     } : (Nat.eql(Nat.mod(Bits.length(value),8),0) == H) -> Bits.take(8,H(() Bits,value,Bits.trim(Nat.add(Bits.length(value),Nat.sub(8,Nat.mod(Bits.length(value),8))),value))) == H(() Bits,value,Bits.trim(Nat.add(Bits.length(value),Nat.sub(8,Nat.mod(Bits.length(value),8))),value)))(refl)
  }!
  
Ether.RLP.section.tip_case(value : Bits, H : Bits.ltn(value,Ether.RLP.Constants.bits_128) == true) : 
   Ether.RLP.Tree.to_nat(Pair.fst(Ether.RLP.Tree(Bits),Bits,Ether.RLP.decode(Ether.Bits.pad(8,value))))
    == Ether.RLP.Tree.to_nat(Ether.RLP.Tree.tip(Bits,value))
 let rewr = Ether.Bits.break(8,Ether.Bits.pad(8,value)) == {Ether.Bits.pad(8,value), Bits.drop(8, Ether.Bits.pad(8,value))}
 _
// ?a-46

Ether.RLP.section(tree : Ether.RLP.Tree<Bits>) : 
  Equal(Ether.RLP.Tree<Nat>, Ether.RLP.Tree.to_nat((Pair.fst!!(Ether.RLP.decode(Ether.RLP.encode(tree))))), Ether.RLP.Tree.to_nat(tree))
  case tree {
    tip :
      let e = refl :: Bool.and(Nat.eql(Ether.Bits.get_bytes_size(tree.value),1),Bits.ltn(tree.value,Ether.RLP.Constants.bits_128),() Bits,Ether.Bits.pad(8,tree.value),Bits.concat.go(Ether.RPL.proof.encode_length(Ether.Bits.get_bytes_size(tree.value),128),Ether.Bits.pad(8,tree.value))) == Ether.RLP.encode(Ether.RLP.Tree.tip(Bits,tree.value))
      case e {
        refl : 
          let remember = case Bool.and(Nat.eql(Ether.Bits.get_bytes_size(tree.value),1),Bits.ltn(tree.value,Ether.RLP.Constants.bits_128)) {
            true : (H)
               let H = Bool.and.eq_sym!!(H)
               open H
               let H.snd = Equal.mirror(Bool, Bits.ltn(tree.value,Ether.RLP.Constants.bits_128), true, H.snd)
               case H.snd {
                 refl :
                   let H.fst = Equal.mirror(Bool, Nat.eql(Ether.Bits.get_bytes_size(tree.value),1), Bool.true, H.fst)
                   case H.fst {
                     refl : _
                   }!
               } : Ether.RLP.Tree.to_nat(Pair.fst(Ether.RLP.Tree(Bits),Bits,Ether.RLP.decode(Bool.and(Nat.eql(Ether.Bits.get_bytes_size(tree.value),1), H.snd.b,() Bits,Ether.Bits.pad(8,tree.value),Bits.concat.go(Ether.RPL.proof.encode_length(Ether.Bits.get_bytes_size(tree.value),128),Ether.Bits.pad(8,tree.value)))))) == Ether.RLP.Tree.to_nat(Ether.RLP.Tree.tip(Bits,tree.value))
            false : _
          } : Equal(Bool, Bool.and(Nat.eql(Ether.Bits.get_bytes_size(tree.value),1),Bits.ltn(tree.value,Ether.RLP.Constants.bits_128)), self) -> Ether.RLP.Tree.to_nat(Pair.fst(Ether.RLP.Tree(Bits),Bits,Ether.RLP.decode(Bool.and(Nat.eql(Ether.Bits.get_bytes_size(tree.value),1),Bits.ltn(tree.value,Ether.RLP.Constants.bits_128),() Bits,Ether.Bits.pad(8,tree.value),Bits.concat.go(Ether.RPL.proof.encode_length(Ether.Bits.get_bytes_size(tree.value),128),Ether.Bits.pad(8,tree.value)))))) == Ether.RLP.Tree.to_nat(Ether.RLP.Tree.tip(Bits,tree.value))
          remember(refl)
      }!
    list : _
  }!
  
  //  case tree {
  //    tip : 
  //      let e = refl ::
  //          Bool.and(Nat.eql(Ether.Bits.get_bytes_size(tree.value),1),Bits.ltn(tree.value,Ether.RLP.Constants.bits_128),() Bits,Ether.Bits.pad(8,tree.value),Bits.concat.go(Ether.RPL.proof.encode_length(Ether.Bits.get_bytes_size(tree.value),128),Ether.Bits.pad(8,tree.value))) == Ether.RLP.encode(Ether.RLP.Tree.tip(tree.value))
  //     case e {
  //       refl : 
  //         let remember = case Bool.and(Nat.eql(Ether.Bits.get_bytes_size(tree.value),1),Bits.ltn(tree.value,Ether.RLP.Constants.bits_128)) {
  //           true : (H) 
  //              let H = Bool.and.eq_sym!!(H)
  //              open H
  //              let H.snd = Equal.mirror(Bool, Bits.ltn(tree.value,Ether.RLP.Constants.bits_128), true, H.snd)
  //              case H.snd {
  //                refl : 
  //                  let H.fst = Equal.mirror(Bool, Nat.eql(Ether.Bits.get_bytes_size(tree.value),1), Bool.true, H.fst)
  //                  case H.fst {
  //                    refl : ?A-526-142
  //                  } : Pair.fst(Ether.RLP.Tree,Bits,Ether.RLP.decode(Bool.and(H.fst.b,Bool.true,() Bits,Ether.Bits.pad(8,tree.value),Bits.concat.go(Ether.RPL.proof.encode_length(Ether.Bits.get_bytes_size(tree.value),128),Ether.Bits.pad(8,tree.value))))) == Ether.RLP.Tree.tip(tree.value)
                   
  //              } : Pair.fst(Ether.RLP.Tree,Bits,Ether.RLP.decode(Bool.and(Nat.eql(Ether.Bits.get_bytes_size(tree.value),1), H.snd.b,() Bits,Ether.Bits.pad(8,tree.value),Bits.concat.go(Ether.RPL.proof.encode_length(Ether.Bits.get_bytes_size(tree.value),128),Ether.Bits.pad(8,tree.value))))) == Ether.RLP.Tree.tip(tree.value)
  //           false : (H) _
  //         } : Equal(Bool, Bool.and(Nat.eql(Ether.Bits.get_bytes_size(tree.value),1),Bits.ltn(tree.value,Ether.RLP.Constants.bits_128)), self) -> Pair.fst(Ether.RLP.Tree,Bits,Ether.RLP.decode(Bool.and(Nat.eql(Ether.Bits.get_bytes_size(tree.value),1),Bits.ltn(tree.value,Ether.RLP.Constants.bits_128),() Bits,Ether.Bits.pad(8,tree.value),Bits.concat.go(Ether.RPL.proof.encode_length(Ether.Bits.get_bytes_size(tree.value),128),Ether.Bits.pad(8,tree.value))))) == Ether.RLP.Tree.tip(tree.value)

          
  //       remember(refl)
  //     }!
  //    list : _
  //  }!
 
 
  // case tree {
  //     tip: 
  //       let e = refl :: Ether.Bits.read_bytes(Bool.and(Nat.eql(Ether.Bits.get_bytes_size(tree.value),1),Bits.ltn(tree.value,Ether.RLP.Constants.bits_128),() List(Bits),List.cons(Bits,tree.value,List.nil(Bits)),List.concat(Bits,Ether.RPL.encode_length(Ether.Bits.get_bytes_size(tree.value),128),List.cons(Bits,tree.value,List.nil(Bits))))) == Ether.RLP.encode(Ether.RLP.Tree.tip(tree.value))
  //       case e {
  //         refl: 
  //           let remember = case Bool.and(Nat.eql(Ether.Bits.get_bytes_size(tree.value),1), Bits.ltn(tree.value,Ether.RLP.Constants.bits_128)) {
  //             true : (H) 
  //               let {bite_size_cond, bits_ltn_cond} = Bool.and.eq_sym!!(mirror(H))
  //               ?ak-142-2
  //             false : ?bk
  //           } : Equal(Bool, self, Bool.and(Nat.eql(Ether.Bits.get_bytes_size(tree.value),1), Bits.ltn(tree.value,Ether.RLP.Constants.bits_128))) -> Ether.RLP.decode(Ether.Bits.read_bytes(self(() List(Bits),List.cons(Bits,tree.value,List.nil(Bits)),List.concat(Bits,Ether.RPL.encode_length(Ether.Bits.get_bytes_size(tree.value),128),List.cons(Bits,tree.value,List.nil(Bits)))))) == Ether.RLP.Tree.tip(tree.value)
  //           remember(refl)
  //         //  case remember.fst with remember.snd {
  //           //  true : ?a
  //            // false : ?b
  //          // } : Ether.RLP.decode(Ether.Bits.read_bytes(Bool.and(Nat.eql(Ether.Bits.get_bytes_size(tree.value),1),Bits.ltn(tree.value,Ether.RLP.Constants.bits_128),() List(Bits),List.cons(Bits,tree.value,List.nil(Bits)),List.concat(Bits,Ether.RPL.encode_length(Ether.Bits.get_bytes_size(tree.value),128),List.cons(Bits,tree.value,List.nil(Bits)))))) == Ether.RLP.Tree.tip(tree.value)
  //           //let remember_eq = refl :: Bool.and(Nat.eql(Ether.Bits.get_bytes_size(tree.value),1), Bits.ltn(tree.value,Ether.RLP.Constants.bits_128)) == eq 
  //           //case Bool.and(Nat.eql(Ether.Bits.get_bytes_size(tree.value),1), Bits.ltn(tree.value,Ether.RLP.Constants.bits_128)) with remember_eq {
  //            // true : ?a
  //             //false : ?b
  //           //}!
  //       } : Ether.RLP.decode(e.b) == Ether.RLP.Tree.tip(tree.value)
        
  //         //  case Nat.eql(Ether.Bits.get_bytes_size(tree.value),1) as eq {
  //           //  true: ?a
  //       //      false: ?b
  //           //}: Ether.RLP.decode(Ether.Bits.read_bytes(Bool.and(eq,Bits.ltn(tree.value,Ether.RLP.Constants.bits_128),() List(Bits),List.cons(Bits,tree.value,List.nil(Bits)),List.concat(Bits,Ether.RPL.encode_length(Ether.Bits.get_bytes_size(tree.value),128),List.cons(Bits,tree.value,List.nil(Bits)))))) == Ether.RLP.Tree.tip(tree.value)
  //       //}: Ether.RLP.decode(e.b) == Ether.RLP.Tree.tip(tree.value)

  //     //  case e {
  //       //  refl:
  //         //  case Nat.eql(Ether.Bits.get_bytes_size(tree.value),1) as eq {
  //           //  true: ?a
  //         //    false: ?b
  //           //}: Ether.RLP.decode(Ether.Bits.read_bytes(Bool.and(eq,Bits.ltn(tree.value,Ether.RLP.Constants.bits_128),() List(Bits),List.cons(Bits,tree.value,List.nil(Bits)),List.concat(Bits,Ether.RPL.encode_length(Ether.Bits.get_bytes_size(tree.value),128),List.cons(Bits,tree.value,List.nil(Bits)))))) == Ether.RLP.Tree.tip(tree.value)
  //       //}: Ether.RLP.decode(e.b) == Ether.RLP.Tree.tip(tree.value)
  //     list:
  //       ?list_goal
  //} : Equal(Ether.RLP.Tree, Ether.RLP.decode(Ether.RLP.encode(tree)), tree)