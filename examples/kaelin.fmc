// # Kaelin 
// 
// A simple MOBA-like boardgame and a showcase for Formality-Core
// 
// It aims to be blockchain-compatible. That means real-time Kaelin matches can
// take place inside smart-contract platforms like Ethereum or Tezos. That's
// because turns have 10-20 seconds, and moves are made in a commit-reveal
// scheme, allowing the game state to be computed by players directly, without
// a central server (aka state-channels). In the case of a dispute (such as a
// player stopping to respond), the blockchain can be consulted and resolve the
// conflict in an acceptable time (about 1 minute).
// 
// Kaelin aims to preserve many of the fun characteristics of a MOBA such as
// map control, micro and macro decisions, team-work, and essentially answer
// the question: how do you dodge a skillshot in a turn-based boardgame?
// 
// ## Heroes
// 
// Name    | Role       | Description    | MOV | HP  | References & Inspiration
// ------- | ---------- | -------------- | --- | --- | -------------------------------------------------
// Tophoro | Tank       | Terrain Bender |   2 | 120 | Toph (Avatar TLA), Totoro (Studio Ghibli)
// Gonk    | Tank       | Warrior        |   3 |  90 | Gon (Hunter X Hunter), Goku (Gradon Ball Z)
// ?       | Tank       | ?              |   ? |   ? | ?
// ?       | Tank       | ?              |   ? |   ? | ?
// ?       | Tank       | ?              |   ? |   ? | ?
// ?       | Tank       | ?              |   ? |   ? | ?
// Erkos   | Ranged     | Fire Mage      |   3 |  40 | Erk (Fire Emblem), Harry Potter (Harry Potter)
// Croni   | Ranged     | Dark Mage      |   3 |  40 | Chromie (Blizzard), Raven (Teen Titans)
// Snarch  | Ranged     | Archer         |   3 |  60 | Zk-Snarks (crypto)
// ?       | Ranged     | ?              |   ? |   ? | ?
// ?       | Ranged     | ?              |   ? |   ? | ?
// ?       | Ranged     | ?              |   ? |   ? | ?
// Sirpix  | Melee      | Thief          |   3 |  60 | Dev
// Kenlua  | Melee      | Swordsman      |   4 |  60 | Killua (Hunter X Hunter), Kenshin (Rurouni Kenshin)
// Flina   | Melee      | Pegasus Knight |   6 |  60 | Florina (Fire Emblem), Link (The Legend of Zelda)
// ?       | Melee      | ?              |   ? |   ? | ?
// ?       | Melee      | ?              |   ? |   ? | ?
// ?       | Melee      | ?              |   ? |   ? | ?
// Stanci  | Support    | Healer         |   3 |  40 | Dev
// ?       | Support    | ?              |   ? |   ? | ?
// ?       | Support    | ?              |   ? |   ? | ?
// ?       | Support    | ?              |   ? |   ? | ?
// ?       | Support    | ?              |   ? |   ? | ?
// ?       | Support    | ?              |   ? |   ? | ?
// Zagatur | Influencer | Summoner       |   0 |  10 | Zagara, Abathur (Blizzard)
// Agdris  | Influencer | Silencer       |   1 |  20 | Agda, Idris (programming language)
// Mewru   | Influencer | Psychic        |   0 |  20 | Mewtwo (Pok√©mon), Meruem (Hunter X Hunter)
// ?       | Influencer | ?              |   ? |   ? | ?
// ?       | ?          | ?              |   ? |   ? | ?
// ?       | ?          | ?              |   ? |   ? | ?
// ?       | ?          | ?              |   ? |   ? | ?
// ?       | ?          | ?              |   ? |   ? | ?
//
// ## Moves
// 
// - Tophoro
//   - Earth Pull : pulls enemies in a 1-3-5 (wave) ahead.
//   - Earth Wall : creates up to 3 earth walls in a 5x5 (circle) around.
//   - Earth Lock : selects an enemy in a 5x5 (circle) around. Stuns him/her. Can't use on next turn.
//   - Earth Root : self-roots for 3 turns, gaining massive shield and heal.
// 
// - Gonk
//   - Endure  : can't die on this turn. Can't attack on this turn. Can't use on next turn.
//   - Breath  : heals 9 HP. Can't move on this turn. 
//   - Empathy : allies in a 5x5 range can't take damage during this turn. Gonk takes all damage they would take.
//   - Shatter : select an enemy up to 1 range. Deals an amount of damage inversely proportional to remaining HP.
//
// - Erkos
//   - Flame Ball : hits a 5x5 (circle) up to 4 range.
//   - Flame Wave : hits a 1-3-3-5-5 (wave) ahead. Deals 5 damage.
//   - Flame Rage : on the next turn, attacks deal +2 dmg. Stacks. Can't attack on this turn.
//   - Flame Nova : loses 30 HP. Deals massive damage in a 11x11 circle (20?).
// 
// - Croni
//   - Shadow Doll : places a doll in empty tile for up to 8 range, blocking the way until the end of the turn.
//   - Shadow Flux : after a delay, hits a 3x3 (square) in up to 8 range for high damage.
//   - Shadow Trap : places a trap in a secret position; activate to reveal and stun in a 3x3 (circle).
//   - Shadow Bond : loses half hp. Can't attack on this turn. Can't use on next turn. If Croni dies on this turn, takes the killer with her.
//
// - Snarch
//   - Quick Shot     : hits a selected enemy up to 6 range.
//   - Explosive Shot : hits up to 2 3x3 (circles) up to 6 range.
//   - Ballista       : mounts/dismounts from a ballista. Can't attack on this turn. While mounted, can't move and attacks range doubled.
// 
// - Sirpix
//   - Stealth Clone : creates a stealth in up to 3 range. If already created, moves it 3 steps. 
//   - Stealth Swap  : reveals your stealth clone's position. If it is an empty tile, swaps with it.
//   - Killing Edge  : hits a 3x3 (square) around.
// 
// - Kenlua
//   - Dodge : select 4 tiles up to 32 range. Prevent all damage from enemies standing on those tiles during this turn.
//   - Slice : hits a 3x3 (square) around, dealing damage. 
//   - Haste : moves 4 steps. 
//   - Slash : hits a 1x1 (point) up to 1 range. Deals massive damage. If the hit lands, returns to the position you were at the beginning of the turn.
// 
// - Flina
//   - Fly     : Moves 4 steps, passing through enemies and cliffs.
//   - Javelin : hits a selected enemy up to 4 range.
//   - Ocarina : ...
// 
// - Stanci
//   - Heal    : selects an ally up to 4 range. Heals him/her.
//   - Shield  : selects an ally up to 4 range. Gives him/her armor.
//   - Restore : hits a 5x5 (circle) up to 4 range, healing allies inside.
//   - Light   : selects an enemy up to 4 range to deal damage.
// 
// - Zagatur
//   - Summon : selects an empty tile up to 4 range. Spawns a clone of Zagatur on it.
//   - Needle : Hits a 3x1 (line) ahead, dealing damage.
//   - Spikes : Hits a 3x3 (circle) around, dealing damage.
// 
// - Agdris
//   - Silence : selects up to two enemies up to 12 range. They can't attack on this turn.
//   ? Protect : selects up to two allies up to 12 range. Grants him/her 10 armor.
//   - Memento : dies. Enemies can't move or attack on this turn.
// 
// - Mewru
//   - Psychock    : hits a 3x3 (circle) up to 5 range, dealing damage.
//   - Telekinesis : pushes enemies in a 1-3-5 (wave) ahead.
//   - Teleport    : selects an empty location on the map. Moves to that location. 
//   - Absorb      : selects an enemy unit. During this turn, damage dealt by this unit to Mewru heals instead.
// 
// ## Move Priority
// 
// <<Instant: 0>>
// - Croni Shadow Trap (activate)
// - Agdris Silence
// - Agdris Memento
//
// <<SelfCast: 16>>
// - Sirpix Stealth Clone
// - Snarch Ballista
// - Erkos Flame Rage
// - Gonk Endure
// - Gonk Breath
// - Gonk Counter
// - Gonk Empathy 
// - Tophoro Earth Root
// - Mewru Absorb
// - Croni Shadow Bond
// 
// <<PointAndClick: 64>>
// - Tophoro Earth Lock
// - Stanci Shield
// - Stanci Heal
// - Kenlua Haste
// - Kenlua Slice
// - Sirpix Stealth Swap
// - SirPix Killing Edge
// - Stanci Light
// - Snarch Quick Shot
// - Flina Lance
// - Erkos Flame Soul
// - Gonk Shatter
//
// <<TerrainControl: 112>>
// - Tophoro Earth Wall
// - Croni Shadow Doll
//
// - <<Walk: 128>>
// - Kenlua Walk
// - Sirpix Walk
// - Flina Walk
// - Snarch Walk
// - Erkos Walk
// - Stanci Walk
// - Croni Walk
// - Gonk Walk
// - Tophoro Walk
// - Agdris Walk
// - Mewru Walk
// - Zagatur Walk
//
// <<Post-Walk: 160>>
// - Flina Fly
// - Mewru Teleport
// - Kenlua Dodge
// 
// <<Skillshot: 176>>
// - Tophoro Earth Pull
// - Kenlua Slash
// - Snarch Explosive Arrow
// - Erkos Flame Wave
// - Erkos Flame Ball
// - Erkos Flame Nova
// - Zagatur Needles
// - Zagatur Spikes
// - Mewru Telekinesis
// - Mewru Psychock
// - Croni Shadow Flux
// - Croni Shadow Ball
// - Stanci Restore
//
// <<EndTurn: 224>>
// - Croni Shadow Trap (place)
// - Zagatur Summon

def kaelin:
  // :::::::::::
  // :: Array ::
  // :::::::::::

  dup fold3   = (fold_array ~3)
  dup fold5   = (fold_array ~5)
  dup fold8   = (fold_array ~8)
  dup fold10  = (fold_array ~10) #
  dup with3   = (with ~3)
  dup take3   = (take ~3)
  dup write3  = (write ~3)
  dup with5   = (with ~5)
  dup take5   = (take ~5)
  dup write5  = (write ~5)
  dup with8   = (with ~8)
  dup take8   = (take ~8)
  dup write8  = (write ~8)
  dup with10  = (with ~10)
  dup take10  = (take ~10)
  dup write10 = (write ~10)

  // :::::::::::::::
  // :: Direction ::
  // :::::::::::::::

  dup RIGHT = #[ 1, 0] 
  dup DOWN  = #[ 0, 1] 
  dup LEFT  = #[-1, 0] 
  dup UP    = #[ 0,-1] 

  // ::::::::::
  // :: Side ::
  // ::::::::::

  dup WHITE = #0
  dup BLACK = #1
  dup BOARD = #2

  dup eql_side = #{a b}
    |a == b|

  dup side_to_icon = #{side}
    cpy side = side
    if |side == WHITE|
    then: (to_chars "O")
    else: if |side == BLACK|
      then: (to_chars "X")
      else: (to_chars "B")

  // :::::::::::
  // :: Piece ::
  // :::::::::::

  dup Air = #
    {Air Wall Cliff Throne Unit}
    Air

  dup Wall = #
    {Air Wall Cliff Throne Unit}
    Wall

  dup Cliff = #
    {Air Wall Cliff Throne Unit}
    Cliff

  dup Throne = # {side}
    {Air Wall Cliff Throne Unit}
    (Throne side)

  dup Unit = # {hero side hp}
    {Air Wall Cliff Throne Unit}
    (Unit hero side hp)

  dup hero_icon = # {hero long}
    cpy long   = long
    let hero00 = (to_chars (if long ["Tophoro ", "To"]))
    let hero01 = (to_chars (if long ["Gonk    ", "Go"]))
    let hero02 = (to_chars (if long ["Missna  ", "Mi"]))
    let hero03 = (to_chars (if long ["Missna  ", "Mi"]))
    let hero04 = (to_chars (if long ["Missna  ", "Mi"]))
    let hero05 = (to_chars (if long ["Missna  ", "Mi"]))
    let hero06 = (to_chars (if long ["Erkos   ", "Er"]))
    let hero07 = (to_chars (if long ["Croni   ", "Cr"]))
    let hero08 = (to_chars (if long ["Snarch  ", "Sn"]))
    let hero09 = (to_chars (if long ["Missna  ", "Mi"]))
    let hero10 = (to_chars (if long ["Missna  ", "Mi"]))
    let hero11 = (to_chars (if long ["Missna  ", "Mi"]))
    let hero12 = (to_chars (if long ["Sirpix  ", "Si"]))
    let hero13 = (to_chars (if long ["Kenlua  ", "Ke"]))
    let hero14 = (to_chars (if long ["Flina   ", "Fl"]))
    let hero15 = (to_chars (if long ["Missna  ", "Mi"]))
    let hero16 = (to_chars (if long ["Missna  ", "Mi"]))
    let hero17 = (to_chars (if long ["Missna  ", "Mi"]))
    let hero18 = (to_chars (if long ["Stanci  ", "St"]))
    let hero19 = (to_chars (if long ["Missna  ", "Mi"]))
    let hero20 = (to_chars (if long ["Missna  ", "Mi"]))
    let hero21 = (to_chars (if long ["Missna  ", "Mi"]))
    let hero22 = (to_chars (if long ["Missna  ", "Mi"]))
    let hero23 = (to_chars (if long ["Missna  ", "Mi"]))
    let hero24 = (to_chars (if long ["Zagatur ", "Za"]))
    let hero25 = (to_chars (if long ["Agdris  ", "Ag"]))
    let hero26 = (to_chars (if long ["Mewru   ", "Me"]))
    let hero27 = (to_chars (if long ["Missna  ", "Mi"]))
    let hero28 = (to_chars (if long ["Missna  ", "Mi"]))
    let hero29 = (to_chars (if long ["Missna  ", "Mi"]))
    let hero30 = (to_chars (if long ["Missna  ", "Mi"]))
    let hero31 = (to_chars (if long ["Missna  ", "Mi"]))
    let quad00 = [[[hero00,hero01],[hero02,hero03]],[[hero04,hero05],[hero06,hero07]]]
    let quad01 = [[[hero08,hero09],[hero10,hero11]],[[hero12,hero13],[hero14,hero15]]]
    let quad02 = [[[hero16,hero17],[hero18,hero19]],[[hero20,hero21],[hero22,hero23]]]
    let quad03 = [[[hero24,hero25],[hero26,hero27]],[[hero28,hero29],[hero30,hero31]]]
    let heroes = [[quad00,quad01],[quad02,quad03]]
    (snd (take5 hero NilF heroes))

  dup piece_icon = # {piece}
    let case_air    = (to_chars " .")
    let case_wall   = (to_chars " W")
    let case_cliff  = (to_chars " C")
    let case_throne = {side} (to_chars " T")
    let case_unit   = {side hero hp} (hero_icon hero 0)
    (piece case_air case_wall case_cliff case_throne case_unit)

  dup piece_info = # {piece}
    let case_air    = [Air, NilF]
    let case_wall   = [Wall, NilF]
    let case_cliff  = [Cliff, NilF]
    let case_throne = {side} [(Throne side), NilF]
    let case_unit   = {side hero hp}
      cpy hero = hero
      cpy hp   = hp
      cpy side = side
      let val  = (Unit side hero hp)
      let info =
        (concat (hero_icon hero 1) // Hero name
        (concat (to_chars ": ")
        (concat (ConsF (box_byte (num_to_char ||hp / 100| % 10|)) NilF) // HP
        (concat (ConsF (box_byte (num_to_char ||hp /  10| % 10|)) NilF) // HP
        (concat (ConsF (box_byte (num_to_char ||hp /   1| % 10|)) NilF) // HP
        (concat (to_chars " hp -- ")
        (concat (if side [(to_chars "black"),(to_chars "white")]) (ConsF #10 NilF))))))))
      [val, info]
    (piece case_air case_wall case_cliff case_throne case_unit)

  dup piece_cpy_with = # {fn piece}
    let case_air    = {fn} [Air, (fn Air)]
    let case_wall   = {fn} [Wall, (fn Wall)]
    let case_cliff  = {fn} [Cliff, (fn Cliff)]
    let case_throne = {side} {fn}
      cpy side = side
      [(Throne side), (fn (Throne side))]
    let case_unit = {side hero hp} {fn}
      cpy side = side
      cpy hero = hero
      cpy hp   = hp
      [(Unit side hero hp), (fn (Unit side hero hp))]
    (piece case_air case_wall case_cliff case_throne case_unit fn)

  dup get_piece_hero = # {piece}
    let case_air    = None
    let case_wall   = None
    let case_cliff  = None
    let case_throne = {a_side} None
    let case_unit   = {a_side a_hero a_hp} (Just a_hero)
    (piece case_air case_wall case_cliff case_throne case_unit)

  dup piece_is_hero = # {hero piece}
    let case_air    = 0
    let case_wall   = 0
    let case_cliff  = 0
    let case_throne = {a_side} 0
    let case_unit   = {a_side a_hero a_hp} |a_hero == hero|
    (piece case_air case_wall case_cliff case_throne case_unit)

  // "a" and "b" are side positions. The function checks if they can swap their position, that is, simulate a walk, and returns:
  // - The same position: if they can't interact with each other.
  // - Inverted position: the elements interacted and one now occupies the position of the other.
  dup a_step_to_b = # {a b}
    let case_a_air      = {b} [Air, b]
    let case_a_wall     = {b} [Wall, b]
    let case_a_cliff    = {b} [Cliff, b]
    let case_a_throne   = {a_side} {b} [(Throne a_side), b]
    let case_a_unit     = {a_side a_hero a_hp} {b}
      let case_b_air    = {a_side a_hero a_hp}
        let a_val       = (Unit a_side a_hero a_hp)
        let b_val       = Air
        [b_val, a_val]
      let case_b_wall   = {a_side a_hero a_hp}
        let a_val       = (Unit a_side a_hero a_hp)
        let b_val       = Wall
        [a_val, b_val]
      let case_b_cliff  = {a_side a_hero a_hp}
        let a_val       = (Unit a_side a_hero a_hp)
        let b_val       = Cliff
        [a_val, b_val]
      let case_b_throne = {b_side} {a_side a_hero a_hp}
        let a_val       = (Unit a_side a_hero a_hp)
        let b_val       = (Throne b_side)
        [a_val, b_val]
      let case_b_unit   = {b_side b_hero b_hp} {a_side a_hero a_hp}
        cpy a_side      = a_side
        cpy b_side      = b_side
        let a_val       = (Unit a_side a_hero a_hp)
        let b_val       = (Unit b_side b_hero b_hp)
        let can_pass    = (eql_side a_side b_side)
        let then_swap   = [{a b}[b,a],{a b}[a,b]]
        (if can_pass then_swap a_val b_val)
      (b case_b_air case_b_wall case_b_cliff case_b_throne case_b_unit a_side a_hero a_hp)
    (a case_a_air case_a_wall case_a_cliff case_a_throne case_a_unit b)

  dup damage_visual_effect = # {dmg piece}
    let case_air    = Cliff
    let case_wall   = Wall
    let case_cliff  = Cliff
    let case_throne = {side} (Throne side)
    let case_unit   = {side hero hp} (Unit side hero |hp - dmg|)
    (piece case_air case_wall case_cliff case_throne case_unit)

  // TODO: 
  // - check if the life of "piece" is bigger than the damage
  dup damage = # {dmg piece}
    let case_air    = Air
    let case_wall   = Wall
    let case_cliff  = Cliff
    let case_throne = {side} (Throne side)
    let case_unit   = {side hero hp} (Unit side hero |hp - dmg|)
    (piece case_air case_wall case_cliff case_throne case_unit)

  // ::::::::::::
  // :: Heroes ::
  // ::::::::::::

  dup TOPHORO  = # 0
  dup GONK     = # 1
  dup ERKOS    = # 6
  dup CRONI    = # 7
  dup SNARCH   = # 8
  dup SIRPIX   = # 12
  dup KENLUA   = # 13
  dup FLINA    = # 14
  dup STANCI   = # 18
  dup ZAGATUR  = # 24
  dup AGDRIS   = # 25
  dup MEWRU    = # 26

  let TO = TOPHORO
  let GO = GONK
  let ER = ERKOS
  let CR = CRONI
  let SN = SNARCH
  let SI = SIRPIX
  let KE = KENLUA
  let FL = FLINA
  let ST = STANCI
  let ZA = ZAGATUR
  let AG = AGDRIS
  let ME = MEWRU

  dup Tophoro  = # {side} (Unit side TOPHORO 120)
  dup Gonk     = # {side} (Unit side GONK     90)
  dup Erkos    = # {side} (Unit side ERKOS    40)
  dup Croni    = # {side} (Unit side CRONI    40)
  dup Snarch   = # {side} (Unit side SNARCH   60)
  dup Sirpix   = # {side} (Unit side SIRPIX   60)
  dup Kenlua   = # {side} (Unit side KENLUA   60)
  dup Flina    = # {side} (Unit side FLINA    60)
  dup Stanci   = # {side} (Unit side STANCI   40)
  dup Zagatur  = # {side} (Unit side ZAGATUR  10)
  dup Agdris   = # {side} (Unit side AGDRIS   20)
  dup Mewru    = # {side} (Unit side MEWRU    20)

  // :::::::::::
  // :: Board ::
  // :::::::::::

  dup new_board = #
    let O   = Air
    let a   = (Gonk WHITE)
    let b   = (Erkos WHITE)
    let c   = (Kenlua WHITE)
    let d   = (Mewru WHITE)
    let e   = (Tophoro BLACK)
    let f   = (Croni BLACK)
    let g   = (Stanci BLACK)
    let h   = (Flina BLACK)
    let W   = Wall
    let C   = Cliff
    let x   = (Throne WHITE)
    let y   = (Throne BLACK)
    let r00 = [[[[[W,W],[W,W]],[[W,W],[W,O]]],[[[O,W],[W,O]],[[O,O],[O,W]]]],[[[[W,O],[O,O]],[[O,W],[W,O]]],[[[O,W],[W,W]],[[y,W],[W,W]]]]]
    let r01 = [[[[[W,O],[O,W]],[[O,O],[W,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,W],[h,g]],[[O,f],[e,W]]]]]
    let r02 = [[[[[W,W],[W,W]],[[W,O],[W,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,C],[O,O]],[[O,O],[O,W]]]]]
    let r03 = [[[[[W,O],[O,W]],[[O,O],[W,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,W],[O,O]],[[O,O],[O,W]]]]]
    let r04 = [[[[[W,O],[W,W]],[[W,W],[W,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,C],[O,O]],[[O,O],[O,W]]]]]
    let r05 = [[[[[W,O],[O,W]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,W],[O,O]],[[O,O],[O,W]]]]]
    let r06 = [[[[[W,W],[W,W]],[[W,O],[W,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,W],[W,O]],[[O,O],[W,W]]]]]
    let r07 = [[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]]]
    let r08 = [[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]]]
    let r09 = [[[[[W,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,W]]]]]
    let r10 = [[[[[W,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,W]]]]]
    let r11 = [[[[[W,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,W]]]]]
    let r12 = [[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]]]
    let r13 = [[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]]]
    let r14 = [[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]]]
    let r15 = [[[[[C,C],[C,C]],[[C,C],[C,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[C,C],[C,C]],[[C,C],[C,C]]]]] // MID
    let r16 = [[[[[C,C],[C,C]],[[C,C],[C,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[C,C],[C,C]],[[C,C],[C,C]]]]] // MID
    let r17 = [[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]]]
    let r18 = [[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]]]
    let r19 = [[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]]]
    let r20 = [[[[[W,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,W]]]]]
    let r21 = [[[[[W,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,W]]]]]
    let r22 = [[[[[W,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,W]]]]]
    let r23 = [[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]]]
    let r24 = [[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]]]
    let r25 = [[[[[W,W],[O,O]],[[O,W],[W,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,W],[W,W]],[[W,W],[W,W]]]]]
    let r26 = [[[[[W,O],[O,O]],[[O,O],[W,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,W],[O,O]],[[O,O],[O,W]]]]]
    let r27 = [[[[[W,O],[O,O]],[[O,O],[C,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,W],[O,W]],[[W,W],[W,W]]]]]
    let r28 = [[[[[W,O],[O,O]],[[O,O],[W,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,W],[O,W]],[[O,O],[O,W]]]]]
    let r29 = [[[[[W,O],[O,O]],[[O,O],[C,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,W],[O,W]],[[O,W],[W,W]]]]]
    let r30 = [[[[[W,a],[b,O]],[[c,d],[W,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,W],[O,W]],[[O,W],[O,W]]]]]
    let r31 = [[[[[W,W],[W,x]],[[W,W],[W,O]]],[[[O,W],[W,O]],[[O,O],[O,W]]]],[[[[W,O],[O,O]],[[O,W],[W,O]]],[[[O,W],[W,W]],[[W,W],[W,W]]]]]
    [[[[[r00,r01],[r02,r03]],[[r04,r05],[r06,r07]]],[[[r08,r09],[r10,r11]],[[r12,r13],[r14,r15]]]],
    [[[[r16,r17],[r18,r19]],[[r20,r21],[r22,r23]]],[[[r24,r25],[r26,r27]],[[r28,r29],[r30,r31]]]]]

  // Simulates an index in an array of 1024 elements (32x32 map).
  // x: column
  // y: line 
  dup board_index = # {pos}
    get [x,y] = pos
    ||y * 32| + x|

  dup board_position = # {idx}
    cpy idx = idx
    [|idx % 32|, |idx / 32|]

  dup board_interact = # {a_pos b_pos fun board}
    cpy a_idx         = (board_index a_pos)
    cpy b_idx         = (board_index b_pos)
    get [board,a_val] = (take10 a_idx Air board)
    get [board,b_val] = (take10 b_idx Air board)
    get [a_val,b_val] = (fun a_val b_val)
    let board         = (write10 a_idx a_val board)
    let board         = (write10 b_idx b_val board)
    board 

  // Apply a function to a board piece
  dup board_apply = # {pos fun board}
    cpy p_idx       = (board_index pos)
    get [board,val] = (take10 p_idx Air board)
    let p_update    = (fun val)
    let board       = (write10 p_idx p_update board)
    board

  dup print_board = 
    let fold_node = {lft rgt}
      get [lft_info, lft_board] = lft
      get [rgt_info, rgt_board] = rgt
      [(concat lft_info rgt_info), (concat lft_board rgt_board)]
    let fold_leaf = {piece}
      get [piece, info] = (piece_info piece)
      [info, (piece_icon piece)]
    dup fold = (fold10 #fold_node #fold_leaf)
    # {board}
      get [info, board] = (fold board)
      let board = (cons-every #64 #10 board)
      (from_chars (concat (ConsF 10 NilF) (concat info (concat board (ConsF 10 NilF)))))

  // :::::::::::::
  // :: Effects ::
  // :::::::::::::

  // Given a position and a direction to step forward, move the element (if is possible) and return the updated map
  dup step = # {a_pos a_dxy board}
    get [a_pos0,a_pos1] = (vec2_cpy a_pos)
    let b_pos           = (vec2_add a_pos0 a_dxy)
    (board_interact a_pos1 b_pos a_step_to_b board)

  dup damage_visual_effect = # {dmg piece}
    let case_air    = Cliff
    let case_wall   = Wall
    let case_cliff  = Cliff
    let case_throne = {side} (Throne side)
    let case_unit   = {side hero hp} (Unit side hero |hp - dmg|)
    (piece case_air case_wall case_cliff case_throne case_unit)

  // TODO: 
  // - check if the life of "piece" is bigger than the damage
  dup damage = # {dmg piece}
    let case_air    = Air
    let case_wall   = Wall
    let case_cliff  = Cliff
    let case_throne = {side} (Throne side)
    let case_unit   = {side hero hp} (Unit side hero |hp - dmg|)
    (piece case_air case_wall case_cliff case_throne case_unit)

  // TODO: Flip properties of a piece about move and attack
  dup stun = # {piece}
    let case_air     = Air
    let case_wall    = Wall
    let case_cliff   = Cliff
    let case_throne  = {side} (Throne side)
    let case_unit    = {side hero hp} (Unit side hero hp)
    (piece case_air case_wall case_cliff case_throne case_unit)

  // Stun enemies in a 3x3 (circle) around
  dup stun_small_circle =
    let area  = vec2_circle_b
    let hits  = {pos board} (board_apply pos stun board)
    (area #hits) 

  // Checks if given position is a specific hero
  dup is_hero_at = # {pos hero board}
    (with10 (board_index pos) (piece_cpy_with (piece_is_hero hero)) board)

  // Walks through a set of directions
  let walk = {hero steps}
    dup hero = hero
    let walk = {state}
      get [pos_dirs,board] = state
      get [pos,dirs]       = pos_dirs
      get [dirs,dir]       = (pop [0,0] dirs)
      get [pos,pos_cpy]    = (vec2_cpy pos)
      get [dir,dir_cpy]    = (vec2_cpy dir)
      let new_pos          = (vec2_add pos_cpy dir_cpy)
      get [pos,pos_cpy]    = (vec2_cpy pos)
      get [board,allow]    = (is_hero_at pos_cpy hero board)
      let board            = (if allow [step, {pos dir board}board] pos dir board)
      [[new_pos,dirs], board]
    dup walk = (steps #walk)
    # {pos dirs board}
      snd (walk [[pos,dirs],board])

  // Walk effects of each hero
  dup kenlua_walk  = (walk #KENLUA ~4)
  dup sirpix_walk  = (walk #SIRPIX ~3)
  dup flina_walk   = (walk #FLINA ~5)
  dup snarch_walk  = (walk #SNARCH ~3)
  dup erkos_walk   = (walk #ERKOS ~3)
  dup stanci_walk  = (walk #STANCI ~3)
  dup croni_walk   = (walk #CRONI ~3)
  dup gonk_walk    = (walk #GONK ~3)
  dup tophoro_walk = (walk #TOPHORO ~2)
  dup agdris_walk  = (walk #AGDRIS ~1)
  dup mewru_walk   = (walk #MEWRU ~0)
  dup zagatur_walk = (walk #ZAGATUR ~0)

  // Using a path, goes from "pos" to "target position"
  // - dirs : movement list to get into the desired position
  // - pos  : initial position
  let add_dirs = {mlen}
    dup move = (mlen {pos_dirs}
      get [pos,dirs] = pos_dirs
      get [dirs,dir] = (pop [0,0] dirs)
      [(vec2_add pos dir), dirs])
    # {pos dirs}
      fst (move [pos,dirs])

  dup add_dirs1 = (add_dirs ~1)
  dup add_dirs2 = (add_dirs ~2)
  dup add_dirs3 = (add_dirs ~3)
  dup add_dirs4 = (add_dirs ~4)

  // Creates up to 3 earth walls in a 5x5 (circle) around.
  // TODO: Add box
  // TODO: Add range area
  dup earth_wall = # {pos1 pos2 pos3 board}
    let case_air     = Wall
    let case_wall    = Wall
    let case_cliff   = Cliff
    let case_throne  = {side} (Throne side)
    let case_unit    = {side hero hp} (Unit side hero hp)
    let change_piece = {t} (t case_air case_wall case_cliff case_throne case_unit)
    let board = (board_apply pos1 change_piece board)
    let board = (board_apply pos2 change_piece board)
    let board = (board_apply pos3 change_piece board)
    board

  dup earth_pull =
    let area = (vec2_wave_in (ConsF #1 (ConsF #3 (ConsF #5 NilF))))
    let hits = {pos dxy board} (step pos dxy board)
    (area #hits)

  // Hits a 1-3-3-5-5 (wave). Deals 5 damage.
  dup flame_wave =
    let area = (vec2_wave (ConsF #1 (ConsF #3 (ConsF #3 (ConsF #5 (ConsF #5 NilF))))))
    let hits = {pos board} (board_apply pos (damage 5) board)  
    (area #hits)
  
  // Hits a 5x5 (circle). Deals 5 damage.
  // TODO: add 4 range
  dup flame_ball =
    let area = vec2_circle_e
    let hits = {pos board} (board_apply pos (damage 5) board)
    //let hits = {pos board} (board_apply pos (damage_visual_effect 5) board)
    (area #hits)

  // Selects an enemy up to 1 range. Deals massive damage (20?)
  dup flame_soul = # {pos dir board}
    let t_pos = (vec2_add pos dir)
    (board_apply t_pos (damage_visual_effect 21) board)

  // Deals massive damage in a 11x11 circle (20?)
  dup flame_nova =
    let area = vec2_circle_j
    let hits = {pos board} (board_apply pos (damage 20) board)
    //let hits = {pos board} (board_apply pos (damage_visual_effect 20) board)
    (area #hits)

  // Places a doll in an empty tile
  // TODO: add 8 range
  dup shadow_doll = # {pos board}
    let case_air     = Wall
    let case_wall    = Wall
    let case_cliff   = Cliff
    let case_throne  = {side} (Throne side)
    let case_unit    = {side hero hp} (Unit side hero hp)
    let change_piece = {t} (t case_air case_wall case_cliff case_throne case_unit)
    (board_apply pos change_piece board)

  // Hits a 3x3 (square) with for high damage (15?).
  // TODO: add 8 range
  dup shadow_flux =
    let area = vec2_circle_c
    //let hits = {pos board} (board_apply pos (damage 15) board)
    let hits = {pos board} (board_apply pos (damage_visual_effect 15) board) 
    (area #hits)

  // TODO: Loses half hp. Can't attack on this turn. Can't use on next turn. If Croni dies on this turn, takes the killer with her.
  //dup shadow_bond = # {side hero hp}

  // Hits a selected enemy up to 3 range. Deals 5 damage.
  dup quick_shot = # {pos dirs board}
    (board_apply (add_dirs4 pos dirs) (damage_visual_effect 3) board)

  // Hits all enemies in a 5x1 (line) ahead. Deals 3 damage.
  dup piercing_bolt =
    let area = (vec2_wave (ConsF #1 (ConsF #1 (ConsF #1 (ConsF #1 (ConsF #1 NilF))))))
    let hits = {pos board} (board_apply pos (damage_visual_effect 3) board)
    (area #hits) 

  // Explosive Arrow : hits up to 2 3x3 (circles). Deals 2 damage.
  // TODO: add 5 range
  //dup explosive_arrow =
    //let area = vec2_circle_b
    //let hits = {pos board} (board_apply pos (damage_visual_effect 2) board)
    //# {pos1 pos2 board}
      //let board = (area #hits pos1 board)
      //let board = (area #hits pos2 board)
      //board

  // TODO: mounts/dismounts from a ballista. Can't attack on this turn. While mounted, can't move and attacks range increase to 12.
  //dup ballista = #

  // Hits a 3x3 (square) around. Deals 3 damage.
  dup killing_edge =
    let area = vec2_circle_c
    let hits = {pos board} (board_apply pos (damage_visual_effect 3) board)
    (area #hits)

  // Select 4 tiles up to 32 range. Prevent all damage from enemies standing on those tiles during this turn.
  // TODO: Add range
  // TODO: Change function applied to the positions to "silence"
  dup dodge = # {pos1 pos2 pos3 pos4 board}
    let case_air     = Air
    let case_wall    = Wall
    let case_cliff   = Cliff
    let case_throne  = {side} (Throne side)
    let case_unit    = {side hero hp} (Unit side hero hp)
    let board = (board_apply pos1 (damage_visual_effect 1) board)
    let board = (board_apply pos2 (damage_visual_effect 1) board)
    let board = (board_apply pos3 (damage_visual_effect 1) board)
    let board = (board_apply pos4 (damage_visual_effect 1) board)
    board

  // Hits a 3x3 (square) around. Deals 8 damage.
  dup slice_area =
    let area = vec2_circle_c
    let hits = {pos board} (board_apply pos (damage_visual_effect 8) board)
    (area #hits)

  // :::::::::::
  // :: Moves ::
  // :::::::::::

  dup PASS          = # 0
  dup KENLUA_WALK   = # 128
  dup SIRPIX_WALK   = # 129
  dup FLINA_WALK    = # 130
  dup SNARCH_WALK   = # 131
  dup ERKOS_WALK    = # 132
  dup STANCI_WALK   = # 133
  dup CRONI_WALK    = # 134
  dup GONK_WALK     = # 135
  dup TOPHORO_WALK  = # 136
  dup AGDRIS_WALK   = # 137
  dup MEWRU_WALK    = # 138
  dup ZAGATUR_WALK  = # 139
  dup EARTH_PULL    = # 176
  dup PIERCING_BOLT = # 179

  // | get_skill_hero
  // : {skill : Num}
  //   Num
  dup get_skill_hero = # {skill}
    let i000 = [[[[ 0, 0],[ 0, 0]],[[ 0, 0],[ 0, 0]]],[[[ 0, 0],[ 0, 0]],[[ 0, 0],[ 0, 0]]]]
    let i016 = [[[[ 0, 0],[ 0, 0]],[[ 0, 0],[ 0, 0]]],[[[ 0, 0],[ 0, 0]],[[ 0, 0],[ 0, 0]]]]
    let i032 = [[[[ 0, 0],[ 0, 0]],[[ 0, 0],[ 0, 0]]],[[[ 0, 0],[ 0, 0]],[[ 0, 0],[ 0, 0]]]]
    let i048 = [[[[ 0, 0],[ 0, 0]],[[ 0, 0],[ 0, 0]]],[[[ 0, 0],[ 0, 0]],[[ 0, 0],[ 0, 0]]]]
    let i064 = [[[[ 0, 0],[ 0, 0]],[[ 0, 0],[ 0, 0]]],[[[ 0, 0],[ 0, 0]],[[ 0, 0],[ 0, 0]]]]
    let i080 = [[[[ 0, 0],[ 0, 0]],[[ 0, 0],[ 0, 0]]],[[[ 0, 0],[ 0, 0]],[[ 0, 0],[ 0, 0]]]]
    let i096 = [[[[ 0, 0],[ 0, 0]],[[ 0, 0],[ 0, 0]]],[[[ 0, 0],[ 0, 0]],[[ 0, 0],[ 0, 0]]]]
    let i112 = [[[[ 0, 0],[ 0, 0]],[[ 0, 0],[ 0, 0]]],[[[ 0, 0],[ 0, 0]],[[ 0, 0],[ 0, 0]]]]
    let i128 = [[[[TO,SI],[FL,SN]],[[ER,ST],[CR,GO]]],[[[TO,AG],[ME,ZA]],[[ 0, 0],[ 0, 0]]]]
    let i144 = [[[[ 0, 0],[ 0, 0]],[[ 0, 0],[ 0, 0]]],[[[ 0, 0],[ 0, 0]],[[ 0, 0],[ 0, 0]]]]
    let i160 = [[[[ 0, 0],[ 0, 0]],[[ 0, 0],[ 0, 0]]],[[[ 0, 0],[ 0, 0]],[[ 0, 0],[ 0, 0]]]]
    let i176 = [[[[TO, 0],[ 0,SN]],[[ 0, 0],[ 0, 0]]],[[[ 0, 0],[ 0, 0]],[[ 0, 0],[ 0, 0]]]]
    let i192 = [[[[ 0, 0],[ 0, 0]],[[ 0, 0],[ 0, 0]]],[[[ 0, 0],[ 0, 0]],[[ 0, 0],[ 0, 0]]]]
    let i208 = [[[[ 0, 0],[ 0, 0]],[[ 0, 0],[ 0, 0]]],[[[ 0, 0],[ 0, 0]],[[ 0, 0],[ 0, 0]]]]
    let i224 = [[[[ 0, 0],[ 0, 0]],[[ 0, 0],[ 0, 0]]],[[[ 0, 0],[ 0, 0]],[[ 0, 0],[ 0, 0]]]]
    let i240 = [[[[ 0, 0],[ 0, 0]],[[ 0, 0],[ 0, 0]]],[[[ 0, 0],[ 0, 0]],[[ 0, 0],[ 0, 0]]]]
    let smap = [[[[i000,i016],[i032,i048]],[[i064,i080],[i096,i112]]],[[[i128,i144],[i160,i176]],[[i192,i208],[i224,i240]]]]
    snd (take8 skill 0 smap)

  // | get_hero_skill
  // : {hero : Num}
  //   {slot : Num}
  //   Num
  dup get_hero_skill = # {hero slot}
    let to = [[[TOPHORO_WALK, 0], [0,0]], [[0,0], [0,0]]]
    let go = [[[GONK_WALK,0],[0,0]],[[0,0],[0,0]]]
    let xx = [[[0,0],[0,0]],[[0,0],[0,0]]]
    let xx = [[[0,0],[0,0]],[[0,0],[0,0]]]
    let xx = [[[0,0],[0,0]],[[0,0],[0,0]]]
    let xx = [[[0,0],[0,0]],[[0,0],[0,0]]]
    let er = [[[ERKOS_WALK,0],[0,0]],[[0,0],[0,0]]]
    let cr = [[[CRONI_WALK,0],[0,0]],[[0,0],[0,0]]]
    let sn = [[[0,0],[0,0]],[[0,0],[0,0]]]
    let xx = [[[0,0],[0,0]],[[0,0],[0,0]]]
    let xx = [[[0,0],[0,0]],[[0,0],[0,0]]]
    let xx = [[[0,0],[0,0]],[[0,0],[0,0]]]
    let si = [[[SIRPIX_WALK,0],[0,0]],[[0,0],[0,0]]]
    let ke = [[[KENLUA_WALK,0],[0,0]],[[0,0],[0,0]]]
    let fl = [[[FLINA_WALK,0],[0,0]],[[0,0],[0,0]]]
    let xx = [[[0,0],[0,0]],[[0,0],[0,0]]]
    let xx = [[[0,0],[0,0]],[[0,0],[0,0]]]
    let xx = [[[0,0],[0,0]],[[0,0],[0,0]]]
    let st = [[[STANCI_WALK,0],[0,0]],[[0,0],[0,0]]]
    let xx = [[[0,0],[0,0]],[[0,0],[0,0]]]
    let xx = [[[0,0],[0,0]],[[0,0],[0,0]]]
    let xx = [[[0,0],[0,0]],[[0,0],[0,0]]]
    let xx = [[[0,0],[0,0]],[[0,0],[0,0]]]
    let xx = [[[0,0],[0,0]],[[0,0],[0,0]]]
    let za = [[[ZAGATUR_WALK,0],[0,0]],[[0,0],[0,0]]]
    let ag = [[[AGDRIS_WALK,0],[0,0]],[[0,0],[0,0]]]
    let me = [[[MEWRU_WALK,0],[0,0]],[[0,0],[0,0]]]
    let xx = [[[0,0],[0,0]],[[0,0],[0,0]]]
    let xx = [[[0,0],[0,0]],[[0,0],[0,0]]]
    let xx = [[[0,0],[0,0]],[[0,0],[0,0]]]
    let xx = [[[0,0],[0,0]],[[0,0],[0,0]]]
    let xx = [[[0,0],[0,0]],[[0,0],[0,0]]]
    let xx = [[[0,0],[0,0]],[[0,0],[0,0]]]
    let h0 = [[[[to,go],[xx,xx]],[[xx,xx],[er,cr]]],[[[sn,xx],[xx,xx]],[[si,ke],[fl,xx]]]]
    let h1 = [[[[xx,xx],[st,xx]],[[xx,xx],[xx,xx]]],[[[za,ag],[me,xx]],[[xx,xx],[xx,xx]]]]
    (snd (take3 slot 0 (snd (take5 hero 0 [h0,h1]))))

  // empty_casts
  // : (Array ~8 (Maybe [Pos, ArgTup]))
  dup empty_casts = #
    let a = [None,None] let b = [a,a] let c = [b,b] let d = [c,c]
    let e = [d,d] let f = [e,e] let g = [f,f] [g,g]

  // cast
  // : {skill : Num} ->
  //   {pos   : [Num,Num]} ->
  //   {args  : ArgTuple} ->
  //   {casts : (Array ~8 (Maybe [Pos, ArgTup]))} ->
  //   (Array ~8 (Maybe [Pos, ArgTup]))
  dup cast = # {skill pos args casts}
    (write8 skill (Just [pos, args]) casts)

  // Casts a skill
  dup cast_skill = # {hero skill effect log_msg state}
    get [state, casts] = state
    get [board, anims] = state
    get [casts, mcast] = (take8 skill None casts)
    let case_none = {board anims casts}
      [[board, anims], casts]
    let case_just = {cast board anims casts}
      get [pos, args]    = cast
      get [pos, pos_cpy] = (vec2_cpy pos)
      get [board, allow] = (with10 (board_index pos_cpy) (piece_cpy_with (piece_is_hero hero)) board)
      get [pos, pos_cpy] = (vec2_cpy pos)
      get [board, anims] = (if allow
        then: {board anims}
          let board = (args (effect pos_cpy) board)
          let anims = {x} (anims (Cons log_msg x))
          [board, anims]
        else: {board anims}
          [board, anims]
        board anims)
      [[board, anims], casts]
    (mcast case_none case_just board anims casts)

  // exec_casts
  // : {casts : (Array ~8 [Pos, ArgTup])}
  //   {board : (Array ~10 Unit)}
  //   (Array ~10 Unit)
  dup exec_casts = # {casts board}
    let anims = {x} x
    let state = [[board, anims], casts]
    let state = (cast_skill KENLUA  KENLUA_WALK   kenlua_walk   "Kenlua walked"             state)
    let state = (cast_skill SIRPIX  SIRPIX_WALK   sirpix_walk   "Sirpix walked"             state)
    let state = (cast_skill FLINA   FLINA_WALK    flina_walk    "Flina walked"              state)
    let state = (cast_skill SNARCH  SNARCH_WALK   snarch_walk   "Snarch walked"             state)
    let state = (cast_skill ERKOS   ERKOS_WALK    erkos_walk    "Erkos walked"              state)
    let state = (cast_skill STANCI  STANCI_WALK   stanci_walk   "Stanci walked"             state)
    let state = (cast_skill CRONI   CRONI_WALK    croni_walk    "Croni walked"              state)
    let state = (cast_skill GONK    GONK_WALK     gonk_walk     "Gonk walked"               state)
    let state = (cast_skill TOPHORO TOPHORO_WALK  tophoro_walk  "Tophoro walked"            state)
    let state = (cast_skill AGDRIS  AGDRIS_WALK   agdris_walk   "Agdris walked"             state)
    let state = (cast_skill MEWRU   MEWRU_WALK    mewru_walk    "Mewru walked"              state)
    let state = (cast_skill ZAGATUR ZAGATUR_WALK  zagatur_walk  "Zagatur walked"            state)
    let state = (cast_skill TOPHORO EARTH_PULL    earth_pull    "Tophoro used earth pull"   state)
    let state = (cast_skill SNARCH  PIERCING_BOLT piercing_bolt "Snarch used piercing bolt" state)
    get [board, anims] = fst state
    [board, (anims Nil)]

  //W W W W W W W . . W W . . . . W W . . . . W W . . W W W T W W W
  //W . . W . . W . . . . . . . . . . . . . . . . . . W X X . X X W
  //W W W W W . W . . . . . . . . . . . . . . . . . . C . . . . . W
  //W . . W . . W . . . . . . . . . . . . . . . . . . W . . . . . W
  //W . W W W W W . . . . . . . . . . . . . . . X . . C . . . . . W
  //W . . W . . . . . . . . . . . . . . . . X X X X X W . . . . . W
  //W W W W W . W . . . . . . . . . . . . X X X X X X W W . . . W W
  //. . . . . . . . . . . . . X X . . . X X X X X X X X X . . . . .
  //. . . . . . . . . . . X X X X . . . X X X X X X X X X . . . . .
  //W . . . . . . . . E X X X X X . . X X X X X T X X X X X . . . W
  //W . . . . . . . . . . X X X X . . . X X X X X X X X X . . . . W
  //W . . . . . . . . . . . . X X . . . X X X X X X X X X . . . . W
  //. . . . . . . . . . . . . . . . . . . X X X X X X X . . . . . .
  //. . . . . . . . . . . . . . . . C . . . X X X X X . . . . . . .
  //. . . . . . . . . . . . . . X X S . . . . . X . . . . . . . . .
  //C C C C C C C . . . . . . X X X X X . . . . . . C C C C C C C C
  //C C C C C C C . . . . E . X X T X X . . . . . . C C C C C C C C
  //. . . . . . . . . . . . . X X X X X . . . . . . . . . . . . . .
  //. . . . . . . . . . . . . . X X X . . . . . . . . . . . . . . .
  //. . . . . . . . . . . . . . . . . . . . . X X X . . . . . . . .
  //W . . . . . . . . . . . . . . . . . . . . X T X . . . . . . . W
  //W . . . . . . . . . . K . . . . . X . . . X X X . . . . . . . W
  //W . . . . . . . . . . . . . . . X X . . . . . . . . . . . . . W
  //. . . . O O . . . . . . . . T X X X . . . . . . . . . . . . . .
  //. . . . . . . . . . . . . . . . X X . . . . . . . . . . . . . .
  //W W . . . W W . . . . . . . . . . X . . . . . . . W W W W W W W
  //W . . . . . W . . . . . . . . . . . . . . . . . . W . . . . . W
  //W . . . . . C . . . . . . . . . . . . . . . . . . W . W W W W W
  //W . . . . . W . . . . . . . . . . . . . . . . . . W . W . . . W
  //W . . . . . C . . . . . . . . . . . . . . . . . . W . W . W W W
  //W O . K . O W . . . . . . . . . . . . . . . . . . W . W . W . W
  //W W W T W W W . . W W . . . . W W . . . . W W . . W W W W W W W"

  //W W W W W W W . . W W . . . . W W . . . . W W . . W W W T W W W
  //W . . W . . W . . . . . . . M . . . . . . . . . . W X X . X X W
  //W W W W W . W . . . . . . M M M . . . . . . . . . C . . . . . W
  //W . . W . . W . . . . . M M M M M . . . . . . . . W . . . . . W
  //W . W W W W W . . . . M M M M M M M . . . . . . . C . . . . . W
  //W . . W . . . . . . M M M M O M M M M . . . . . . W . . . . . W
  //W W W W W . W . . M M M M O O O M M M M . . . . . W W . . . W W
  //. . . . . . . . M M M M O O O O O M M M M . . . . . . . . . . .
  //. . . . . . . M M M M O O O O O O O M M M M . . . . . X . . . .
  //W . . . . . M M M M O O O O 4 O O O O M M M M . . . X X X . . W
  //W . . . . M M M M O O O O 4 4 4 O O O O M M M M . . . X . . . W
  //W . . . M M M M O O O O 4 4 4 4 4 O O O O M M M M . . . . . . W
  //. . . M M M M O O O O 4 4 4 4 4 4 4 O O O O M M M M . . . . . .
  //. . M M M M O O O O 4 4 4 4 C 4 4 4 4 O O O O M M M M . . . . .
  //. . . M M M M O O O O 4 4 4 4 4 4 4 O O O O M M M M . . . . . .
  //C C C C C C C M O O O O 4 4 4 4 4 O O O O M M M C C C C C C C C
  //C C C C C C C M M O O O O 4 4 4 O O O O M M M M C C C C C C C C
  //. . . . . . M M M M O O O O 4 O O O O M M M M . . . . . . . . .
  //. . . . . . . M M M M O O O O O O O M M M M . . . . . . . . . .
  //. . . . . . . . M M M M O O O O O M M M M . . . . . . . . . . .
  //W . . . . . . . . M M M M O O O M M M M . . . . . . . . . . . W
  //W . . . . . . . . . M M M M O M M M M . . . C . . . . . . . . W
  //W . . . . . . . . . . M M M M M M M . . . . 4 . . . . . . . . W
  //. . . . O O . . . . . . M M M M M . . . . . 4 . . . . . . . . .
  //. . . . . . . . . . . . . M M M . . . . . . 4 . . . . . . . . .
  //W W . . . W W . . . . . . . M . . . . . . . 4 . . W W W W W W W
  //W . . . . . W . . . . . . . . . . . . . . . O . . W . . . . . W
  //W . . . . . C . . . . . . . . . . . . . . . O . . W . W W W W W
  //W . . . . . W . . . . . . . . . . . . . . . O . . W . W . . . W
  //W . . . . . C . . . . . . . . . . . . . . . O . . W . W . W W W
  //W O . . . O W . . . . . . . . . . . . . . . . . . W . W . W . W
  //W W W T W W W . . W W . . . . W W . . . . W W . . W W W W W W W"

  dup example = #
    let board = new_board
    let casts = empty_casts
    let casts = (cast CRONI_WALK [29,1] {t}(t (Cons [0,1] (Cons [0,1] (Cons [1,0] Nil)))) casts)
    let casts = (cast EARTH_PULL [30,1] {t}(t [0,1]) casts)
    get [board,anims] = (exec_casts casts board)
    [(print_board board), anims]

  dup export = #
    [new_board,
    [exec_casts,
    [empty_casts,
    [cast,
    [get_hero_skill,
      0]]]]]

  # export
