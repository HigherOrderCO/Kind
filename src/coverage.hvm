// Main : (String)
(Main) = (Kind.API.check_coverage)

// Kind.API.show_errors (fns: (List (Pair (Kind.SplitTree) U60))) : (List (Pair U60 (Kind.Error)))
(Kind.API.show_errors (List.nil)) = (List.nil)
(Kind.API.show_errors (List.cons x xs)) = let fnid = (Pair.snd x); let orig_ = (OrigOf fnid); (List.concat (List.map (Kind.SplitTree.to_errors orig_ fnid (Pair.fst x)) @x (Pair.new fnid x)) (Kind.API.show_errors xs))

// Kind.API.output.show_errors (ls: (List (Pair U60 (Kind.Error)))) : (String)
(Kind.API.output.show_errors (List.nil)) = ""
(Kind.API.output.show_errors (List.cons err errs)) = (Kind.Printer.text (List.cons (Kind.API.output.error (Pair.fst err) (Pair.snd err) (Kind.Subst.end)) (List.cons (String.new_line) (List.cons (Kind.API.output.show_errors errs) (List.nil)))))

// Kind.API.check_coverage : (String)
(Kind.API.check_coverage) = let trees = (Kind.API.check_coverages (Coverage)); let output = (Kind.API.output.show_errors (Kind.API.show_errors trees)); (Bool.if (String.is_nil output) (Kind.Printer.text (List.cons "All functions covering." (List.cons (String.new_line) (List.cons (String.new_line) (List.nil))))) output)

// Kind.API.output.error (fnid: U60) (err: (Kind.Error)) (sub: (Kind.Subst)) : (String)
(Kind.API.output.error f_ (Kind.Error.uncovered orig_ fnid cause) sub) = (Kind.Printer.text (List.cons (Kind.Printer.color "4") (List.cons "The function is not covering all constructors. Example:" (List.cons (String.new_line) (List.cons " - " (List.cons (String.join " " (List.map cause @x (Kind.Term.show x))) (List.cons (Kind.Printer.color "0") (List.cons (String.new_line) (List.cons (String.new_line) (List.cons (Kind.API.output.error.details fnid (Kind.Context.empty) sub orig_) (List.nil)))))))))))
(Kind.API.output.error fnid (Kind.Error.unbound_variable ctx orig) sub) = (Kind.Printer.text (List.cons (Kind.Printer.color "4") (List.cons "Unbound Variable." (List.cons (Kind.Printer.color "0") (List.cons (String.new_line) (List.cons (Kind.API.output.error.details fnid ctx sub orig) (List.nil)))))))
(Kind.API.output.error fnid (Kind.Error.cant_infer_lambda ctx orig) sub) = (Kind.Printer.text (List.cons (Kind.Printer.color "4") (List.cons (String.cons 67 (String.cons 97 (String.cons 110 (String.cons 39 "t infer lambda.")))) (List.cons (Kind.Printer.color "0") (List.cons (String.new_line) (List.cons (Kind.API.output.error.details fnid ctx sub orig) (List.nil)))))))
(Kind.API.output.error fnid (Kind.Error.cant_infer_hole ctx orig) sub) = (Kind.Printer.text (List.cons (Kind.Printer.color "4") (List.cons (String.cons 67 (String.cons 97 (String.cons 110 (String.cons 39 "t infer hole.")))) (List.cons (Kind.Printer.color "0") (List.cons (String.new_line) (List.cons (Kind.API.output.error.details fnid ctx sub orig) (List.nil)))))))
(Kind.API.output.error fnid (Kind.Error.too_many_arguments ctx orig) sub) = (Kind.Printer.text (List.cons (Kind.Printer.color "4") (List.cons "Too many arguments." (List.cons (Kind.Printer.color "0") (List.cons (String.new_line) (List.cons (Kind.API.output.error.details fnid ctx sub orig) (List.nil)))))))
(Kind.API.output.error fnid (Kind.Error.invalid_call ctx orig) sub) = (Kind.Printer.text (List.cons (Kind.Printer.color "4") (List.cons "Invalid call." (List.cons (Kind.Printer.color "0") (List.cons (String.new_line) (List.cons (Kind.API.output.error.details fnid ctx sub orig) (List.nil)))))))
(Kind.API.output.error fnid (Kind.Error.type_mismatch ctx orig expected detected) sub) = (Kind.Printer.text (List.cons (Kind.Printer.color "4") (List.cons "Type mismatch" (List.cons (Kind.Printer.color "0") (List.cons (String.new_line) (List.cons "- Expected: " (List.cons (String.cut (Kind.Term.show (Kind.Term.fill expected sub))) (List.cons (String.new_line) (List.cons "- Detected: " (List.cons (String.cut (Kind.Term.show (Kind.Term.fill detected sub))) (List.cons (String.new_line) (List.cons (Kind.API.output.error.details fnid ctx sub orig) (List.nil)))))))))))))
(Kind.API.output.error fnid (Kind.Error.impossible_case ctx orig expected detected) sub) = (Kind.Printer.text (List.cons (Kind.Printer.color "4") (List.cons "Impossible case. You can remove it." (List.cons (Kind.Printer.color "0") (List.cons (String.new_line) (List.cons (Kind.API.output.error.details fnid ctx sub orig) (List.nil)))))))
(Kind.API.output.error fnid (Kind.Error.inspection ctx orig expected) sub) = (Kind.Printer.text (List.cons (Kind.Printer.color "4") (List.cons "Inspection." (List.cons (Kind.Printer.color "0") (List.cons (String.new_line) (List.cons "- Goal: " (List.cons (String.cut (Kind.Term.show (Kind.Term.fill expected sub))) (List.cons (String.new_line) (List.cons (Kind.API.output.error.details fnid ctx sub orig) (List.nil))))))))))

// Kind.API.output.error.details (fnid: U60) (ctx: (Kind.Context)) (sub: (Kind.Subst)) (origin: U60) : (String)
(Kind.API.output.error.details fnid ctx sub orig) = (Kind.Printer.text (List.cons (Bool.if (Kind.Context.is_empty ctx) "" (Kind.Printer.text (List.cons (Kind.Printer.color "4") (List.cons "Kind.Context:" (List.cons (Kind.Printer.color "0") (List.cons (String.new_line) (List.cons (Kind.Context.show ctx sub) (List.nil)))))))) (List.cons (Kind.Printer.color "4") (List.cons (String.cons 79 (String.cons 110 (String.cons 32 (String.cons 39 "{{#F")))) (List.cons (Show.to_string (U60.show (>> orig 48))) (List.cons (String.cons 70 (String.cons 35 (String.cons 125 (String.cons 125 (String.cons 39 ":"))))) (List.cons (Kind.Printer.color "0") (List.cons (String.new_line) (List.cons "{{#R" (List.cons (Show.to_string (U60.show (>> orig 48))) (List.cons ":" (List.cons (Show.to_string (U60.show (& orig 16777215))) (List.cons ":" (List.cons (Show.to_string (U60.show (& (>> orig 24) 16777215))) (List.cons "R#}}" (List.cons (String.new_line) (List.nil)))))))))))))))))

// Kind.Printer.text (ls: (List (String))) : (String)
(Kind.Printer.text (List.nil)) = ""
(Kind.Printer.text (List.cons x xs)) = (String.concat x (Kind.Printer.text xs))

// String.concat (xs: (String)) (ys: (String)) : (String)
(String.concat (String.cons x xs) ys) = (String.cons x (String.concat xs ys))
(String.concat "" ys) = ys

// Bool.if -(a: Type) (b: (Bool)) (t: a) (f: a) : a
(Bool.if (Bool.true) t f) = t
(Bool.if (Bool.false) t f) = f

// String.join (sep: (String)) (list: (List (String))) : (String)
(String.join sep list) = (String.intercalate sep list)

// String.intercalate (sep: (String)) (xs: (List (String))) : (String)
(String.intercalate sep xs) = (String.flatten (List.intersperse sep xs))

// String.flatten (xs: (List (String))) : (String)
(String.flatten (List.nil)) = ""
(String.flatten (List.cons head tail)) = (String.concat head (String.flatten tail))

// List.intersperse -(a: Type) (sep: a) (xs: (List a)) : (List a)
(List.intersperse sep (List.nil)) = (List.nil)
(List.intersperse sep (List.cons xh (List.nil))) = (List.pure xh)
(List.intersperse sep (List.cons xh xt)) = (List.cons xh (List.cons sep (List.intersperse sep xt)))

// List.pure -(t: Type) (x: t) : (List t)
(List.pure x) = (List.cons x (List.nil))

// Kind.Context.is_empty (ctx: (Kind.Context)) : (Bool)
(Kind.Context.is_empty (Kind.Context.empty)) = (Bool.true)
(Kind.Context.is_empty (Kind.Context.entry name type vals rest)) = (Bool.false)

// String.cut.go (str: (String)) (df: (String)) (n: U60) : (String)
(String.cut.go "" df n) = ""
(String.cut.go (String.cons x xs) df 0) = df
(String.cut.go (String.cons x xs) df n) = (String.cons x (String.cut.go xs df (- n 1)))

// String.cut (str: (String)) : (String)
(String.cut str) = (String.cut.go str "(...)" 2048)

// String.new_line : (String)
(String.new_line) = (String.pure (Char.newline))

// String.pure (x: (Char)) : (String)
(String.pure x) = (String.cons x "")

// Char : Type
(Char) = 0

// Char.newline : (Char)
(Char.newline) = 10

// Kind.Printer.color (color_code: (String)) : (String)
(Kind.Printer.color color_code) = (Kind.Printer.text (List.cons (String.cons 27 "") (List.cons "[" (List.cons color_code (List.cons "m" (List.nil))))))

// Kind.Term.fill (term: (Kind.Term)) (subst: (Kind.Subst)) : (Kind.Term)
(Kind.Term.fill term (Kind.Subst.end)) = term
(Kind.Term.fill (Kind.Term.typ orig) sub) = (Kind.Term.typ orig)
(Kind.Term.fill (Kind.Term.var orig name index) sub) = (Kind.Term.var orig name index)
(Kind.Term.fill (Kind.Term.all orig name typ body) sub) = (Kind.Term.all orig name (Kind.Term.fill typ sub) @x (Kind.Term.fill (body x) sub))
(Kind.Term.fill (Kind.Term.lam orig name body) sub) = (Kind.Term.lam orig name @x (Kind.Term.fill (body x) sub))
(Kind.Term.fill (Kind.Term.let orig name expr body) sub) = (Kind.Term.eval_let orig name (Kind.Term.fill expr sub) @x (Kind.Term.fill (body x) sub))
(Kind.Term.fill (Kind.Term.ann orig expr typ) sub) = (Kind.Term.eval_ann orig (Kind.Term.fill expr sub) (Kind.Term.fill typ sub))
(Kind.Term.fill (Kind.Term.sub orig name indx redx expr) sub) = (Kind.Term.eval_sub orig name indx redx (Kind.Term.fill expr sub))
(Kind.Term.fill (Kind.Term.app orig expr typ) sub) = (Kind.Term.eval_app orig (Kind.Term.fill expr sub) (Kind.Term.fill typ sub))
(Kind.Term.fill (Kind.Term.hlp orig) sub) = (Kind.Term.hlp orig)
(Kind.Term.fill (Kind.Term.u60 orig) sub) = (Kind.Term.u60 orig)
(Kind.Term.fill (Kind.Term.num orig num) sub) = (Kind.Term.num orig num)
(Kind.Term.fill (Kind.Term.op2 orig op left right) sub) = (Kind.Term.op2 orig op (Kind.Term.fill left sub) (Kind.Term.fill right sub))
(Kind.Term.fill (Kind.Term.ct0 ctid orig) sub) = (Kind.Term.ct0 ctid orig)
(Kind.Term.fill (Kind.Term.ct1 ctid orig x0) sub) = (Kind.Term.ct1 ctid orig (Kind.Term.fill x0 sub))
(Kind.Term.fill (Kind.Term.ct2 ctid orig x0 x1) sub) = (Kind.Term.ct2 ctid orig (Kind.Term.fill x0 sub) (Kind.Term.fill x1 sub))
(Kind.Term.fill (Kind.Term.ct3 ctid orig x0 x1 x2) sub) = (Kind.Term.ct3 ctid orig (Kind.Term.fill x0 sub) (Kind.Term.fill x1 sub) (Kind.Term.fill x2 sub))
(Kind.Term.fill (Kind.Term.ct4 ctid orig x0 x1 x2 x3) sub) = (Kind.Term.ct4 ctid orig (Kind.Term.fill x0 sub) (Kind.Term.fill x1 sub) (Kind.Term.fill x2 sub) (Kind.Term.fill x3 sub))
(Kind.Term.fill (Kind.Term.ct5 ctid orig x0 x1 x2 x3 x4) sub) = (Kind.Term.ct5 ctid orig (Kind.Term.fill x0 sub) (Kind.Term.fill x1 sub) (Kind.Term.fill x2 sub) (Kind.Term.fill x3 sub) (Kind.Term.fill x4 sub))
(Kind.Term.fill (Kind.Term.ct6 ctid orig x0 x1 x2 x3 x4 x5) sub) = (Kind.Term.ct6 ctid orig (Kind.Term.fill x0 sub) (Kind.Term.fill x1 sub) (Kind.Term.fill x2 sub) (Kind.Term.fill x3 sub) (Kind.Term.fill x4 sub) (Kind.Term.fill x5 sub))
(Kind.Term.fill (Kind.Term.ct7 ctid orig args) sub) = (Kind.Term.ct7 ctid orig (Kind.Term.fill args sub))
(Kind.Term.fill (Kind.Term.ct8 ctid orig args) sub) = (Kind.Term.ct8 ctid orig (Kind.Term.fill args sub))
(Kind.Term.fill (Kind.Term.fn0 fnid orig) sub) = (Kind.Term.FN0 fnid orig)
(Kind.Term.fill (Kind.Term.fn1 fnid orig x0) sub) = (Kind.Term.FN1 fnid orig (Kind.Term.fill x0 sub))
(Kind.Term.fill (Kind.Term.fn2 fnid orig x0 x1) sub) = (Kind.Term.FN2 fnid orig (Kind.Term.fill x0 sub) (Kind.Term.fill x1 sub))
(Kind.Term.fill (Kind.Term.fn3 fnid orig x0 x1 x2) sub) = (Kind.Term.FN3 fnid orig (Kind.Term.fill x0 sub) (Kind.Term.fill x1 sub) (Kind.Term.fill x2 sub))
(Kind.Term.fill (Kind.Term.fn4 fnid orig x0 x1 x2 x3) sub) = (Kind.Term.FN4 fnid orig (Kind.Term.fill x0 sub) (Kind.Term.fill x1 sub) (Kind.Term.fill x2 sub) (Kind.Term.fill x3 sub))
(Kind.Term.fill (Kind.Term.fn5 fnid orig x0 x1 x2 x3 x4) sub) = (Kind.Term.FN5 fnid orig (Kind.Term.fill x0 sub) (Kind.Term.fill x1 sub) (Kind.Term.fill x2 sub) (Kind.Term.fill x3 sub) (Kind.Term.fill x4 sub))
(Kind.Term.fill (Kind.Term.fn6 fnid orig x0 x1 x2 x3 x4 x5) sub) = (Kind.Term.FN6 fnid orig (Kind.Term.fill x0 sub) (Kind.Term.fill x1 sub) (Kind.Term.fill x2 sub) (Kind.Term.fill x3 sub) (Kind.Term.fill x4 sub) (Kind.Term.fill x5 sub))
(Kind.Term.fill (Kind.Term.fn7 fnid orig args) sub) = (Kind.Term.FN7 fnid orig (Kind.Term.fill args sub))
(Kind.Term.fill (Kind.Term.fn8 fnid orig args) sub) = (Kind.Term.FN8 fnid orig (Kind.Term.fill args sub))
(Kind.Term.fill (Kind.Term.args7 x0 x1 x2 x3 x4 x5 x6) sub) = (Kind.Term.args7 (Kind.Term.fill x0 sub) (Kind.Term.fill x1 sub) (Kind.Term.fill x2 sub) (Kind.Term.fill x3 sub) (Kind.Term.fill x4 sub) (Kind.Term.fill x5 sub) (Kind.Term.fill x6 sub))
(Kind.Term.fill (Kind.Term.args8 x0 x1 x2 x3 x4 x5 x6 x7) sub) = (Kind.Term.args8 (Kind.Term.fill x0 sub) (Kind.Term.fill x1 sub) (Kind.Term.fill x2 sub) (Kind.Term.fill x3 sub) (Kind.Term.fill x4 sub) (Kind.Term.fill x5 sub) (Kind.Term.fill x6 sub) (Kind.Term.fill x7 sub))
(Kind.Term.fill (Kind.Term.hol orig numb) sub) = let substRes = (Kind.Subst.look sub numb); (Maybe.match substRes (Kind.Term.hol orig numb) @substRes.value (Kind.Term.fill substRes.value sub))

// Kind.Term.eval_let (orig: U60) (name: U60) (expr: (Kind.Term)) (body: (_: (Kind.Term)) (Kind.Term)) : (Kind.Term)
(Kind.Term.eval_let orig name expr body) = (body expr)

// Kind.Term.eval_ann (orig: U60) (expr: (Kind.Term)) (type: (Kind.Term)) : (Kind.Term)
(Kind.Term.eval_ann orig expr type) = expr

// Kind.Term.eval_app (orig: U60) (left: (Kind.Term)) (right: (Kind.Term)) : (Kind.Term)
(Kind.Term.eval_app orig (Kind.Term.lam orig1 name body) arg) = (body arg)
(Kind.Term.eval_app orig func arg) = (Kind.Term.app orig func arg)

// Maybe.match -(t: Type) (x: (Maybe t)) -(p: (x: (Maybe t)) Type) (none: (p (Maybe.none t))) (some: (value: t) (p (Maybe.some t value))) : (p x)
(Maybe.match (Maybe.none) none some) = none
(Maybe.match (Maybe.some value_) none some) = (some value_)

// Kind.Subst.look (subst: (Kind.Subst)) (depth: U60) : (Maybe (Kind.Term))
(Kind.Subst.look (Kind.Subst.end) 0) = (Maybe.none)
(Kind.Subst.look (Kind.Subst.unfilled rest) 0) = (Maybe.none)
(Kind.Subst.look (Kind.Subst.sub term rest) 0) = (Maybe.some term)
(Kind.Subst.look (Kind.Subst.end) n) = (Maybe.none)
(Kind.Subst.look (Kind.Subst.unfilled rest) n) = (Kind.Subst.look rest (- n 1))
(Kind.Subst.look (Kind.Subst.sub term rest) n) = (Kind.Subst.look rest (- n 1))

// Kind.Term.eval_sub (orig: U60) (name: U60) (indx: U60) (redx: U60) (expr: (Kind.Term)) : (Kind.Term)
(Kind.Term.eval_sub orig name indx redx expr) = expr

// Kind.Context.show.type (name: U60) (type: (Kind.Term)) (sub: (Kind.Subst)) (pad: U60) : (String)
(Kind.Context.show.type name type sub pad) = (Kind.Printer.text (List.cons "- " (List.cons (String.pad_right (U60.to_nat pad) 32 (Kind.Name.show name)) (List.cons " : " (List.cons (String.cut (Kind.Term.show (Kind.Term.fill type sub))) (List.cons (String.new_line) (List.nil)))))))

// Kind.Context.show.vals (name: U60) (vals: (List (Kind.Term))) (sub: (Kind.Subst)) (pad: U60) : (String)
(Kind.Context.show.vals name (List.nil) sub pad) = ""
(Kind.Context.show.vals name (List.cons val vals) sub pad) = (Kind.Printer.text (List.cons (Kind.Printer.color "2") (List.cons "- " (List.cons (String.pad_right (U60.to_nat pad) 32 (Kind.Name.show name)) (List.cons " = " (List.cons (String.cut (Kind.Term.show (Kind.Term.fill val sub))) (List.cons (Kind.Printer.color "0") (List.cons (String.new_line) (List.cons (Kind.Context.show.vals name vals sub pad) (List.nil))))))))))

// Kind.Context.show.go (ctx: (Kind.Context)) (subst: (Kind.Subst)) (pad: U60) : (String)
(Kind.Context.show.go (Kind.Context.empty) sub pad) = ""
(Kind.Context.show.go (Kind.Context.entry name type vals rest) sub pad) = (Kind.Printer.text (List.cons (Kind.Context.show.type name type sub pad) (List.cons (Kind.Context.show.vals name vals sub pad) (List.cons (Kind.Context.show.go rest sub pad) (List.nil)))))

// Kind.Context.show (ctx: (Kind.Context)) (subst: (Kind.Subst)) : (String)
(Kind.Context.show ctx subst) = (Kind.Context.show.go ctx subst (Kind.Context.max_name_length ctx))

// String.pad_right (size: (Nat)) (chr: (Char)) (str: (String)) : (String)
(String.pad_right (Nat.zero) chr str) = str
(String.pad_right (Nat.succ sp) chr "") = (String.cons chr (String.pad_right sp chr ""))
(String.pad_right (Nat.succ sp) chr (String.cons x xs)) = (String.cons x (String.pad_right sp chr xs))

// Kind.Name.show.go (name: U60) (chrs: (String)) : (String)
(Kind.Name.show.go name chrs) = (U60.if (== name 0) chrs let val = (% name 64); let chr = (U60.if (== val 0) 46 (U60.if (& (<= 1 val) (<= val 10)) (+ (- val 1) 48) (U60.if (& (<= 11 val) (<= val 36)) (+ (- val 11) 65) (U60.if (& (<= 37 val) (<= val 62)) (+ (- val 37) 97) (U60.if (== val 63) 95 63))))); (Kind.Name.show.go (/ name 64) (String.cons chr chrs)))

// Kind.Name.show (name: U60) : (String)
(Kind.Name.show name) = (Kind.Name.show.go name "")

// U60.if -(r: Type) (n: U60) (t: r) (f: r) : r
(U60.if 0 t f) = f
(U60.if x t f) = t

// U60.to_nat (x: U60) : (Nat)
(U60.to_nat 0) = (Nat.zero)
(U60.to_nat n) = (Nat.succ (U60.to_nat (- n 1)))

// Kind.Term.show.forall (orig: U60) (name: U60) (type: (Kind.Term)) (body: (_: (Kind.Term)) (Kind.Term)) : (String)
(Kind.Term.show.forall orig name type body) = (U60.if (== name 63) (Kind.Printer.text (List.cons "(" (List.cons (Kind.Term.show type) (List.cons " -> " (List.cons (Kind.Term.show (body (Kind.Term.var orig name 0))) (List.cons ")" (List.nil))))))) (Kind.Printer.text (List.cons "((" (List.cons (Kind.Name.show name) (List.cons ": " (List.cons (Kind.Term.show type) (List.cons ") -> " (List.cons (Kind.Term.show (body (Kind.Term.var orig name 0))) (List.cons ")" (List.nil))))))))))

// Kind.Term.show (term: (Kind.Term)) : (String)
(Kind.Term.show term) = let sugars = (List.cons (Kind.Term.show.sugar.string term) (List.cons (Kind.Term.show.sugar.list term) (List.cons (Kind.Term.show.sugar.sigma term) (List.nil)))); (Maybe.try sugars (Kind.Term.show.go term))

// Kind.Term.show.go (term: (Kind.Term)) : (String)
(Kind.Term.show.go (Kind.Term.typ orig)) = "Type"
(Kind.Term.show.go (Kind.Term.var orig name index)) = (Kind.Printer.text (List.cons (Kind.Name.show name) (List.nil)))
(Kind.Term.show.go (Kind.Term.hol orig numb)) = (Kind.Printer.text (List.cons "_" (List.nil)))
(Kind.Term.show.go (Kind.Term.all orig name type body)) = (Kind.Term.show.forall orig name type body)
(Kind.Term.show.go (Kind.Term.lam orig name body)) = (Kind.Printer.text (List.cons "(" (List.cons (Kind.Name.show name) (List.cons " => " (List.cons (Kind.Term.show (body (Kind.Term.var orig name 0))) (List.cons ")" (List.nil)))))))
(Kind.Term.show.go (Kind.Term.let orig name exp body)) = (Kind.Printer.text (List.cons "let " (List.cons (Kind.Name.show name) (List.cons " = " (List.cons (Kind.Term.show exp) (List.cons "; " (List.cons (Kind.Term.show (body (Kind.Term.var orig name 0))) (List.nil))))))))
(Kind.Term.show.go (Kind.Term.ann orig expr type)) = (Kind.Printer.text (List.cons "{" (List.cons (Kind.Term.show expr) (List.cons " :: " (List.cons (Kind.Term.show type) (List.cons "}" (List.nil)))))))
(Kind.Term.show.go (Kind.Term.sub orig name indx redx expr)) = (Kind.Printer.text (List.cons (Kind.Term.show expr) (List.cons " ## " (List.cons (Kind.Name.show name) (List.cons "/" (List.cons (Show.to_string (U60.show redx)) (List.nil)))))))
(Kind.Term.show.go (Kind.Term.app orig func argm)) = (Kind.Printer.text (List.cons "(" (List.cons (Kind.Term.show func) (List.cons " " (List.cons (Kind.Term.show argm) (List.cons ")" (List.nil)))))))
(Kind.Term.show.go (Kind.Term.ct0 ctid orig)) = (NameOf ctid)
(Kind.Term.show.go (Kind.Term.ct1 ctid orig x0)) = (Kind.Printer.text (List.cons "(" (List.cons (NameOf ctid) (List.cons " " (List.cons (Kind.Term.show x0) (List.cons ")" (List.nil)))))))
(Kind.Term.show.go (Kind.Term.ct2 ctid orig x0 x1)) = (Kind.Printer.text (List.cons "(" (List.cons (NameOf ctid) (List.cons " " (List.cons (Kind.Term.show x0) (List.cons " " (List.cons (Kind.Term.show x1) (List.cons ")" (List.nil)))))))))
(Kind.Term.show.go (Kind.Term.ct3 ctid orig x0 x1 x2)) = (Kind.Printer.text (List.cons "(" (List.cons (NameOf ctid) (List.cons " " (List.cons (Kind.Term.show x0) (List.cons " " (List.cons (Kind.Term.show x1) (List.cons " " (List.cons (Kind.Term.show x2) (List.cons ")" (List.nil)))))))))))
(Kind.Term.show.go (Kind.Term.ct4 ctid orig x0 x1 x2 x3)) = (Kind.Printer.text (List.cons "(" (List.cons (NameOf ctid) (List.cons " " (List.cons (Kind.Term.show x0) (List.cons " " (List.cons (Kind.Term.show x1) (List.cons " " (List.cons (Kind.Term.show x2) (List.cons " " (List.cons (Kind.Term.show x3) (List.cons ")" (List.nil)))))))))))))
(Kind.Term.show.go (Kind.Term.ct5 ctid orig x0 x1 x2 x3 x4)) = (Kind.Printer.text (List.cons "(" (List.cons (NameOf ctid) (List.cons " " (List.cons (Kind.Term.show x0) (List.cons " " (List.cons (Kind.Term.show x1) (List.cons " " (List.cons (Kind.Term.show x2) (List.cons " " (List.cons (Kind.Term.show x3) (List.cons " " (List.cons (Kind.Term.show x4) (List.cons ")" (List.nil)))))))))))))))
(Kind.Term.show.go (Kind.Term.ct6 ctid orig x0 x1 x2 x3 x4 x5)) = (Kind.Printer.text (List.cons "(" (List.cons (NameOf ctid) (List.cons " " (List.cons (Kind.Term.show x0) (List.cons " " (List.cons (Kind.Term.show x1) (List.cons " " (List.cons (Kind.Term.show x2) (List.cons " " (List.cons (Kind.Term.show x3) (List.cons " " (List.cons (Kind.Term.show x4) (List.cons " " (List.cons (Kind.Term.show x5) (List.cons ")" (List.nil)))))))))))))))))
(Kind.Term.show.go (Kind.Term.ct7 ctid orig args)) = (Kind.Printer.text (List.cons "(" (List.cons (NameOf ctid) (List.cons " " (List.cons (Kind.Term.show args) (List.cons ")" (List.nil)))))))
(Kind.Term.show.go (Kind.Term.ct8 ctid orig args)) = (Kind.Printer.text (List.cons "(" (List.cons (NameOf ctid) (List.cons " " (List.cons (Kind.Term.show args) (List.cons ")" (List.nil)))))))
(Kind.Term.show.go (Kind.Term.fn0 ctid orig)) = (NameOf ctid)
(Kind.Term.show.go (Kind.Term.fn1 ctid orig x0)) = (Kind.Printer.text (List.cons "(" (List.cons (NameOf ctid) (List.cons " " (List.cons (Kind.Term.show x0) (List.cons ")" (List.nil)))))))
(Kind.Term.show.go (Kind.Term.fn2 ctid orig x0 x1)) = (Kind.Printer.text (List.cons "(" (List.cons (NameOf ctid) (List.cons " " (List.cons (Kind.Term.show x0) (List.cons " " (List.cons (Kind.Term.show x1) (List.cons ")" (List.nil)))))))))
(Kind.Term.show.go (Kind.Term.fn3 ctid orig x0 x1 x2)) = (Kind.Printer.text (List.cons "(" (List.cons (NameOf ctid) (List.cons " " (List.cons (Kind.Term.show x0) (List.cons " " (List.cons (Kind.Term.show x1) (List.cons " " (List.cons (Kind.Term.show x2) (List.cons ")" (List.nil)))))))))))
(Kind.Term.show.go (Kind.Term.fn4 ctid orig x0 x1 x2 x3)) = (Kind.Printer.text (List.cons "(" (List.cons (NameOf ctid) (List.cons " " (List.cons (Kind.Term.show x0) (List.cons " " (List.cons (Kind.Term.show x1) (List.cons " " (List.cons (Kind.Term.show x2) (List.cons " " (List.cons (Kind.Term.show x3) (List.cons ")" (List.nil)))))))))))))
(Kind.Term.show.go (Kind.Term.fn5 ctid orig x0 x1 x2 x3 x4)) = (Kind.Printer.text (List.cons "(" (List.cons (NameOf ctid) (List.cons " " (List.cons (Kind.Term.show x0) (List.cons " " (List.cons (Kind.Term.show x1) (List.cons " " (List.cons (Kind.Term.show x2) (List.cons " " (List.cons (Kind.Term.show x3) (List.cons " " (List.cons (Kind.Term.show x4) (List.cons ")" (List.nil)))))))))))))))
(Kind.Term.show.go (Kind.Term.fn6 ctid orig x0 x1 x2 x3 x4 x5)) = (Kind.Printer.text (List.cons "(" (List.cons (NameOf ctid) (List.cons " " (List.cons (Kind.Term.show x0) (List.cons " " (List.cons (Kind.Term.show x1) (List.cons " " (List.cons (Kind.Term.show x2) (List.cons " " (List.cons (Kind.Term.show x3) (List.cons " " (List.cons (Kind.Term.show x4) (List.cons " " (List.cons (Kind.Term.show x5) (List.cons ")" (List.nil)))))))))))))))))
(Kind.Term.show.go (Kind.Term.fn7 ctid orig args)) = (Kind.Printer.text (List.cons "(" (List.cons (NameOf ctid) (List.cons " " (List.cons (Kind.Term.show args) (List.cons ")" (List.nil)))))))
(Kind.Term.show.go (Kind.Term.fn8 ctid orig args)) = (Kind.Printer.text (List.cons "(" (List.cons (NameOf ctid) (List.cons " " (List.cons (Kind.Term.show args) (List.cons ")" (List.nil)))))))
(Kind.Term.show.go (Kind.Term.args7 x0 x1 x2 x3 x4 x5 x6)) = (Kind.Printer.text (List.cons (Kind.Term.show x0) (List.cons " " (List.cons (Kind.Term.show x1) (List.cons " " (List.cons (Kind.Term.show x2) (List.cons " " (List.cons (Kind.Term.show x3) (List.cons " " (List.cons (Kind.Term.show x4) (List.cons " " (List.cons (Kind.Term.show x5) (List.cons " " (List.cons (Kind.Term.show x6) (List.nil)))))))))))))))
(Kind.Term.show.go (Kind.Term.args8 x0 x1 x2 x3 x4 x5 x6 x7)) = (Kind.Printer.text (List.cons (Kind.Term.show x0) (List.cons " " (List.cons (Kind.Term.show x1) (List.cons " " (List.cons (Kind.Term.show x2) (List.cons " " (List.cons (Kind.Term.show x3) (List.cons " " (List.cons (Kind.Term.show x4) (List.cons " " (List.cons (Kind.Term.show x5) (List.cons " " (List.cons (Kind.Term.show x6) (List.cons " " (List.cons (Kind.Term.show x7) (List.nil)))))))))))))))))
(Kind.Term.show.go (Kind.Term.hlp orig)) = "?"
(Kind.Term.show.go (Kind.Term.u60 orig)) = "U60"
(Kind.Term.show.go (Kind.Term.num orig numb)) = (Show.to_string (U60.show numb))
(Kind.Term.show.go (Kind.Term.op2 orig operator left right)) = (Kind.Printer.text (List.cons "(" (List.cons (Kind.Operator.show operator) (List.cons " " (List.cons (Kind.Term.show left) (List.cons " " (List.cons (Kind.Term.show right) (List.cons ")" (List.nil)))))))))

// Kind.Term.show.sugar.sigma (term: (Kind.Term)) : (Maybe (String))
(Kind.Term.show.sugar.sigma (Kind.Term.ct2 (Sigma.) orig typ (Kind.Term.lam orig_ name body))) = (Maybe.some (Kind.Printer.text (List.cons "([" (List.cons (Kind.Name.show name) (List.cons ": " (List.cons (Kind.Term.show typ) (List.cons "] -> " (List.cons (Kind.Term.show (body (Kind.Term.var orig_ name 0))) (List.cons ")" (List.nil))))))))))
(Kind.Term.show.sugar.sigma term) = (Maybe.none)

// U60.show (n: U60) : (Show)
(U60.show 0) = @str (String.cons 48 str)
(U60.show n) = @str let next = (String.cons (+ 48 (% n 10)) str); let func = (U60.if (< n 10) @h h @h ((U60.show (/ n 10)) h)); (func next)

// Show : Type
(Show) = 0

// Maybe.try -(a: Type) (ls: (List (Maybe a))) (alt: a) : a
(Maybe.try (List.nil) alt) = alt
(Maybe.try (List.cons maybe xs) alt) = (Maybe.match maybe (Maybe.try xs alt) @maybe.value maybe.value)

// Kind.Operator.show (op: (Kind.Operator)) : (String)
(Kind.Operator.show (Kind.Operator.add)) = "+"
(Kind.Operator.show (Kind.Operator.sub)) = "-"
(Kind.Operator.show (Kind.Operator.mul)) = "*"
(Kind.Operator.show (Kind.Operator.div)) = "/"
(Kind.Operator.show (Kind.Operator.mod)) = "%"
(Kind.Operator.show (Kind.Operator.and)) = "&"
(Kind.Operator.show (Kind.Operator.or)) = "|"
(Kind.Operator.show (Kind.Operator.xor)) = "^"
(Kind.Operator.show (Kind.Operator.shl)) = "<<"
(Kind.Operator.show (Kind.Operator.shr)) = ">>"
(Kind.Operator.show (Kind.Operator.ltn)) = "<"
(Kind.Operator.show (Kind.Operator.lte)) = "<="
(Kind.Operator.show (Kind.Operator.eql)) = "=="
(Kind.Operator.show (Kind.Operator.gte)) = ">="
(Kind.Operator.show (Kind.Operator.gtn)) = ">"
(Kind.Operator.show (Kind.Operator.neq)) = "!="

// Kind.Term.show.sugar.string.go (term: (Kind.Term)) : (Maybe (String))
(Kind.Term.show.sugar.string.go (Kind.Term.ct0 (String.nil.) orig)) = (Maybe.some "")
(Kind.Term.show.sugar.string.go (Kind.Term.ct2 (String.cons.) orig (Kind.Term.num orig1 x0) x1)) = (Maybe.bind (Kind.Term.show.sugar.string.go x1) @tail (Maybe.pure (String.cons x0 tail)))
(Kind.Term.show.sugar.string.go other) = (Maybe.none)

// Kind.Term.show.sugar.string (term: (Kind.Term)) : (Maybe (String))
(Kind.Term.show.sugar.string term) = (Maybe.bind (Kind.Term.show.sugar.string.go term) @res let quot = (String.cons 39 ""); (Maybe.pure (Kind.Printer.text (List.cons quot (List.cons res (List.cons quot (List.nil)))))))

// Maybe.bind -(a: Type) -(b: Type) (ma: (Maybe a)) (mb: (_: a) (Maybe b)) : (Maybe b)
(Maybe.bind (Maybe.none) mb) = (Maybe.none)
(Maybe.bind (Maybe.some val) mb) = (mb val)

// Maybe.pure -(a: Type) (x: a) : (Maybe a)
(Maybe.pure x) = (Maybe.some x)

// Kind.Term.show.sugar.list.go (term: (Kind.Term)) : (Maybe (List (String)))
(Kind.Term.show.sugar.list.go (Kind.Term.ct0 (List.nil.) orig)) = (Maybe.some (List.nil))
(Kind.Term.show.sugar.list.go (Kind.Term.ct2 (List.cons.) orig x0 x1)) = (Maybe.bind (Kind.Term.show.sugar.list.go x1) @tail (Maybe.pure (List.cons (Kind.Term.show x0) tail)))
(Kind.Term.show.sugar.list.go other) = (Maybe.none)

// Kind.Term.show.sugar.list (term: (Kind.Term)) : (Maybe (String))
(Kind.Term.show.sugar.list term) = (Maybe.bind (Kind.Term.show.sugar.list.go term) @res (Maybe.pure (Kind.Printer.text (List.cons "[" (List.cons (String.join " " res) (List.cons "]" (List.nil)))))))

// Show.to_string (show: (Show)) : (String)
(Show.to_string show) = (show "")

// Kind.Context.max_name_length.aux (ctx: (Kind.Context)) (acc: U60) : U60
(Kind.Context.max_name_length.aux (Kind.Context.empty) acc) = acc
(Kind.Context.max_name_length.aux (Kind.Context.entry name type vals rest) acc) = (Kind.Context.max_name_length.aux rest (U60.max (Nat.to_u60 (String.length (Kind.Name.show name))) acc))

// Kind.Context.max_name_length (ctx: (Kind.Context)) : U60
(Kind.Context.max_name_length ctx) = (Kind.Context.max_name_length.aux ctx 0)

// U60.max (fst: U60) (snd: U60) : U60
(U60.max fst snd) = (U60.if (> fst snd) fst snd)

// Nat.to_u60 (n: (Nat)) : U60
(Nat.to_u60 (Nat.zero)) = 0
(Nat.to_u60 (Nat.succ n)) = (+ 1 (Nat.to_u60 n))

// String.length (xs: (String)) : (Nat)
(String.length "") = (Nat.zero)
(String.length (String.cons x xs)) = (Nat.succ (String.length xs))

// List.map -(a: Type) -(b: Type) (xs: (List a)) (f: (_: a) b) : (List b)
(List.map (List.nil) f) = (List.nil)
(List.map (List.cons head tail) f) = (List.cons (f head) (List.map tail f))

// String.is_nil (xs: (String)) : (Bool)
(String.is_nil "") = (Bool.true)
(String.is_nil (String.cons x xs)) = (Bool.false)

// Kind.API.check_coverages (function_ids: (List U60)) : (List (Pair (Kind.SplitTree) U60))
(Kind.API.check_coverages (List.nil)) = (List.nil)
(Kind.API.check_coverages (List.cons fnid fs)) = let rules = (Definition.RulesOf fnid); let ty = (Definition.TypeOf fnid); let head = (Kind.Coverage.cover (Kind.Context.empty) fnid rules ty); let tail = (Kind.API.check_coverages fs); (List.cons (Pair.new (HVM.log (Kind.SplitTree.show head) head) fnid) tail)

// Kind.Coverage.cover (context: (Kind.Context)) (depth: U60) (clauses: (List (Kind.Rule))) (funTy: (Kind.Term)) : (Kind.SplitTree)
(Kind.Coverage.cover ctx dep clauses funTy) = (Bool.if (Kind.Coverage.catch_all clauses) (Kind.SplitTree.done) let res = (Kind.Coverage.is_empty ctx dep clauses (Kind.Term.eval funTy)); (Bool.if res (Kind.SplitTree.done) (Kind.Coverage.act ctx dep clauses (Kind.Term.eval funTy))))

// Kind.Term.eval (term: (Kind.Term)) : (Kind.Term)
(Kind.Term.eval (Kind.Term.typ orig)) = (Kind.Term.typ orig)
(Kind.Term.eval (Kind.Term.var orig name index)) = (Kind.Term.var orig name index)
(Kind.Term.eval (Kind.Term.hol orig numb)) = (Kind.Term.hol orig numb)
(Kind.Term.eval (Kind.Term.all orig name typ body)) = (Kind.Term.all orig name (Kind.Term.eval typ) @x (Kind.Term.eval (body x)))
(Kind.Term.eval (Kind.Term.lam orig name body)) = (Kind.Term.lam orig name @x (Kind.Term.eval (body x)))
(Kind.Term.eval (Kind.Term.let orig name expr body)) = (Kind.Term.eval_let orig name (Kind.Term.eval expr) @x (Kind.Term.eval (body x)))
(Kind.Term.eval (Kind.Term.ann orig expr typ)) = (Kind.Term.eval_ann orig (Kind.Term.eval expr) (Kind.Term.eval typ))
(Kind.Term.eval (Kind.Term.sub orig name indx redx expr)) = (Kind.Term.eval_sub orig name indx redx (Kind.Term.eval expr))
(Kind.Term.eval (Kind.Term.app orig expr typ)) = (Kind.Term.eval_app orig (Kind.Term.eval expr) (Kind.Term.eval typ))
(Kind.Term.eval (Kind.Term.hlp orig)) = (Kind.Term.hlp orig)
(Kind.Term.eval (Kind.Term.u60 orig)) = (Kind.Term.u60 orig)
(Kind.Term.eval (Kind.Term.num orig num)) = (Kind.Term.num orig num)
(Kind.Term.eval (Kind.Term.op2 orig op left right)) = (Kind.Term.eval_op orig op (Kind.Term.eval left) (Kind.Term.eval right))
(Kind.Term.eval (Kind.Term.ct0 ctid orig)) = (Kind.Term.ct0 ctid orig)
(Kind.Term.eval (Kind.Term.ct1 ctid orig x0)) = (Kind.Term.ct1 ctid orig (Kind.Term.eval x0))
(Kind.Term.eval (Kind.Term.ct2 ctid orig x0 x1)) = (Kind.Term.ct2 ctid orig (Kind.Term.eval x0) (Kind.Term.eval x1))
(Kind.Term.eval (Kind.Term.ct3 ctid orig x0 x1 x2)) = (Kind.Term.ct3 ctid orig (Kind.Term.eval x0) (Kind.Term.eval x1) (Kind.Term.eval x2))
(Kind.Term.eval (Kind.Term.ct4 ctid orig x0 x1 x2 x3)) = (Kind.Term.ct4 ctid orig (Kind.Term.eval x0) (Kind.Term.eval x1) (Kind.Term.eval x2) (Kind.Term.eval x3))
(Kind.Term.eval (Kind.Term.ct5 ctid orig x0 x1 x2 x3 x4)) = (Kind.Term.ct5 ctid orig (Kind.Term.eval x0) (Kind.Term.eval x1) (Kind.Term.eval x2) (Kind.Term.eval x3) (Kind.Term.eval x4))
(Kind.Term.eval (Kind.Term.ct6 ctid orig x0 x1 x2 x3 x4 x5)) = (Kind.Term.ct6 ctid orig (Kind.Term.eval x0) (Kind.Term.eval x1) (Kind.Term.eval x2) (Kind.Term.eval x3) (Kind.Term.eval x4) (Kind.Term.eval x5))
(Kind.Term.eval (Kind.Term.ct7 ctid orig args)) = (Kind.Term.ct7 ctid orig (Kind.Term.eval args))
(Kind.Term.eval (Kind.Term.ct8 ctid orig args)) = (Kind.Term.ct8 ctid orig (Kind.Term.eval args))
(Kind.Term.eval (Kind.Term.fn0 fnid orig)) = (Kind.Term.FN0 fnid orig)
(Kind.Term.eval (Kind.Term.fn1 fnid orig x0)) = (Kind.Term.FN1 fnid orig (Kind.Term.eval x0))
(Kind.Term.eval (Kind.Term.fn2 fnid orig x0 x1)) = (Kind.Term.FN2 fnid orig (Kind.Term.eval x0) (Kind.Term.eval x1))
(Kind.Term.eval (Kind.Term.fn3 fnid orig x0 x1 x2)) = (Kind.Term.FN3 fnid orig (Kind.Term.eval x0) (Kind.Term.eval x1) (Kind.Term.eval x2))
(Kind.Term.eval (Kind.Term.fn4 fnid orig x0 x1 x2 x3)) = (Kind.Term.FN4 fnid orig (Kind.Term.eval x0) (Kind.Term.eval x1) (Kind.Term.eval x2) (Kind.Term.eval x3))
(Kind.Term.eval (Kind.Term.fn5 fnid orig x0 x1 x2 x3 x4)) = (Kind.Term.FN5 fnid orig (Kind.Term.eval x0) (Kind.Term.eval x1) (Kind.Term.eval x2) (Kind.Term.eval x3) (Kind.Term.eval x4))
(Kind.Term.eval (Kind.Term.fn6 fnid orig x0 x1 x2 x3 x4 x5)) = (Kind.Term.FN6 fnid orig (Kind.Term.eval x0) (Kind.Term.eval x1) (Kind.Term.eval x2) (Kind.Term.eval x3) (Kind.Term.eval x4) (Kind.Term.eval x5))
(Kind.Term.eval (Kind.Term.fn7 ctid orig args)) = (Kind.Term.FN7 ctid orig (Kind.Term.eval args))
(Kind.Term.eval (Kind.Term.fn8 ctid orig args)) = (Kind.Term.FN8 ctid orig (Kind.Term.eval args))
(Kind.Term.eval (Kind.Term.args7 x0 x1 x2 x3 x4 x5 x6)) = (Kind.Term.args7 (Kind.Term.eval x0) (Kind.Term.eval x1) (Kind.Term.eval x2) (Kind.Term.eval x3) (Kind.Term.eval x4) (Kind.Term.eval x5) (Kind.Term.eval x6))
(Kind.Term.eval (Kind.Term.args8 x0 x1 x2 x3 x4 x5 x6 x7)) = (Kind.Term.args8 (Kind.Term.eval x0) (Kind.Term.eval x1) (Kind.Term.eval x2) (Kind.Term.eval x3) (Kind.Term.eval x4) (Kind.Term.eval x5) (Kind.Term.eval x6) (Kind.Term.eval x7))

// Kind.Term.eval_op (orig: U60) (op: (Kind.Operator)) (left: (Kind.Term)) (right: (Kind.Term)) : (Kind.Term)
(Kind.Term.eval_op orig (Kind.Operator.add) (Kind.Term.num a.orig a.num) (Kind.Term.num b.orig b.num)) = (Kind.Term.num 0 (+ a.num b.num))
(Kind.Term.eval_op orig (Kind.Operator.sub) (Kind.Term.num a.orig a.num) (Kind.Term.num b.orig b.num)) = (Kind.Term.num 0 (- a.num b.num))
(Kind.Term.eval_op orig (Kind.Operator.mul) (Kind.Term.num a.orig a.num) (Kind.Term.num b.orig b.num)) = (Kind.Term.num 0 (* a.num b.num))
(Kind.Term.eval_op orig (Kind.Operator.div) (Kind.Term.num a.orig a.num) (Kind.Term.num b.orig b.num)) = (Kind.Term.num 0 (/ a.num b.num))
(Kind.Term.eval_op orig (Kind.Operator.mod) (Kind.Term.num a.orig a.num) (Kind.Term.num b.orig b.num)) = (Kind.Term.num 0 (% a.num b.num))
(Kind.Term.eval_op orig (Kind.Operator.and) (Kind.Term.num a.orig a.num) (Kind.Term.num b.orig b.num)) = (Kind.Term.num 0 (& a.num b.num))
(Kind.Term.eval_op orig (Kind.Operator.or) (Kind.Term.num a.orig a.num) (Kind.Term.num b.orig b.num)) = (Kind.Term.num 0 (| a.num b.num))
(Kind.Term.eval_op orig (Kind.Operator.xor) (Kind.Term.num a.orig a.num) (Kind.Term.num b.orig b.num)) = (Kind.Term.num 0 (^ a.num b.num))
(Kind.Term.eval_op orig (Kind.Operator.shl) (Kind.Term.num a.orig a.num) (Kind.Term.num b.orig b.num)) = (Kind.Term.num 0 (<< a.num b.num))
(Kind.Term.eval_op orig (Kind.Operator.shr) (Kind.Term.num a.orig a.num) (Kind.Term.num b.orig b.num)) = (Kind.Term.num 0 (>> a.num b.num))
(Kind.Term.eval_op orig (Kind.Operator.ltn) (Kind.Term.num a.orig a.num) (Kind.Term.num b.orig b.num)) = (Kind.Term.num 0 (< a.num b.num))
(Kind.Term.eval_op orig (Kind.Operator.lte) (Kind.Term.num a.orig a.num) (Kind.Term.num b.orig b.num)) = (Kind.Term.num 0 (<= a.num b.num))
(Kind.Term.eval_op orig (Kind.Operator.eql) (Kind.Term.num a.orig a.num) (Kind.Term.num b.orig b.num)) = (Kind.Term.num 0 (== a.num b.num))
(Kind.Term.eval_op orig (Kind.Operator.gte) (Kind.Term.num a.orig a.num) (Kind.Term.num b.orig b.num)) = (Kind.Term.num 0 (>= a.num b.num))
(Kind.Term.eval_op orig (Kind.Operator.gtn) (Kind.Term.num a.orig a.num) (Kind.Term.num b.orig b.num)) = (Kind.Term.num 0 (> a.num b.num))
(Kind.Term.eval_op orig (Kind.Operator.neq) (Kind.Term.num a.orig a.num) (Kind.Term.num b.orig b.num)) = (Kind.Term.num 0 (!= a.num b.num))
(Kind.Term.eval_op orig op left right) = (Kind.Term.op2 orig op left right)

// Kind.Coverage.is_empty (context: (Kind.Context)) (depth: U60) (clauses: (List (Kind.Rule))) (funTy: (Kind.Term)) : (Bool)
(Kind.Coverage.is_empty ctx depth clauses (Kind.Term.all orig_ name_ typ body)) = let data_type = (Kind.Coverage.get_inductive typ); (Maybe.match data_type (Kind.Coverage.is_empty ctx depth clauses (body (Kind.Term.hol orig_ name_))) @data_type.value let constructors = (Family.ConstructorsOf data_type.value); (Bool.if (Nat.equal (List.length constructors) (Nat.zero)) (Bool.true) (Kind.Coverage.is_empty ctx depth clauses (body (Kind.Term.hol orig_ name_)))))
(Kind.Coverage.is_empty ctx depth clauses typ) = (Bool.false)

// Nat.equal (n: (Nat)) (m: (Nat)) : (Bool)
(Nat.equal (Nat.zero) (Nat.zero)) = (Bool.true)
(Nat.equal (Nat.succ n) (Nat.succ m)) = (Nat.equal n m)
(Nat.equal n m) = (Bool.false)

// List.length -(a: Type) (xs: (List a)) : (Nat)
(List.length (List.nil)) = (Nat.zero)
(List.length (List.cons head tail)) = (Nat.succ (List.length tail))

// Kind.Coverage.get_inductive (term: (Kind.Term)) : (Maybe U60)
(Kind.Coverage.get_inductive (Kind.Term.ct0 ctid orig)) = (Maybe.some ctid)
(Kind.Coverage.get_inductive (Kind.Term.ct1 ctid orig x0)) = (Maybe.some ctid)
(Kind.Coverage.get_inductive (Kind.Term.ct2 ctid orig x0 x1)) = (Maybe.some ctid)
(Kind.Coverage.get_inductive (Kind.Term.ct3 ctid orig x0 x1 x2)) = (Maybe.some ctid)
(Kind.Coverage.get_inductive (Kind.Term.ct4 ctid orig x0 x1 x2 x3)) = (Maybe.some ctid)
(Kind.Coverage.get_inductive (Kind.Term.ct5 ctid orig x0 x1 x2 x3 x4)) = (Maybe.some ctid)
(Kind.Coverage.get_inductive (Kind.Term.ct6 ctid orig x0 x1 x2 x3 x4 x5)) = (Maybe.some ctid)
(Kind.Coverage.get_inductive (Kind.Term.ct7 ctid orig args)) = (Maybe.some ctid)
(Kind.Coverage.get_inductive (Kind.Term.ct8 ctid orig args)) = (Maybe.some ctid)
(Kind.Coverage.get_inductive other) = (Maybe.none)

// Kind.Coverage.cover_constructor (context: (Kind.Context)) (depth: U60) (clauses: (List (Kind.Rule))) (ty: (Kind.Term)) (body: (_: (Kind.Term)) (Kind.Term)) (constructor: U60) : (Pair U60 (Kind.SplitTree))
(Kind.Coverage.cover_constructor ctx depth clauses ty body constr) = let creator = (Constructor.CreatorOf constr); let type_cons = (Constructor.TypeOf constr); let matches = (Kind.Coverage.match_type ctx depth type_cons ty); (Bool.if matches let new_ty = (Kind.Coverage.specialize_type creator body); let specialized = (Kind.Coverage.specialize clauses constr); (Pair.new constr (Kind.Coverage.cover ctx depth specialized new_ty)) (Pair.new constr (Kind.SplitTree.impossible)))

// Kind.Coverage.is_uncovered.list (split: (List (Pair U60 (Kind.SplitTree)))) : (Bool)
(Kind.Coverage.is_uncovered.list (List.cons pair xs)) = (Bool.or (Kind.Coverage.is_uncovered (Pair.snd pair)) (Kind.Coverage.is_uncovered.list xs))
(Kind.Coverage.is_uncovered.list (List.nil)) = (Bool.false)

// Kind.Coverage.is_uncovered (split: (Kind.SplitTree)) : (Bool)
(Kind.Coverage.is_uncovered (Kind.SplitTree.uncovered)) = (Bool.true)
(Kind.Coverage.is_uncovered (Kind.SplitTree.split list)) = (Kind.Coverage.is_uncovered.list list)
(Kind.Coverage.is_uncovered other) = (Bool.false)

// Kind.Coverage.map_constructor (context: (Kind.Context)) (depth: U60) (clauses: (List (Kind.Rule))) (ty: (Kind.Term)) (body: (_: (Kind.Term)) (Kind.Term)) (constructors: (List U60)) : (List (Pair U60 (Kind.SplitTree)))
(Kind.Coverage.map_constructor ctx dep clauses typ body (List.nil)) = (List.nil)
(Kind.Coverage.map_constructor ctx dep clauses typ body (List.cons constructor xs)) = let res = (Kind.Coverage.cover_constructor ctx dep clauses typ body constructor); (Bool.if (Kind.Coverage.is_uncovered (Pair.snd res)) (List.cons res (List.nil)) let tail = (Kind.Coverage.map_constructor ctx dep clauses typ body xs); (List.cons res tail))

// Kind.Coverage.act (context: (Kind.Context)) (depth: U60) (clauses: (List (Kind.Rule))) (funTy: (Kind.Term)) : (Kind.SplitTree)
(Kind.Coverage.act ctx dep clauses (Kind.Term.all orig_ name typ body)) = (Bool.if (Kind.Coverage.can_intro clauses) let ctx = (Kind.Context.extend ctx name typ (List.nil)); let res = (Kind.Term.eval (body (Kind.Term.var orig_ name dep))); let tree = (Kind.Coverage.cover ctx (+ dep 1) (Kind.Coverage.intro clauses) res); let locate_tree = (Bool.if (U60.equal name 0) @tree tree @tree (Kind.SplitTree.intro tree)); (locate_tree tree) let data_type = (Kind.Coverage.get_inductive typ); (Maybe.match data_type (Impossible "an induction in something that is not inductive is.. strange") @data_type.value let constructors = (Family.ConstructorsOf data_type.value); let res = (Kind.Coverage.map_constructor ctx dep clauses typ body constructors); (Kind.SplitTree.split res)))
(Kind.Coverage.act ctx dep clauses funTy) = (Kind.SplitTree.uncovered)

// Kind.Coverage.specialize (matrix: (List (Kind.Rule))) (constructor: U60) : (List (Kind.Rule))
(Kind.Coverage.specialize (List.nil) constr) = (List.nil)
(Kind.Coverage.specialize (List.cons (Kind.Rule.rhs t1) xs) constr) = (List.cons (Kind.Rule.rhs t1) xs)
(Kind.Coverage.specialize (List.cons (Kind.Rule.lhs (Kind.Term.var orig_ name_ idx_) re) xs) constr) = let creator = (Constructor.CreatorOf constr); let synth = (Kind.Coverage.synth_by_creator creator (Kind.Term.var orig_ name_ idx_)); let res = (Kind.Coverage.possible_match synth constr); (Maybe.match res (Kind.Coverage.specialize xs constr) @res.value (List.cons (Kind.Coverage.append_rule res.value re) (Kind.Coverage.specialize xs constr)))
(Kind.Coverage.specialize (List.cons (Kind.Rule.lhs arg re) xs) constr) = let res = (Kind.Coverage.possible_match arg constr); (Maybe.match res (Kind.Coverage.specialize xs constr) @res.value (List.cons (Kind.Coverage.append_rule res.value re) (Kind.Coverage.specialize xs constr)))

// Kind.Coverage.synth_by_creator (constr_ty: (Kind.Coverage.Creator)) (var: (Kind.Term)) : (Kind.Term)
(Kind.Coverage.synth_by_creator (Kind.Coverage.Creator.cons typ body) var) = (Kind.Coverage.synth_by_creator (body var) var)
(Kind.Coverage.synth_by_creator (Kind.Coverage.Creator.end res) var) = res

// Kind.Coverage.possible_match (term: (Kind.Term)) (constructor: U60) : (Maybe (List (Kind.Term)))
(Kind.Coverage.possible_match (Kind.Term.ct0 ctid orig) const) = (Bool.if (Constructor.Compare ctid const) (Maybe.some (List.nil)) (Maybe.none))
(Kind.Coverage.possible_match (Kind.Term.ct1 ctid orig x0) const) = (Bool.if (Constructor.Compare ctid const) (Maybe.some (List.cons x0 (List.nil))) (Maybe.none))
(Kind.Coverage.possible_match (Kind.Term.ct2 ctid orig x0 x1) const) = (Bool.if (Constructor.Compare ctid const) (Maybe.some (List.cons x0 (List.cons x1 (List.nil)))) (Maybe.none))
(Kind.Coverage.possible_match (Kind.Term.ct3 ctid orig x0 x1 x2) const) = (Bool.if (Constructor.Compare ctid const) (Maybe.some (List.cons x0 (List.cons x1 (List.cons x2 (List.nil))))) (Maybe.none))
(Kind.Coverage.possible_match (Kind.Term.ct4 ctid orig x0 x1 x2 x3) const) = (Bool.if (Constructor.Compare ctid const) (Maybe.some (List.cons x0 (List.cons x1 (List.cons x2 (List.cons x3 (List.nil)))))) (Maybe.none))
(Kind.Coverage.possible_match (Kind.Term.ct5 ctid orig x0 x1 x2 x3 x4) const) = (Bool.if (Constructor.Compare ctid const) (Maybe.some (List.cons x0 (List.cons x1 (List.cons x2 (List.cons x3 (List.cons x4 (List.nil))))))) (Maybe.none))
(Kind.Coverage.possible_match (Kind.Term.ct6 ctid orig x0 x1 x2 x3 x4 x5) const) = (Bool.if (Constructor.Compare ctid const) (Maybe.some (List.cons x0 (List.cons x1 (List.cons x2 (List.cons x3 (List.cons x4 (List.cons x5 (List.nil)))))))) (Maybe.none))
(Kind.Coverage.possible_match (Kind.Term.ct7 ctid orig args) const) = (Bool.if (Constructor.Compare ctid const) (Kind.Coverage.possible_match args const) (Maybe.none))
(Kind.Coverage.possible_match (Kind.Term.ct8 ctid orig args) const) = (Bool.if (Constructor.Compare ctid const) (Kind.Coverage.possible_match args const) (Maybe.none))
(Kind.Coverage.possible_match (Kind.Term.args7 x0 x1 x2 x3 x4 x5 x6) const) = (Maybe.some (List.cons x0 (List.cons x1 (List.cons x2 (List.cons x3 (List.cons x4 (List.cons x5 (List.cons x6 (List.nil)))))))))
(Kind.Coverage.possible_match (Kind.Term.args8 x0 x1 x2 x3 x4 x5 x6 x7) const) = (Maybe.some (List.cons x0 (List.cons x1 (List.cons x2 (List.cons x3 (List.cons x4 (List.cons x5 (List.cons x6 (List.cons x7 (List.nil))))))))))
(Kind.Coverage.possible_match x0_ const) = (Maybe.none)

// Kind.Coverage.append_rule (term: (List (Kind.Term))) (rule: (Kind.Rule)) : (Kind.Rule)
(Kind.Coverage.append_rule (List.nil) rule) = rule
(Kind.Coverage.append_rule (List.cons x xs) rule) = (Kind.Rule.lhs x (Kind.Coverage.append_rule xs rule))

// Kind.Coverage.can_intro (clauses: (List (Kind.Rule))) : (Bool)
(Kind.Coverage.can_intro (List.nil)) = (Bool.true)
(Kind.Coverage.can_intro (List.cons (Kind.Rule.lhs (Kind.Term.var o_ n_ i_) t_) xs)) = (Kind.Coverage.can_intro xs)
(Kind.Coverage.can_intro (List.cons x xs)) = (Bool.false)

// U60.equal (a: U60) (b: U60) : (Bool)
(U60.equal a b) = (U60.to_bool (== a b))

// U60.to_bool (n: U60) : (Bool)
(U60.to_bool 0) = (Bool.false)
(U60.to_bool n) = (Bool.true)

// Pair.snd -(a: Type) -(b: Type) (pair: (Pair a b)) : b
(Pair.snd (Pair.new fst snd)) = snd

// Kind.Coverage.match_type.go (depth: U60) (left: (Kind.Term)) (right: (Kind.Term)) : (Kind.Checker (Bool))
(Kind.Coverage.match_type.go depth (Kind.Term.all orig_ name typ body) right) = (Kind.Coverage.match_type.go (+ depth 1) (Kind.Term.eval (body (Kind.Term.hol orig_ depth))) right)
(Kind.Coverage.match_type.go depth left right) = (Kind.Checker.equal left right)

// Kind.Coverage.match_type (ctx: (Kind.Context)) (depth: U60) (left: (Kind.Term)) (right: (Kind.Term)) : (Bool)
(Kind.Coverage.match_type ctx depth left right) = let checker = (Kind.Coverage.match_type.go depth left right); let res = ((((((checker ctx) depth) (Bool.true)) (Kind.Subst.end)) (List.nil)) (List.nil)); (Kind.Result.match res @res.ctx @res.depth @res.rhs @res.sub @res.equations @res.errors @res.ret res.ret @res.ctx @res.sub @res.errors (Bool.false))

// Kind.Result.match -(a: Type) (x: (Kind.Result a)) -(p: (x: (Kind.Result a)) Type) (checked: (ctx: (Kind.Context)) (depth: U60) (rhs: (Bool)) (sub: (Kind.Subst)) (equations: (List (Kind.Equation))) (errors: (List (Kind.Error))) (ret: a) (p (Kind.Result.checked a ctx depth rhs sub equations errors ret))) (errored: (ctx: (Kind.Context)) (sub: (Kind.Subst)) (errors: (List (Kind.Error))) (p (Kind.Result.errored a ctx sub errors))) : (p x)
(Kind.Result.match (Kind.Result.checked ctx_ depth_ rhs_ sub_ equations_ errors_ ret_) checked errored) = (((((((checked ctx_) depth_) rhs_) sub_) equations_) errors_) ret_)
(Kind.Result.match (Kind.Result.errored ctx_ sub_ errors_) checked errored) = (((errored ctx_) sub_) errors_)

// Kind.Checker.equal (left: (Kind.Term)) (right: (Kind.Term)) : (Kind.Checker (Bool))
(Kind.Checker.equal (Kind.Term.typ orig) (Kind.Term.typ orig1)) = (Kind.Checker.pure (Bool.true))
(Kind.Checker.equal (Kind.Term.all a.orig a.name a.type a.body) (Kind.Term.all b.orig b.name b.type b.body)) = (Kind.Checker.bind (Kind.Checker.get_depth) @dep (Kind.Checker.bind (Kind.Checker.equal a.type b.type) @type (Kind.Checker.bind (Kind.Checker.extended (Kind.Checker.equal (a.body (Kind.Term.var a.orig a.name dep)) (b.body (Kind.Term.var b.orig b.name dep))) (Null) (Null) (List.nil)) @body (Kind.Checker.pure (Bool.and type body)))))
(Kind.Checker.equal (Kind.Term.lam a.orig a.name a.body) (Kind.Term.lam b.orig b.name b.body)) = (Kind.Checker.bind (Kind.Checker.get_depth) @dep (Kind.Checker.bind (Kind.Checker.extended (Kind.Checker.equal (a.body (Kind.Term.var a.orig a.name dep)) (b.body (Kind.Term.var b.orig b.name dep))) (Null) (Null) (List.nil)) @body (Kind.Checker.pure body)))
(Kind.Checker.equal (Kind.Term.app a.orig a.func a.argm) (Kind.Term.app b.orig b.func b.argm)) = (Kind.Checker.bind (Kind.Checker.equal a.func b.func) @func (Kind.Checker.bind (Kind.Checker.equal a.argm b.argm) @argm (Kind.Checker.pure (Bool.and func argm))))
(Kind.Checker.equal (Kind.Term.let a.orig a.name a.expr a.body) (Kind.Term.let b.orig b.name b.expr b.body)) = (Kind.Checker.bind (Kind.Checker.get_depth) @dep (Kind.Checker.bind (Kind.Checker.equal a.expr b.expr) @expr (Kind.Checker.bind (Kind.Checker.extended (Kind.Checker.equal (a.body (Kind.Term.var a.orig a.name dep)) (b.body (Kind.Term.var b.orig b.name dep))) (Null) (Null) (List.nil)) @body (Kind.Checker.pure (Bool.and expr body)))))
(Kind.Checker.equal (Kind.Term.ann a.orig a.expr a.type) (Kind.Term.ann b.orig b.expr b.type)) = (Kind.Checker.bind (Kind.Checker.equal a.expr b.expr) @func (Kind.Checker.bind (Kind.Checker.equal a.type b.type) @type (Kind.Checker.pure (Bool.and func type))))
(Kind.Checker.equal (Kind.Term.sub a.orig a.name a.indx a.redx a.expr) (Kind.Term.sub b.orig b.name b.indx b.redx b.expr)) = (Kind.Checker.bind (Kind.Checker.equal a.expr b.expr) @func (Kind.Checker.pure func))
(Kind.Checker.equal (Kind.Term.u60 a.orig) (Kind.Term.u60 b.orig)) = (Kind.Checker.pure (Bool.true))
(Kind.Checker.equal (Kind.Term.num a.orig a.num) (Kind.Term.num b.orig b.num)) = (Kind.Checker.pure (U60.equal a.num b.num))
(Kind.Checker.equal (Kind.Term.op2 a.orig a.op a.val0 a.val1) (Kind.Term.op2 b.orig b.op b.val0 b.val1)) = let op = (Kind.Operator.equal a.op b.op); (Kind.Checker.bind (Kind.Checker.equal a.val0 b.val0) @val0 (Kind.Checker.bind (Kind.Checker.equal a.val1 b.val1) @val1 (Kind.Checker.pure (Bool.and op (Bool.and val0 val1)))))
(Kind.Checker.equal (Kind.Term.hol a.orig a.numb) (Kind.Term.hol b.orig b.numb)) = (Bool.if (U60.equal a.numb b.numb) (Kind.Checker.pure (Bool.true)) (Kind.Checker.equal.hol a.orig a.numb (Kind.Term.hol b.orig b.numb)))
(Kind.Checker.equal (Kind.Term.hol a.orig a.numb) b) = (Kind.Checker.equal.hol a.orig a.numb b)
(Kind.Checker.equal b (Kind.Term.hol a.orig a.numb)) = (Kind.Checker.equal.hol a.orig a.numb b)
(Kind.Checker.equal (Kind.Term.var a.orig a.name a.idx) b) = (Kind.Checker.bind (Kind.Checker.get_right_hand_side) @rhs (Kind.Checker.equal.var rhs a.orig a.name a.idx b))
(Kind.Checker.equal b (Kind.Term.var a.orig a.name a.idx)) = (Kind.Checker.bind (Kind.Checker.get_right_hand_side) @rhs (Kind.Checker.equal.var rhs a.orig a.name a.idx b))
(Kind.Checker.equal (Kind.Term.ct0 a.ctid a.orig) (Kind.Term.ct0 b.ctid b.orig)) = let ctid = (U60.equal (HashOf a.ctid) (HashOf b.ctid)); (Kind.Checker.pure ctid)
(Kind.Checker.equal (Kind.Term.ct1 a.ctid a.orig a.x0) (Kind.Term.ct1 b.ctid b.orig b.x0)) = let ctid = (U60.equal (HashOf a.ctid) (HashOf b.ctid)); (Kind.Checker.bind (Kind.Checker.equal a.x0 b.x0) @x0 (Kind.Checker.pure (Bool.and ctid x0)))
(Kind.Checker.equal (Kind.Term.ct2 a.ctid a.orig a.x0 a.x1) (Kind.Term.ct2 b.ctid b.orig b.x0 b.x1)) = let ctid = (U60.equal (HashOf a.ctid) (HashOf b.ctid)); (Kind.Checker.bind (Kind.Checker.equal a.x0 b.x0) @x0 (Kind.Checker.bind (Kind.Checker.equal a.x1 b.x1) @x1 (Kind.Checker.pure (Bool.and ctid (Bool.and x0 x1)))))
(Kind.Checker.equal (Kind.Term.ct3 a.ctid a.orig a.x0 a.x1 a.x2) (Kind.Term.ct3 b.ctid b.orig b.x0 b.x1 b.x2)) = let ctid = (U60.equal (HashOf a.ctid) (HashOf b.ctid)); (Kind.Checker.bind (Kind.Checker.equal a.x0 b.x0) @x0 (Kind.Checker.bind (Kind.Checker.equal a.x1 b.x1) @x1 (Kind.Checker.bind (Kind.Checker.equal a.x2 b.x2) @x2 (Kind.Checker.pure (Bool.and ctid (Bool.and x0 (Bool.and x1 x2)))))))
(Kind.Checker.equal (Kind.Term.ct4 a.ctid a.orig a.x0 a.x1 a.x2 a.x3) (Kind.Term.ct4 b.ctid b.orig b.x0 b.x1 b.x2 b.x3)) = let ctid = (U60.equal (HashOf a.ctid) (HashOf b.ctid)); (Kind.Checker.bind (Kind.Checker.equal a.x0 b.x0) @x0 (Kind.Checker.bind (Kind.Checker.equal a.x1 b.x1) @x1 (Kind.Checker.bind (Kind.Checker.equal a.x2 b.x2) @x2 (Kind.Checker.bind (Kind.Checker.equal a.x3 b.x3) @x3 (Kind.Checker.pure (Bool.and ctid (Bool.and x0 (Bool.and x1 (Bool.and x2 x3)))))))))
(Kind.Checker.equal (Kind.Term.ct5 a.ctid a.orig a.x0 a.x1 a.x2 a.x3 a.x4) (Kind.Term.ct5 b.ctid b.orig b.x0 b.x1 b.x2 b.x3 b.x4)) = let ctid = (U60.equal (HashOf a.ctid) (HashOf b.ctid)); (Kind.Checker.bind (Kind.Checker.equal a.x0 b.x0) @x0 (Kind.Checker.bind (Kind.Checker.equal a.x1 b.x1) @x1 (Kind.Checker.bind (Kind.Checker.equal a.x2 b.x2) @x2 (Kind.Checker.bind (Kind.Checker.equal a.x3 b.x3) @x3 (Kind.Checker.bind (Kind.Checker.equal a.x4 b.x4) @x4 (Kind.Checker.pure (Bool.and ctid (Bool.and x0 (Bool.and x1 (Bool.and x2 (Bool.and x3 x4)))))))))))
(Kind.Checker.equal (Kind.Term.ct6 a.ctid a.orig a.x0 a.x1 a.x2 a.x3 a.x4 a.x5) (Kind.Term.ct6 b.ctid b.orig b.x0 b.x1 b.x2 b.x3 b.x4 b.x5)) = let ctid = (U60.equal (HashOf a.ctid) (HashOf b.ctid)); (Kind.Checker.bind (Kind.Checker.equal a.x0 b.x0) @x0 (Kind.Checker.bind (Kind.Checker.equal a.x1 b.x1) @x1 (Kind.Checker.bind (Kind.Checker.equal a.x2 b.x2) @x2 (Kind.Checker.bind (Kind.Checker.equal a.x3 b.x3) @x3 (Kind.Checker.bind (Kind.Checker.equal a.x4 b.x4) @x4 (Kind.Checker.bind (Kind.Checker.equal a.x5 b.x5) @x5 (Kind.Checker.pure (Bool.and ctid (Bool.and x0 (Bool.and x1 (Bool.and x2 (Bool.and x3 (Bool.and x4 x5)))))))))))))
(Kind.Checker.equal (Kind.Term.ct7 a.ctid a.orig a.args) (Kind.Term.ct7 b.ctid b.orig b.args)) = let ctid = (U60.equal (HashOf a.ctid) (HashOf b.ctid)); (Kind.Checker.bind (Kind.Checker.equal a.args b.args) @xargs (Kind.Checker.pure (Bool.and ctid xargs)))
(Kind.Checker.equal (Kind.Term.ct8 a.ctid a.orig a.args) (Kind.Term.ct8 b.ctid b.orig b.args)) = let ctid = (U60.equal (HashOf a.ctid) (HashOf b.ctid)); (Kind.Checker.bind (Kind.Checker.equal a.args b.args) @xargs (Kind.Checker.pure (Bool.and ctid xargs)))
(Kind.Checker.equal (Kind.Term.args7 a.x0 a.x1 a.x2 a.x3 a.x4 a.x5 a.x6) (Kind.Term.args7 b.x0 b.x1 b.x2 b.x3 b.x4 b.x5 b.x6)) = (Kind.Checker.bind (Kind.Checker.equal a.x0 b.x0) @x0 (Kind.Checker.bind (Kind.Checker.equal a.x1 b.x1) @x1 (Kind.Checker.bind (Kind.Checker.equal a.x2 b.x2) @x2 (Kind.Checker.bind (Kind.Checker.equal a.x3 b.x3) @x3 (Kind.Checker.bind (Kind.Checker.equal a.x4 b.x4) @x4 (Kind.Checker.bind (Kind.Checker.equal a.x5 b.x5) @x5 (Kind.Checker.bind (Kind.Checker.equal a.x6 b.x6) @x6 (Kind.Checker.pure (Bool.and x0 (Bool.and x1 (Bool.and x2 (Bool.and x3 (Bool.and x4 (Bool.and x5 x6))))))))))))))
(Kind.Checker.equal (Kind.Term.args8 a.x0 a.x1 a.x2 a.x3 a.x4 a.x5 a.x6 a.x7) (Kind.Term.args8 b.x0 b.x1 b.x2 b.x3 b.x4 b.x5 b.x6 b.x7)) = (Kind.Checker.bind (Kind.Checker.equal a.x0 b.x0) @x0 (Kind.Checker.bind (Kind.Checker.equal a.x1 b.x1) @x1 (Kind.Checker.bind (Kind.Checker.equal a.x2 b.x2) @x2 (Kind.Checker.bind (Kind.Checker.equal a.x3 b.x3) @x3 (Kind.Checker.bind (Kind.Checker.equal a.x4 b.x4) @x4 (Kind.Checker.bind (Kind.Checker.equal a.x5 b.x5) @x5 (Kind.Checker.bind (Kind.Checker.equal a.x6 b.x6) @x6 (Kind.Checker.bind (Kind.Checker.equal a.x7 b.x7) @x7 (Kind.Checker.pure (Bool.and x0 (Bool.and x1 (Bool.and x2 (Bool.and x3 (Bool.and x4 (Bool.and x5 (Bool.and x6 x7))))))))))))))))
(Kind.Checker.equal (Kind.Term.fn0 a.ctid a.orig) (Kind.Term.fn0 b.ctid b.orig)) = let ctid = (U60.equal (HashOf a.ctid) (HashOf b.ctid)); (Kind.Checker.pure ctid)
(Kind.Checker.equal (Kind.Term.fn1 a.ctid a.orig a.x0) (Kind.Term.fn1 b.ctid b.orig b.x0)) = let ctid = (U60.equal (HashOf a.ctid) (HashOf b.ctid)); (Kind.Checker.bind (Kind.Checker.equal a.x0 b.x0) @x0 (Kind.Checker.pure (Bool.and ctid x0)))
(Kind.Checker.equal (Kind.Term.fn2 a.ctid a.orig a.x0 a.x1) (Kind.Term.fn2 b.ctid b.orig b.x0 b.x1)) = let ctid = (U60.equal (HashOf a.ctid) (HashOf b.ctid)); (Kind.Checker.bind (Kind.Checker.equal a.x0 b.x0) @x0 (Kind.Checker.bind (Kind.Checker.equal a.x1 b.x1) @x1 (Kind.Checker.pure (Bool.and ctid (Bool.and x0 x1)))))
(Kind.Checker.equal (Kind.Term.fn3 a.ctid a.orig a.x0 a.x1 a.x2) (Kind.Term.fn3 b.ctid b.orig b.x0 b.x1 b.x2)) = let ctid = (U60.equal (HashOf a.ctid) (HashOf b.ctid)); (Kind.Checker.bind (Kind.Checker.equal a.x0 b.x0) @x0 (Kind.Checker.bind (Kind.Checker.equal a.x1 b.x1) @x1 (Kind.Checker.bind (Kind.Checker.equal a.x2 b.x2) @x2 (Kind.Checker.pure (Bool.and ctid (Bool.and x0 (Bool.and x1 x2)))))))
(Kind.Checker.equal (Kind.Term.fn4 a.ctid a.orig a.x0 a.x1 a.x2 a.x3) (Kind.Term.fn4 b.ctid b.orig b.x0 b.x1 b.x2 b.x3)) = let ctid = (U60.equal (HashOf a.ctid) (HashOf b.ctid)); (Kind.Checker.bind (Kind.Checker.equal a.x0 b.x0) @x0 (Kind.Checker.bind (Kind.Checker.equal a.x1 b.x1) @x1 (Kind.Checker.bind (Kind.Checker.equal a.x2 b.x2) @x2 (Kind.Checker.bind (Kind.Checker.equal a.x3 b.x3) @x3 (Kind.Checker.pure (Bool.and ctid (Bool.and x0 (Bool.and x1 (Bool.and x2 x3)))))))))
(Kind.Checker.equal (Kind.Term.fn5 a.ctid a.orig a.x0 a.x1 a.x2 a.x3 a.x4) (Kind.Term.fn5 b.ctid b.orig b.x0 b.x1 b.x2 b.x3 b.x4)) = let ctid = (U60.equal (HashOf a.ctid) (HashOf b.ctid)); (Kind.Checker.bind (Kind.Checker.equal a.x0 b.x0) @x0 (Kind.Checker.bind (Kind.Checker.equal a.x1 b.x1) @x1 (Kind.Checker.bind (Kind.Checker.equal a.x2 b.x2) @x2 (Kind.Checker.bind (Kind.Checker.equal a.x3 b.x3) @x3 (Kind.Checker.bind (Kind.Checker.equal a.x4 b.x4) @x4 (Kind.Checker.pure (Bool.and ctid (Bool.and x0 (Bool.and x1 (Bool.and x2 (Bool.and x3 x4)))))))))))
(Kind.Checker.equal (Kind.Term.fn6 a.ctid a.orig a.x0 a.x1 a.x2 a.x3 a.x4 a.x5) (Kind.Term.fn6 b.ctid b.orig b.x0 b.x1 b.x2 b.x3 b.x4 b.x5)) = let ctid = (U60.equal (HashOf a.ctid) (HashOf b.ctid)); (Kind.Checker.bind (Kind.Checker.equal a.x0 b.x0) @x0 (Kind.Checker.bind (Kind.Checker.equal a.x1 b.x1) @x1 (Kind.Checker.bind (Kind.Checker.equal a.x2 b.x2) @x2 (Kind.Checker.bind (Kind.Checker.equal a.x3 b.x3) @x3 (Kind.Checker.bind (Kind.Checker.equal a.x4 b.x4) @x4 (Kind.Checker.bind (Kind.Checker.equal a.x5 b.x5) @x5 (Kind.Checker.pure (Bool.and ctid (Bool.and x0 (Bool.and x1 (Bool.and x2 (Bool.and x3 (Bool.and x4 x5)))))))))))))
(Kind.Checker.equal (Kind.Term.fn7 a.ctid a.orig a.args) (Kind.Term.fn7 b.ctid b.orig b.args)) = let ctid = (U60.equal (HashOf a.ctid) (HashOf b.ctid)); (Kind.Checker.bind (Kind.Checker.equal a.args b.args) @xargs (Kind.Checker.pure (Bool.and ctid xargs)))
(Kind.Checker.equal (Kind.Term.fn8 a.ctid a.orig a.args) (Kind.Term.fn8 b.ctid b.orig b.args)) = let ctid = (U60.equal (HashOf a.ctid) (HashOf b.ctid)); (Kind.Checker.bind (Kind.Checker.equal a.args b.args) @xargs (Kind.Checker.pure (Bool.and ctid xargs)))
(Kind.Checker.equal a b) = (Kind.Checker.bind (Kind.Checker.get_subst) @sub (Bool.if (Bool.or (Kind.Term.fillable a sub) (Kind.Term.fillable b sub)) (Kind.Checker.equal (Kind.Term.fill a sub) (Kind.Term.fill b sub)) (Kind.Checker.pure (Bool.false))))

// Kind.Checker.equal.var (rhs: (Bool)) (orig: U60) (name: U60) (idx: U60) (b: (Kind.Term)) : (Kind.Checker (Bool))
(Kind.Checker.equal.var (Bool.false) orig name idx b) = (Kind.Checker.bind (Kind.Checker.add_value idx b) @_ (Kind.Checker.pure (Bool.true)))
(Kind.Checker.equal.var (Bool.true) a.orig a.name a.idx (Kind.Term.var b.orig b.name b.idx)) = (Bool.if (U60.equal a.idx b.idx) (Kind.Checker.pure (Bool.true)) (Kind.Checker.bind (Kind.Checker.find a.idx (List.nil) @n @t @v v) @a.val (Kind.Checker.bind (Kind.Checker.find b.idx (List.nil) @n @t @v v) @b.val (Kind.Checker.bind (Kind.Checker.equal.var.try_values a.val (Kind.Term.var b.orig b.name b.idx)) @a.chk (Kind.Checker.bind (Kind.Checker.equal.var.try_values b.val (Kind.Term.var a.orig a.name a.idx)) @b.chk (Kind.Checker.pure (Bool.or a.chk b.chk)))))))
(Kind.Checker.equal.var (Bool.true) a.orig a.name a.idx b) = (Kind.Checker.bind (Kind.Checker.get_subst) @sub (Bool.if (Kind.Term.fillable b sub) (Kind.Checker.equal (Kind.Term.var a.orig a.name a.idx) (Kind.Term.fill b sub)) (Kind.Checker.bind (Kind.Checker.find a.idx (List.nil) @n @t @v v) @a.val (Kind.Checker.bind (Kind.Checker.equal.var.try_values a.val b) @res (Kind.Checker.pure res)))))

// Kind.Checker.equal.var.try_values (ls: (List (Kind.Term))) (term: (Kind.Term)) : (Kind.Checker (Bool))
(Kind.Checker.equal.var.try_values (List.nil) term) = (Kind.Checker.pure (Bool.false))
(Kind.Checker.equal.var.try_values (List.cons x xs) term) = (Kind.Checker.bind (Kind.Checker.equal x term) @head (Bool.if head (Kind.Checker.pure (Bool.true)) (Kind.Checker.equal.var.try_values xs term)))

// Kind.Checker.equal.hol (orig: U60) (numb: U60) (b: (Kind.Term)) : (Kind.Checker (Bool))
(Kind.Checker.equal.hol a.orig a.numb b) = (Kind.Checker.bind (Kind.Checker.look a.numb) @got (Kind.Checker.bind (Kind.Checker.equal.hol.val got a.orig a.numb b) @res (Kind.Checker.pure res)))

// Kind.Checker.equal.hol.val (val: (Maybe (Kind.Term))) (orig: U60) (numb: U60) (b: (Kind.Term)) : (Kind.Checker (Bool))
(Kind.Checker.equal.hol.val (Maybe.none) orig numb b) = (Kind.Checker.bind (Kind.Checker.fill numb b) @_ (Kind.Checker.pure (Bool.true)))
(Kind.Checker.equal.hol.val (Maybe.some val) orig numb b) = (Kind.Checker.equal val b)

// Kind.Checker.pure -(t: Type) (a: t) : (Kind.Checker t)
(Kind.Checker.pure res) = @context @depth @rhs @subst @eqts @errs (Kind.Result.checked context depth rhs subst eqts errs res)

// Kind.Checker (a: Type) : Type
(Kind.Checker a) = 0

// Kind.Checker.get_subst : (Kind.Checker (Kind.Subst))
(Kind.Checker.get_subst) = @context @depth @rhs @subst @eqts @errs (Kind.Result.checked context depth rhs subst eqts errs subst)

// Kind.Operator.equal (left: (Kind.Operator)) (right: (Kind.Operator)) : (Bool)
(Kind.Operator.equal (Kind.Operator.and) (Kind.Operator.and)) = (Bool.true)
(Kind.Operator.equal (Kind.Operator.sub) (Kind.Operator.sub)) = (Bool.true)
(Kind.Operator.equal (Kind.Operator.mul) (Kind.Operator.mul)) = (Bool.true)
(Kind.Operator.equal (Kind.Operator.div) (Kind.Operator.div)) = (Bool.true)
(Kind.Operator.equal (Kind.Operator.mod) (Kind.Operator.mod)) = (Bool.true)
(Kind.Operator.equal (Kind.Operator.and) (Kind.Operator.and)) = (Bool.true)
(Kind.Operator.equal (Kind.Operator.or) (Kind.Operator.or)) = (Bool.true)
(Kind.Operator.equal (Kind.Operator.xor) (Kind.Operator.xor)) = (Bool.true)
(Kind.Operator.equal (Kind.Operator.shl) (Kind.Operator.shl)) = (Bool.true)
(Kind.Operator.equal (Kind.Operator.shr) (Kind.Operator.shr)) = (Bool.true)
(Kind.Operator.equal (Kind.Operator.ltn) (Kind.Operator.ltn)) = (Bool.true)
(Kind.Operator.equal (Kind.Operator.lte) (Kind.Operator.lte)) = (Bool.true)
(Kind.Operator.equal (Kind.Operator.eql) (Kind.Operator.eql)) = (Bool.true)
(Kind.Operator.equal (Kind.Operator.gte) (Kind.Operator.gte)) = (Bool.true)
(Kind.Operator.equal (Kind.Operator.gtn) (Kind.Operator.gtn)) = (Bool.true)
(Kind.Operator.equal (Kind.Operator.neq) (Kind.Operator.neq)) = (Bool.true)
(Kind.Operator.equal a b) = (Bool.false)

// Kind.Checker.add_value (idx: U60) (val: (Kind.Term)) : (Kind.Checker (Unit))
(Kind.Checker.add_value idx val) = @context @depth @rhs @subst @eqts @errs (Kind.Result.checked (Kind.Context.add_value context idx val) depth rhs subst eqts errs (Unit.new))

// Kind.Context.add_value (prev: (Kind.Context)) (name: U60) (term: (Kind.Term)) : (Kind.Context)
(Kind.Context.add_value (Kind.Context.entry name type vals rest) 0 val) = (Kind.Context.entry name type (List.cons val vals) rest)
(Kind.Context.add_value (Kind.Context.entry name type vals rest) n val) = (Kind.Context.entry name type vals (Kind.Context.add_value rest (- n 1) val))
(Kind.Context.add_value (Kind.Context.empty) n val) = (Kind.Context.empty)

// Kind.Checker.bind.result -(a: Type) -(b: Type) (result: (Kind.Result a)) (then: (_: a) (Kind.Checker b)) : (Kind.Result b)
(Kind.Checker.bind.result (Kind.Result.checked context depth rhs sub equations errs ret) then) = (((((((then ret) context) depth) rhs) sub) equations) errs)
(Kind.Checker.bind.result (Kind.Result.errored context sub errs) then) = (Kind.Result.errored context sub errs)

// Kind.Checker.bind -(a: Type) -(b: Type) (checker: (Kind.Checker a)) (then: (_: a) (Kind.Checker b)) : (Kind.Checker b)
(Kind.Checker.bind checker then) = @context @depth @rhs @subst @eqts @errs (Kind.Checker.bind.result ((((((checker context) depth) rhs) subst) eqts) errs) then)

// Kind.Checker.get_right_hand_side : (Kind.Checker (Bool))
(Kind.Checker.get_right_hand_side) = @context @depth @rhs @subst @eqts @errs (Kind.Result.checked context depth rhs subst eqts errs rhs)

// Kind.Checker.extended -(a: Type) (checker: (Kind.Checker a)) (name: U60) (type: (Kind.Term)) (vals: (List (Kind.Term))) : (Kind.Checker a)
(Kind.Checker.extended checker name type vals) = (Kind.Checker.bind (Kind.Checker.extend name type vals) @_ (Kind.Checker.bind checker @got (Kind.Checker.bind (Kind.Checker.shrink) @_ (Kind.Checker.pure got))))

// Kind.Checker.extend (name: U60) (type: (Kind.Term)) (vals: (List (Kind.Term))) : (Kind.Checker (Unit))
(Kind.Checker.extend name type vals) = @context @depth @rhs @subst @eqts @errs (Kind.Result.checked (Kind.Context.extend context name type vals) (+ depth 1) rhs subst eqts errs (Unit.new))

// Kind.Context.extend (prev: (Kind.Context)) (name: U60) (term: (Kind.Term)) (ls: (List (Kind.Term))) : (Kind.Context)
(Kind.Context.extend (Kind.Context.empty) name type values) = (Kind.Context.entry name type values (Kind.Context.empty))
(Kind.Context.extend (Kind.Context.entry n t v rest) name type values) = (Kind.Context.entry n t v (Kind.Context.extend rest name type values))

// Kind.Checker.shrink : (Kind.Checker (Unit))
(Kind.Checker.shrink) = @context @depth @rhs @subst @eqts @errs (Kind.Result.checked (Kind.Context.shrink context) (- depth 1) rhs subst eqts errs (Unit.new))

// Kind.Context.shrink (ctx: (Kind.Context)) : (Kind.Context)
(Kind.Context.shrink (Kind.Context.empty)) = (Kind.Context.empty)
(Kind.Context.shrink (Kind.Context.entry name type vals (Kind.Context.empty))) = (Kind.Context.empty)
(Kind.Context.shrink (Kind.Context.entry name type vals rest)) = (Kind.Context.entry name type vals (Kind.Context.shrink rest))

// Kind.Term.fillable (term: (Kind.Term)) (sub: (Kind.Subst)) : (Bool)
(Kind.Term.fillable term (Kind.Subst.end)) = (Bool.false)
(Kind.Term.fillable (Kind.Term.typ orig) sub) = (Bool.false)
(Kind.Term.fillable (Kind.Term.var orig name index) sub) = (Bool.false)
(Kind.Term.fillable (Kind.Term.hlp orig) sub) = (Bool.false)
(Kind.Term.fillable (Kind.Term.u60 orig) sub) = (Bool.false)
(Kind.Term.fillable (Kind.Term.num orig num) sub) = (Bool.false)
(Kind.Term.fillable (Kind.Term.all orig name typ body) sub) = (Bool.or (Kind.Term.fillable typ sub) (Kind.Term.fillable (body (Kind.Term.hlp 0)) sub))
(Kind.Term.fillable (Kind.Term.lam orig name body) sub) = (Kind.Term.fillable (body (Kind.Term.hlp 0)) sub)
(Kind.Term.fillable (Kind.Term.app orig expr typ) sub) = (Bool.or (Kind.Term.fillable expr sub) (Kind.Term.fillable typ sub))
(Kind.Term.fillable (Kind.Term.let orig name expr body) sub) = (Bool.or (Kind.Term.fillable expr sub) (Kind.Term.fillable (body (Kind.Term.hlp 0)) sub))
(Kind.Term.fillable (Kind.Term.ann orig expr typ) sub) = (Bool.or (Kind.Term.fillable expr sub) (Kind.Term.fillable typ sub))
(Kind.Term.fillable (Kind.Term.sub orig name indx redx expr) sub) = (Kind.Term.fillable expr sub)
(Kind.Term.fillable (Kind.Term.op2 orig op left right) sub) = (Bool.or (Kind.Term.fillable left sub) (Kind.Term.fillable right sub))
(Kind.Term.fillable (Kind.Term.hol orig numb) sub) = (Maybe.is_some (Kind.Subst.look sub numb))
(Kind.Term.fillable (Kind.Term.ct0 ctid orig) sub) = (Bool.false)
(Kind.Term.fillable (Kind.Term.ct1 ctid orig x0) sub) = (Kind.Term.fillable x0 sub)
(Kind.Term.fillable (Kind.Term.ct2 ctid orig x0 x1) sub) = (Bool.or (Kind.Term.fillable x0 sub) (Kind.Term.fillable x1 sub))
(Kind.Term.fillable (Kind.Term.ct3 ctid orig x0 x1 x2) sub) = (Bool.or (Kind.Term.fillable x0 sub) (Bool.or (Kind.Term.fillable x1 sub) (Kind.Term.fillable x2 sub)))
(Kind.Term.fillable (Kind.Term.ct4 ctid orig x0 x1 x2 x3) sub) = (Bool.or (Kind.Term.fillable x0 sub) (Bool.or (Kind.Term.fillable x1 sub) (Bool.or (Kind.Term.fillable x2 sub) (Kind.Term.fillable x3 sub))))
(Kind.Term.fillable (Kind.Term.ct5 ctid orig x0 x1 x2 x3 x4) sub) = (Bool.or (Kind.Term.fillable x0 sub) (Bool.or (Kind.Term.fillable x1 sub) (Bool.or (Kind.Term.fillable x2 sub) (Bool.or (Kind.Term.fillable x3 sub) (Kind.Term.fillable x4 sub)))))
(Kind.Term.fillable (Kind.Term.ct6 ctid orig x0 x1 x2 x3 x4 x5) sub) = (Bool.or (Kind.Term.fillable x0 sub) (Bool.or (Kind.Term.fillable x1 sub) (Bool.or (Kind.Term.fillable x2 sub) (Bool.or (Kind.Term.fillable x3 sub) (Bool.or (Kind.Term.fillable x4 sub) (Kind.Term.fillable x5 sub))))))
(Kind.Term.fillable (Kind.Term.ct7 fnid orig args) sub) = (Kind.Term.fillable args sub)
(Kind.Term.fillable (Kind.Term.ct8 fnid orig args) sub) = (Kind.Term.fillable args sub)
(Kind.Term.fillable (Kind.Term.fn0 fnid orig) sub) = (Bool.false)
(Kind.Term.fillable (Kind.Term.fn1 fnid orig x0) sub) = (Kind.Term.fillable x0 sub)
(Kind.Term.fillable (Kind.Term.fn2 fnid orig x0 x1) sub) = (Bool.or (Kind.Term.fillable x0 sub) (Kind.Term.fillable x1 sub))
(Kind.Term.fillable (Kind.Term.fn3 fnid orig x0 x1 x2) sub) = (Bool.or (Kind.Term.fillable x0 sub) (Bool.or (Kind.Term.fillable x1 sub) (Kind.Term.fillable x2 sub)))
(Kind.Term.fillable (Kind.Term.fn4 fnid orig x0 x1 x2 x3) sub) = (Bool.or (Kind.Term.fillable x0 sub) (Bool.or (Kind.Term.fillable x1 sub) (Bool.or (Kind.Term.fillable x2 sub) (Kind.Term.fillable x3 sub))))
(Kind.Term.fillable (Kind.Term.fn5 fnid orig x0 x1 x2 x3 x4) sub) = (Bool.or (Kind.Term.fillable x0 sub) (Bool.or (Kind.Term.fillable x1 sub) (Bool.or (Kind.Term.fillable x2 sub) (Bool.or (Kind.Term.fillable x3 sub) (Kind.Term.fillable x4 sub)))))
(Kind.Term.fillable (Kind.Term.fn6 fnid orig x0 x1 x2 x3 x4 x5) sub) = (Bool.or (Kind.Term.fillable x0 sub) (Bool.or (Kind.Term.fillable x1 sub) (Bool.or (Kind.Term.fillable x2 sub) (Bool.or (Kind.Term.fillable x3 sub) (Bool.or (Kind.Term.fillable x4 sub) (Kind.Term.fillable x5 sub))))))
(Kind.Term.fillable (Kind.Term.fn7 fnid orig args) sub) = (Kind.Term.fillable args sub)
(Kind.Term.fillable (Kind.Term.fn8 fnid orig args) sub) = (Kind.Term.fillable args sub)
(Kind.Term.fillable (Kind.Term.args7 x0 x1 x2 x3 x4 x5 x6) sub) = (Bool.or (Kind.Term.fillable x0 sub) (Bool.or (Kind.Term.fillable x1 sub) (Bool.or (Kind.Term.fillable x2 sub) (Bool.or (Kind.Term.fillable x3 sub) (Bool.or (Kind.Term.fillable x4 sub) (Bool.or (Kind.Term.fillable x5 sub) (Kind.Term.fillable x6 sub)))))))
(Kind.Term.fillable (Kind.Term.args8 x0 x1 x2 x3 x4 x5 x6 x7) sub) = (Bool.or (Kind.Term.fillable x0 sub) (Bool.or (Kind.Term.fillable x1 sub) (Bool.or (Kind.Term.fillable x2 sub) (Bool.or (Kind.Term.fillable x3 sub) (Bool.or (Kind.Term.fillable x4 sub) (Bool.or (Kind.Term.fillable x5 sub) (Bool.or (Kind.Term.fillable x6 sub) (Kind.Term.fillable x7 sub))))))))

// Maybe.is_some -(a: Type) (m: (Maybe a)) : (Bool)
(Maybe.is_some (Maybe.none)) = (Bool.false)
(Maybe.is_some (Maybe.some v)) = (Bool.true)

// Bool.or (a: (Bool)) (b: (Bool)) : (Bool)
(Bool.or (Bool.true) b) = (Bool.true)
(Bool.or (Bool.false) b) = b

// Bool.and (a: (Bool)) (b: (Bool)) : (Bool)
(Bool.and (Bool.true) b) = b
(Bool.and (Bool.false) b) = (Bool.false)

// Kind.Checker.find -(r: Type) (index: U60) (alt: r) (fun: (_: U60) (_: (Kind.Term)) (_: (List (Kind.Term))) r) : (Kind.Checker r)
(Kind.Checker.find index alt fun) = @context @depth @rhs @subst @eqts @errs (Kind.Result.checked context depth rhs subst eqts errs (Kind.Context.find context index alt fun))

// Kind.Context.find -(res: Type) (ctx: (Kind.Context)) (name: U60) (alt: res) (fun: (_: U60) (_: (Kind.Term)) (_: (List (Kind.Term))) res) : res
(Kind.Context.find (Kind.Context.entry name type vals rest) 0 alt fun) = (((fun name) type) vals)
(Kind.Context.find (Kind.Context.entry name type vals rest) n alt fun) = (Kind.Context.find rest (- n 1) alt fun)
(Kind.Context.find (Kind.Context.empty) n alt fun) = alt

// Kind.Checker.get_depth : (Kind.Checker U60)
(Kind.Checker.get_depth) = @context @depth @rhs @subst @eqts @errs (Kind.Result.checked context depth rhs subst eqts errs depth)

// Kind.Checker.fill (index: U60) (val: (Kind.Term)) : (Kind.Checker (Unit))
(Kind.Checker.fill index val) = @context @depth @rhs @subst @eqts @errs (Kind.Result.checked context depth rhs (Kind.Subst.fill subst index val) eqts errs (Unit.new))

// Kind.Subst.fill (subst: (Kind.Subst)) (depth: U60) (term: (Kind.Term)) : (Kind.Subst)
(Kind.Subst.fill (Kind.Subst.end) 0 term) = (Kind.Subst.sub term (Kind.Subst.end))
(Kind.Subst.fill (Kind.Subst.unfilled rest) 0 term) = (Kind.Subst.sub term rest)
(Kind.Subst.fill (Kind.Subst.sub lost rest) 0 term) = (Kind.Subst.sub term rest)
(Kind.Subst.fill (Kind.Subst.end) n term) = (Kind.Subst.unfilled (Kind.Subst.fill (Kind.Subst.end) (- n 1) term))
(Kind.Subst.fill (Kind.Subst.unfilled rest) n term) = (Kind.Subst.unfilled (Kind.Subst.fill rest (- n 1) term))
(Kind.Subst.fill (Kind.Subst.sub keep rest) n term) = (Kind.Subst.sub keep (Kind.Subst.fill rest (- n 1) term))

// Kind.Checker.look (index: U60) : (Kind.Checker (Maybe (Kind.Term)))
(Kind.Checker.look index) = @context @depth @rhs @subst @eqts @errs (Kind.Result.checked context depth rhs subst eqts errs (Kind.Subst.look subst index))

// Kind.Coverage.specialize_type (constr_ty: (Kind.Coverage.Creator)) (goal_ty: (_: (Kind.Term)) (Kind.Term)) : (Kind.Term)
(Kind.Coverage.specialize_type (Kind.Coverage.Creator.cons typ body) goal_ty) = (Kind.Term.all 0 0 typ @arg (Kind.Coverage.specialize_type (body arg) goal_ty))
(Kind.Coverage.specialize_type (Kind.Coverage.Creator.end res) goal_ty) = (goal_ty res)

// Kind.Coverage.intro (clauses: (List (Kind.Rule))) : (List (Kind.Rule))
(Kind.Coverage.intro (List.nil)) = (List.nil)
(Kind.Coverage.intro (List.cons (Kind.Rule.lhs x r) xs)) = (List.cons r (Kind.Coverage.intro xs))
(Kind.Coverage.intro (List.cons x xs)) = (Impossible "bad intro lol")

// Kind.Coverage.catch_all (clauses: (List (Kind.Rule))) : (Bool)
(Kind.Coverage.catch_all (List.cons (Kind.Rule.lhs (Kind.Term.var orig_ name_ idx_) rule) xs)) = (Kind.Coverage.catch_all (List.cons rule xs))
(Kind.Coverage.catch_all (List.nil)) = (Bool.false)
(Kind.Coverage.catch_all (List.cons (Kind.Rule.rhs rule) xs)) = (Bool.true)
(Kind.Coverage.catch_all (List.cons x xs)) = (Kind.Coverage.catch_all xs)

// Kind.SplitTree.show.list (last: (Bool)) (ident: (String)) (list: (List (Pair U60 (Kind.SplitTree)))) : (List (String))
(Kind.SplitTree.show.list last ident (List.nil)) = (List.nil)
(Kind.SplitTree.show.list last ident (List.cons x (List.nil))) = (List.cons (Kind.SplitTree.show.go (Bool.true) (String.join "" (List.cons ident (List.cons (Constructor.NameOf (Pair.fst x)) (List.cons " => " (List.nil))))) (Pair.snd x)) (List.nil))
(Kind.SplitTree.show.list last ident (List.cons x xs)) = (List.cons (Kind.SplitTree.show.go (Bool.false) (String.join "" (List.cons ident (List.cons (Constructor.NameOf (Pair.fst x)) (List.cons " => " (List.nil))))) (Pair.snd x)) (Kind.SplitTree.show.list last ident xs))

// Kind.SplitTree.show.go (last: (Bool)) (ident: (String)) (tree: (Kind.SplitTree)) : (String)
(Kind.SplitTree.show.go last ident (Kind.SplitTree.split split)) = (String.join "" (List.cons ident (List.cons "Split" (List.cons (String.cons 10 "") (List.cons (String.join "" (Kind.SplitTree.show.list last ident split)) (List.nil))))))
(Kind.SplitTree.show.go last ident (Kind.SplitTree.intro s)) = (String.join "" (List.cons ident (List.cons "Intro" (List.cons (String.cons 10 "") (List.cons (Kind.SplitTree.show.go last ident s) (List.nil))))))
(Kind.SplitTree.show.go last ident (Kind.SplitTree.done)) = (String.join "" (List.cons ident (List.cons "done" (List.cons (String.cons 10 "") (List.nil)))))
(Kind.SplitTree.show.go last ident (Kind.SplitTree.impossible)) = (String.join "" (List.cons ident (List.cons "impossible" (List.cons (String.cons 10 "") (List.nil)))))
(Kind.SplitTree.show.go last ident (Kind.SplitTree.uncovered)) = (String.join "" (List.cons ident (List.cons "uncovered" (List.cons (String.cons 10 "") (List.nil)))))

// Kind.SplitTree.show (tree: (Kind.SplitTree)) : (String)
(Kind.SplitTree.show tree) = (Kind.SplitTree.show.go (Bool.true) "" tree)

// Pair.fst -(a: Type) -(b: Type) (pair: (Pair a b)) : a
(Pair.fst (Pair.new fst snd)) = fst

// Kind.Split.complete_matcher (creator: (Kind.Coverage.Creator)) : (Kind.Term)
(Kind.Split.complete_matcher (Kind.Coverage.Creator.cons x xs)) = (Kind.Split.complete_matcher (xs (Kind.Term.hol 0 0)))
(Kind.Split.complete_matcher (Kind.Coverage.Creator.end term)) = term

// Kind.SplitTree.to_errors.go (split: (Kind.SplitTree)) : (List (List (Kind.Term)))
(Kind.SplitTree.to_errors.go (Kind.SplitTree.split list)) = (Kind.SplitTree.to_errors.list.go list)
(Kind.SplitTree.to_errors.go (Kind.SplitTree.intro s)) = (List.map (Kind.SplitTree.to_errors.go s) @xs (List.cons (Kind.Term.hol 0 0) xs))
(Kind.SplitTree.to_errors.go (Kind.SplitTree.done)) = (List.nil)
(Kind.SplitTree.to_errors.go (Kind.SplitTree.impossible)) = (List.nil)
(Kind.SplitTree.to_errors.go (Kind.SplitTree.uncovered)) = (List.cons (List.nil) (List.nil))

// Kind.SplitTree.to_errors.list.go (split: (List (Pair U60 (Kind.SplitTree)))) : (List (List (Kind.Term)))
(Kind.SplitTree.to_errors.list.go (List.nil)) = (List.nil)
(Kind.SplitTree.to_errors.list.go (List.cons x xs)) = let terms = (Kind.SplitTree.to_errors.go (Pair.snd x)); let matcher = (Kind.Split.complete_matcher (Constructor.CreatorOf (Pair.fst x))); let head = (List.map terms @xs (List.cons matcher xs)); let tail = (Kind.SplitTree.to_errors.list.go xs); (List.concat head tail)

// Kind.SplitTree.to_errors (orig_: U60) (fnid: U60) (split: (Kind.SplitTree)) : (List (Kind.Error))
(Kind.SplitTree.to_errors orig_ fnid (Kind.SplitTree.split list)) = (List.map (Kind.SplitTree.to_errors.list.go list) @x (Kind.Error.uncovered orig_ fnid x))
(Kind.SplitTree.to_errors orig_ fnid (Kind.SplitTree.intro s)) = (List.map (Kind.SplitTree.to_errors.go (Kind.SplitTree.intro s)) @x (Kind.Error.uncovered orig_ fnid x))
(Kind.SplitTree.to_errors orig_ fnid (Kind.SplitTree.done)) = (List.nil)
(Kind.SplitTree.to_errors orig_ fnid (Kind.SplitTree.impossible)) = (List.nil)
(Kind.SplitTree.to_errors orig_ fnid (Kind.SplitTree.uncovered)) = (List.nil)

// List.concat -(a: Type) (xs: (List a)) (ys: (List a)) : (List a)
(List.concat (List.nil) ys) = ys
(List.concat (List.cons head tail) ys) = (List.cons head (List.concat tail ys))

