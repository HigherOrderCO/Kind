// Types
// =====

// A Formality Letter is a character in: [A-Za-z0-9._]
Fm.Letter: Type
  Char

// A Formality Name is a string of letters
Fm.Name: Type
  String

// A Formality term (high-order)
type Fm.Term {
  // A variable bound by another constructor
  var(
    name: Fm.Name, // the variable name, used for pretty printing
    indx: Nat, // the variable bruijn level, used for equality and binding
  ),
  // A reference to a top-level definition
  ref(
    name: Fm.Name, // the reference name
  ),
  // The type of types
  typ,
  // The self-dependent function type (self-Pi)
  all(
    eras: Bool, // if it is erased at runtime
    self: Fm.Name, // the term name
    name: Fm.Name, // the input name
    xtyp: Fm.Term, // the input type
    body: Fm.Term -> Fm.Term -> Fm.Term, // the returned type
  ),
  // An anonymous function (lambda)
  lam(
    name: Fm.Name, // the input name
    body: Fm.Term -> Fm.Term, // the returned body
  ),
  // A function application
  app(
    func: Fm.Term, // the function
    argm: Fm.Term, // the argument
  ),
  // A local definition
  let(
    name: Fm.Name, // the expression name
    expr: Fm.Term, // the expression value
    body: Fm.Term -> Fm.Term, // the body where name=value
  ),
  // A local alias
  def(
    name: Fm.Name, // the expression name
    expr: Fm.Term, // the expression value
    body: Fm.Term -> Fm.Term, // the body where name=value
  ),
  // An inline annotation
  ann(
    done: Bool, // was this type-checked?
    term: Fm.Term, // the annotated term
    type: Fm.Term, // the annotated type
  ),
  // A hole to show the goal
  gol(
    name: Fm.Name, // the goal's name
    dref: List(Bits), // a list of labels to expand when displaying it
    verb: Bool, // show labels of expandable terms?
  ),
  // A hole to be auto-filled
  hol(
    path: Bits,
  ),
  // A natural number
  nat(
    natx: Nat,
  ),
  // A character
  chr(
    chrx: Char,
  ),
  // A string
  str(
    strx: String,
  ),
  // A case-of expression
  cse(
    path: Bits,
    expr: Fm.Term,
    name: Fm.Name,
    with: List(Fm.Def),
    cses: Map(Fm.Term),
    moti: Maybe(Fm.Term),
  ),
  // An origin
  ori(
    orig: Fm.Origin,
    expr: Fm.Term,
  )
}

type Fm.Origin {
  new(
    file: String,
    from: Nat,
    upto: Nat,
  )
}

// A primitive type (
type Fm.Prim {
  bool,
  nat,
  u16,
  string,
  data(ctrs: List(Nat)),
  //bits,
}

// A compilable term intermediate format
type Fm.Comp {
  nil,
  var(name: Fm.Name),
  ref(name: Fm.Name),
  lam(name: Fm.Name, body: Fm.Comp),
  app(func: Fm.Comp, argm: Fm.Comp),
  let(name: Fm.Name, expr: Fm.Comp, body: Fm.Comp),
  eli(prim: Fm.Prim, expr: Fm.Comp),
  ins(prim: Fm.Prim, expr: Fm.Comp),
  nat(natx: Nat),
  chr(chrx: Char),
  str(strx: String),
}

// A constructor
type Fm.Constructor {
  new(
    name: Fm.Name,
    args: List(Fm.Binder),
    inds: List(Fm.Binder),
  )
}

// An algebraic datatype
type Fm.Datatype {
  new(
    name: Fm.Name,
    pars: List(Fm.Binder),
    inds: List(Fm.Binder),
    ctrs: List(Fm.Constructor),
  )
}

// A type error
type Fm.Error {
  // Two types do not match
  type_mismatch(
    origin: Maybe(Fm.Origin),
    expected: Either(String, Fm.Term),
    detected: Either(String, Fm.Term),
    context: Fm.Context,
  ),
  // Found a goal to be shown
  show_goal(
    name: Fm.Name,
    dref: List(Bits),
    verb: Bool,
    goal: Maybe(Fm.Term),
    context: Fm.Context,
  ),
  // Waits for another term's type checking
  waiting(
    name: Fm.Name,
  ),
  // Error in a dependency
  indirect(
    name: Fm.Name,
  ),
  // Patch the original term
  patch(
    path: Bits,
    term: Fm.Term,
  ),
  // Some reference isn't found
  undefined_reference(
    origin: Maybe(Fm.Origin),
    name: Fm.Name,
  ),
  // A lambda without a type
  cant_infer(
    origin: Maybe(Fm.Origin),
    term: Fm.Term,
    context: Fm.Context,
  ),
}

// The result of a type-checking attempt
type Fm.Check<V: Type> {
  result(
    value: Maybe(V), // the returned value
    errors: List(Fm.Error), // a list of errors
  ),
}

// Status of a type-checking process
type Fm.Status {
  init,
  wait,
  done,
  fail(errors: List(Fm.Error)),
}

// A top-level definition
type Fm.Def {
  new(
    file: String,
    code: String,
    name: Fm.Name,
    term: Fm.Term,
    type: Fm.Term,
    stat: Fm.Status,
  ),
}

type Fm.Binder {
  new(
    eras: Bool,
    name: Fm.Name,
    term: Fm.Term,
  )
}

// A map from Names to definitions
Fm.Defs: Type
  Map(Fm.Def)

// A context is a list of (name, term) pairs
Fm.Context: Type
  List(Pair(Fm.Name,Fm.Term))

// A path
Fm.Path: Type
  Bits -> Bits

// Maybe a path
Fm.MPath: Type
  Maybe(Fm.Path)

// Paths
// =====

Fm.Path.to_bits(path: Fm.Path): Bits
  path(Bits.e)

Fm.Path.nil: Fm.Path
  (x) x

Fm.Path.o(path: Fm.Path): Fm.Path
  (x) path(Bits.o(x))

Fm.Path.i(path: Fm.Path): Fm.Path
  (x) path(Bits.i(x))

Fm.MPath.to_bits(path: Maybe(Fm.Path)): Bits
  case path {
    none: Bits.e,
    some: path.value(Bits.e),
  }

Fm.MPath.nil: Maybe(Fm.Path)
  Maybe.some<_>(Fm.Path.nil)

Fm.MPath.o(path: Maybe(Fm.Path)): Maybe(Fm.Path)
  Maybe.mapped<_>(path)<_>(Fm.Path.o)

Fm.MPath.i(path: Maybe(Fm.Path)): Maybe(Fm.Path)
  Maybe.mapped<_>(path)<_>(Fm.Path.i)

// Contexts
// ========

// Gets a core term from a map by its name
Fm.get<A: Type>(name: Fm.Name, map: Map(A)): Maybe(A)
  Map.get<A>(Fm.Name.to_bits(name), map)

// Adds a name, core term pair to a map
Fm.set<A: Type>(name: Fm.Name, val: A, map: Map(A)): Map(A)
  Map.set<A>(Fm.Name.to_bits(name), val, map)

// Finds a value in a context
Fm.Context.find(name: Fm.Name, ctx: Fm.Context): Maybe(Fm.Term)
  case ctx {
    nil:
      Maybe.none<_>,
    cons:
      case ctx.head {
        new:
          if Fm.Name.eql(name, ctx.head.fst) then
            Maybe.some<_>(ctx.head.snd)
          else
            Fm.Context.find(name, ctx.tail)
      }
  }

// Gets the names of a context
Fm.Context.names(ctx: Fm.Context): List(Fm.Name)
  List.mapped<_>(ctx)<_>((x) Pair.fst<_,_>(x))

// Stringification
// ===============

Fm.Error.origin(error: Fm.Error): Maybe(Fm.Origin)
  case error {
    type_mismatch: error.origin,
    waiting: Maybe.none<_>,
    indirect: Maybe.none<_>,
    show_goal: Maybe.none<_>,
    patch: Maybe.none<_>,
    undefined_reference: error.origin,
    cant_infer: error.origin,
  }

// Stringifies an error
Fm.Error.show(error: Fm.Error, defs: Fm.Defs): String
  case error {
    type_mismatch: 
      let expected = case error.expected {
        left: error.expected.value,
        right: Fm.Term.show(Fm.Term.normalize(error.expected.value, Map.new<_>)),
      };
      let detected = case error.detected {
        left: error.detected.value,
        right: Fm.Term.show(Fm.Term.normalize(error.detected.value, Map.new<_>)),
      };
      String.flatten([
        "Type mismatch.\n",
        "- Expected: ", expected, "\n",
        "- Detected: ", detected, "\n",
        case error.context {
          nil : "",
          cons: String.flatten(["With context:\n", Fm.Context.show(error.context)]),
        },
      ]),
    waiting:
      String.flatten([
        "Waiting for '", error.name, "'."
      ]),
    indirect:
      String.flatten([
        "Error on dependency '", error.name, "'."
      ]),
    show_goal:
      let goal_name = String.flatten(["Goal ?", Fm.Name.show(error.name), ":\n"]);
      let with_type = case error.goal {
        none: "",
        some: 
          let goal = Fm.Term.expand(error.dref, error.goal.value, defs);
          String.flatten([
            "With type: ",
            if error.verb then
              Fm.Term.show.go(goal, Maybe.some<Bits -> Bits>((x) x))
            else
              Fm.Term.show(goal),
            "\n",
          ]),
      };
      let with_ctxt = case error.context {
        nil: "",
        cons: String.flatten([
          "With ctxt:\n",
          Fm.Context.show(error.context),
        ]),
      };
      String.flatten([goal_name, with_type, with_ctxt]),
    patch:
      String.flatten([
        "Patching: ", Fm.Term.show(error.term),
      ]),
    undefined_reference: 
      String.flatten([
        "Undefined reference: ", Fm.Name.show(error.name), "\n",
      ]),
    cant_infer:
      let term = Fm.Term.show(error.term);
      let context = Fm.Context.show(error.context);
      String.flatten([
        "Can't infer type of: ", term, "\n",
        "With ctxt:\n", context,
      ])
  }

// Return the first type error, plus all hole errors.
Fm.Error.relevant(errors: List(Fm.Error), got: Bool): List(Fm.Error)
  case errors {
    nil:
      List.nil<Fm.Error>,
    cons:
      let keep = case errors.head {
        type_mismatch: Bool.not(got),
        show_goal: Bool.true,
        waiting: Bool.false,
        indirect: Bool.false,
        patch: Bool.false,
        undefined_reference: Bool.not(got),
        cant_infer: Bool.not(got),
      };
      let got = case errors.head {
        type_mismatch: Bool.true,
        show_goal: got,
        waiting: got,
        indirect: got,
        patch: got,
        undefined_reference: Bool.true,
        cant_infer: got,
      };
      let tail = Fm.Error.relevant(errors.tail, got);
      if keep then
        List.cons<_>(errors.head, tail)
      else
        tail
  }

// Stringifies a context
Fm.Context.show(context: Fm.Context): String
  case context {
    nil: "",
    cons: case context.head {
      new:
        let name = Fm.Name.show(context.head.fst);
        let type = Fm.Term.show(context.head.snd);
        let rest = Fm.Context.show(context.tail);
        String.flatten([
          rest,
          "- ",
          name,
          ": ",
          type,
          "\n",
        ])
    }
  }

// Attempts to view a term as a Nat literal
Fm.Term.show.as_nat.go(term: Fm.Term): Maybe(Nat)
  case term {
    app: case term.func {
      ref: 
        if String.eql(term.func.name, "Nat.succ") then do Maybe {
          var pred = Fm.Term.show.as_nat.go(term.argm);
          return Nat.succ(pred);
        } else
          Maybe.none<_>,
      _: Maybe.none<_>,
    },
    ref:
      if String.eql(term.name, "Nat.zero") then
        Maybe.some<_>(0)
      else
        Maybe.none<_>,
    _: Maybe.none<_>,
  }

Fm.Term.show.as_nat(term: Fm.Term): Maybe(String)
  Maybe.mapped<_>(Fm.Term.show.as_nat.go(term))<_>(Nat.show)

Fm.color(col: String, str: String): String
  String.cons(Nat.to_u16(27),
  String.cons('[',
  String.concat(col,
  String.cons('m', 
  String.concat(str,
  String.cons(Nat.to_u16(27),
  String.cons('[',
  String.cons('0',
  String.cons('m', 
  String.nil)))))))))

Fm.Term.show.is_ref(term: Fm.Term, name: Fm.Name): Bool
  case term {
    ref: String.eql(name, term.name),
    _: Bool.false,
  }

Fm.Term.show.app(term: Fm.Term, path: Maybe(Bits -> Bits), args: List(String)): String
  case term {
    app:
      let argm = Fm.Term.show.go(term.argm, Fm.MPath.i(path));
      Fm.Term.show.app(term.func, Fm.MPath.o(path), List.cons<_>(argm, args)),
    _:
      let arity = List.length<_>(args);
      if Bool.and(Fm.Term.show.is_ref(term,"Equal"), Nat.eql(arity,3)) then
        let func = Fm.Term.show.go(term, path);
        let eq_lft = Maybe.default<_>("?", List.at<_>(1, args));
        let eq_rgt = Maybe.default<_>("?", List.at<_>(2, args));
        String.flatten([eq_lft, " == ", eq_rgt])
      else
        let func = Fm.Term.show.go(term, path);
        let wrap = case func {nil: Bool.false, cons: U16.eql(func.head,'(')};
        let args = String.join(",", args);
        let func = if wrap then String.flatten(["(",func,")"]) else func;
        String.flatten([func, "(", args, ")"]),
  }

// SHOW: Stringifies a term
Fm.Term.show.go(term: Fm.Term, path: Maybe(Bits -> Bits)): String
  case Fm.Term.show.as_nat(term) as as_nat {
    some: as_nat.value,
    none: case term {
      ref:
        let name = Fm.Name.show(term.name);
        case path {
          none:
            name,
            //String.flatten(["$", name]),
          some: 
            let path_val = Bits.concat(Fm.Path.to_bits(path.value), Bits.i(Bits.e));
            let path_str = Nat.show(Bits.to_nat(path_val));
            String.flatten([name, Fm.color("2", String.concat("-", path_str))]),
        },
      var:
        Fm.Name.show(term.name),
        //String.flatten([Fm.Name.show(term.name), "#", Nat.show(term.indx)]),
      typ:
        "Type",
      all:
        let eras = term.eras;
        let self = Fm.Name.show(term.self);
        let name = Fm.Name.show(term.name);
        let type = Fm.Term.show.go(term.xtyp, Fm.MPath.o(path));
        let open = if eras then "<" else "(";
        let clos = if eras then ">" else ")";
        let body = Fm.Term.show.go(
          term.body(
            Fm.Term.var(term.self, 0),
            Fm.Term.var(term.name, 0)),
          Fm.MPath.i(path));
        String.flatten([self,open,name,":",type,clos," ",body]),
      lam:
        let name = Fm.Name.show(term.name);
        let body = Fm.Term.show.go(
          term.body(Fm.Term.var(term.name, 0)),
          Fm.MPath.o(path));
        String.flatten(["(",name,") ",body]),
      app: Fm.Term.show.app(term, path, List.nil<_>),
      let:
        let name = Fm.Name.show(term.name);
        let expr = Fm.Term.show.go(term.expr, Fm.MPath.o(path));
        let body = Fm.Term.show.go(
          term.body(Fm.Term.var(term.name, 0)),
          Fm.MPath.i(path));
        String.flatten(["let ", name, " = ", expr, "; ", body]),
      def:
        let name = Fm.Name.show(term.name);
        let expr = Fm.Term.show.go(term.expr, Fm.MPath.o(path));
        let body = Fm.Term.show.go(
          term.body(Fm.Term.var(term.name, 0)),
          Fm.MPath.i(path));
        String.flatten(["def ", name, " = ", expr, "; ", body]),
      ann:
        let term = Fm.Term.show.go(term.term, Fm.MPath.o(path));
        let type = Fm.Term.show.go(term.type, Fm.MPath.i(path));
        String.flatten([term,"::",type]),
      gol:
        let name = Fm.Name.show(term.name);
        String.flatten(["?", name]),
      hol:
        "_",
      nat:
        String.flatten([Nat.show(term.natx)]),
      chr:
        String.flatten(["'", Fm.escape.char(term.chrx), "'"]),
      str:
        String.flatten(["\"", Fm.escape(term.strx), "\""]),
      cse:
        let expr = Fm.Term.show.go(term.expr, Fm.MPath.o(path));
        let name = Fm.Name.show(term.name);
        let wyth = String.join("", List.mapped<_>(term.with)<_>((defn)
          case defn {
            new:
              let name = Fm.Name.show(defn.name);
              let type = Fm.Term.show.go(defn.type, Maybe.none<_>);
              let term = Fm.Term.show.go(defn.term, Maybe.none<_>);
              String.flatten([name, ": ", type, " = " term, ";"])
          }));
        let cses = Map.to_list<_>(term.cses);
        let cses = String.join("", List.mapped<_>(cses)<_>((x)
          let name = Fm.Name.from_bits(Pair.fst<_,_>(x));
          let term = Fm.Term.show.go(Pair.snd<_,_>(x), Maybe.none<_>);
          String.flatten([name, ": ", term, "; "])));
        let moti = case term.moti {
          none: "",
          some: String.flatten([": ", Fm.Term.show.go(term.moti.value, Maybe.none<_>)]),
        };
        String.flatten(["case ",expr," as ",name,wyth," { ",cses,"}",moti]),
      ori:
        Fm.Term.show.go(term.expr, path),
    }
  }


Fm.Term.show(term: Fm.Term): String
  Fm.Term.show.go(term, Maybe.none<_>)

// Stringifies a defs
Fm.Defs.show(defs: Fm.Defs): String
  let str = "";
  for name_defn in Map.to_list<Fm.Def>(defs) with str:
    case name_defn {
      new: case name_defn.snd as defn {
        new: String.flatten([
          str,
          Fm.Name.show(defn.name),
          ": ",
          Fm.Term.show(defn.type),
          "\n  ",
          Fm.Term.show(defn.term),
          "\n",
        ])
      }
    }

// Reduction
// =========

// BIND: Binds named variables to their lambdas
Fm.Term.bind(vars: Fm.Context, path: Fm.Path, term: Fm.Term): Fm.Term 
  case term {
    ref: case Fm.Context.find(term.name, vars) as got {
      none: Fm.Term.ref(term.name),
      some: got.value,
    },
    var: case List.at_last<_>(term.indx, vars) as got {
      none: Fm.Term.var(term.name, term.indx),
      some: Pair.snd<_,_>(got.value),
    },
    typ: Fm.Term.typ,
    all: 
      let vlen = List.length<_>(vars);
      def xtyp = Fm.Term.bind(vars, Fm.Path.o(path), term.xtyp);
      def body = (s,x) Fm.Term.bind(
        List.cons<_>({term.name,x},
          List.cons<_>({term.self,s},
          vars)),
        Fm.Path.i(path),
        term.body(
          Fm.Term.var(term.self, vlen),
          Fm.Term.var(term.name, Nat.succ(vlen))));
      Fm.Term.all(term.eras, term.self, term.name, xtyp, body),
    lam:
      let vlen = List.length<_>(vars);
      def body = (x) Fm.Term.bind(
        List.cons<_>({term.name,x},vars),
        Fm.Path.o(path),
        term.body(Fm.Term.var(term.name, vlen)));
      Fm.Term.lam(term.name, body),
    app:
      def func = Fm.Term.bind(vars, Fm.Path.o(path), term.func);
      def argm = Fm.Term.bind(vars, Fm.Path.i(path), term.argm);
      Fm.Term.app(func, argm),
    let:
      let vlen = List.length<_>(vars);
      def expr = Fm.Term.bind(vars, Fm.Path.o(path), term.expr);
      def body = (x) Fm.Term.bind(
        List.cons<_>({term.name,x}, vars),
        Fm.Path.i(path),
        term.body(Fm.Term.var(term.name, vlen)));
      Fm.Term.let(term.name, expr, body),
    def:
      let vlen = List.length<_>(vars);
      def expr = Fm.Term.bind(vars, Fm.Path.o(path), term.expr);
      def body = (x) Fm.Term.bind(
        List.cons<_>({term.name,x}, vars),
        Fm.Path.i(path),
        term.body(Fm.Term.var(term.name, vlen)));
      Fm.Term.def(term.name, expr, body),
    ann:
      def term = Fm.Term.bind(vars, Fm.Path.o(path), term.term);
      def type = Fm.Term.bind(vars, Fm.Path.i(path), term.type);
      Fm.Term.ann(term.done, term, type),
    gol:
      Fm.Term.gol(term.name, term.dref, term.verb),
    hol:
      Fm.Term.hol(Fm.Path.to_bits(path)),
    nat:
      Fm.Term.nat(term.natx),
    chr:
      Fm.Term.chr(term.chrx),
    str:
      Fm.Term.str(term.strx),
    cse:
      let expr = Fm.Term.bind(vars, Fm.Path.o(path), term.expr);
      let name = term.name; // TODO
      let wyth = term.with; // TODO
      let cses = term.cses; // TODO
      let moti = term.moti; // TODO
      Fm.Term.cse(Fm.Path.to_bits(path), expr, name, wyth, cses, moti),
    ori:
      Fm.Term.ori(term.orig, Fm.Term.bind(vars, path, term.expr)),
  }

// REDUCE: Reduces a high order term to weak head normal form
Fm.Term.reduce(term: Fm.Term, defs: Fm.Defs): Fm.Term
  case term {
    ref: case Fm.get<_>(term.name, defs) as got {
      none: Fm.Term.ref(term.name),
      some: case got.value { new: Fm.Term.reduce(got.value.term, defs) },
    },
    app:
      let func = Fm.Term.reduce(term.func, defs);
      case func {
        lam: Fm.Term.reduce(func.body(term.argm), defs),
        _: term,
      },
    let:
      Fm.Term.reduce(term.body(term.expr), defs),
    def:
      Fm.Term.reduce(term.body(term.expr), defs),
    ann:
      Fm.Term.reduce(term.term, defs),
    nat:
      Fm.Term.reduce(Fm.Term.unroll_nat(term.natx), defs),
    chr:
      Fm.Term.reduce(Fm.Term.unroll_chr(term.chrx), defs),
    str:
      Fm.Term.reduce(Fm.Term.unroll_str(term.strx), defs),
    ori:
      Fm.Term.reduce(term.expr, defs),
    _: term,
  }

// NORMALIZE: Normalizes a high order term
Fm.Term.normalize(term: Fm.Term, defs: Fm.Defs): Fm.Term
  case Fm.Term.reduce(term, defs) as term {
    ref:
      Fm.Term.ref(term.name),
    var:
      Fm.Term.var(term.name, term.indx),
    typ:
      Fm.Term.typ,
    all: 
      def xtyp = Fm.Term.normalize(term.xtyp, defs);
      def body = (s,x) Fm.Term.normalize(term.body(s,x), defs);
      Fm.Term.all(term.eras, term.self, term.name, xtyp, body),
    lam:
      def body = (x) Fm.Term.normalize(term.body(x), defs);
      Fm.Term.lam(term.name, body),
    app:
      def func = Fm.Term.normalize(term.func, defs);
      def argm = Fm.Term.normalize(term.argm, defs);
      Fm.Term.app(func, argm),
    let:
      def expr = Fm.Term.normalize(term.expr, defs);
      def body = (x) Fm.Term.normalize(term.body(x), defs);
      Fm.Term.let(term.name, expr, body),
    def:
      def expr = Fm.Term.normalize(term.expr, defs);
      def body = (x) Fm.Term.normalize(term.body(x), defs);
      Fm.Term.def(term.name, expr, body),
    ann:
      def term = Fm.Term.normalize(term.term, defs);
      def type = Fm.Term.normalize(term.type, defs);
      Fm.Term.ann(term.done, term, type),
    gol:
      Fm.Term.gol(term.name, term.dref, term.verb),
    hol:
      Fm.Term.hol(term.path),
    nat:
      Fm.Term.nat(term.natx),
    chr:
      Fm.Term.chr(term.chrx),
    str:
      Fm.Term.str(term.strx),
    cse:
      term,
    ori:
      Fm.Term.normalize(term.expr, defs),
  }

//Fm.Term.clean(term: Fm.Term, defs: Fm.Defs): Fm.Term
  //case term {
    //ref:
      //Fm.Term.ref(term.name),
    //var:
      //Fm.Term.var(term.name, term.indx),
    //typ:
      //Fm.Term.typ,
    //all: 
      //def xtyp = Fm.Term.clean(term.xtyp, defs);
      //def body = (s,x) Fm.Term.clean(term.body(s,x), defs);
      //Fm.Term.all(term.eras, term.self, term.name, xtyp, body),
    //lam:
      //def body = (x) Fm.Term.clean(term.body(x), defs);
      //Fm.Term.lam(term.name, body),
    //app:
      //def func = Fm.Term.clean(term.func, defs);
      //def argm = Fm.Term.clean(term.argm, defs);
      //Fm.Term.app(func, argm),
    //let:
      //def expr = Fm.Term.clean(term.expr, defs);
      //def body = (x) Fm.Term.clean(term.body(x), defs);
      //Fm.Term.let(term.name, expr, body),
    //def:
      //def expr = Fm.Term.clean(term.expr, defs);
      //def body = (x) Fm.Term.clean(term.body(x), defs);
      //Fm.Term.def(term.name, expr, body),
    //ann:
      //def term = Fm.Term.clean(term.term, defs);
      //def type = Fm.Term.clean(term.type, defs);
      //Fm.Term.ann(term.done, term, type),
    //gol:
      //Fm.Term.gol(term.name, term.dref, term.verb),
    //hol:
      //Fm.Term.hol(term.path),
    //nat:
      //Fm.Term.nat(term.natx),
    //chr:
      //Fm.Term.chr(term.chrx),
    //str:
      //Fm.Term.str(term.strx),
    //cse:
      //term,
    //ori:
      //Fm.Term.clean(term.expr, defs),
  //}

// Patching
// ========

Fm.define(
  file: String,
  code: String,
  name: Fm.Name,
  term: Fm.Term,
  type: Fm.Term,
  done: Bool,
  defs: Fm.Defs,
): Fm.Defs
  //let skip = Debug.log<_>(String.flatten(["define: ", name]), (x) Unit.new);
  let stat = if done then Fm.Status.done else Fm.Status.init;
  Fm.set<_>(name, Fm.Def.new(file, code, name, term, type, stat), defs)
  
// PATCH_AT Does something at a specific path
Fm.Term.patch_at(path: Bits, term: Fm.Term, fn: Fm.Term -> Fm.Term): Fm.Term
  case term {
    all: case path {
      e: fn(term),
      o: Fm.Term.all(term.eras, term.self, term.name, Fm.Term.patch_at(path.pred,term.xtyp,fn), term.body),
      i: Fm.Term.all(term.eras, term.self, term.name, term.xtyp, (s,x) Fm.Term.patch_at(path.pred,term.body(s,x),fn)),
    },
    lam: case path {
      e: fn(term),
      o: Fm.Term.lam(term.name, (x) Fm.Term.patch_at(Bits.tail(path), term.body(x), fn)),
      i: Fm.Term.lam(term.name, (x) Fm.Term.patch_at(Bits.tail(path), term.body(x), fn)),
    },
    app: case path {
      e: fn(term),
      o: Fm.Term.app(Fm.Term.patch_at(path.pred,term.func,fn), term.argm),
      i: Fm.Term.app(term.func, Fm.Term.patch_at(path.pred,term.argm,fn)),
    },
    let: case path {
      e: fn(term),
      o: Fm.Term.let(term.name, Fm.Term.patch_at(path.pred,term.expr,fn), term.body),
      i: Fm.Term.let(term.name, term.expr, (x) Fm.Term.patch_at(path.pred,term.body(x),fn)),
    },
    def: case path {
      e: fn(term),
      o: Fm.Term.def(term.name, Fm.Term.patch_at(path.pred,term.expr,fn), term.body),
      i: Fm.Term.def(term.name, term.expr, (x) Fm.Term.patch_at(path.pred,term.body(x),fn)),
    },
    ann: case path {
      e: fn(term),
      o: Fm.Term.ann(term.done, Fm.Term.patch_at(path,term.term,fn), term.type),
      i: Fm.Term.ann(term.done, Fm.Term.patch_at(path,term.term,fn), term.type),
    },
    ori: Fm.Term.patch_at(path, term.expr, fn),
    _: case path {
      e: fn(term),
      o: term,
      i: term,
    },
  }

// Expands the ref at given path
Fm.Term.expand_at(path: Bits, term: Fm.Term, defs: Fm.Defs): Fm.Term
  Fm.Term.patch_at(path, term, (term) case term {
    ref: case Fm.get<_>(term.name, defs) as got {
      none: Fm.Term.ref(term.name),
      some: case got.value { new: got.value.term },
    },
    _: term,
  })

// Expands constructor applications for better pretty printing
Fm.Term.expand_ct(term: Fm.Term, defs: Fm.Defs, arity: Nat): Fm.Term
  case term {
    ref: // TODO: support constructors generally, not hardcodedly
      let expand = Bool.false;
      let expand = Bool.or(Bool.and(String.eql(term.name, "Nat.succ"), Nat.gtn(arity, 1)), expand);
      let expand = Bool.or(Bool.and(String.eql(term.name, "Nat.zero"), Nat.gtn(arity, 0)), expand);
      let expand = Bool.or(Bool.and(String.eql(term.name, "Bool.true"), Nat.gtn(arity, 0)), expand);
      let expand = Bool.or(Bool.and(String.eql(term.name, "Bool.false"), Nat.gtn(arity, 0)), expand);
      if expand then
        case Fm.get<_>(term.name, defs) as got {
          none: Fm.Term.ref(term.name),
          some: case got.value { new: got.value.term },
        }
      else
        Fm.Term.ref(term.name),
    var:
      Fm.Term.var(term.name, term.indx),
    typ:
      Fm.Term.typ,
    all: 
      def xtyp = Fm.Term.expand_ct(term.xtyp, defs, 0);
      def body = (s,x) Fm.Term.expand_ct(term.body(s,x), defs, 0);
      Fm.Term.all(term.eras, term.self, term.name, xtyp, body),
    lam:
      def body = (x) Fm.Term.expand_ct(term.body(x), defs, 0);
      Fm.Term.lam(term.name, body),
    app:
      def func = Fm.Term.expand_ct(term.func, defs, Nat.succ(arity));
      def argm = Fm.Term.expand_ct(term.argm, defs, 0);
      Fm.Term.app(func, argm),
    let:
      def expr = Fm.Term.expand_ct(term.expr, defs, 0);
      def body = (x) Fm.Term.expand_ct(term.body(x), defs, 0);
      Fm.Term.let(term.name, expr, body),
    def:
      def expr = Fm.Term.expand_ct(term.expr, defs, 0);
      def body = (x) Fm.Term.expand_ct(term.body(x), defs, 0);
      Fm.Term.def(term.name, expr, body),
    ann:
      def term = Fm.Term.expand_ct(term.term, defs, 0);
      def type = Fm.Term.expand_ct(term.type, defs, 0);
      Fm.Term.ann(term.done, term, type),
    gol:
      Fm.Term.gol(term.name, term.dref, term.verb),
    hol:
      Fm.Term.hol(term.path),
    nat:
      Fm.Term.nat(term.natx),
    chr:
      Fm.Term.chr(term.chrx),
    str:
      Fm.Term.str(term.strx),
    cse:
      term,
    ori:
      def expr = Fm.Term.expand_ct(term.expr, defs, 0);
      Fm.Term.ori(term.orig, term.expr),
  }

// Expands a term for pretty printing
Fm.Term.expand(dref: List(Bits), term: Fm.Term, defs: Fm.Defs): Fm.Term
  let term = Fm.Term.normalize(term, Map.new<_>);
  for path in dref with term:
    let term = Fm.Term.expand_at(path, term, defs);
    let term = Fm.Term.normalize(term, Map.new<_>);
    let term = Fm.Term.expand_ct(term, defs, 0);
    let term = Fm.Term.normalize(term, Map.new<_>);
    term

// Equality
// ========

Fm.Term.serialize.name(name: String): Bits
  Fm.Name.to_bits(name)

// Helper function
Fm.Term.serialize(term: Fm.Term, depth: Nat, init: Nat, x: Bits): Bits
  case term {
    ref:
      let name = Bits.concat(Fm.Term.serialize.name(term.name));
      Bits.o(Bits.o(Bits.o(name(x)))),
    var:
      if Nat.gte(term.indx, init) then
        let name = Bits.concat(Nat.to_bits(Nat.pred(Nat.sub(depth,term.indx))));
        Bits.o(Bits.o(Bits.i(name(x))))
      else
        let name = Bits.concat(Nat.to_bits(term.indx));
        Bits.o(Bits.i(Bits.o(name(x)))),
    typ:
      Bits.o(Bits.i(Bits.i(x))),
    all:
      let eras = if term.eras then Bits.i else Bits.o
      let self = Bits.concat(Fm.Name.to_bits(term.self));
      let xtyp = Fm.Term.serialize(term.xtyp, depth, init);
      let body = Fm.Term.serialize(
        term.body(
          Fm.Term.var(term.self, depth),
          Fm.Term.var(term.name, Nat.succ(depth))),
        Nat.succ(Nat.succ(depth)),
        init);
      Bits.i(Bits.o(Bits.o(eras(self(xtyp(body(x))))))),
    lam:
      let body = Fm.Term.serialize(
        term.body(Fm.Term.var(term.name, depth)),
        Nat.succ(depth),
        init);
      Bits.i(Bits.o(Bits.i(body(x)))),
    app:
      let func = Fm.Term.serialize(term.func, depth, init);
      let argm = Fm.Term.serialize(term.argm, depth, init);
      Bits.i(Bits.i(Bits.o(func(argm(x))))),
    let:
      let expr = Fm.Term.serialize(term.expr, depth, init);
      let body = Fm.Term.serialize(
        term.body(Fm.Term.var(term.name, depth)),
        Nat.succ(depth),
        init);
      Bits.i(Bits.i(Bits.i(expr(body(x))))),
    def:
      Fm.Term.serialize(term.body(term.expr), depth, init, x),
    ann:
      Fm.Term.serialize(term.term, depth, init, x),
    gol:
      let name = Bits.concat(Fm.Name.to_bits(term.name));
      Bits.o(Bits.o(Bits.o(name(x)))),
    hol:
      x,
    nat:
      Fm.Term.serialize(Fm.Term.unroll_nat(term.natx), depth, init, x),
    chr:
      Fm.Term.serialize(Fm.Term.unroll_chr(term.chrx), depth, init, x),
    str:
      Fm.Term.serialize(Fm.Term.unroll_str(term.strx), depth, init, x),
    cse:
      x,
    ori:
      Fm.Term.serialize(term.expr, depth, init, x),
  }

// Determines if two terms are identical
Fm.Term.identical(a: Fm.Term, b: Fm.Term, lv: Nat): Bool
  let ah = Fm.Term.serialize(a, lv, lv, Bits.e);
  let bh = Fm.Term.serialize(b, lv, lv, Bits.e);
  Bits.eql(ah, bh)

// Helper function
Fm.Term.equal.patch<A: Type>(path: Bits, term: Fm.Term, ret: A): Fm.Check(A)
  Fm.Check.result<_>(Maybe.some<_>(ret), [Fm.Error.patch(path, Fm.Term.normalize(term, Map.new<_>))])

// Fills some extra holes that aren't captured by the Equal function. For
// example, `Sigma(A, B) == Sigma(_, _)` won't fill these holes since it will
// fall on the seen (recursive) case. Since, at that point, we assume both sides
// are equal, then we can unify the respective holes.
Fm.Term.equal.extra_holes(
  a: Fm.Term,
  b: Fm.Term,
): Fm.Check(Unit)
  case a {
    app: case b {
      app: do Fm.Check {
        Fm.Term.equal.extra_holes(a.func, b.func);
        Fm.Term.equal.extra_holes(a.argm, b.argm);
      },
      ori: Fm.Term.equal.extra_holes(a, b.expr),
      hol: Fm.Term.equal.patch<_>(b.path, a, Unit.new), 
      _: do Fm.Check { return Unit.new; },
    },
    ori: Fm.Term.equal.extra_holes(a.expr, b),
    hol: Fm.Term.equal.patch<_>(a.path, b, Unit.new),
    _: case b {
      ori: Fm.Term.equal.extra_holes(a, b.expr),
      hol: Fm.Term.equal.patch<_>(b.path, a, Unit.new), 
      _: do Fm.Check { return Unit.new; },
    }
  }

// EQUAL: Determines if two terms are equal
Fm.Term.equal(a: Fm.Term, b: Fm.Term, defs: Fm.Defs, lv: Nat, seen: Set): Fm.Check(Bool)
  let ah = Fm.Term.serialize(Fm.Term.reduce(a,Map.new<_>), lv, lv, Bits.e);
  let bh = Fm.Term.serialize(Fm.Term.reduce(b,Map.new<_>), lv, lv, Bits.e);
  if Bits.eql(ah, bh) then do Fm.Check {
    return Bool.true;
  } else do Fm.Check {
    let a1 = Fm.Term.reduce(a, defs);
    let b1 = Fm.Term.reduce(b, defs);
    let ah = Fm.Term.serialize(a1, lv, lv, Bits.e);
    let bh = Fm.Term.serialize(b1, lv, lv, Bits.e);
    if Bits.eql(ah, bh) then do Fm.Check {
      return Bool.true;
    } else do Fm.Check {
      let id = Bits.concat(ah, bh);
      if Set.has(id, seen) then do Fm.Check {
        Fm.Term.equal.extra_holes(a, b);
        return Bool.true;
      } else case a1 {
        all: case b1 {
          all: do Fm.Check {
            let seen = Set.set(id, seen);
            let a1_body = a1.body(
              Fm.Term.var(a1.self, lv),
              Fm.Term.var(a1.name, Nat.succ(lv)));
            let b1_body = b1.body(
              Fm.Term.var(b1.self, lv),
              Fm.Term.var(b1.name, Nat.succ(lv)));
            let eq_self = String.eql(a1.self, b1.self);
            let eq_eras = Bool.eql(a1.eras, b1.eras);
            if Bool.and(eq_self, eq_eras) then do Fm.Check {
              var eq_type = Fm.Term.equal(a1.xtyp, b1.xtyp, defs, lv, seen);
              var eq_body = Fm.Term.equal(a1_body, b1_body, defs, Nat.succ(Nat.succ(lv)), seen);
              return Bool.and(eq_type, eq_body);
            } else do Fm.Check {
              return Bool.false;
            };
          },
          hol:
            Fm.Term.equal.patch<_>(b1.path, a, Bool.true),
          _: do Fm.Check {
            return Bool.false;
          },
        },
        lam: case b1 {
          lam: do Fm.Check {
              let seen = Set.set(id, seen);
              let a1_body = a1.body(Fm.Term.var(a1.name, lv));
              let b1_body = b1.body(Fm.Term.var(b1.name, lv));
              var eq_body = Fm.Term.equal(a1_body, b1_body, defs, Nat.succ(lv), seen);
              return eq_body;
            },
            hol: Fm.Term.equal.patch<_>(b1.path, a, Bool.true),
            _: do Fm.Check {
              return Bool.false;
            },
          },
        app: case b1 {
          app: do Fm.Check {
            let seen = Set.set(id, seen);
            var eq_func = Fm.Term.equal(a1.func, b1.func, defs, lv, seen);
            var eq_argm = Fm.Term.equal(a1.argm, b1.argm, defs, lv, seen);
            return Bool.and(eq_func, eq_argm);
          },
          hol: Fm.Term.equal.patch<_>(b1.path, a, Bool.true),
          _: do Fm.Check {
            return Bool.false;
          },
        },
        let: case b1 {
          let: do Fm.Check {
            let seen = Set.set(id, seen);
            let a1_body = a1.body(Fm.Term.var(a1.name, lv));
            let b1_body = b1.body(Fm.Term.var(b1.name, lv));
            var eq_expr = Fm.Term.equal(a1.expr, b1.expr, defs, lv, seen);
            var eq_body = Fm.Term.equal(a1_body, b1_body, defs, Nat.succ(lv), seen);
            return Bool.and(eq_expr, eq_body);
          },
          hol:
            Fm.Term.equal.patch<_>(b1.path, a, Bool.true),
          _: do Fm.Check {
            return Bool.false;
          },
        },
        hol:
          Fm.Term.equal.patch<_>(a1.path, b, Bool.true),
        _: case b1 {
          hol: Fm.Term.equal.patch<_>(b1.path, a, Bool.true),
          _: do Fm.Check {
            return Bool.false;
          },
        },
      };
    };
  }

// Type Checking
// =============

// Fm.Check monad pure
Fm.Check.pure<V: Type>(value: V): Fm.Check(V)
  Fm.Check.result<V>(Maybe.some<V>(value), [])

// Fm.Check monad bind
Fm.Check.bind<A: Type, B: Type>(a: Fm.Check(A), f: A -> Fm.Check(B)): Fm.Check(B)
  case a {
    result: case a.value as got {
      none: Fm.Check.result<B>(Maybe.none<B>, a.errors),
      some: case f(got.value) as b {
        result: Fm.Check.result<B>(b.value, List.concat<_>(a.errors,b.errors)),
      }
    }
  }

// Fm.Check monad
Fm.Check.monad: Monad(Fm.Check)
  Monad.new<Fm.Check>(Fm.Check.bind, Fm.Check.pure)

// Fm.Check to Maybe
Fm.Check.value<A: Type>(chk: Fm.Check(A)): Maybe(A)
  case chk {
    result: chk.value
  }

// Fm.Check none
Fm.Check.none<A: Type>: Fm.Check(A)
  Fm.Check.result<A>(Maybe.none<A>, [])

// CHECK: Checks the type of a core term
Fm.Term.check(
  term: Fm.Term,
  type: Maybe(Fm.Term),
  defs: Fm.Defs,
  ctx: Fm.Context,
  path: Fm.MPath,
  orig: Maybe(Fm.Origin),
): Fm.Check(Fm.Term)
  do Fm.Check {
    var infr = case term {
      ref: case Fm.get<_>(term.name, defs) as got {
        none: Fm.Check.result<_>(type, [Fm.Error.undefined_reference(orig, term.name)]),
        some: case got.value {
          new:
            let ref_name = got.value.name;
            let ref_type = got.value.type;
            let ref_term = got.value.term;
            let ref_stat = got.value.stat;
            case ref_stat {
              init: Fm.Check.result<_>(Maybe.some<_>(ref_type), [Fm.Error.waiting(ref_name)]),
              wait: Fm.Check.result<_>(Maybe.some<_>(ref_type), []),
              done: Fm.Check.result<_>(Maybe.some<_>(ref_type), []),
              fail: Fm.Check.result<_>(Maybe.some<_>(ref_type), [Fm.Error.indirect(ref_name)]),
            },
        }
      },
      var: case List.at_last<_>(term.indx, ctx) as got {
        none: Fm.Check.result<_>(type, [Fm.Error.undefined_reference(orig, term.name)]),
        some: do Fm.Check { return case got.value { new: got.value.snd }; },
      },
      typ: do Fm.Check {
        return Fm.Term.typ;
      },
      all: do Fm.Check {
        let ctx_size = List.length<_>(ctx);
        let self_var = Fm.Term.var(term.self, ctx_size);
        let body_var = Fm.Term.var(term.name, Nat.succ(ctx_size));
        let body_ctx = List.cons<_>({term.name,term.xtyp}, List.cons<_>({term.self,term}, ctx));
        Fm.Term.check(term.xtyp, Maybe.some<_>(Fm.Term.typ), defs, ctx, Fm.MPath.o(path), orig);
        Fm.Term.check(term.body(self_var,body_var), Maybe.some<_>(Fm.Term.typ), defs, body_ctx, Fm.MPath.i(path), orig);
        return Fm.Term.typ;
      },
      lam: case type {
        none: do Fm.Check {
          Fm.Check.result<_>(type, [Fm.Error.cant_infer(orig, term, ctx)]);
        },
        some: do Fm.Check {
          let typv = Fm.Term.reduce(type.value, defs);
          case typv {
            all: do Fm.Check {
              let ctx_size = List.length<_>(ctx);
              let self_var = term;
              let body_var = Fm.Term.var(term.name, ctx_size);
              let body_typ = typv.body(self_var, body_var);
              let body_ctx = List.cons<_>({term.name,typv.xtyp}, ctx);
              Fm.Term.check(term.body(body_var), Maybe.some<_>(body_typ), defs, body_ctx, Fm.MPath.o(path), orig);
              return type.value;
            },
            _: do Fm.Check {
              let expected = Either.left<_,_>("Function");
              let detected = Either.right<_,_>(type.value);
              Fm.Check.result<_>(type, [Fm.Error.type_mismatch(orig, expected, detected, ctx)]);
            }
          };
        }
      },
      app: do Fm.Check {
        var func_typ = Fm.Term.check(term.func, Maybe.none<_>, defs, ctx, Fm.MPath.o(path), orig);
        let func_typ = Fm.Term.reduce(func_typ, defs);
        case func_typ {
          all: do Fm.Check {
            Fm.Term.check(term.argm, Maybe.some<_>(func_typ.xtyp), defs, ctx, Fm.MPath.i(path), orig);
            return func_typ.body(term.func, term.argm);
          },
          _: do Fm.Check {
            let expected = Either.left<_,_>("Function");
            let detected = Either.right<_,_>(func_typ);
            Fm.Check.result<_>(type, [Fm.Error.type_mismatch(orig, expected, detected, ctx)]);
          },
        };
      },
      ann:
        if term.done then do Fm.Check {
          return term.type;
        } else do Fm.Check {
          Fm.Term.check(term.term, Maybe.some<_>(term.type), defs, ctx, Fm.MPath.o(path), orig);
          Fm.Term.check(term.type, Maybe.some<_>(Fm.Term.typ), defs, ctx, Fm.MPath.i(path), orig);
          return term.type;
        },
      let: do Fm.Check {
        let ctx_size = List.length<_>(ctx);
        var expr_typ = Fm.Term.check(term.expr, Maybe.none<_>, defs, ctx, Fm.MPath.o(path), orig);
        let body_val = term.body(Fm.Term.var(term.name, ctx_size));
        let body_ctx = List.cons<_>({term.name, expr_typ}, ctx);
        var body_typ = Fm.Term.check(body_val, type, defs, body_ctx, Fm.MPath.i(path), orig);
        return body_typ;
      },
      def: do Fm.Check {
        Fm.Term.check(term.body(term.expr), type, defs, ctx, path, orig);
      },
      nat: do Fm.Check {
        return Fm.Term.ref("Nat");
      },
      chr: do Fm.Check {
        return Fm.Term.ref("Char");
      },
      str: do Fm.Check {
        return Fm.Term.ref("String");
      },
      cse: do Fm.Check {
        let expr = term.expr;
        var etyp = Fm.Term.check(expr, Maybe.none<_>, defs, ctx, Fm.MPath.o(path), orig);
        // If cse has no moti and we have an inferred type, then we guess it
        // with the information we have, substituting selfs and indices.
        // Otherwise, we just replace it by a normal hole.
        let dsug = case term.moti {
          none:
            let moti = case type {
              none:
                Fm.Term.hol(Bits.e),
              some:
                let size = List.length<_>(ctx);
                let moti = Fm.SmartMotive.make(term.name, term.expr, etyp, type.value, size, defs);
                moti,
            };
            Maybe.some<_>(Fm.Term.cse(term.path, term.expr, term.name, term.with, term.cses, Maybe.some<_>(moti))),
          some:
            Fm.Term.desugar_cse(term.expr, term.name, term.with, term.cses, term.moti.value, etyp, defs, ctx),
        };
        case dsug {
          none: Fm.Check.result<_>(type, [Fm.Error.cant_infer(orig, term, ctx)]),
          some: Fm.Check.result<_>(type, [Fm.Error.patch(Fm.MPath.to_bits(path),dsug.value)]),
        };
      },
      gol: do Fm.Check {
        Fm.Check.result<_>(type, [
          Fm.Error.show_goal(term.name, term.dref, term.verb, type, ctx)
        ]);
      },
      hol: do Fm.Check {
        Fm.Check.result<_>(type, []);
      },
      ori: do Fm.Check {
        Fm.Term.check(term.expr, type, defs, ctx, path, Maybe.some<_>(term.orig));
      },
    };
    case type {
      none:
        Fm.Check.result<_>(Maybe.some<_>(infr), []),
      some: do Fm.Check {
        var eqls = Fm.Term.equal(type.value, infr, defs, List.length<_>(ctx), Set.new);
        if eqls then do Fm.Check {
          return type.value;
        } else Fm.Check.result<_>(type, [
          Fm.Error.type_mismatch(
            orig,
            Either.right<_,_>(type.value),
            Either.right<_,_>(infr),
            ctx)
        ]);
      }
    };
  }

// SmartMotive
// ==========

// Replaces a term by another. Assumes bound variables are linked to native
// lambdas, so no shifting is necessary. Used in desugarers. TODO: variable
// captures may happen if the motive has lambdas with identical names to the
// case-of name/indices. To improve this, we would need to replace term.body by
// variables. But since variables are bruijn-leveled, this won't work since the
// motive desugarer adds lambdas. Thus, in order for it to work, we'd need
// either bruijn indices, or to make the motive desugarer call level-shift for
// each lambda it adds.
Fm.SmartMotive.replace(term: Fm.Term, from: Fm.Term, to: Fm.Term, lv: Nat): Fm.Term
  //let skip = Debug.log<_>(String.flatten(["replace term=", Fm.Term.show(term), " from=", Fm.Term.show(from), " to=", Fm.Term.show(to), " lv=", Nat.show(lv)]), (x) Unit.new);
  if Fm.Term.identical(term, from, lv) then
    to
  else case term {
    ref:
      Fm.Term.ref(term.name),
    var:
      Fm.Term.var(term.name, term.indx),
    typ:
      Fm.Term.typ,
    all: 
      let xtyp = Fm.SmartMotive.replace(term.xtyp, from, to, lv);
      let body = term.body(Fm.Term.ref(term.self),Fm.Term.ref(term.name));
      let body = Fm.SmartMotive.replace(body, from, to, Nat.succ(Nat.succ(lv)));
      Fm.Term.all(term.eras, term.self, term.name, xtyp, (s,x) body),
    lam:
      let body = term.body(Fm.Term.ref(term.name));
      let body = Fm.SmartMotive.replace(body, from, to, Nat.succ(lv));
      Fm.Term.lam(term.name, (x) body),
    app:
      let func = Fm.SmartMotive.replace(term.func, from, to, lv);
      let argm = Fm.SmartMotive.replace(term.argm, from, to, lv);
      Fm.Term.app(func, argm),
    let:
      let expr = Fm.SmartMotive.replace(term.expr, from, to, lv);
      let body = term.body(Fm.Term.ref(term.name))
      let body = Fm.SmartMotive.replace(body, from, to, Nat.succ(lv));
      Fm.Term.let(term.name, expr, (x) body),
    def:
      let expr = Fm.SmartMotive.replace(term.expr, from, to, lv);
      let body = term.body(Fm.Term.ref(term.name))
      let body = Fm.SmartMotive.replace(body, from, to, Nat.succ(lv));
      Fm.Term.def(term.name, expr, (x) body),
    ann:
      let term = Fm.SmartMotive.replace(term.term, from, to, lv);
      let type = Fm.SmartMotive.replace(term.type, from, to, lv);
      Fm.Term.ann(term.done, term, type),
    gol:
      term,
    hol:
      term,
    nat:
      term,
    chr:
      term,
    str:
      term,
    cse:
      term,
    ori:
      Fm.SmartMotive.replace(term.expr, from, to, lv),
  }

Fm.SmartMotive.vals(expr: Fm.Term, type: Fm.Term, defs: Fm.Defs): List(Fm.Term)
  case Fm.Term.reduce(type, defs) as type {
    all: Fm.SmartMotive.vals(expr, type.body(Fm.Term.typ,Fm.Term.typ), defs),
    _: Fm.SmartMotive.vals.cont(expr, type, [], defs),
  }

Fm.SmartMotive.vals.cont(expr: Fm.Term, term: Fm.Term, args: List(Fm.Term), defs: Fm.Defs): List(Fm.Term)
  case Fm.Term.reduce(term, defs) as term {
    app: Fm.SmartMotive.vals.cont(expr, term.func, List.cons<_>(term.argm, args), defs),
    _: List.cons<_>(expr, List.tail<_>(List.reverse<_>(args))),
  }

Fm.SmartMotive.nams(name: Fm.Name, type: Fm.Term, defs: Fm.Defs): List(Fm.Name)
  case Fm.Term.reduce(type, defs) as type {
    all: Fm.SmartMotive.nams.cont(name, type.xtyp, [], defs),
    _: [],
  }

Fm.SmartMotive.nams.cont(name: Fm.Name, term: Fm.Term, binds: List(Fm.Name), defs: Fm.Defs): List(Fm.Name)
  case Fm.Term.reduce(term, defs) as term {
    all: Fm.SmartMotive.nams.cont(
      name,
      term.body(Fm.Term.ref(term.self),Fm.Term.ref(term.name)),
      List.cons<_>(String.flatten([name, ".", term.name]), binds),
      defs),
    _: List.cons<_>(name, List.tail<_>(binds)),
  }

Fm.SmartMotive.make(
  name: Fm.Name,
  expr: Fm.Term, 
  type: Fm.Term,
  moti: Fm.Term,
  lv  : Nat,
  defs: Fm.Defs,
): Fm.Term
  let vals = Fm.SmartMotive.vals(expr,type,defs);
  let nams = Fm.SmartMotive.nams(name,type,defs);
  let subs = List.zip<_,_>(nams,vals);
  //let skip = Debug.log<_>(String.flatten(["-expr: ", Fm.Term.show(expr)]), (x) Unit.new);
  //let skip = Debug.log<_>(String.flatten(["-type: ", Fm.Term.show(type)]), (x) Unit.new);
  //let skip = Debug.log<_>(String.flatten(["-type: ", Fm.Term.show(Fm.Term.reduce(type,defs))]), (x) Unit.new);
  //let skip = Debug.log<_>(String.flatten(["-vals: ", String.join(", ", List.mapped<_>(vals)<_>(Fm.Term.show))]), (x) Unit.new);
  //let skip = Debug.log<_>(String.flatten(["-nams: ", String.join(", ", nams)]), (x) Unit.new);
  //let skip = Debug.log<_>(String.flatten(["-moti: ", Fm.Term.show(moti)]), (x) Unit.new);
  let moti = List.fold<_>(subs)<_>(moti, (sub,moti) case sub {
    new: Fm.SmartMotive.replace(moti, sub.snd, Fm.Term.ref(sub.fst), lv),
  });
  //let skip = Debug.log<_>(String.flatten(["+moti: ", Fm.Term.show(moti)]), (x) Unit.new);
  moti

// Sugars
// ======

// Unrolls a natural number
Fm.Term.unroll_nat(natx: Nat): Fm.Term
  case natx {
    zero:
      Fm.Term.ref(Fm.Name.read("Nat.zero")),
    succ:
      let func = Fm.Term.ref(Fm.Name.read("Nat.succ"));
      let argm = Fm.Term.nat(natx.pred);
      Fm.Term.app(func, argm),
  }

// Unrolls a character
Fm.Term.unroll_chr(chrx: Char): Fm.Term
  let bits = U16.to_bits(chrx);
  let term = Fm.Term.ref(Fm.Name.read("Word.from_bits"));
  let term = Fm.Term.app(term, Fm.Term.nat(16));
  let term = Fm.Term.app(term, Fm.Term.unroll_chr.bits(bits));
  let term = Fm.Term.app(Fm.Term.ref(Fm.Name.read("U16.new")), term);
  term

Fm.Term.unroll_chr.bits(bits: Bits): Fm.Term
  case bits {
    e: Fm.Term.ref(Fm.Name.read("Bits.e")),
    o: Fm.Term.app(Fm.Term.ref(Fm.Name.read("Bits.o")), Fm.Term.unroll_chr.bits(bits.pred)),
    i: Fm.Term.app(Fm.Term.ref(Fm.Name.read("Bits.i")), Fm.Term.unroll_chr.bits(bits.pred)),
  }

// Unrolls a string
Fm.Term.unroll_str(strx: String): Fm.Term
  case strx {
    nil:
      Fm.Term.ref(Fm.Name.read("String.nil")),
    cons:
      let char = Fm.Term.chr(strx.head);
      let term = Fm.Term.ref(Fm.Name.read("String.cons"));
      let term = Fm.Term.app(term, char);
      let term = Fm.Term.app(term, Fm.Term.str(strx.tail));
      term,
  }

// Desugars the case-of expression (wraps lambdas around arguments)
Fm.Term.desugar_cse(
  expr: Fm.Term,
  name: Fm.Name,
  with: List(Fm.Def),
  cses: Map(Fm.Term),
  moti: Fm.Term,
  type: Fm.Term,
  defs: Fm.Defs,
  ctxt: Fm.Context,
): Maybe(Fm.Term)
  case Fm.Term.reduce(type, defs) as type {
    all:
      let moti = Fm.Term.desugar_cse.motive(with, moti);
      let argm = Fm.Term.desugar_cse.argument(name, [], type.xtyp, moti, defs);
      let expr = Fm.Term.app(expr, argm);
      let type = type.body(Fm.Term.var(type.self,0), Fm.Term.var(type.name,0));
      Maybe.some<_>(Fm.Term.desugar_cse.cases(expr, name, with, cses, type, defs, ctxt)),
    _:
      Maybe.none<_>,
  }

// Desugars the case-of expression (cases)
Fm.Term.desugar_cse.cases(
  expr: Fm.Term,
  name: Fm.Name,
  wyth: List(Fm.Def),
  cses: Map(Fm.Term),
  type: Fm.Term,
  defs: Fm.Defs,
  ctxt: Fm.Context,
): Fm.Term
  case Fm.Term.reduce(type, defs) as type {
    all: 
      let got = Maybe.or<_>(Fm.get<_>(type.name, cses), Fm.get<_>("_", cses));
      case got {
        some:
          let argm = Fm.Term.desugar_cse.argument(name, wyth, type.xtyp, got.value, defs);
          let expr = Fm.Term.app(expr, argm);
          let type = type.body(Fm.Term.var(type.self,0), Fm.Term.var(type.name,0));
          Fm.Term.desugar_cse.cases(expr, name, wyth, cses, type, defs, ctxt),
        none: 
          for defn in wyth with expr:
            case defn {
              new: Fm.Term.app(expr, defn.term)
            },
      },
    _:
      for defn in wyth with expr:
        Fm.Term.app(expr, case defn { new: defn.term }),
  }

// Extends a type with motive variables
Fm.Term.desugar_cse.motive(
  wyth: List(Fm.Def),
  moti: Fm.Term,
): Fm.Term
  case wyth {
    cons: case wyth.head {
      new:
        def all_name = wyth.head.name;
        def all_xtyp = wyth.head.type;
        def all_body = (s,x) Fm.Term.desugar_cse.motive(wyth.tail, moti);
        Fm.Term.all(Bool.false, "", all_name, all_xtyp, all_body)
    },
    nil: moti,
  }

// Desugars the case-of expression (wraps lambdas around an argument)
Fm.Term.desugar_cse.argument(
  name: Fm.Name,
  wyth: List(Fm.Def),
  type: Fm.Term,
  body: Fm.Term,
  defs: Fm.Defs,
): Fm.Term
  case Fm.Term.reduce(type, defs) as type {
    all:
      def type = type.body(Fm.Term.var(type.self,0), Fm.Term.var(type.name,0));
      def lam_name =
        if String.is_empty(type.name) then
          name
        else
          String.flatten([name, ".", type.name]);
      def lam_body = (x) Fm.Term.desugar_cse.argument(name, wyth, type, body, defs);
      Fm.Term.lam(lam_name, lam_body),
    _: case wyth {
      cons: case wyth.head {
        new:
          def lam_name = wyth.head.name;
          def lam_body = (x) Fm.Term.desugar_cse.argument(name, wyth.tail, type, body, defs);
          Fm.Term.lam(lam_name, lam_body)
      },
      nil: body,
    }
  }

// Builds the type of a datatype
Fm.Datatype.build_type(type: Fm.Datatype): Fm.Term
  case type {
    new: Fm.Datatype.build_type.go(type, type.name, type.pars, type.inds),
  }

Fm.Datatype.build_type.go(
  type: Fm.Datatype,
  name: Fm.Name,
  pars: List(Fm.Binder),
  inds: List(Fm.Binder),
): Fm.Term
  case pars {
    cons: case pars.head {
      new:
        def par_eras = pars.head.eras;
        def par_name = pars.head.name;
        def par_xtyp = pars.head.term;
        def par_body = (s,x) Fm.Datatype.build_type.go(type, name, pars.tail, inds);
        Fm.Term.all(Bool.false, "", par_name, par_xtyp, par_body)
    },
    nil: case inds {
      cons: case inds.head {
        new: 
          def ind_eras = inds.head.eras;
          def ind_name = inds.head.name;
          def ind_xtyp = inds.head.term;
          def ind_body = (s,x) Fm.Datatype.build_type.go(type, name, pars, inds.tail);
          Fm.Term.all(Bool.false, "", ind_name, ind_xtyp, ind_body)
      },
      nil: Fm.Term.typ,
    }
  }

// Builds the term of a datatype (motive)
Fm.Datatype.build_term.motive(
  type: Fm.Datatype,
): Fm.Term
  case type {
    new: Fm.Datatype.build_term.motive.go(type, type.name, type.inds),
  }

Fm.Datatype.build_term.motive.go(
  type: Fm.Datatype,
  name: Fm.Name,
  inds: List(Fm.Binder),
): Fm.Term
  case inds {
    cons: case inds.head {
      new:
        def ind_eras = inds.head.eras;
        def ind_name = inds.head.name;
        def ind_xtyp = inds.head.term;
        def ind_body = (s,x) Fm.Datatype.build_term.motive.go(type, name, inds.tail);
        Fm.Term.all(ind_eras, "", ind_name, ind_xtyp, ind_body),
    },
    nil:
      case type {
        new:
          let slf = Fm.Term.ref(name);
          let slf = for var in type.pars:
            Fm.Term.app(slf, Fm.Term.ref(case var { new: var.name }));
          let slf = for var in type.inds:
            Fm.Term.app(slf, Fm.Term.ref(case var { new: var.name }));
          Fm.Term.all(Bool.false, "", "", slf, (s,x) Fm.Term.typ)
      }
  }

// Builds the term of a datatype (constructors)
Fm.Datatype.build_term.constructors(type: Fm.Datatype): Fm.Term
  case type {
    new: Fm.Datatype.build_term.constructors.go(type, type.name, type.ctrs)
  }

Fm.Datatype.build_term.constructors.go(
  type: Fm.Datatype,
  name: Fm.Name,
  ctrs: List(Fm.Constructor),
): Fm.Term
  case ctrs {
    cons: case ctrs.head {
      new: Fm.Term.all(Bool.false, "",
        ctrs.head.name,
        Fm.Datatype.build_term.constructor(type, ctrs.head),
        (s,x) Fm.Datatype.build_term.constructors.go(type, name, ctrs.tail))
    },
    nil:
      case type {
        new:
          let ret = Fm.Term.ref(Fm.Name.read("P"));
          let ret = for var in type.inds:
            Fm.Term.app(ret, Fm.Term.ref(case var { new: var.name }));
          Fm.Term.app(ret, Fm.Term.ref(String.concat(name,".Self")))
      }
  }

// Builds the term of a datatype (constructor)
Fm.Datatype.build_term.constructor(type: Fm.Datatype, ctor: Fm.Constructor): Fm.Term
  case ctor {
    new: Fm.Datatype.build_term.constructor.go(type, ctor, ctor.args),
  }

Fm.Datatype.build_term.constructor.go(
  type: Fm.Datatype,
  ctor: Fm.Constructor,
  args: List(Fm.Binder),
): Fm.Term
  case args {
    cons: case args.head {
      new:
        let eras = args.head.eras;
        let name = args.head.name;
        let xtyp = args.head.term;
        let body = Fm.Datatype.build_term.constructor.go(type, ctor, args.tail);
        Fm.Term.all(eras, "", name, xtyp, (s,x) body)
    },
    nil:
      case type {
        new: case ctor {
          new:
            let ret = Fm.Term.ref(Fm.Name.read("P"));
            let ret = for var in ctor.inds:
              Fm.Term.app(ret, case var { new: var.term });
            let ctr = String.flatten([type.name,Fm.Name.read("."),ctor.name]);
            let slf = Fm.Term.ref(ctr);
            let slf = for var in type.pars:
              Fm.Term.app(slf, Fm.Term.ref(case var { new: var.name }));
            let slf = for var in ctor.args:
              Fm.Term.app(slf, Fm.Term.ref(case var { new: var.name }));
            Fm.Term.app(ret, slf)
        }
      }
  }
        
// Builds the term of a datatype
Fm.Datatype.build_term(type: Fm.Datatype): Fm.Term
  case type {
    new: Fm.Datatype.build_term.go(type, type.name, type.pars, type.inds),
  }

Fm.Datatype.build_term.go(
  type: Fm.Datatype,
  name: Fm.Name,
  pars: List(Fm.Binder),
  inds: List(Fm.Binder),
): Fm.Term
  case pars {
    cons: case pars.head {
      new:
        def par_name = pars.head.name;
        def par_body = (x) Fm.Datatype.build_term.go(type, name, pars.tail, inds);
        Fm.Term.lam(par_name, par_body),
    },
    nil: case inds {
      cons: case inds.head {
        new:
          def ind_name = inds.head.name;
          def ind_body = (x) Fm.Datatype.build_term.go(type, name, pars, inds.tail);
          Fm.Term.lam(ind_name, ind_body),
      },
      nil: 
        def moti = Fm.Datatype.build_term.motive(type);
        def body = (s,x) Fm.Datatype.build_term.constructors(type); // TODO
        Fm.Term.all(Bool.true, String.concat(name,".Self"), Fm.Name.read("P"), moti, body)
    }
  }

Fm.Constructor.build_type(type: Fm.Datatype, ctor: Fm.Constructor): Fm.Term
  case type {
    new: case ctor {
      new: Fm.Constructor.build_type.go(
        type,
        ctor,
        type.name,
        type.pars,
        ctor.args)
    }
  }

Fm.Constructor.build_type.go(
  type: Fm.Datatype,
  ctor: Fm.Constructor,
  name: Fm.Name,
  pars: List(Fm.Binder),
  args: List(Fm.Binder),
): Fm.Term
  case pars {
    cons: case pars.head {
      new:
        def pars_eras = pars.head.eras;
        def pars_name = pars.head.name;
        def pars_xtyp = pars.head.term;
        def pars_body = (s,x) Fm.Constructor.build_type.go(type, ctor, name, pars.tail, args);
        Fm.Term.all(pars_eras, "", pars_name, pars_xtyp, pars_body),
    },
    nil: case args {
      cons: case args.head {
        new:
          def ctr_eras = args.head.eras;
          def ctr_name = args.head.name;
          def ctr_xtyp = args.head.term;
          def ctr_body = (s,x) Fm.Constructor.build_type.go(type, ctor, name, pars, args.tail);
          Fm.Term.all(ctr_eras, "", ctr_name, ctr_xtyp, ctr_body),
      },
      nil: case type {
        new: case ctor {
          new:
            let type = Fm.Term.ref(name);
            let type = for var in type.pars:
              Fm.Term.app(type, Fm.Term.ref(case var { new: var.name }));
            let type = for var in ctor.inds:
              Fm.Term.app(type, case var { new: var.term });
            type,
        }
      }
    }
  }

Fm.Constructor.build_term.opt(type: Fm.Datatype, ctor: Fm.Constructor): Fm.Term
  case type {
    new: Fm.Constructor.build_term.opt.go(type, ctor, type.ctrs)
  }

Fm.Constructor.build_term.opt.go(
  type: Fm.Datatype,
  ctor: Fm.Constructor,
  ctrs: List(Fm.Constructor),
): Fm.Term
  case ctrs {
    cons: case ctrs.head {
      new:
        def name = ctrs.head.name;
        def body = (x) Fm.Constructor.build_term.opt.go(type, ctor, ctrs.tail);
        Fm.Term.lam(name, body)
    },
    nil: 
      case ctor {
        new:
          let ret = Fm.Term.ref(ctor.name);
          let ret = for arg in ctor.args:
            Fm.Term.app(ret, Fm.Term.ref(case arg { new: arg.name }));
          ret
      },
  }

Fm.Constructor.build_term(type: Fm.Datatype, ctor: Fm.Constructor): Fm.Term
  case type {
    new: case ctor {
      new: Fm.Constructor.build_term.go(type, ctor, type.name, type.pars, ctor.args)
    }
  }

Fm.Constructor.build_term.go(
  type: Fm.Datatype,
  ctor: Fm.Constructor,
  name: Fm.Name,
  pars: List(Fm.Binder),
  args: List(Fm.Binder),
): Fm.Term
  case pars {
    cons: case pars.head {
      new:
        def par_name = pars.head.name;
        def par_body = (x) Fm.Constructor.build_term.go(type, ctor, name, pars.tail, args);
        Fm.Term.lam(par_name, par_body),
    },
    nil: case args {
      cons: case args.head {
        new:
          def ctr_name = args.head.name;
          def ctr_body = (x) Fm.Constructor.build_term.go(type, ctor, name, pars, args.tail);
          Fm.Term.lam(ctr_name, ctr_body),
      },
      nil:
        def lam_name = Fm.Name.read("P");
        def lam_body = (x) Fm.Constructor.build_term.opt(type, ctor);
        Fm.Term.lam(lam_name, lam_body),
    }
  }

// Parsing
// =======

// Is this character a valid letter?
Fm.Name.is_letter(chr: Char): Bool
  if      U16.btw('A', chr, 'Z') then Bool.true
  else if U16.btw('a', chr, 'z') then Bool.true
  else if U16.btw('0', chr, '9') then Bool.true
  else if U16.eql('.', chr)      then Bool.true
  else if U16.eql('_', chr)      then Bool.true
  else                                Bool.false

// Converts a String to a Fm.Name
Fm.Name.read(str: String): Fm.Name
  str

// Converts a Fm.Name to a String
Fm.Name.show(name: Fm.Name): String
  name
  
// Converts a name to a bits
Fm.Name.to_bits(name: Fm.Name): Bits
  case name {
    nil:
      Bits.e,
    cons:
      let chr = name.head;
      let u16 = 
        if      U16.btw('A', chr, 'Z') then U16.sub(chr, Nat.to_u16(65))
        else if U16.btw('a', chr, 'z') then U16.sub(chr, Nat.to_u16(71))
        else if U16.btw('0', chr, '9') then U16.add(chr, Nat.to_u16(4))
        else if U16.eql('.', chr)      then Nat.to_u16(62)
        else if U16.eql('_', chr)      then Nat.to_u16(63)
        else                                Nat.to_u16(0);
      let bts = case u16 { new: Word.to_bits<6>(Word.trim<16>(6, u16.value)) };
      Bits.concat(Bits.reverse(bts), Fm.Name.to_bits(name.tail)),
  }

// Converts a bits to a name
Fm.Name.from_bits(bits: Bits): Fm.Name
  let list = Bits.chunks_of(6, bits);
  let name = List.fold<_>(list)<_>(String.nil, (bts, name)
    let u16 = U16.new(Word.from_bits(16, Bits.reverse(bts)));
    let chr = 
      if      U16.btw( Nat.to_u16(0), u16, Nat.to_u16(25)) then U16.add(u16, Nat.to_u16(65))
      else if U16.btw(Nat.to_u16(26), u16, Nat.to_u16(51)) then U16.add(u16, Nat.to_u16(71))
      else if U16.btw(Nat.to_u16(52), u16, Nat.to_u16(61)) then U16.sub(u16, Nat.to_u16(4))
      else if U16.eql(Nat.to_u16(62), u16)                 then Nat.to_u16(46)
      else                                                      Nat.to_u16(95);
    String.cons(chr, name));
  name

// Are two names the same?
Fm.Name.eql(a: Fm.Name, b: Fm.Name): Bool
  String.eql(a, b)

Fm.backslash: Char
  Nat.to_u16(92)

// String escapable sequences
// TODO: '\\' isn't working, investigate
Fm.escapes: List(Pair(String, Char))
  [
    {"\\b" , '\b'},
    {"\\f" , '\f'},
    {"\\n" , '\n'},
    {"\\r" , '\r'},
    {"\\t" , '\t'},
    {"\\v" , '\v'},
    {String.cons(Fm.backslash, String.cons(Fm.backslash, String.nil)), Fm.backslash},
    {"\\\"", '"'},
    {"\\0" , '\0'},
    {"\\'" , '\''},
  ]

Fm.escape.char(chr: Char): String
  if U16.eql(chr, Fm.backslash) then
    String.cons(Fm.backslash, String.cons(chr, String.nil))
  else if U16.eql(chr, '"') then
    String.cons(Fm.backslash, String.cons(chr, String.nil))
  else if U16.eql(chr, '\'') then
    String.cons(Fm.backslash, String.cons(chr, String.nil))
  else if U16.btw(' ', chr, '~') then
    String.cons(chr, String.nil)
  else
    String.flatten([
      String.cons(Fm.backslash, String.nil),
      "u{", U16.show_hex(chr), "}",
      String.nil,
    ])


Fm.escape(str: String): String
  case str {
    nil:
      String.nil,
    cons:
      let head = Fm.escape.char(str.head);
      let tail = Fm.escape(str.tail);
      String.concat(head, tail)
  }
        
// Spaces and comments
Fm.Parser.spaces: Parser(List(Unit))
  Parser.many<_>(Parser.first_of<_>([
    Parser.text(" "),
    Parser.text("\n"),
    do Parser {
      Parser.text("//");
      Parser.until<_>(Parser.text("\n"), Parser.one);
      return Unit.new;
    }
  ]))

Fm.Parser.init: Parser(Nat)
  do Parser {
    Fm.Parser.spaces;
    var from = Parser.get_index;
    return from;
  }

Fm.Parser.stop(from: Nat): Parser(Fm.Origin)
  do Parser {
    var upto = Parser.get_index;
    let orig = Fm.Origin.new("", from, upto);
    return orig;
  }

// Parses spaces then a text
Fm.Parser.text(text: String): Parser(Unit)
  do Parser {
    Fm.Parser.spaces;
    Parser.text(text);
  }

// Parses a letter: @[a-zA-Z_.]@
Fm.Parser.letter: Parser(Fm.Letter)
  (idx, code) case code {
    nil: Parser.Reply.error<_>(idx, code, "Unexpected eof."),
    cons:
      if Fm.Name.is_letter(code.head) then
        Parser.Reply.value<_>(Nat.succ(idx), code.tail, code.head)
      else
        Parser.Reply.error<_>(idx, code, "Expected letter."),
  }
  
// Parses a (possibly empty) name: @[a-zA-Z_.]*@
Fm.Parser.name: Parser(Fm.Name)
  do Parser {
    Fm.Parser.spaces;
    var chrs = Parser.many<Fm.Letter>(Fm.Parser.letter);
    return List.fold<_>(chrs)<_>(String.nil, String.cons);
  }

// Parses a non-empty name: @[a-zA-Z_.]+@
Fm.Parser.name1: Parser(Fm.Name)
  do Parser {
    Fm.Parser.spaces;
    var chrs = Parser.many1<Fm.Letter>(Fm.Parser.letter);
    return List.fold<_>(chrs)<_>(String.nil, String.cons);
  }

// Parses a type: @Type@
Fm.Parser.type: Parser(Fm.Term)
  do Parser {
    var init = Fm.Parser.init;
    Fm.Parser.text("Type");
    var orig = Fm.Parser.stop(init);
    return Fm.Term.ori(orig, Fm.Term.typ);
  }

// Parses a lambda (erased): @<name> body@
Fm.Parser.lambda.erased: Parser(Fm.Term)
  do Parser {
    var init = Fm.Parser.init;
    Fm.Parser.text("<");
    var name = Parser.until1<_>(
      Fm.Parser.text(">"),
      Fm.Parser.item<_>(Fm.Parser.name1));
    var body = Fm.Parser.term;
    var orig = Fm.Parser.stop(init);
    let expr = Fm.Parser.make_lambda(name, body);
    return Fm.Term.ori(orig, expr);
  }

// Parses a lambda: @(name) body@
Fm.Parser.lambda: Parser(Fm.Term)
  do Parser {
    var init = Fm.Parser.init;
    Fm.Parser.text("(");
    var name = Parser.until1<_>(
      Fm.Parser.text(")"),
      Fm.Parser.item<_>(Fm.Parser.name1));
    var body = Fm.Parser.term;
    var orig = Fm.Parser.stop(init);
    let expr = Fm.Parser.make_lambda(name, body);
    return Fm.Term.ori(orig, expr);
  }

// Parses a lambda: @() body@
Fm.Parser.lambda.nameless: Parser(Fm.Term)
  do Parser {
    var init = Fm.Parser.init;
    Fm.Parser.text("()");
    var body = Fm.Parser.term;
    var orig = Fm.Parser.stop(init);
    let expr = Fm.Term.lam("", (x) body);
    return Fm.Term.ori(orig, expr);
  }

// Parses a parenthesis: @(term)@
Fm.Parser.parenthesis: Parser(Fm.Term)
  do Parser {
    Fm.Parser.text("(");
    var term = Fm.Parser.term;
    Fm.Parser.text(")");
    return term;
  }

// Parses a name:term pair
Fm.Parser.name_term: Parser(Pair(Fm.Name, Fm.Term))
  do Parser {
    var name = Fm.Parser.name;
    Fm.Parser.text(":");
    var type = Fm.Parser.term;
    return {name, type};
  }

// Parses a binding list, @(a: A, b: B, c: C)@
Fm.Parser.binder.homo(eras: Bool): Parser(List(Fm.Binder))
  do Parser {
    Fm.Parser.text(if eras then "<" else "(");
    var bind = Parser.until1<_>(
      Fm.Parser.text(if eras then ">" else ")"),
      Fm.Parser.item<_>(Fm.Parser.name_term));
    return List.mapped<_>(bind)<_>((pair) case pair {
      new: Fm.Binder.new(eras, pair.fst, pair.snd)
    });
  }

// Parses a mixed binding list, @<a: A, b: B>(c: C, d: D)<e: E>@
Fm.Parser.binder: Parser(List(Fm.Binder))
  do Parser {
    var lists = Parser.many1<_>(Parser.first_of<_>([
      Fm.Parser.binder.homo(Bool.true),
      Fm.Parser.binder.homo(Bool.false),
    ]));
    return List.flatten<_>(lists);
  }

// Parses a forall: @self(a: A, b: B, c: C) D@
Fm.Parser.forall: Parser(Fm.Term)
  do Parser {
    var init = Fm.Parser.init;
    var self = Fm.Parser.name;
    var bind = Fm.Parser.binder;
    Parser.maybe<_>(Fm.Parser.text("->"));
    var body = Fm.Parser.term;
    let term = List.fold<_>(bind)<_>(body, (x,t) case x {
      new: Fm.Term.all(x.eras, "", x.name, x.term, (s,x) t)
    });
    var orig = Fm.Parser.stop(init);
    return case term {
      all: Fm.Term.ori(orig, Fm.Term.all(term.eras, self, term.name, term.xtyp, term.body)),
      _: term,
    };
  }

// Parses a let: @let name = expr; body@
Fm.Parser.let: Parser(Fm.Term)
  do Parser {
    var init = Fm.Parser.init;
    Fm.Parser.text("let ");
    var name = Fm.Parser.name;
    Fm.Parser.text("=");
    var expr = Fm.Parser.term;
    Parser.maybe<_>(Fm.Parser.text(";"));
    var body = Fm.Parser.term;
    var orig = Fm.Parser.stop(init);
    return Fm.Term.ori(orig, Fm.Term.let(name, expr, (x) body));
  }

// Parses a getter: @let {x,y} = expr; body@
Fm.Parser.get: Parser(Fm.Term)
  do Parser {
    var init = Fm.Parser.init;
    Fm.Parser.text("let ");
    Fm.Parser.text("{");
    var nam0 = Fm.Parser.name;
    Fm.Parser.text(",");
    var nam1 = Fm.Parser.name;
    Fm.Parser.text("}");
    Fm.Parser.text("=");
    var expr = Fm.Parser.term;
    Parser.maybe<_>(Fm.Parser.text(";"));
    var body = Fm.Parser.term;
    var orig = Fm.Parser.stop(init);
    let term = expr;
    let term = Fm.Term.app(term, Fm.Term.lam("x", (x) Fm.Term.hol(Bits.e)));
    let term = Fm.Term.app(term, Fm.Term.lam(nam0, (x) Fm.Term.lam(nam1, (y) body)));
    return Fm.Term.ori(orig, term);
  }

// Parses a def: @def name = expr; body@
Fm.Parser.def: Parser(Fm.Term)
  do Parser {
    var init = Fm.Parser.init;
    Fm.Parser.text("def ");
    var name = Fm.Parser.name;
    Fm.Parser.text("=");
    var expr = Fm.Parser.term;
    Parser.maybe<_>(Fm.Parser.text(";"));
    var body = Fm.Parser.term;
    var orig = Fm.Parser.stop(init);
    return Fm.Term.ori(orig, Fm.Term.def(name, expr, (x) body));
  }

// Parses an if-then-else: @if b then t else f@
Fm.Parser.if: Parser(Fm.Term)
  do Parser {
    var init = Fm.Parser.init;
    Fm.Parser.text("if ");
    var cond = Fm.Parser.term;
    Fm.Parser.text("then");
    var tcse = Fm.Parser.term;
    Fm.Parser.text("else");
    var fcse = Fm.Parser.term;
    var orig = Fm.Parser.stop(init);
    let term = cond;
    let term = Fm.Term.app(term, Fm.Term.lam("", (x) Fm.Term.hol(Bits.e)));
    let term = Fm.Term.app(term, tcse);
    let term = Fm.Term.app(term, fcse);
    return Fm.Term.ori(orig, term);
  }

// Parses a single char
Fm.Parser.char.single: Parser(Char)
  Parser.first_of<_>([
    Parser.first_of<_>(List.mapped<_>(Fm.escapes)<_>((esc) case esc {
      new: do Parser {
        Parser.text(esc.fst);
        return esc.snd;
      }
    })),
    Parser.one,
  ])

// Parses a char literal: @'x'@
Fm.Parser.char: Parser(Fm.Term)
  do Parser {
    var init = Fm.Parser.init;
    Fm.Parser.text("'");
    var chrx = Fm.Parser.char.single;
    Parser.text("'");
    var orig = Fm.Parser.stop(init);
    return Fm.Term.ori(orig, Fm.Term.chr(chrx));
  }

// Parses a string literal: @"foo"@
Fm.Parser.string: Parser(Fm.Term)
  do Parser {
    var init = Fm.Parser.init;
    let quot = String.cons('"', String.nil);
    Fm.Parser.text(quot);
    var chrs = Parser.until<_>(Parser.text(quot), Fm.Parser.char.single);
    let strx = List.fold<_>(chrs)<_>(String.nil, String.cons);
    var orig = Fm.Parser.stop(init);
    return Fm.Term.ori(orig, Fm.Term.str(strx));
  }

// Parses a pair literal: @{1, 2}@
Fm.Parser.pair: Parser(Fm.Term)
  do Parser {
    var init = Fm.Parser.init;
    Fm.Parser.text("{");
    var val0 = Fm.Parser.term;
    Fm.Parser.text(",");
    var val1 = Fm.Parser.term;
    Fm.Parser.text("}");
    var orig = Fm.Parser.stop(init);
    let term = Fm.Term.ref("Pair.new");
    let term = Fm.Term.app(term, Fm.Term.hol(Bits.e));
    let term = Fm.Term.app(term, Fm.Term.hol(Bits.e));
    let term = Fm.Term.app(term, val0);
    let term = Fm.Term.app(term, val1);
    return Fm.Term.ori(orig, term);
  }

// Parses a sigma type literal: @{x : A} P(x)@
Fm.Parser.sigma.type: Parser(Fm.Term)
  do Parser {
    var init = Fm.Parser.init;
    Fm.Parser.text("{");
    var name = Fm.Parser.name1;
    Fm.Parser.text(":");
    var typ0 = Fm.Parser.term;
    Fm.Parser.text("}");
    var typ1 = Fm.Parser.term;
    var orig = Fm.Parser.stop(init);
    let term = Fm.Term.ref("Sigma");
    let term = Fm.Term.app(term, typ0);
    let term = Fm.Term.app(term, Fm.Term.lam("x", (x) typ1));
    return Fm.Term.ori(orig, term);
  }

// Parses the some constructor of the Maybe type: @some(x)@
Fm.Parser.some: Parser(Fm.Term)
  do Parser {
    var init = Fm.Parser.init;
    Fm.Parser.text("some(");
    var expr = Fm.Parser.term;
    Fm.Parser.text(")");
    var orig = Fm.Parser.stop(init);
    let term = Fm.Term.ref("Maybe.some");
    let term = Fm.Term.app(term, Fm.Term.hol(Bits.e));
    let term = Fm.Term.app(term, expr);
    return Fm.Term.ori(orig, term);
  }

// Parses the Equal.apply function: @apply(f,x)@
Fm.Parser.apply: Parser(Fm.Term)
  do Parser {
    var init = Fm.Parser.init;
    Fm.Parser.text("apply(");
    var func = Fm.Parser.term;
    Fm.Parser.text(",");
    var equa = Fm.Parser.term;
    Fm.Parser.text(")");
    var orig = Fm.Parser.stop(init);
    let term = Fm.Term.ref("Equal.apply");
    let term = Fm.Term.app(term, Fm.Term.hol(Bits.e));
    let term = Fm.Term.app(term, Fm.Term.hol(Bits.e));
    let term = Fm.Term.app(term, Fm.Term.hol(Bits.e));
    let term = Fm.Term.app(term, Fm.Term.hol(Bits.e));
    let term = Fm.Term.app(term, func);
    let term = Fm.Term.app(term, equa);
    return Fm.Term.ori(orig, term);
  }

// Parses a list literal: @[1, 2, 3]@
Fm.Parser.list: Parser(Fm.Term)
  do Parser {
    var init = Fm.Parser.init;
    Fm.Parser.text("[");
    var vals = Parser.until<_>(
      Fm.Parser.text("]"),
      Fm.Parser.item<_>(Fm.Parser.term));
    var orig = Fm.Parser.stop(init);
    return List.fold<_>(vals)<_>(
      Fm.Term.app(Fm.Term.ref(Fm.Name.read("List.nil")), Fm.Term.hol(Bits.e)),
      (x,xs)
        let term = Fm.Term.ref(Fm.Name.read("List.cons"));
        let term = Fm.Term.app(term, Fm.Term.hol(Bits.e));
        let term = Fm.Term.app(term, x);
        let term = Fm.Term.app(term, xs);
        Fm.Term.ori(orig, term));
  }

// Parses a logger: @log("foo", "bar")@
Fm.Parser.log: Parser(Fm.Term)
  do Parser {
    var init = Fm.Parser.init;
    Fm.Parser.text("log(");
    var strs = Parser.until<_>(Fm.Parser.text(")"), Fm.Parser.item<_>(Fm.Parser.term));
    var cont = Fm.Parser.term;
    let term = Fm.Term.ref("Debug.log");
    let term = Fm.Term.app(term, Fm.Term.hol(Bits.e));
    let args = List.fold<_>(strs)<_>(Fm.Term.ref("String.nil"), (x,xs) 
      let arg = Fm.Term.ref("String.concat");
      let arg = Fm.Term.app(arg, x);
      let arg = Fm.Term.app(arg, xs);
      arg);
    let term = Fm.Term.app(term, args);
    let term = Fm.Term.app(term, Fm.Term.lam("x", (x) cont));
    var orig = Fm.Parser.stop(init);
    return Fm.Term.ori(orig, term);
  }

// Parses a for-in expression
Fm.Parser.forin: Parser(Fm.Term)
  do Parser {
    var init = Fm.Parser.init;
    Fm.Parser.text("for ");
    var elem = Fm.Parser.name1;
    Fm.Parser.text("in");
    var list = Fm.Parser.term;
    Fm.Parser.text("with");
    var name = Fm.Parser.name1;
    Fm.Parser.text(":");
    var loop = Fm.Parser.term;
    var orig = Fm.Parser.stop(init);
    let term = Fm.Term.ref("List.for");
    let term = Fm.Term.app(term, Fm.Term.hol(Bits.e));
    let term = Fm.Term.app(term, list);
    let term = Fm.Term.app(term, Fm.Term.hol(Bits.e));
    let term = Fm.Term.app(term, Fm.Term.ref(name));
    let lamb = Fm.Term.lam(elem, (i) Fm.Term.lam(name, (x) loop));
    let term = Fm.Term.app(term, lamb);
    let term = Fm.Term.let(name, term, (x) Fm.Term.ref(name));
    return Fm.Term.ori(orig, term);
  }

// Parses a for-in expression, second style
Fm.Parser.forin2: Parser(Fm.Term)
  do Parser {
    var init = Fm.Parser.init;
    Fm.Parser.text("for ");
    var elem = Fm.Parser.name1;
    Fm.Parser.text("in");
    var list = Fm.Parser.term;
    Fm.Parser.text(":");
    var name = Fm.Parser.name1;
    Fm.Parser.text("=");
    var loop = Fm.Parser.term;
    Parser.maybe<_>(Fm.Parser.text(";"));
    var body = Fm.Parser.term;
    var orig = Fm.Parser.stop(init);
    let term = Fm.Term.ref("List.for");
    let term = Fm.Term.app(term, Fm.Term.hol(Bits.e));
    let term = Fm.Term.app(term, list);
    let term = Fm.Term.app(term, Fm.Term.hol(Bits.e));
    let term = Fm.Term.app(term, Fm.Term.ref(name));
    let lamb = Fm.Term.lam(elem, (i) Fm.Term.lam(name, (x) loop));
    let term = Fm.Term.app(term, lamb);
    let term = Fm.Term.let(name, term, (x) body);
    return Fm.Term.ori(orig, term);
  }

// Parses a let-for-in expression
Fm.Parser.letforin: Parser(Fm.Term)
  do Parser {
    var init = Fm.Parser.init;
    Fm.Parser.text("let ");
    var name = Fm.Parser.name1;
    Fm.Parser.text("=");
    Fm.Parser.text("for ");
    var elem = Fm.Parser.name1;
    Fm.Parser.text("in");
    var list = Fm.Parser.term;
    Fm.Parser.text(":");
    var loop = Fm.Parser.term;
    Parser.maybe<_>(Fm.Parser.text(";"));
    var body = Fm.Parser.term;
    var orig = Fm.Parser.stop(init);
    let term = Fm.Term.ref("List.for");
    let term = Fm.Term.app(term, Fm.Term.hol(Bits.e));
    let term = Fm.Term.app(term, list);
    let term = Fm.Term.app(term, Fm.Term.hol(Bits.e));
    let term = Fm.Term.app(term, Fm.Term.ref(name));
    let lamb = Fm.Term.lam(elem, (i) Fm.Term.lam(name, (x) loop));
    let term = Fm.Term.app(term, lamb);
    let term = Fm.Term.let(name, term, (x) body);
    return Fm.Term.ori(orig, term);
  }

// Parses statements of the do-notation
Fm.Parser.do.statements(monad_name: Fm.Name): Parser(Fm.Term)
  Parser.first_of<_>([
    // Binding call: @ask x = expr; rest@
    do Parser {
      var init = Fm.Parser.init;
      Fm.Parser.text("var ");
      var name = Fm.Parser.name1;
      Fm.Parser.text("=");
      var expr = Fm.Parser.term;
      Parser.maybe<_>(Fm.Parser.text(";"));
      var body = Fm.Parser.do.statements(monad_name);
      var orig = Fm.Parser.stop(init);
      let term = Fm.Term.app(Fm.Term.ref("Monad.bind"), Fm.Term.ref(monad_name));
      let term = Fm.Term.app(term, Fm.Term.ref(String.concat(monad_name, ".monad")));
      let term = Fm.Term.app(term, Fm.Term.hol(Bits.e));
      let term = Fm.Term.app(term, Fm.Term.hol(Bits.e));
      let term = Fm.Term.app(term, expr);
      let term = Fm.Term.app(term, Fm.Term.lam(name, (x) body));
      return Fm.Term.ori(orig, term);
    },
    // Local definition (let): @let x = expr; rest@
    do Parser {
      var init = Fm.Parser.init;
      Fm.Parser.text("let ");
      var name = Fm.Parser.name1;
      Fm.Parser.text("=");
      var expr = Fm.Parser.term;
      Parser.maybe<_>(Fm.Parser.text(";"));
      var body = Fm.Parser.do.statements(monad_name);
      var orig = Fm.Parser.stop(init);
      return Fm.Term.ori(orig, Fm.Term.let(name, expr, (x) body));
    },
    // Return pure: @return expr;@
    do Parser {
      var init = Fm.Parser.init;
      Fm.Parser.text("return ");
      var expr = Fm.Parser.term;
      Parser.maybe<_>(Fm.Parser.text(";"));
      var orig = Fm.Parser.stop(init);
      let term = Fm.Term.app(Fm.Term.ref("Monad.pure"), Fm.Term.ref(monad_name));
      let term = Fm.Term.app(term, Fm.Term.ref(String.concat(monad_name, ".monad")));
      let term = Fm.Term.app(term, Fm.Term.hol(Bits.e));
      let term = Fm.Term.app(term, expr);
      return Fm.Term.ori(orig, term);
    },
    // Non-binding call: @expr; rest@
    do Parser {
      var init = Fm.Parser.init;
      var expr = Fm.Parser.term;
      Parser.maybe<_>(Fm.Parser.text(";"));
      var body = Fm.Parser.do.statements(monad_name);
      var orig = Fm.Parser.stop(init);
      let term = Fm.Term.app(Fm.Term.ref("Monad.bind"), Fm.Term.ref(monad_name));
      let term = Fm.Term.app(term, Fm.Term.ref(String.concat(monad_name, ".monad")));
      let term = Fm.Term.app(term, Fm.Term.hol(Bits.e));
      let term = Fm.Term.app(term, Fm.Term.hol(Bits.e));
      let term = Fm.Term.app(term, expr);
      let term = Fm.Term.app(term, Fm.Term.lam("", (x) body));
      return Fm.Term.ori(orig, term);
    },
    // Return direct: @expr;@
    do Parser {
      var expr = Fm.Parser.term;
      Parser.maybe<_>(Fm.Parser.text(";"));
      return expr;
    },
  ])

// Parses a block of the do-notation
Fm.Parser.do: Parser(Fm.Term)
  do Parser {
    Fm.Parser.text("do ");
    var name = Fm.Parser.name1;
    Fm.Parser.text("{");
    var term = Fm.Parser.do.statements(name);
    Fm.Parser.text("}");
    return term;
  }

// Parses a with statement of a case
Fm.Parser.case.with: Parser(Fm.Def)
  do Parser {
    Fm.Parser.text("with");
    var name = Fm.Parser.name1;
    Fm.Parser.text(":");
    var type = Fm.Parser.term;
    Fm.Parser.text("=");
    var term = Fm.Parser.term;
    return Fm.Def.new("", "", name, term, type, Fm.Status.init);
  }

// Parses a case statement of a case
Fm.Parser.case.case: Parser(Pair(Fm.Name, Fm.Term))
  do Parser {
    var name = Fm.Parser.name1;
    Fm.Parser.text(":");
    var term = Fm.Parser.term;
    Parser.maybe<_>(Fm.Parser.text(","));
    return {name, term};
  }

// Parses a case: @case f(x) as k with a:A = X; { zero: x, succ: y } : T@
Fm.Parser.case: Parser(Fm.Term)
  do Parser {
    var init = Fm.Parser.init;
    Fm.Parser.text("case ");
    Fm.Parser.spaces;
    var expr = Fm.Parser.term;
    var name = Parser.maybe<_>(do Parser {
      Fm.Parser.text("as");
      Fm.Parser.name1;
    });
    let name = case name {
      none: case Fm.Term.reduce(expr, Map.new<_>) as expr {
        ref: expr.name,
        var: expr.name,
        _: Fm.Name.read("self"),
      },
      some: name.value,
    };
    var wyth = Parser.many<_>(Fm.Parser.case.with);
    Fm.Parser.text("{");
    var cses = Parser.until<_>(Fm.Parser.text("}"), Fm.Parser.case.case);
    let cses = Map.from_list<_,_>(Fm.Name.to_bits, cses);
    var moti = Parser.first_of<_>([
      // Explicit motive
      do Parser {
        Fm.Parser.text(":");
        var term = Fm.Parser.term;
        return Maybe.some<_>(term);
      },
      // Smart motive
      do Parser {
        Fm.Parser.text("!");
        return Maybe.none<_>;
      },
      // Hole motive
      do Parser {
        return Maybe.some<_>(Fm.Term.hol(Bits.e));
      },
    ]);
    var orig = Fm.Parser.stop(init);
    //let moti = case moti { none: Fm.Term.hol(Bits.e), some: moti.value };
    return Fm.Term.ori(orig, Fm.Term.cse(Bits.e, expr, name, wyth, cses, moti));
  }

// Parses a case: @case f(x) as k with a:A = X; { zero: x, succ: y } : T@
Fm.Parser.open: Parser(Fm.Term)
  do Parser {
    var init = Fm.Parser.init;
    Fm.Parser.text("open ");
    Fm.Parser.spaces;
    var expr = Fm.Parser.term;
    var name = Parser.maybe<_>(do Parser {
      Fm.Parser.text("as");
      Fm.Parser.name1;
    });
    Parser.maybe<_>(Fm.Parser.text(";"));
    let name = case name {
      none: case Fm.Term.reduce(expr, Map.new<_>) as expr {
        ref: expr.name,
        var: expr.name,
        _: Fm.Name.read("self"),
      },
      some: name.value,
    };
    let wyth = [];
    var rest = Fm.Parser.term;
    let cses = Map.from_list<_,_>(Fm.Name.to_bits, [{"_",rest}]);
    let moti = Maybe.some<_>(Fm.Term.hol(Bits.e));
    var orig = Fm.Parser.stop(init);
    return Fm.Term.ori(orig, Fm.Term.cse(Bits.e, expr, name, wyth, cses, moti));
  }

// Parses a goal: @?name@
Fm.Parser.goal: Parser(Fm.Term)
  do Parser {
    var init = Fm.Parser.init;
    Fm.Parser.text("?");
    var name = Fm.Parser.name;
    var dref = Parser.many<_>(do Parser {
      Fm.Parser.text("-");
      var nat = Parser.nat;
      let bits = Bits.reverse(Bits.tail(Bits.reverse(Nat.to_bits(nat))));
      do Parser { return bits; };
    });
    var verb = do Parser {
      var verb = Parser.maybe<_>(Parser.text("-"));
      return Maybe.to_bool<_>(verb);
    };
    var orig = Fm.Parser.stop(init);
    return Fm.Term.ori(orig, Fm.Term.gol(name, dref, verb));
  }

// Parses a hole: @_@
Fm.Parser.hole: Parser(Fm.Term)
  do Parser {
    var init = Fm.Parser.init;
    Fm.Parser.text("_");
    var orig = Fm.Parser.stop(init);
    return Fm.Term.ori(orig, Fm.Term.hol(Bits.e));
  }

// Parses a natural number: @123@
Fm.Parser.nat: Parser(Fm.Term)
  do Parser {
    var init = Fm.Parser.init;
    Fm.Parser.spaces;
    var natx = Parser.nat;
    var orig = Fm.Parser.stop(init);
    return Fm.Term.ori(orig, Fm.Term.nat(natx));
  }

// Parses a reference: @name@
Fm.Parser.reference: Parser(Fm.Term)
  do Parser {
    var init = Fm.Parser.init;
    var name = Fm.Parser.name1;
    if String.eql(name, "case") then do Parser {
      Parser.fail<_>("Reserved keyword.");
    } else if String.eql(name, "do") then do Parser {
      Parser.fail<_>("Reserved keyword.");
    } else if String.eql(name, "if") then do Parser {
      Parser.fail<_>("Reserved keyword.");
    //} else if String.eql(name, "then") then do Parser {
      //Parser.fail<_>("Reserved keyword.");
    //} else if String.eql(name, "else") then do Parser {
      //Parser.fail<_>("Reserved keyword.");
    } else if String.eql(name, "let") then do Parser {
      Parser.fail<_>("Reserved keyword.");
    } else if String.eql(name, "def") then do Parser {
      Parser.fail<_>("Reserved keyword.");
    } else if String.eql(name, "true") then do Parser {
      return Fm.Term.ref("Bool.true");
    } else if String.eql(name, "false") then do Parser {
      return Fm.Term.ref("Bool.false");
    } else if String.eql(name, "unit") then do Parser {
      return Fm.Term.ref("Unit.new");
    } else if String.eql(name, "none") then do Parser {
      let term = Fm.Term.ref("Maybe.none");
      let term = Fm.Term.app(term, Fm.Term.hol(Bits.e));
      return term;
    } else if String.eql(name, "refl") then do Parser {
      let term = Fm.Term.ref("Equal.refl");
      let term = Fm.Term.app(term, Fm.Term.hol(Bits.e));
      let term = Fm.Term.app(term, Fm.Term.hol(Bits.e));
      return term;
    } else do Parser {
      var orig = Fm.Parser.stop(init);
      return Fm.Term.ori(orig, Fm.Term.ref(name));
    };
  }

// Parses an optional comma after
Fm.Parser.item<V: Type>(parser: Parser(V)): Parser(V)
  do Parser {
    Fm.Parser.spaces;
    var value = parser;
    Parser.maybe<_>(Fm.Parser.text(","));
    return value;
  }

// Parses an application (erased): @func<argm0>@
Fm.Parser.application.erased(init: Nat, func: Fm.Term): Parser(Fm.Term)
  do Parser {
    var init = Parser.get_index;
    Parser.text("<");
    var args = Parser.until1<_>(
      Parser.spaces_text(">"),
      Fm.Parser.item<_>(Fm.Parser.term));
    var orig = Fm.Parser.stop(init);
    let expr = List.for<_>(args)<_>(func, (x,f) Fm.Term.app(f, x));
    return Fm.Term.ori(orig, expr);
  }

// Parses an application: @func<argm0>@
Fm.Parser.application(init: Nat, func: Fm.Term): Parser(Fm.Term)
  do Parser {
    Parser.text("(");
    var args = Parser.until1<_>(
      Fm.Parser.text(")"),
      Fm.Parser.item<_>(Fm.Parser.term));
    var orig = Fm.Parser.stop(init);
    let expr = List.for<_>(args)<_>(func, (x,f) Fm.Term.app(f, x));
    return Fm.Term.ori(orig, expr);
  }

// Parses an arrow: @A -> B@
Fm.Parser.arrow(init: Nat, xtyp: Fm.Term): Parser(Fm.Term)
  do Parser {
    Fm.Parser.text("->");
    var body = Fm.Parser.term;
    var orig = Fm.Parser.stop(init);
    return Fm.Term.ori(orig, Fm.Term.all(Bool.false, "", "", xtyp, (s,x) body));
  }

// Parses an operation: @x + y@
Fm.Parser.op(sym: String, ref: String, init: Nat, val0: Fm.Term): Parser(Fm.Term)
  do Parser {
    Fm.Parser.text(sym);
    var val1 = Fm.Parser.term;
    var orig = Fm.Parser.stop(init);
    let term = Fm.Term.ref(ref);
    let term = Fm.Term.app(term, val0);
    let term = Fm.Term.app(term, val1);
    return Fm.Term.ori(orig, term);
  }

// Parses an addition: @x + y@
Fm.Parser.add: Nat -> Fm.Term -> Parser(Fm.Term)
  Fm.Parser.op("+", "Nat.add")

// Parses a subtraction: @x - y@
Fm.Parser.sub: Nat -> Fm.Term -> Parser(Fm.Term)
  Fm.Parser.op("+", "Nat.add")

// Parses a multiplication: @x * y@
Fm.Parser.mul: Nat -> Fm.Term -> Parser(Fm.Term)
  Fm.Parser.op("*", "Nat.mul")

// Parses a division: @x / y@
Fm.Parser.div: Nat -> Fm.Term -> Parser(Fm.Term)
  Fm.Parser.op("/", "Nat.div")

// Parses a modulus: @x % y@
Fm.Parser.mod: Nat -> Fm.Term -> Parser(Fm.Term)
  Fm.Parser.op("%", "Nat.mod")

// Parses a list conser: @head & tail@
Fm.Parser.cons(init: Nat, head: Fm.Term): Parser(Fm.Term)
  do Parser {
    Fm.Parser.text("&");
    var tail = Fm.Parser.term;
    var orig = Fm.Parser.stop(init);
    let term = Fm.Term.ref("List.cons");
    let term = Fm.Term.app(term, Fm.Term.hol(Bits.e));
    let term = Fm.Term.app(term, head);
    let term = Fm.Term.app(term, tail);
    var orig = Fm.Parser.stop(init);
    return Fm.Term.ori(orig, term);
  }

// Parses a list concat: @xs ++ ys@
Fm.Parser.concat(init: Nat, lst0: Fm.Term): Parser(Fm.Term)
  do Parser {
    Fm.Parser.text("++");
    var lst1 = Fm.Parser.term;
    var orig = Fm.Parser.stop(init);
    let term = Fm.Term.ref("List.concat");
    let term = Fm.Term.app(term, Fm.Term.hol(Bits.e));
    let term = Fm.Term.app(term, lst0);
    let term = Fm.Term.app(term, lst1);
    var orig = Fm.Parser.stop(init);
    return Fm.Term.ori(orig, term);
  }

// Parses a string concat: @xs | ys@
Fm.Parser.string_concat(init: Nat, str0: Fm.Term): Parser(Fm.Term)
  do Parser {
    Fm.Parser.text("|");
    var str1 = Fm.Parser.term;
    var orig = Fm.Parser.stop(init);
    let term = Fm.Term.ref("String.concat");
    let term = Fm.Term.app(term, str0);
    let term = Fm.Term.app(term, str1);
    var orig = Fm.Parser.stop(init);
    return Fm.Term.ori(orig, term);
  }

// Parses a sigma literal: @1 ~ 2@
Fm.Parser.sigma(init: Nat, val0: Fm.Term): Parser(Fm.Term)
  do Parser {
    Fm.Parser.text("~");
    var val1 = Fm.Parser.term;
    var orig = Fm.Parser.stop(init);
    let term = Fm.Term.ref("Sigma.new");
    let term = Fm.Term.app(term, Fm.Term.hol(Bits.e));
    let term = Fm.Term.app(term, Fm.Term.hol(Bits.e));
    let term = Fm.Term.app(term, val0);
    let term = Fm.Term.app(term, val1);
    return Fm.Term.ori(orig, term);
  }

// Parses an equality: @a == b@
Fm.Parser.equality(init: Nat, val0: Fm.Term): Parser(Fm.Term)
  do Parser {
    Fm.Parser.text("==");
    var val1 = Fm.Parser.term;
    var orig = Fm.Parser.stop(init);
    let term = Fm.Term.ref("Equal");
    let term = Fm.Term.app(term, Fm.Term.hol(Bits.e));
    let term = Fm.Term.app(term, val0);
    let term = Fm.Term.app(term, val1);
    return Fm.Term.ori(orig, term);
  }

// Parses an annotation: @term :: type@
Fm.Parser.annotation(init: Nat, term: Fm.Term): Parser(Fm.Term)
  do Parser {
    Fm.Parser.text("::");
    var type = Fm.Parser.term;
    var orig = Fm.Parser.stop(init);
    return Fm.Term.ori(orig, Fm.Term.ann(Bool.false, term, type));
  }
  
// Parses a core term (prefix phase)
Fm.Parser.term: Parser(Fm.Term)
  do Parser {
    var code = Parser.get_code;
    var init = Fm.Parser.init;
    var term = Parser.first_of<_>([
      Fm.Parser.type,
      Fm.Parser.forall,
      Fm.Parser.lambda,
      Fm.Parser.lambda.erased,
      Fm.Parser.lambda.nameless,
      Fm.Parser.parenthesis,
      Fm.Parser.letforin,
      Fm.Parser.let,
      Fm.Parser.get,
      Fm.Parser.def,
      Fm.Parser.if,
      Fm.Parser.char,
      Fm.Parser.string,
      Fm.Parser.pair,
      Fm.Parser.sigma.type,
      Fm.Parser.some,
      Fm.Parser.apply,
      Fm.Parser.list,
      Fm.Parser.log,
      Fm.Parser.forin,
      Fm.Parser.forin2,
      Fm.Parser.do,
      Fm.Parser.case,
      Fm.Parser.open,
      Fm.Parser.goal,
      Fm.Parser.hole,
      Fm.Parser.nat,
      Fm.Parser.reference,
    ]);
    Fm.Parser.suffix(init, term);
  }

// Parses a core term (suffix phase)
Fm.Parser.suffix(init: Nat, term: Fm.Term): Parser(Fm.Term)
  (idx, code)
  let suffix_parser = Parser.first_of<_>([
    Fm.Parser.application(init, term),
    Fm.Parser.application.erased(init, term),
    Fm.Parser.arrow(init, term),
    Fm.Parser.add(init, term),
    Fm.Parser.sub(init, term),
    Fm.Parser.mul(init, term),
    Fm.Parser.div(init, term),
    Fm.Parser.mod(init, term),
    Fm.Parser.cons(init, term),
    Fm.Parser.concat(init, term),
    Fm.Parser.string_concat(init, term),
    Fm.Parser.sigma(init, term),
    Fm.Parser.equality(init, term),
    Fm.Parser.annotation(init, term),
  ]);
  case suffix_parser(idx, code) as suffix_parsed {
    error: Parser.Reply.value<_>(idx, code, term),
    value: Fm.Parser.suffix(init, suffix_parsed.val, suffix_parsed.idx, suffix_parsed.code),
  }

// Builds a chained forall
Fm.Parser.make_forall(binds: List(Fm.Binder), body: Fm.Term): Fm.Term
  case binds {
    nil: body,
    cons: case binds.head {
      new:
        def all_eras = binds.head.eras;
        def all_self = "";
        def all_name = binds.head.name;
        def all_xtyp = binds.head.term;
        def all_body = (s,x) Fm.Parser.make_forall(binds.tail, body);
        Fm.Term.all(all_eras, all_self, all_name, all_xtyp, all_body),
    }
  }

// Builds a chained lambda
Fm.Parser.make_lambda(names: List(Fm.Name), body: Fm.Term): Fm.Term
  case names {
    nil: body,
    cons: Fm.Term.lam(names.head, (x) Fm.Parser.make_lambda(names.tail, body)),
  }

// Parses a constructor: @foo(a: A, b: B, c: C) ~ (i: I, j: J)@
Fm.Parser.constructor(namespace: Fm.Name): Parser(Fm.Constructor)
  do Parser {
    var name = Fm.Parser.name1;
    var args = Parser.maybe<_>(Fm.Parser.binder);
    var inds = Parser.maybe<_>(do Parser {
      Fm.Parser.text("~");
      Fm.Parser.binder;
    });
    let args = Maybe.default<_>([], args);
    let inds = Maybe.default<_>([], inds);
    return Fm.Constructor.new(name, args, inds);
  }

// Parses a datatype: @type Foo (x: A) ~ (i: I) { ctor0(a: A) ~ (i: I), ... }@
Fm.Parser.datatype: Parser(Fm.Datatype)
  do Parser {
    Fm.Parser.text("type ");
    var name = Fm.Parser.name1; 
    var pars = Parser.maybe<_>(Fm.Parser.binder);
    var inds = Parser.maybe<_>(do Parser {
      Fm.Parser.text("~");
      Fm.Parser.binder;
    });
    let pars = Maybe.default<_>([], pars);
    let inds = Maybe.default<_>([], inds);
    Fm.Parser.text("{");
    var ctrs = Parser.until<_>(
      Fm.Parser.text("}"),
      Fm.Parser.item<_>(Fm.Parser.constructor(name)));
    return Fm.Datatype.new(name, pars, inds, ctrs);
  }

// Parses a definition
Fm.Parser.file.def(file: String, code: String, defs: Fm.Defs): Parser(Fm.Defs)
  do Parser {
    var name = Fm.Parser.name1;
    var args = Parser.many<_>(Fm.Parser.binder);
    let args = List.flatten<_>(args);
    Fm.Parser.text(":");
    var type = Fm.Parser.term;
    var term = Fm.Parser.term;
    let type = Fm.Parser.make_forall(args, type);
    let term = Fm.Parser.make_lambda(List.mapped<_>(args)<_>((x) case x { new: x.name }),term);
    let type = Fm.Term.bind([], (x) Bits.i(x), type);
    let term = Fm.Term.bind([], (x) Bits.o(x), term);
    let defs = Fm.define(file, code, name, term, type, Bool.false, defs);
    return defs;
  }

// Parses an ADT
Fm.Parser.file.adt(file: String, code: String, defs: Fm.Defs): Parser(Fm.Defs)
  do Parser {
    var adt = Fm.Parser.datatype;
    case adt {
      new: do Parser {
        let term = Fm.Datatype.build_term(adt);
        let term = Fm.Term.bind([], (x) Bits.i(x), term);
        let type = Fm.Datatype.build_type(adt);
        let type = Fm.Term.bind([], (x) Bits.o(x), type);
        let defs = Fm.define(file, code, adt.name, term, type, Bool.false, defs);
        let defs = List.fold<_>(adt.ctrs)<_>(defs, (ctr, defs)
          let typ_name = adt.name;
          let ctr_name = String.flatten([typ_name, Fm.Name.read("."), case ctr { new: ctr.name }]);
          let ctr_term = Fm.Constructor.build_term(adt, ctr);
          let ctr_term = Fm.Term.bind([], (x) Bits.i(x), ctr_term);
          let ctr_type = Fm.Constructor.build_type(adt, ctr);
          let ctr_type = Fm.Term.bind([], (x) Bits.o(x), ctr_type);
          Fm.define(file, code, ctr_name, ctr_term, ctr_type, Bool.false, defs));
        return defs;
      }
    };
  }

// Parses the end of a file
Fm.Parser.file.end(file: String, code: String, defs: Fm.Defs): Parser(Fm.Defs)
  do Parser {
    Fm.Parser.spaces;
    Parser.eof;
    return defs;
  }

// Parses many definitions
Fm.Parser.file(file: String, code: String, defs: Fm.Defs): Parser(Fm.Defs)
  do Parser {
    var stop = Parser.is_eof;
    if stop then do Parser {
      return defs;
    } else Parser.first_of<_>([
      do Parser {
        Fm.Parser.text("#");
        var file = Fm.Parser.name1;
        Fm.Parser.file(file, code, defs);
      },
      do Parser {
        var defs = Parser.first_of<_>([
          Fm.Parser.file.def(file, code, defs),
          Fm.Parser.file.adt(file, code, defs),
          Fm.Parser.file.end(file, code, defs),
        ]);
        Fm.Parser.file(file, code, defs);
      },
    ]);
  }

// Stringifies a parser error
Fm.highlight.tc(
  code: String,
  ix0: Nat,
  ix1: Nat,
  col: Nat,
  row: Nat,
  lft: Maybe(Nat),
  lin: String,
  res: List(String),
): String
  //use skip = Debug.log<_>(String.flatten([
    //"ix0=", Nat.show(ix0), " ",
    //"ix1=", Nat.show(ix1), " ",
    //"col=", Nat.show(col), " ",
    //"row=", Nat.show(row), " ",
    //"lft=", case lft { none: "-", some: Nat.show(lft.value) }, " ",
    //"len=", Nat.show(String.length(code)), " ",
    //"chr=", Fm.escape.char(case code { nil: '_', cons: code.head }), " ",
    //"res={", String.join("|", List.reverse<_>(res)), "}",
  //]))
  case code {
    nil:
      Fm.highlight.end(col, row, List.reverse<_>(res)),
    cons:
      if U16.eql(code.head, '\n') then
        let stp = Maybe.extract<_>(lft)<_>(Bool.false, Nat.is_zero);
        if stp then
          Fm.highlight.end(col, row, List.reverse<_>(res))
        else
          let spa = 3;
          let siz = Nat.succ(Nat.double(spa));
          let lft = case ix1 {
            zero: case lft {
              none: Maybe.some<_>(spa),
              some: Maybe.some<_>(Nat.pred(lft.value)),
            },
            succ: lft,
          };
          let ix0 = Nat.pred(ix0);
          let ix1 = Nat.pred(ix1);
          let col = 0;
          let row = Nat.succ(row);
          let res = List.take<_>(siz, List.cons<_>(String.reverse(lin), res));
          let lin = String.reverse(String.flatten([
            String.pad_left(4, ' ', Nat.show(row)),
            " | "
          ]));
          Fm.highlight.tc(code.tail, ix0, ix1, col, row, lft, lin, res)
      else
        let chr = String.cons(code.head, String.nil);
        let chr =
          if Bool.and(Nat.is_zero(ix0), Bool.not(Nat.is_zero(ix1))) then
            String.reverse(Fm.color("31", Fm.color("4", chr)))
          else
            chr;
        let ix0 = Nat.pred(ix0);
        let ix1 = Nat.pred(ix1);
        let col = Nat.succ(col);
        let lin = String.flatten([chr, lin]);
        Fm.highlight.tc(code.tail, ix0, ix1, col, row, lft, lin, res)
  }
  
Fm.highlight.end(
  col: Nat,
  row: Nat,
  res: List(String),
): String
  String.join("\n", res)

Fm.highlight(
  code: String,
  idx0: Nat,
  idx1: Nat,
): String
  Fm.highlight.tc(code, idx0, idx1, 0, 1, Maybe.none<_>, String.reverse("   1 | "), [])
  
// Reads a term from string
Fm.Term.read(code: String): Maybe(Fm.Term)
  case Fm.Parser.term(0,code) as parsed {
    error: Maybe.none<_>,
    value: Maybe.some<_>(parsed.val),
  }

// Reads a defs from string
Fm.Defs.read(file: String, code: String, defs: Fm.Defs): Either(String, Fm.Defs)
  case Fm.Parser.file(file, code, defs, 0, code) as parsed {
    error:
      let err = parsed.err;
      let hig = Fm.highlight(code, parsed.idx, Nat.succ(parsed.idx));
      let str = String.flatten([err, "\n", hig]);
      Either.left<_,_>(str),
    value:
      Either.right<_,_>(parsed.val),
  }

// FormCore
// ========

Fm.Term.core(term: Fm.Term): String
  case term {
    ref:
      Fm.Name.show(term.name),
    var:
      Fm.Name.show(term.name),
    typ:
      "*",
    all:
      let eras = term.eras;
      let init = if eras then "%" else "@"
      let self = Fm.Name.show(term.self);
      let name = Fm.Name.show(term.name);
      let xtyp = Fm.Term.core(term.xtyp);
      let body = Fm.Term.core(term.body(Fm.Term.var(term.self,0),Fm.Term.var(term.name,0)));
      String.flatten([init,self,"(",name,":",xtyp,") ",body]),
    lam:
      let name = Fm.Name.show(term.name);
      let body = Fm.Term.core(term.body(Fm.Term.var(term.name,0)));
      String.flatten(["#",name," ",body]),
    app:
      let func = Fm.Term.core(term.func);
      let argm = Fm.Term.core(term.argm);
      String.flatten(["(",func," ",argm,")"]),
    let:
      let name = Fm.Name.show(term.name);
      let expr = Fm.Term.core(term.expr);
      let body = Fm.Term.core(term.body(Fm.Term.var(term.name,0)));
      String.flatten(["!", name, " = ", expr, "; ", body]),
    def:
      let name = Fm.Name.show(term.name);
      let expr = Fm.Term.core(term.expr);
      let body = Fm.Term.core(term.body(Fm.Term.var(term.name,0)));
      String.flatten(["$", name, " = ", expr, "; ", body]),
    ann:
      let term = Fm.Term.core(term.term);
      let type = Fm.Term.core(term.type);
      String.flatten(["{",term,":",type,"}"]),
    gol:
      "<GOL>",
    hol:
      "<HOL>",
    nat:
      String.flatten(["+", Nat.show(term.natx)]),
    chr:
      String.flatten(["'", Fm.escape.char(term.chrx), "'"]),
    str:
      String.flatten(["\"", Fm.escape(term.strx), "\""]),
    cse:
      "<CSE>",
    ori:
      Fm.Term.core(term.expr),
  }

// Converts everything to FormCore
Fm.Defs.core(defs: Fm.Defs): String
  let result = "";
  for defn in Map.values<_>(defs) with result:
    case defn {
      new: 
        case defn.stat {
          done:
            let name = defn.name;
            let term = Fm.Term.core(defn.term);
            let type = Fm.Term.core(defn.type);
            String.flatten([result, name, " : ", type, " = ", term, ";\n"]),
          wait: result,
          init: result,
          fail: result,
      }
    }

// Synth
// =====

// SYNTH: Fixes a list of errors, if possible
Fm.Synth.fix(
  file: String,
  code: String,
  name: Fm.Name,
  term: Fm.Term,
  type: Fm.Term,
  defs: Fm.Defs,
  errs: List(Fm.Error),
  fixd: Bool,
): IO(Maybe(Fm.Defs))
  case errs {
    nil:
      if fixd then do IO {
        let type = Fm.Term.bind([], (x) Bits.i(x), type);
        let term = Fm.Term.bind([], (x) Bits.o(x), term);
        let defs = Fm.set<_>(name, Fm.Def.new(file, code, name, term, type, Fm.Status.init), defs);
        return Maybe.some<_>(defs);
      } else do IO {
        return Maybe.none<_>;
      },
    cons: case errs.head {
      waiting: do IO {
        var defs = Fm.Synth.one(errs.head.name, defs);
        Fm.Synth.fix(file, code, name, term, type, defs, errs.tail, Bool.true);
      },
      undefined_reference: do IO {
        var defs = Fm.Synth.one(errs.head.name, defs);
        Fm.Synth.fix(file, code, name, term, type, defs, errs.tail, Bool.true);
      },
      patch: case errs.head.path {
        e: do IO { // shouldn't happen
          return Maybe.none<_>;
        },
        o: do IO { // hole is on term
          let term = Fm.Term.patch_at(errs.head.path.pred, term, (x) errs.head.term);
          Fm.Synth.fix(file, code, name, term, type, defs, errs.tail, Bool.true);
        },
        i: do IO { // hole is on type
          let type = Fm.Term.patch_at(errs.head.path.pred, type, (x) errs.head.term);
          Fm.Synth.fix(file, code, name, term, type, defs, errs.tail, Bool.true);
        },
      },
      // The error isn't fixable
      _: Fm.Synth.fix(file, code, name, term, type, defs, errs.tail, fixd),
    }
  }

Fm.Synth.file_of(name: Fm.Name): String
  case name {
    nil: ".fm"
    cons: if U16.eql(name.head, '.')
      then ".fm"
      else String.cons(name.head, Fm.Synth.file_of(name.tail))
  }

Fm.Synth.load(name: Fm.Name, defs: Fm.Defs): IO(Maybe(Fm.Defs))
  do IO {
    let file = Fm.Synth.file_of(name);
    //let skip = Debug.log<_>(String.flatten(["loading file: ", file, " (", name, ")"]), (x) Unit.new);
    var code = IO.get_file(file);
    let read = Fm.Defs.read(file, code, defs);
    case read {
      left: do IO { // TODO: should return parse error somehow... or perhaps add that on Fm.Synth.file?
        return Maybe.none<_>;
      },
      right: do IO {
        let defs = read.value;
        case Fm.get<_>(name, defs) as got {
          none: do IO {
            return Maybe.none<_>;
          },
          some: do IO {
            return Maybe.some<_>(defs);
          },
        };
      },
    };
  }

// Synths one def
Fm.Synth.one(name: Fm.Name, defs: Fm.Defs): IO(Fm.Defs)
  case Fm.get<_>(name, defs) as got {
    none: do IO {
      var loaded = Fm.Synth.load(name, defs);
      case loaded {
        none: do IO {
          IO.print(String.flatten(["Undefined: ", name]));
          return defs;
        },
        some: do IO {
          Fm.Synth.one(name, loaded.value);
        },
      };
    },
    some: case got.value {
      new: do IO {
        let file = got.value.file;
        let code = got.value.code;
        let name = got.value.name;
        let term = got.value.term;
        let type = got.value.type;
        let stat = got.value.stat;
        //let skip = Debug.log<_>(String.flatten([name, ": ", Fm.Term.show(type), " = ", Fm.Term.show(term)]), (x) Unit.new);
        //Debug.log<_>(String.flatten(["synth ", name, " ", case stat { init: "INIT", wait: "WAIT", done: "DONE", fail: "FAIL" }]), (x)
        case stat {
          wait: do IO { return defs; },
          done: do IO { return defs; },
          fail: do IO { return defs; },
          init: do IO {
            let defs = Fm.set<_>(name, Fm.Def.new(file, code, name, term, type, Fm.Status.wait), defs);
            let checked = do Fm.Check {
              var chk_type = Fm.Term.check(type, Maybe.some<_>(Fm.Term.typ), defs, [], Fm.MPath.i(Fm.MPath.nil), Maybe.none<_>);
              var chk_term = Fm.Term.check(term, Maybe.some<_>(type), defs, [], Fm.MPath.o(Fm.MPath.nil), Maybe.none<_>);
              return Unit.new;
            };
            case checked {
              result:
                //let skip = Debug.log<_>(String.join("\n", List.mapped<_>(checked.errors)<_>((x) String.concat("-- ", Fm.Error.show(x,Map.new<_>)))), (x) Unit.new);
                if List.is_empty<_>(checked.errors) then do IO {
                  let defs = Fm.define(file, code, name, term, type, Bool.true, defs);
                  //let defs = Fm.set<_>(name, Fm.Def.new(file, code, name, term, type, Fm.Status.done), defs);
                  return defs;
                } else do IO {
                  var fixed = Fm.Synth.fix(file, code, name, term, type, defs, checked.errors, Bool.false);
                  case fixed {
                    none: do IO {
                      let stat = Fm.Status.fail(checked.errors);
                      let defs = Fm.set<_>(name, Fm.Def.new(file, code, name, term, type, stat), defs);
                      return defs;
                    },
                    some: Fm.Synth.one(name, fixed.value),
                  };
                }
            };
          }
        };
      }
    }
  }

// Synths many defs
Fm.Synth.many(names: List(String), defs: Fm.Defs): IO(Fm.Defs)
  case names {
    nil: do IO {
      return defs;
    },
    cons: do IO {
      var defs = Fm.Synth.one(names.head, defs);
      Fm.Synth.many(names.tail, defs);
    },
  }

Fm.Synth.file(file: String, defs: Fm.Defs): IO(Either(String, Pair(List(Fm.Name), Fm.Defs)))
  do IO {
    var code = IO.get_file(file);
    let read = Fm.Defs.read(file, code, defs);
    case read {
      left: do IO {
        return Either.left<_,_>(read.value);
      },
      right: do IO {
        let file_defs = read.value;
        let file_keys = Map.keys<_>(file_defs);
        let file_nams = List.mapped<_>(file_keys)<_>(Fm.Name.from_bits);
        var defs = Fm.Synth.many(file_nams, file_defs);
        return Either.right<_,_>({file_nams, defs});
      },
    };
  }

// Load
// ====

//Fm.Load.missing(errors: List(Fm.Error)): List(String)
  //case errors {
    //nil: List.nil<_>,
    //cons:
      //let tail = Fm.Load.missing(errors.tail);
      //case errors.head {
        //undefined_reference: List.cons<_>(errors.head.name, tail),
        //_: tail,
      //}
  //}

//Fm.Load.one(name: Fm.Name, defs: Fm.Defs): IO(Fm.Defs)
  //let skip = Debug.log<_>(String.flatten(["Fm.Load.one ", name]), (x) Unit.new);
  ////let skip = Debug.log<_>(String.flatten(["load_name ", name, " ", String.join("|",List.mapped<_>(Map.keys<_>(defs))<_>(Fm.Name.from_bits))]), (x) Unit.new);
  //let defs = Fm.Synth.one(name, defs);
  //case Fm.get<_>(name, defs) as got {
    //some: case got.value {
      //new: 
        //let file = got.value.file;
        //let code = got.value.code;
        //let name = got.value.name;
        //let term = got.value.term;
        //let type = got.value.type;
        //let stat = got.value.stat;
        //case stat {
          //init: do IO { return defs; },
          //wait: do IO { return defs; },
          //done: do IO { return defs; },
          //fail: do IO {
            //let missing = Fm.Load.missing(stat.errors);
            //case missing {
              //nil : do IO { return defs; },
              //cons: do IO {
                //let defs = Fm.set<_>(name, Fm.Def.new(file,code,name,term,type,Fm.Status.init), defs);
                //var defs = Fm.Load.many(missing, defs);
                //var defs = Fm.Load.one(name, defs);
                //return defs;
              //},
            //};
          //},
        //}
    //},
    //none: do IO {
      //let file = Fm.Load.file_of(name);
      //var code = IO.get_file(file);
      //let read = Fm.Defs.read(file, code, defs);
      //let skip = Debug.log<_>(String.flatten(["loading file: ", file]), (x) Unit.new);
      //case read {
        //left: do IO { return defs; },
        //right: do IO {
          //let defs = read.value;
          //case Fm.get<_>(name, defs) as got {
            //none: do IO { return defs; },
            //some: Fm.Load.one(name, defs)
          //};
        //},
      //};
    //},
  //}

//Fm.Load.many(names: List(Fm.Name), defs: Fm.Defs): IO(Fm.Defs)
  //do IO {
    //case names {
      //nil: do IO { return defs; },
      //cons: do IO {
        //var defs = Fm.Load.one(names.head, defs);
        //Fm.Load.many(names.tail, defs);
      //}
    //};
  //}

// API
// ===

Fm.Defs.report.go(defs: Fm.Defs, list: List(Fm.Name), errs: String, typs: String): String
  case list {
    nil: String.flatten([
      typs, "\n",
      case errs {
        nil: "All terms check.",
        cons: errs,
      }
    ]),
    cons:
      let name = list.head;
      case Fm.get<_>(name, defs) as got {
        none: Fm.Defs.report.go(defs, list.tail, errs, typs),
        some: case got.value {
          new:
            let typs = String.flatten([typs, name,": ",Fm.Term.show(got.value.type),"\n"]);
            case got.value.stat {
              init: Fm.Defs.report.go(defs, list.tail, errs, typs),
              wait: Fm.Defs.report.go(defs, list.tail, errs, typs),
              done: Fm.Defs.report.go(defs, list.tail, errs, typs),
              fail: case got.value.stat.errors {
                nil: Fm.Defs.report.go(defs, list.tail, errs, typs),
                cons:
                  let name_str = Fm.Name.show(got.value.name);
                  let rel_errs = Fm.Error.relevant(got.value.stat.errors, Bool.false);
                  let rel_msgs = List.mapped<_>(rel_errs)<_>((err)
                    String.flatten([
                      Fm.Error.show(err, defs),
                      case Fm.Error.origin(err) as origin {
                        none: "",
                        some: case origin.value {
                          new: String.flatten([
                            "Inside '", got.value.file, "':\n",
                            Fm.highlight(got.value.code, origin.value.from, origin.value.upto),
                            "\n",
                          ])
                        },
                      }
                    ]));
                  let errs = String.flatten([errs, String.join("\n", rel_msgs), "\n"]);
                  Fm.Defs.report.go(defs, list.tail, errs, typs)
              }
            }
        }
      }
  }

Fm.Defs.report(defs: Fm.Defs, list: List(Fm.Name)): String
  Fm.Defs.report.go(defs, list, "", "")

Fm.to_core.io.one(name: String): IO(String)
  do IO {
    var defs = Fm.Synth.one(name, Map.new<_>);
    return Fm.Defs.core(defs);
  }

Fm.checker.io.one(name: String): IO(Unit)
  do IO {
    var defs = Fm.Synth.one(name, Map.new<_>);
    IO.print(Fm.Defs.report(defs, [name]));
  }

Fm.checker.io.file(file: String): IO(Unit)
  do IO {
    var loaded = Fm.Synth.file(file, Map.new<_>);
    case loaded {
      left: do IO {
        IO.print(String.flatten(["On '", file, "':"]));
        IO.print(loaded.value);
      },
      right: case loaded.value {
        new: do IO {
          let nams = loaded.value.fst;
          let defs = loaded.value.snd;
          IO.print(Fm.Defs.report(defs, nams));
        }
      },
    };
  }

// Receives a Formality code and returns the type checker reports. Since synth
// is IO, we need to "purify" it in order to implement a `String->String`
// function. Since IO is a pure datatype, we can do it by just answering all
// calls with an empty string. This will work as long as Synth doesn't request
// external files, which is the case when the source code has no dependencies.
Fm.checker.code(code: String): String
  case Fm.Defs.read("Main.fm", code, Map.new<_>) as read {
    left:
      read.value,
    right: IO.purify<String>(do IO {
      let defs = read.value;
      let nams = List.mapped<_>(Map.keys<_>(defs))<_>(Fm.Name.from_bits);
      var defs = Fm.Synth.many(nams, defs);
      return Fm.Defs.report(defs, nams);
    }),
  }

//Fm: IO(Unit)
  //do IO {
    //IO.print(Fm.checker.code("type Bit { o, i } main: Bit ?a"));
  //}

Fm: IO(Unit)
  do IO {
    let _ = Fm.to_core.io.one;
    let _ = Fm.checker.io.one;
    let _ = Fm.checker.io.file;
    let _ = Fm.checker.code;
    let _ = Fm.Term.read;
    Fm.checker.io.file("Main.fm");
  }
